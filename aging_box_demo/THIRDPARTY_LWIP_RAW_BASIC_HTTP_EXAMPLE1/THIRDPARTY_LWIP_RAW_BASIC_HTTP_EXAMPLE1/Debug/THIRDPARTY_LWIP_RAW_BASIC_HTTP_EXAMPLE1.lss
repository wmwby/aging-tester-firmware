
THIRDPARTY_LWIP_RAW_BASIC_HTTP_EXAMPLE1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000fe18  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000048  20000000  0000fe18  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00003efc  20000048  0000fe60  00020048  2**3
                  ALLOC
  3 .stack        00000a04  20003f44  00013d5c  00020048  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00020048  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020070  2**0
                  CONTENTS, READONLY
  6 .debug_info   00034fd9  00000000  00000000  000200c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005e52  00000000  00000000  000550a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000650d  00000000  00000000  0005aef4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000012d0  00000000  00000000  00061401  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000010b0  00000000  00000000  000626d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001ff58  00000000  00000000  00063781  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000205d2  00000000  00000000  000836d9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0006eacd  00000000  00000000  000a3cab  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003e64  00000000  00000000  00112778  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
       0:	20004948 	.word	0x20004948
       4:	00005555 	.word	0x00005555
       8:	000055e9 	.word	0x000055e9
       c:	000055e9 	.word	0x000055e9
	...
      2c:	000055e9 	.word	0x000055e9
	...
      38:	000055e9 	.word	0x000055e9
      3c:	000055e9 	.word	0x000055e9
      40:	000055e9 	.word	0x000055e9
      44:	000055e9 	.word	0x000055e9
      48:	000055e9 	.word	0x000055e9
      4c:	000055e9 	.word	0x000055e9
      50:	00002629 	.word	0x00002629
      54:	000055e9 	.word	0x000055e9
      58:	000055e9 	.word	0x000055e9
      5c:	00002ee5 	.word	0x00002ee5
      60:	00002efd 	.word	0x00002efd
      64:	00002f15 	.word	0x00002f15
      68:	00002f2d 	.word	0x00002f2d
      6c:	00002f45 	.word	0x00002f45
      70:	00002f5d 	.word	0x00002f5d
      74:	00004e91 	.word	0x00004e91
      78:	00004ea5 	.word	0x00004ea5
      7c:	00004eb9 	.word	0x00004eb9
      80:	00004ecd 	.word	0x00004ecd
      84:	00004ee1 	.word	0x00004ee1
      88:	00004ef5 	.word	0x00004ef5
      8c:	00004f09 	.word	0x00004f09
      90:	00004f1d 	.word	0x00004f1d
      94:	000055e9 	.word	0x000055e9
      98:	000055e9 	.word	0x000055e9
      9c:	000055e9 	.word	0x000055e9
      a0:	000055e9 	.word	0x000055e9

000000a4 <__do_global_dtors_aux>:
      a4:	b510      	push	{r4, lr}
      a6:	4c06      	ldr	r4, [pc, #24]	; (c0 <__do_global_dtors_aux+0x1c>)
      a8:	7823      	ldrb	r3, [r4, #0]
      aa:	2b00      	cmp	r3, #0
      ac:	d107      	bne.n	be <__do_global_dtors_aux+0x1a>
      ae:	4b05      	ldr	r3, [pc, #20]	; (c4 <__do_global_dtors_aux+0x20>)
      b0:	2b00      	cmp	r3, #0
      b2:	d002      	beq.n	ba <__do_global_dtors_aux+0x16>
      b4:	4804      	ldr	r0, [pc, #16]	; (c8 <__do_global_dtors_aux+0x24>)
      b6:	e000      	b.n	ba <__do_global_dtors_aux+0x16>
      b8:	bf00      	nop
      ba:	2301      	movs	r3, #1
      bc:	7023      	strb	r3, [r4, #0]
      be:	bd10      	pop	{r4, pc}
      c0:	20000048 	.word	0x20000048
      c4:	00000000 	.word	0x00000000
      c8:	0000fe18 	.word	0x0000fe18

000000cc <frame_dummy>:
      cc:	4b08      	ldr	r3, [pc, #32]	; (f0 <frame_dummy+0x24>)
      ce:	b510      	push	{r4, lr}
      d0:	2b00      	cmp	r3, #0
      d2:	d003      	beq.n	dc <frame_dummy+0x10>
      d4:	4907      	ldr	r1, [pc, #28]	; (f4 <frame_dummy+0x28>)
      d6:	4808      	ldr	r0, [pc, #32]	; (f8 <frame_dummy+0x2c>)
      d8:	e000      	b.n	dc <frame_dummy+0x10>
      da:	bf00      	nop
      dc:	4807      	ldr	r0, [pc, #28]	; (fc <frame_dummy+0x30>)
      de:	6803      	ldr	r3, [r0, #0]
      e0:	2b00      	cmp	r3, #0
      e2:	d100      	bne.n	e6 <frame_dummy+0x1a>
      e4:	bd10      	pop	{r4, pc}
      e6:	4b06      	ldr	r3, [pc, #24]	; (100 <frame_dummy+0x34>)
      e8:	2b00      	cmp	r3, #0
      ea:	d0fb      	beq.n	e4 <frame_dummy+0x18>
      ec:	4798      	blx	r3
      ee:	e7f9      	b.n	e4 <frame_dummy+0x18>
      f0:	00000000 	.word	0x00000000
      f4:	2000004c 	.word	0x2000004c
      f8:	0000fe18 	.word	0x0000fe18
      fc:	0000fe18 	.word	0x0000fe18
     100:	00000000 	.word	0x00000000

00000104 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
     104:	b580      	push	{r7, lr}
     106:	b082      	sub	sp, #8
     108:	af00      	add	r7, sp, #0
     10a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
     10c:	687b      	ldr	r3, [r7, #4]
     10e:	2200      	movs	r2, #0
     110:	701a      	strb	r2, [r3, #0]
}
     112:	46c0      	nop			; (mov r8, r8)
     114:	46bd      	mov	sp, r7
     116:	b002      	add	sp, #8
     118:	bd80      	pop	{r7, pc}
     11a:	46c0      	nop			; (mov r8, r8)

0000011c <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
     11c:	b580      	push	{r7, lr}
     11e:	b082      	sub	sp, #8
     120:	af00      	add	r7, sp, #0
     122:	0002      	movs	r2, r0
     124:	6039      	str	r1, [r7, #0]
     126:	1dfb      	adds	r3, r7, #7
     128:	701a      	strb	r2, [r3, #0]
	switch (bus) {
     12a:	1dfb      	adds	r3, r7, #7
     12c:	781b      	ldrb	r3, [r3, #0]
     12e:	2b01      	cmp	r3, #1
     130:	d00a      	beq.n	148 <system_apb_clock_set_mask+0x2c>
     132:	2b02      	cmp	r3, #2
     134:	d00f      	beq.n	156 <system_apb_clock_set_mask+0x3a>
     136:	2b00      	cmp	r3, #0
     138:	d114      	bne.n	164 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
     13a:	4b0e      	ldr	r3, [pc, #56]	; (174 <system_apb_clock_set_mask+0x58>)
     13c:	4a0d      	ldr	r2, [pc, #52]	; (174 <system_apb_clock_set_mask+0x58>)
     13e:	6991      	ldr	r1, [r2, #24]
     140:	683a      	ldr	r2, [r7, #0]
     142:	430a      	orrs	r2, r1
     144:	619a      	str	r2, [r3, #24]
			break;
     146:	e00f      	b.n	168 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
     148:	4b0a      	ldr	r3, [pc, #40]	; (174 <system_apb_clock_set_mask+0x58>)
     14a:	4a0a      	ldr	r2, [pc, #40]	; (174 <system_apb_clock_set_mask+0x58>)
     14c:	69d1      	ldr	r1, [r2, #28]
     14e:	683a      	ldr	r2, [r7, #0]
     150:	430a      	orrs	r2, r1
     152:	61da      	str	r2, [r3, #28]
			break;
     154:	e008      	b.n	168 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
     156:	4b07      	ldr	r3, [pc, #28]	; (174 <system_apb_clock_set_mask+0x58>)
     158:	4a06      	ldr	r2, [pc, #24]	; (174 <system_apb_clock_set_mask+0x58>)
     15a:	6a11      	ldr	r1, [r2, #32]
     15c:	683a      	ldr	r2, [r7, #0]
     15e:	430a      	orrs	r2, r1
     160:	621a      	str	r2, [r3, #32]
			break;
     162:	e001      	b.n	168 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
     164:	2317      	movs	r3, #23
     166:	e000      	b.n	16a <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
     168:	2300      	movs	r3, #0
}
     16a:	0018      	movs	r0, r3
     16c:	46bd      	mov	sp, r7
     16e:	b002      	add	sp, #8
     170:	bd80      	pop	{r7, pc}
     172:	46c0      	nop			; (mov r8, r8)
     174:	40000400 	.word	0x40000400

00000178 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
     178:	b580      	push	{r7, lr}
     17a:	b082      	sub	sp, #8
     17c:	af00      	add	r7, sp, #0
     17e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     180:	687b      	ldr	r3, [r7, #4]
     182:	2280      	movs	r2, #128	; 0x80
     184:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
     186:	687b      	ldr	r3, [r7, #4]
     188:	2200      	movs	r2, #0
     18a:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
     18c:	687b      	ldr	r3, [r7, #4]
     18e:	2201      	movs	r2, #1
     190:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
     192:	687b      	ldr	r3, [r7, #4]
     194:	2200      	movs	r2, #0
     196:	70da      	strb	r2, [r3, #3]
}
     198:	46c0      	nop			; (mov r8, r8)
     19a:	46bd      	mov	sp, r7
     19c:	b002      	add	sp, #8
     19e:	bd80      	pop	{r7, pc}

000001a0 <system_is_debugger_present>:
 * \retval true  Debugger is connected to the system
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
     1a0:	b580      	push	{r7, lr}
     1a2:	af00      	add	r7, sp, #0
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
     1a4:	4b05      	ldr	r3, [pc, #20]	; (1bc <system_is_debugger_present+0x1c>)
     1a6:	789b      	ldrb	r3, [r3, #2]
     1a8:	b2db      	uxtb	r3, r3
     1aa:	001a      	movs	r2, r3
     1ac:	2302      	movs	r3, #2
     1ae:	4013      	ands	r3, r2
     1b0:	1e5a      	subs	r2, r3, #1
     1b2:	4193      	sbcs	r3, r2
     1b4:	b2db      	uxtb	r3, r3
}
     1b6:	0018      	movs	r0, r3
     1b8:	46bd      	mov	sp, r7
     1ba:	bd80      	pop	{r7, pc}
     1bc:	41002000 	.word	0x41002000

000001c0 <i2c_master_is_syncing>:
 * \retval true   Module is busy synchronizing
 * \retval false  Module is not synchronizing
 */
static inline bool i2c_master_is_syncing (
		const struct i2c_master_module *const module)
{
     1c0:	b580      	push	{r7, lr}
     1c2:	b084      	sub	sp, #16
     1c4:	af00      	add	r7, sp, #0
     1c6:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
     1c8:	687b      	ldr	r3, [r7, #4]
     1ca:	681b      	ldr	r3, [r3, #0]
     1cc:	60fb      	str	r3, [r7, #12]

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
     1ce:	68fb      	ldr	r3, [r7, #12]
     1d0:	8a1b      	ldrh	r3, [r3, #16]
     1d2:	b29b      	uxth	r3, r3
     1d4:	001a      	movs	r2, r3
     1d6:	2380      	movs	r3, #128	; 0x80
     1d8:	021b      	lsls	r3, r3, #8
     1da:	4013      	ands	r3, r2
     1dc:	1e5a      	subs	r2, r3, #1
     1de:	4193      	sbcs	r3, r2
     1e0:	b2db      	uxtb	r3, r3
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
#else
#  error Unknown SERCOM SYNCBUSY scheme!
#endif
}
     1e2:	0018      	movs	r0, r3
     1e4:	46bd      	mov	sp, r7
     1e6:	b004      	add	sp, #16
     1e8:	bd80      	pop	{r7, pc}
     1ea:	46c0      	nop			; (mov r8, r8)

000001ec <_i2c_master_wait_for_sync>:
 *
 * \param[in]  module  Pointer to software module structure
 */
static void _i2c_master_wait_for_sync(
		const struct i2c_master_module *const module)
{
     1ec:	b580      	push	{r7, lr}
     1ee:	b082      	sub	sp, #8
     1f0:	af00      	add	r7, sp, #0
     1f2:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
     1f4:	46c0      	nop			; (mov r8, r8)
     1f6:	687b      	ldr	r3, [r7, #4]
     1f8:	0018      	movs	r0, r3
     1fa:	4b04      	ldr	r3, [pc, #16]	; (20c <_i2c_master_wait_for_sync+0x20>)
     1fc:	4798      	blx	r3
     1fe:	1e03      	subs	r3, r0, #0
     200:	d1f9      	bne.n	1f6 <_i2c_master_wait_for_sync+0xa>
		/* Wait for I2C module to sync. */
	}
}
     202:	46c0      	nop			; (mov r8, r8)
     204:	46bd      	mov	sp, r7
     206:	b002      	add	sp, #8
     208:	bd80      	pop	{r7, pc}
     20a:	46c0      	nop			; (mov r8, r8)
     20c:	000001c1 	.word	0x000001c1

00000210 <_i2c_master_set_config>:
 *                                          with set GCLK frequency
 */
static enum status_code _i2c_master_set_config(
		struct i2c_master_module *const module,
		const struct i2c_master_config *const config)
{
     210:	b590      	push	{r4, r7, lr}
     212:	b08d      	sub	sp, #52	; 0x34
     214:	af00      	add	r7, sp, #0
     216:	6078      	str	r0, [r7, #4]
     218:	6039      	str	r1, [r7, #0]
	Assert(config);

	/* Temporary variables. */
	uint32_t tmp_ctrla;
	int32_t tmp_baud;
	enum status_code tmp_status_code = STATUS_OK;
     21a:	232b      	movs	r3, #43	; 0x2b
     21c:	18fb      	adds	r3, r7, r3
     21e:	2200      	movs	r2, #0
     220:	701a      	strb	r2, [r3, #0]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     222:	687b      	ldr	r3, [r7, #4]
     224:	681b      	ldr	r3, [r3, #0]
     226:	61fb      	str	r3, [r7, #28]
	Sercom *const sercom_hw = module->hw;
     228:	687b      	ldr	r3, [r7, #4]
     22a:	681b      	ldr	r3, [r3, #0]
     22c:	61bb      	str	r3, [r7, #24]

	uint8_t sercom_index = _sercom_get_sercom_inst_index(sercom_hw);
     22e:	2317      	movs	r3, #23
     230:	18fc      	adds	r4, r7, r3
     232:	69bb      	ldr	r3, [r7, #24]
     234:	0018      	movs	r0, r3
     236:	4b59      	ldr	r3, [pc, #356]	; (39c <_i2c_master_set_config+0x18c>)
     238:	4798      	blx	r3
     23a:	0003      	movs	r3, r0
     23c:	7023      	strb	r3, [r4, #0]

	/* Pin configuration */
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
     23e:	230c      	movs	r3, #12
     240:	18fb      	adds	r3, r7, r3
     242:	0018      	movs	r0, r3
     244:	4b56      	ldr	r3, [pc, #344]	; (3a0 <_i2c_master_set_config+0x190>)
     246:	4798      	blx	r3

	uint32_t pad0 = config->pinmux_pad0;
     248:	683b      	ldr	r3, [r7, #0]
     24a:	695b      	ldr	r3, [r3, #20]
     24c:	627b      	str	r3, [r7, #36]	; 0x24
	uint32_t pad1 = config->pinmux_pad1;
     24e:	683b      	ldr	r3, [r7, #0]
     250:	699b      	ldr	r3, [r3, #24]
     252:	623b      	str	r3, [r7, #32]

	/* SERCOM PAD0 - SDA */
	if (pad0 == PINMUX_DEFAULT) {
     254:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     256:	2b00      	cmp	r3, #0
     258:	d106      	bne.n	268 <_i2c_master_set_config+0x58>
		pad0 = _sercom_get_default_pad(sercom_hw, 0);
     25a:	69bb      	ldr	r3, [r7, #24]
     25c:	2100      	movs	r1, #0
     25e:	0018      	movs	r0, r3
     260:	4b50      	ldr	r3, [pc, #320]	; (3a4 <_i2c_master_set_config+0x194>)
     262:	4798      	blx	r3
     264:	0003      	movs	r3, r0
     266:	627b      	str	r3, [r7, #36]	; 0x24
	}
	pin_conf.mux_position = pad0 & 0xFFFF;
     268:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     26a:	b2da      	uxtb	r2, r3
     26c:	230c      	movs	r3, #12
     26e:	18fb      	adds	r3, r7, r3
     270:	701a      	strb	r2, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
     272:	230c      	movs	r3, #12
     274:	18fb      	adds	r3, r7, r3
     276:	2202      	movs	r2, #2
     278:	705a      	strb	r2, [r3, #1]
	system_pinmux_pin_set_config(pad0 >> 16, &pin_conf);
     27a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     27c:	0c1b      	lsrs	r3, r3, #16
     27e:	b2db      	uxtb	r3, r3
     280:	220c      	movs	r2, #12
     282:	18ba      	adds	r2, r7, r2
     284:	0011      	movs	r1, r2
     286:	0018      	movs	r0, r3
     288:	4b47      	ldr	r3, [pc, #284]	; (3a8 <_i2c_master_set_config+0x198>)
     28a:	4798      	blx	r3

	/* SERCOM PAD1 - SCL */
	if (pad1 == PINMUX_DEFAULT) {
     28c:	6a3b      	ldr	r3, [r7, #32]
     28e:	2b00      	cmp	r3, #0
     290:	d106      	bne.n	2a0 <_i2c_master_set_config+0x90>
		pad1 = _sercom_get_default_pad(sercom_hw, 1);
     292:	69bb      	ldr	r3, [r7, #24]
     294:	2101      	movs	r1, #1
     296:	0018      	movs	r0, r3
     298:	4b42      	ldr	r3, [pc, #264]	; (3a4 <_i2c_master_set_config+0x194>)
     29a:	4798      	blx	r3
     29c:	0003      	movs	r3, r0
     29e:	623b      	str	r3, [r7, #32]
	}
	pin_conf.mux_position = pad1 & 0xFFFF;
     2a0:	6a3b      	ldr	r3, [r7, #32]
     2a2:	b2da      	uxtb	r2, r3
     2a4:	230c      	movs	r3, #12
     2a6:	18fb      	adds	r3, r7, r3
     2a8:	701a      	strb	r2, [r3, #0]
	pin_conf.direction    = SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK;
     2aa:	230c      	movs	r3, #12
     2ac:	18fb      	adds	r3, r7, r3
     2ae:	2202      	movs	r2, #2
     2b0:	705a      	strb	r2, [r3, #1]
	system_pinmux_pin_set_config(pad1 >> 16, &pin_conf);
     2b2:	6a3b      	ldr	r3, [r7, #32]
     2b4:	0c1b      	lsrs	r3, r3, #16
     2b6:	b2db      	uxtb	r3, r3
     2b8:	220c      	movs	r2, #12
     2ba:	18ba      	adds	r2, r7, r2
     2bc:	0011      	movs	r1, r2
     2be:	0018      	movs	r0, r3
     2c0:	4b39      	ldr	r3, [pc, #228]	; (3a8 <_i2c_master_set_config+0x198>)
     2c2:	4798      	blx	r3

	/* Save timeout on unknown bus state in software module. */
	module->unknown_bus_state_timeout = config->unknown_bus_state_timeout;
     2c4:	683b      	ldr	r3, [r7, #0]
     2c6:	899a      	ldrh	r2, [r3, #12]
     2c8:	687b      	ldr	r3, [r7, #4]
     2ca:	80da      	strh	r2, [r3, #6]

	/* Save timeout on buffer write. */
	module->buffer_timeout = config->buffer_timeout;
     2cc:	683b      	ldr	r3, [r7, #0]
     2ce:	89da      	ldrh	r2, [r3, #14]
     2d0:	687b      	ldr	r3, [r7, #4]
     2d2:	811a      	strh	r2, [r3, #8]

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
     2d4:	683b      	ldr	r3, [r7, #0]
     2d6:	7c1b      	ldrb	r3, [r3, #16]
     2d8:	2b00      	cmp	r3, #0
     2da:	d103      	bne.n	2e4 <_i2c_master_set_config+0xd4>
     2dc:	4b33      	ldr	r3, [pc, #204]	; (3ac <_i2c_master_set_config+0x19c>)
     2de:	4798      	blx	r3
     2e0:	1e03      	subs	r3, r0, #0
     2e2:	d002      	beq.n	2ea <_i2c_master_set_config+0xda>
		tmp_ctrla = SERCOM_I2CM_CTRLA_RUNSTDBY;
     2e4:	2380      	movs	r3, #128	; 0x80
     2e6:	62fb      	str	r3, [r7, #44]	; 0x2c
     2e8:	e001      	b.n	2ee <_i2c_master_set_config+0xde>
	} else {
		tmp_ctrla = 0;
     2ea:	2300      	movs	r3, #0
     2ec:	62fb      	str	r3, [r7, #44]	; 0x2c
	}

	/* Check and set start data hold timeout. */
	if (config->start_hold_time != I2C_MASTER_START_HOLD_TIME_DISABLED) {
     2ee:	683b      	ldr	r3, [r7, #0]
     2f0:	689b      	ldr	r3, [r3, #8]
     2f2:	2b00      	cmp	r3, #0
     2f4:	d004      	beq.n	300 <_i2c_master_set_config+0xf0>
		tmp_ctrla |= config->start_hold_time;
     2f6:	683b      	ldr	r3, [r7, #0]
     2f8:	689b      	ldr	r3, [r3, #8]
     2fa:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     2fc:	4313      	orrs	r3, r2
     2fe:	62fb      	str	r3, [r7, #44]	; 0x2c
	}

	/* Check and set SCL low timeout. */
	if (config->scl_low_timeout) {
     300:	683b      	ldr	r3, [r7, #0]
     302:	7f1b      	ldrb	r3, [r3, #28]
     304:	2b00      	cmp	r3, #0
     306:	d004      	beq.n	312 <_i2c_master_set_config+0x102>
		tmp_ctrla |= SERCOM_I2CM_CTRLA_LOWTOUT;
     308:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     30a:	2280      	movs	r2, #128	; 0x80
     30c:	05d2      	lsls	r2, r2, #23
     30e:	4313      	orrs	r3, r2
     310:	62fb      	str	r3, [r7, #44]	; 0x2c
	}

	/* Check and set inactive bus timeout. */
	if (config->inactive_timeout != I2C_MASTER_INACTIVE_TIMEOUT_DISABLED) {
     312:	683b      	ldr	r3, [r7, #0]
     314:	6a1b      	ldr	r3, [r3, #32]
     316:	2b00      	cmp	r3, #0
     318:	d004      	beq.n	324 <_i2c_master_set_config+0x114>
		tmp_ctrla |= config->inactive_timeout;
     31a:	683b      	ldr	r3, [r7, #0]
     31c:	6a1b      	ldr	r3, [r3, #32]
     31e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     320:	4313      	orrs	r3, r2
     322:	62fb      	str	r3, [r7, #44]	; 0x2c
	}

	/* Write config to register CTRLA. */
	i2c_module->CTRLA.reg |= tmp_ctrla;
     324:	69fb      	ldr	r3, [r7, #28]
     326:	681a      	ldr	r2, [r3, #0]
     328:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     32a:	431a      	orrs	r2, r3
     32c:	69fb      	ldr	r3, [r7, #28]
     32e:	601a      	str	r2, [r3, #0]

	/* Set configurations in CTRLB. */
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
     330:	69fb      	ldr	r3, [r7, #28]
     332:	2280      	movs	r2, #128	; 0x80
     334:	0052      	lsls	r2, r2, #1
     336:	605a      	str	r2, [r3, #4]

	/* Find and set baudrate. */
	tmp_baud = (int32_t)(div_ceil(
     338:	2317      	movs	r3, #23
     33a:	18fb      	adds	r3, r7, r3
     33c:	781b      	ldrb	r3, [r3, #0]
     33e:	330d      	adds	r3, #13
     340:	b2db      	uxtb	r3, r3
     342:	0018      	movs	r0, r3
     344:	4b1a      	ldr	r3, [pc, #104]	; (3b0 <_i2c_master_set_config+0x1a0>)
     346:	4798      	blx	r3
     348:	0001      	movs	r1, r0
     34a:	683b      	ldr	r3, [r7, #0]
     34c:	681b      	ldr	r3, [r3, #0]
     34e:	22fa      	movs	r2, #250	; 0xfa
     350:	00d2      	lsls	r2, r2, #3
     352:	4353      	muls	r3, r2
     354:	18cb      	adds	r3, r1, r3
     356:	1e58      	subs	r0, r3, #1
     358:	683b      	ldr	r3, [r7, #0]
     35a:	681b      	ldr	r3, [r3, #0]
     35c:	22fa      	movs	r2, #250	; 0xfa
     35e:	00d2      	lsls	r2, r2, #3
     360:	435a      	muls	r2, r3
     362:	4b14      	ldr	r3, [pc, #80]	; (3b4 <_i2c_master_set_config+0x1a4>)
     364:	0011      	movs	r1, r2
     366:	4798      	blx	r3
     368:	0003      	movs	r3, r0
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate))) - 5);
     36a:	3b05      	subs	r3, #5

	/* Set configurations in CTRLB. */
	i2c_module->CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;

	/* Find and set baudrate. */
	tmp_baud = (int32_t)(div_ceil(
     36c:	613b      	str	r3, [r7, #16]
				system_gclk_chan_get_hz(SERCOM0_GCLK_ID_CORE + sercom_index),
				(2000*(config->baud_rate))) - 5);

	/* Check that baud rate is supported at current speed. */
	if (tmp_baud > 255 || tmp_baud < 0) {
     36e:	693b      	ldr	r3, [r7, #16]
     370:	2bff      	cmp	r3, #255	; 0xff
     372:	dc02      	bgt.n	37a <_i2c_master_set_config+0x16a>
     374:	693b      	ldr	r3, [r7, #16]
     376:	2b00      	cmp	r3, #0
     378:	da04      	bge.n	384 <_i2c_master_set_config+0x174>
		/* Baud rate not supported. */
		tmp_status_code = STATUS_ERR_BAUDRATE_UNAVAILABLE;
     37a:	232b      	movs	r3, #43	; 0x2b
     37c:	18fb      	adds	r3, r7, r3
     37e:	2240      	movs	r2, #64	; 0x40
     380:	701a      	strb	r2, [r3, #0]
     382:	e004      	b.n	38e <_i2c_master_set_config+0x17e>
	} else {
		/* Baud rate acceptable. */
		i2c_module->BAUD.reg = (uint8_t)tmp_baud;
     384:	693b      	ldr	r3, [r7, #16]
     386:	b2db      	uxtb	r3, r3
     388:	b29a      	uxth	r2, r3
     38a:	69fb      	ldr	r3, [r7, #28]
     38c:	815a      	strh	r2, [r3, #10]
	}

	return tmp_status_code;
     38e:	232b      	movs	r3, #43	; 0x2b
     390:	18fb      	adds	r3, r7, r3
     392:	781b      	ldrb	r3, [r3, #0]
}
     394:	0018      	movs	r0, r3
     396:	46bd      	mov	sp, r7
     398:	b00d      	add	sp, #52	; 0x34
     39a:	bd90      	pop	{r4, r7, pc}
     39c:	00002dc9 	.word	0x00002dc9
     3a0:	00000179 	.word	0x00000179
     3a4:	00002c0d 	.word	0x00002c0d
     3a8:	00004d95 	.word	0x00004d95
     3ac:	000001a1 	.word	0x000001a1
     3b0:	00004bcd 	.word	0x00004bcd
     3b4:	0000f8ed 	.word	0x0000f8ed

000003b8 <i2c_master_init>:
 */
enum status_code i2c_master_init(
		struct i2c_master_module *const module,
		Sercom *const hw,
		const struct i2c_master_config *const config)
{
     3b8:	b590      	push	{r4, r7, lr}
     3ba:	b08b      	sub	sp, #44	; 0x2c
     3bc:	af00      	add	r7, sp, #0
     3be:	60f8      	str	r0, [r7, #12]
     3c0:	60b9      	str	r1, [r7, #8]
     3c2:	607a      	str	r2, [r7, #4]
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize software module */
	module->hw = hw;
     3c4:	68fb      	ldr	r3, [r7, #12]
     3c6:	68ba      	ldr	r2, [r7, #8]
     3c8:	601a      	str	r2, [r3, #0]

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     3ca:	68fb      	ldr	r3, [r7, #12]
     3cc:	681b      	ldr	r3, [r3, #0]
     3ce:	627b      	str	r3, [r7, #36]	; 0x24

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
     3d0:	68fb      	ldr	r3, [r7, #12]
     3d2:	681b      	ldr	r3, [r3, #0]
     3d4:	0018      	movs	r0, r3
     3d6:	4b3b      	ldr	r3, [pc, #236]	; (4c4 <i2c_master_init+0x10c>)
     3d8:	4798      	blx	r3
     3da:	0003      	movs	r3, r0
     3dc:	623b      	str	r3, [r7, #32]
	uint32_t pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
     3de:	6a3b      	ldr	r3, [r7, #32]
     3e0:	3302      	adds	r3, #2
     3e2:	61fb      	str	r3, [r7, #28]
	uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
     3e4:	6a3b      	ldr	r3, [r7, #32]
     3e6:	330d      	adds	r3, #13
     3e8:	61bb      	str	r3, [r7, #24]

	/* Turn on module in PM */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
     3ea:	2201      	movs	r2, #1
     3ec:	69fb      	ldr	r3, [r7, #28]
     3ee:	409a      	lsls	r2, r3
     3f0:	0013      	movs	r3, r2
     3f2:	0019      	movs	r1, r3
     3f4:	2002      	movs	r0, #2
     3f6:	4b34      	ldr	r3, [pc, #208]	; (4c8 <i2c_master_init+0x110>)
     3f8:	4798      	blx	r3

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
     3fa:	2314      	movs	r3, #20
     3fc:	18fb      	adds	r3, r7, r3
     3fe:	0018      	movs	r0, r3
     400:	4b32      	ldr	r3, [pc, #200]	; (4cc <i2c_master_init+0x114>)
     402:	4798      	blx	r3
	gclk_chan_conf.source_generator = config->generator_source;
     404:	687b      	ldr	r3, [r7, #4]
     406:	791a      	ldrb	r2, [r3, #4]
     408:	2314      	movs	r3, #20
     40a:	18fb      	adds	r3, r7, r3
     40c:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
     40e:	69bb      	ldr	r3, [r7, #24]
     410:	b2db      	uxtb	r3, r3
     412:	2214      	movs	r2, #20
     414:	18ba      	adds	r2, r7, r2
     416:	0011      	movs	r1, r2
     418:	0018      	movs	r0, r3
     41a:	4b2d      	ldr	r3, [pc, #180]	; (4d0 <i2c_master_init+0x118>)
     41c:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
     41e:	69bb      	ldr	r3, [r7, #24]
     420:	b2db      	uxtb	r3, r3
     422:	0018      	movs	r0, r3
     424:	4b2b      	ldr	r3, [pc, #172]	; (4d4 <i2c_master_init+0x11c>)
     426:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
     428:	687b      	ldr	r3, [r7, #4]
     42a:	791b      	ldrb	r3, [r3, #4]
     42c:	2100      	movs	r1, #0
     42e:	0018      	movs	r0, r3
     430:	4b29      	ldr	r3, [pc, #164]	; (4d8 <i2c_master_init+0x120>)
     432:	4798      	blx	r3

	/* Check if module is enabled. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_ENABLE) {
     434:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     436:	681b      	ldr	r3, [r3, #0]
     438:	2202      	movs	r2, #2
     43a:	4013      	ands	r3, r2
     43c:	d001      	beq.n	442 <i2c_master_init+0x8a>
		return STATUS_ERR_DENIED;
     43e:	231c      	movs	r3, #28
     440:	e03b      	b.n	4ba <i2c_master_init+0x102>
	}

	/* Check if reset is in progress. */
	if (i2c_module->CTRLA.reg & SERCOM_I2CM_CTRLA_SWRST) {
     442:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     444:	681b      	ldr	r3, [r3, #0]
     446:	2201      	movs	r2, #1
     448:	4013      	ands	r3, r2
     44a:	d001      	beq.n	450 <i2c_master_init+0x98>
		return STATUS_BUSY;
     44c:	2305      	movs	r3, #5
     44e:	e034      	b.n	4ba <i2c_master_init+0x102>
	}

#if I2C_MASTER_CALLBACK_MODE == true
	/* Get sercom instance index and register callback. */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
     450:	68fb      	ldr	r3, [r7, #12]
     452:	681b      	ldr	r3, [r3, #0]
     454:	2217      	movs	r2, #23
     456:	18bc      	adds	r4, r7, r2
     458:	0018      	movs	r0, r3
     45a:	4b1a      	ldr	r3, [pc, #104]	; (4c4 <i2c_master_init+0x10c>)
     45c:	4798      	blx	r3
     45e:	0003      	movs	r3, r0
     460:	7023      	strb	r3, [r4, #0]
	_sercom_set_handler(instance_index, _i2c_master_interrupt_handler);
     462:	4a1e      	ldr	r2, [pc, #120]	; (4dc <i2c_master_init+0x124>)
     464:	2317      	movs	r3, #23
     466:	18fb      	adds	r3, r7, r3
     468:	781b      	ldrb	r3, [r3, #0]
     46a:	0011      	movs	r1, r2
     46c:	0018      	movs	r0, r3
     46e:	4b1c      	ldr	r3, [pc, #112]	; (4e0 <i2c_master_init+0x128>)
     470:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
     472:	2317      	movs	r3, #23
     474:	18fb      	adds	r3, r7, r3
     476:	781a      	ldrb	r2, [r3, #0]
     478:	4b1a      	ldr	r3, [pc, #104]	; (4e4 <i2c_master_init+0x12c>)
     47a:	0092      	lsls	r2, r2, #2
     47c:	68f9      	ldr	r1, [r7, #12]
     47e:	50d1      	str	r1, [r2, r3]

	/* Initialize values in module. */
	module->registered_callback = 0;
     480:	68fb      	ldr	r3, [r7, #12]
     482:	2200      	movs	r2, #0
     484:	761a      	strb	r2, [r3, #24]
	module->enabled_callback = 0;
     486:	68fb      	ldr	r3, [r7, #12]
     488:	2200      	movs	r2, #0
     48a:	765a      	strb	r2, [r3, #25]
	module->buffer_length = 0;
     48c:	68fb      	ldr	r3, [r7, #12]
     48e:	2200      	movs	r2, #0
     490:	835a      	strh	r2, [r3, #26]
	module->buffer_remaining = 0;
     492:	68fb      	ldr	r3, [r7, #12]
     494:	2200      	movs	r2, #0
     496:	839a      	strh	r2, [r3, #28]

	module->status = STATUS_OK;
     498:	68fb      	ldr	r3, [r7, #12]
     49a:	2225      	movs	r2, #37	; 0x25
     49c:	2100      	movs	r1, #0
     49e:	5499      	strb	r1, [r3, r2]
	module->buffer = NULL;
     4a0:	68fb      	ldr	r3, [r7, #12]
     4a2:	2200      	movs	r2, #0
     4a4:	621a      	str	r2, [r3, #32]
#endif

	/* Set sercom module to operate in I2C master mode. */
	i2c_module->CTRLA.reg = SERCOM_I2CM_CTRLA_MODE_I2C_MASTER;
     4a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     4a8:	2214      	movs	r2, #20
     4aa:	601a      	str	r2, [r3, #0]

	/* Set config and return status. */
	return _i2c_master_set_config(module, config);
     4ac:	687a      	ldr	r2, [r7, #4]
     4ae:	68fb      	ldr	r3, [r7, #12]
     4b0:	0011      	movs	r1, r2
     4b2:	0018      	movs	r0, r3
     4b4:	4b0c      	ldr	r3, [pc, #48]	; (4e8 <i2c_master_init+0x130>)
     4b6:	4798      	blx	r3
     4b8:	0003      	movs	r3, r0
}
     4ba:	0018      	movs	r0, r3
     4bc:	46bd      	mov	sp, r7
     4be:	b00b      	add	sp, #44	; 0x2c
     4c0:	bd90      	pop	{r4, r7, pc}
     4c2:	46c0      	nop			; (mov r8, r8)
     4c4:	00002dc9 	.word	0x00002dc9
     4c8:	0000011d 	.word	0x0000011d
     4cc:	00000105 	.word	0x00000105
     4d0:	00004aa9 	.word	0x00004aa9
     4d4:	00004aed 	.word	0x00004aed
     4d8:	00002b81 	.word	0x00002b81
     4dc:	00000b01 	.word	0x00000b01
     4e0:	00002e2d 	.word	0x00002e2d
     4e4:	20002e54 	.word	0x20002e54
     4e8:	00000211 	.word	0x00000211

000004ec <_i2c_master_address_response>:
 * \retval STATUS_ERR_BAD_ADDRESS       If slave is busy, or no slave
 *                                      acknowledged the address
 */
static enum status_code _i2c_master_address_response(
		struct i2c_master_module *const module)
{
     4ec:	b580      	push	{r7, lr}
     4ee:	b084      	sub	sp, #16
     4f0:	af00      	add	r7, sp, #0
     4f2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     4f4:	687b      	ldr	r3, [r7, #4]
     4f6:	681b      	ldr	r3, [r3, #0]
     4f8:	60fb      	str	r3, [r7, #12]

	/* Check for error and ignore bus-error; workaround for BUSSTATE stuck in
	 * BUSY */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB) {
     4fa:	68fb      	ldr	r3, [r7, #12]
     4fc:	7b9b      	ldrb	r3, [r3, #14]
     4fe:	b2db      	uxtb	r3, r3
     500:	001a      	movs	r2, r3
     502:	2302      	movs	r3, #2
     504:	4013      	ands	r3, r2
     506:	d00b      	beq.n	520 <_i2c_master_address_response+0x34>

		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
     508:	68fb      	ldr	r3, [r7, #12]
     50a:	2202      	movs	r2, #2
     50c:	739a      	strb	r2, [r3, #14]

		/* Check arbitration. */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
     50e:	68fb      	ldr	r3, [r7, #12]
     510:	8a1b      	ldrh	r3, [r3, #16]
     512:	b29b      	uxth	r3, r3
     514:	001a      	movs	r2, r3
     516:	2302      	movs	r3, #2
     518:	4013      	ands	r3, r2
     51a:	d011      	beq.n	540 <_i2c_master_address_response+0x54>
			/* Return packet collision. */
			return STATUS_ERR_PACKET_COLLISION;
     51c:	2341      	movs	r3, #65	; 0x41
     51e:	e010      	b.n	542 <_i2c_master_address_response+0x56>
		}
	/* Check that slave responded with ack. */
	} else if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
     520:	68fb      	ldr	r3, [r7, #12]
     522:	8a1b      	ldrh	r3, [r3, #16]
     524:	b29b      	uxth	r3, r3
     526:	001a      	movs	r2, r3
     528:	2304      	movs	r3, #4
     52a:	4013      	ands	r3, r2
     52c:	d008      	beq.n	540 <_i2c_master_address_response+0x54>
		/* Slave busy. Issue ack and stop command. */
		i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     52e:	68fb      	ldr	r3, [r7, #12]
     530:	685b      	ldr	r3, [r3, #4]
     532:	22c0      	movs	r2, #192	; 0xc0
     534:	0292      	lsls	r2, r2, #10
     536:	431a      	orrs	r2, r3
     538:	68fb      	ldr	r3, [r7, #12]
     53a:	605a      	str	r2, [r3, #4]

		/* Return bad address value. */
		return STATUS_ERR_BAD_ADDRESS;
     53c:	2318      	movs	r3, #24
     53e:	e000      	b.n	542 <_i2c_master_address_response+0x56>
	}

	return STATUS_OK;
     540:	2300      	movs	r3, #0
}
     542:	0018      	movs	r0, r3
     544:	46bd      	mov	sp, r7
     546:	b004      	add	sp, #16
     548:	bd80      	pop	{r7, pc}
     54a:	46c0      	nop			; (mov r8, r8)

0000054c <_i2c_master_wait_for_bus>:
 * \retval STATUS_ERR_TIMEOUT  If no response was given within specified timeout
 *                             period
 */
static enum status_code _i2c_master_wait_for_bus(
		struct i2c_master_module *const module)
{
     54c:	b580      	push	{r7, lr}
     54e:	b084      	sub	sp, #16
     550:	af00      	add	r7, sp, #0
     552:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     554:	687b      	ldr	r3, [r7, #4]
     556:	681b      	ldr	r3, [r3, #0]
     558:	60bb      	str	r3, [r7, #8]

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
     55a:	230e      	movs	r3, #14
     55c:	18fb      	adds	r3, r7, r3
     55e:	2200      	movs	r2, #0
     560:	801a      	strh	r2, [r3, #0]
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
     562:	e00f      	b.n	584 <_i2c_master_wait_for_bus+0x38>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {

		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
     564:	230e      	movs	r3, #14
     566:	18fb      	adds	r3, r7, r3
     568:	220e      	movs	r2, #14
     56a:	18ba      	adds	r2, r7, r2
     56c:	8812      	ldrh	r2, [r2, #0]
     56e:	3201      	adds	r2, #1
     570:	801a      	strh	r2, [r3, #0]
     572:	687b      	ldr	r3, [r7, #4]
     574:	891b      	ldrh	r3, [r3, #8]
     576:	220e      	movs	r2, #14
     578:	18ba      	adds	r2, r7, r2
     57a:	8812      	ldrh	r2, [r2, #0]
     57c:	429a      	cmp	r2, r3
     57e:	d301      	bcc.n	584 <_i2c_master_wait_for_bus+0x38>
			return STATUS_ERR_TIMEOUT;
     580:	2312      	movs	r3, #18
     582:	e00e      	b.n	5a2 <_i2c_master_wait_for_bus+0x56>

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
     584:	68bb      	ldr	r3, [r7, #8]
     586:	7b9b      	ldrb	r3, [r3, #14]
     588:	b2db      	uxtb	r3, r3
     58a:	001a      	movs	r2, r3
     58c:	2301      	movs	r3, #1
     58e:	4013      	ands	r3, r2
     590:	d106      	bne.n	5a0 <_i2c_master_wait_for_bus+0x54>
			!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_SB)) {
     592:	68bb      	ldr	r3, [r7, #8]
     594:	7b9b      	ldrb	r3, [r3, #14]
     596:	b2db      	uxtb	r3, r3
     598:	001a      	movs	r2, r3
     59a:	2302      	movs	r3, #2
     59c:	4013      	ands	r3, r2

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Wait for reply. */
	uint16_t timeout_counter = 0;
	while (!(i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB) &&
     59e:	d0e1      	beq.n	564 <_i2c_master_wait_for_bus+0x18>
		/* Check timeout condition. */
		if (++timeout_counter >= module->buffer_timeout) {
			return STATUS_ERR_TIMEOUT;
		}
	}
	return STATUS_OK;
     5a0:	2300      	movs	r3, #0
}
     5a2:	0018      	movs	r0, r3
     5a4:	46bd      	mov	sp, r7
     5a6:	b004      	add	sp, #16
     5a8:	bd80      	pop	{r7, pc}
     5aa:	46c0      	nop			; (mov r8, r8)

000005ac <_i2c_master_read_packet>:
 *
 */
static enum status_code _i2c_master_read_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
     5ac:	b590      	push	{r4, r7, lr}
     5ae:	b087      	sub	sp, #28
     5b0:	af00      	add	r7, sp, #0
     5b2:	6078      	str	r0, [r7, #4]
     5b4:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);
	Assert(packet);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     5b6:	687b      	ldr	r3, [r7, #4]
     5b8:	681b      	ldr	r3, [r3, #0]
     5ba:	60fb      	str	r3, [r7, #12]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
     5bc:	2314      	movs	r3, #20
     5be:	18fb      	adds	r3, r7, r3
     5c0:	683a      	ldr	r2, [r7, #0]
     5c2:	8852      	ldrh	r2, [r2, #2]
     5c4:	801a      	strh	r2, [r3, #0]

	/* Written buffer counter. */
	uint16_t counter = 0;
     5c6:	2312      	movs	r3, #18
     5c8:	18fb      	adds	r3, r7, r3
     5ca:	2200      	movs	r2, #0
     5cc:	801a      	strh	r2, [r3, #0]

	/* Set address and direction bit. Will send start command on bus. */
	i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_READ;
     5ce:	683b      	ldr	r3, [r7, #0]
     5d0:	881b      	ldrh	r3, [r3, #0]
     5d2:	005b      	lsls	r3, r3, #1
     5d4:	b25b      	sxtb	r3, r3
     5d6:	2201      	movs	r2, #1
     5d8:	4313      	orrs	r3, r2
     5da:	b25b      	sxtb	r3, r3
     5dc:	b2da      	uxtb	r2, r3
     5de:	68fb      	ldr	r3, [r7, #12]
     5e0:	751a      	strb	r2, [r3, #20]

	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
     5e2:	2317      	movs	r3, #23
     5e4:	18fc      	adds	r4, r7, r3
     5e6:	687b      	ldr	r3, [r7, #4]
     5e8:	0018      	movs	r0, r3
     5ea:	4b49      	ldr	r3, [pc, #292]	; (710 <_i2c_master_read_packet+0x164>)
     5ec:	4798      	blx	r3
     5ee:	0003      	movs	r3, r0
     5f0:	7023      	strb	r3, [r4, #0]

	/* Set action to ack. */
	i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     5f2:	68fb      	ldr	r3, [r7, #12]
     5f4:	685b      	ldr	r3, [r3, #4]
     5f6:	4a47      	ldr	r2, [pc, #284]	; (714 <_i2c_master_read_packet+0x168>)
     5f8:	401a      	ands	r2, r3
     5fa:	68fb      	ldr	r3, [r7, #12]
     5fc:	605a      	str	r2, [r3, #4]

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
     5fe:	2317      	movs	r3, #23
     600:	18fb      	adds	r3, r7, r3
     602:	781b      	ldrb	r3, [r3, #0]
     604:	2b00      	cmp	r3, #0
     606:	d107      	bne.n	618 <_i2c_master_read_packet+0x6c>
		tmp_status = _i2c_master_address_response(module);
     608:	2317      	movs	r3, #23
     60a:	18fc      	adds	r4, r7, r3
     60c:	687b      	ldr	r3, [r7, #4]
     60e:	0018      	movs	r0, r3
     610:	4b41      	ldr	r3, [pc, #260]	; (718 <_i2c_master_read_packet+0x16c>)
     612:	4798      	blx	r3
     614:	0003      	movs	r3, r0
     616:	7023      	strb	r3, [r4, #0]
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
     618:	2317      	movs	r3, #23
     61a:	18fb      	adds	r3, r7, r3
     61c:	781b      	ldrb	r3, [r3, #0]
     61e:	2b00      	cmp	r3, #0
     620:	d000      	beq.n	624 <_i2c_master_read_packet+0x78>
     622:	e06d      	b.n	700 <_i2c_master_read_packet+0x154>
		/* Read data buffer. */
		while (tmp_data_length--) {
     624:	e038      	b.n	698 <_i2c_master_read_packet+0xec>
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
     626:	68fb      	ldr	r3, [r7, #12]
     628:	8a1b      	ldrh	r3, [r3, #16]
     62a:	b29b      	uxth	r3, r3
     62c:	001a      	movs	r2, r3
     62e:	2320      	movs	r3, #32
     630:	4013      	ands	r3, r2
     632:	d101      	bne.n	638 <_i2c_master_read_packet+0x8c>
				return STATUS_ERR_PACKET_COLLISION;
     634:	2341      	movs	r3, #65	; 0x41
     636:	e066      	b.n	706 <_i2c_master_read_packet+0x15a>
			}

			if (module->send_nack && tmp_data_length == 0) {
     638:	687b      	ldr	r3, [r7, #4]
     63a:	7adb      	ldrb	r3, [r3, #11]
     63c:	2b00      	cmp	r3, #0
     63e:	d00c      	beq.n	65a <_i2c_master_read_packet+0xae>
     640:	2314      	movs	r3, #20
     642:	18fb      	adds	r3, r7, r3
     644:	881b      	ldrh	r3, [r3, #0]
     646:	2b00      	cmp	r3, #0
     648:	d107      	bne.n	65a <_i2c_master_read_packet+0xae>
				/* Set action to NACK */
				i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     64a:	68fb      	ldr	r3, [r7, #12]
     64c:	685b      	ldr	r3, [r3, #4]
     64e:	2280      	movs	r2, #128	; 0x80
     650:	02d2      	lsls	r2, r2, #11
     652:	431a      	orrs	r2, r3
     654:	68fb      	ldr	r3, [r7, #12]
     656:	605a      	str	r2, [r3, #4]
     658:	e019      	b.n	68e <_i2c_master_read_packet+0xe2>
			} else {
				/* Save data to buffer. */
				_i2c_master_wait_for_sync(module);
     65a:	687b      	ldr	r3, [r7, #4]
     65c:	0018      	movs	r0, r3
     65e:	4b2f      	ldr	r3, [pc, #188]	; (71c <_i2c_master_read_packet+0x170>)
     660:	4798      	blx	r3
				packet->data[counter++] = i2c_module->DATA.reg;
     662:	683b      	ldr	r3, [r7, #0]
     664:	685a      	ldr	r2, [r3, #4]
     666:	2312      	movs	r3, #18
     668:	18fb      	adds	r3, r7, r3
     66a:	881b      	ldrh	r3, [r3, #0]
     66c:	2112      	movs	r1, #18
     66e:	1879      	adds	r1, r7, r1
     670:	1c58      	adds	r0, r3, #1
     672:	8008      	strh	r0, [r1, #0]
     674:	18d3      	adds	r3, r2, r3
     676:	68fa      	ldr	r2, [r7, #12]
     678:	7e12      	ldrb	r2, [r2, #24]
     67a:	b2d2      	uxtb	r2, r2
     67c:	701a      	strb	r2, [r3, #0]
				/* Wait for response. */
				tmp_status = _i2c_master_wait_for_bus(module);
     67e:	2317      	movs	r3, #23
     680:	18fc      	adds	r4, r7, r3
     682:	687b      	ldr	r3, [r7, #4]
     684:	0018      	movs	r0, r3
     686:	4b22      	ldr	r3, [pc, #136]	; (710 <_i2c_master_read_packet+0x164>)
     688:	4798      	blx	r3
     68a:	0003      	movs	r3, r0
     68c:	7023      	strb	r3, [r4, #0]
			}

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
     68e:	2317      	movs	r3, #23
     690:	18fb      	adds	r3, r7, r3
     692:	781b      	ldrb	r3, [r3, #0]
     694:	2b00      	cmp	r3, #0
     696:	d109      	bne.n	6ac <_i2c_master_read_packet+0x100>
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
		/* Read data buffer. */
		while (tmp_data_length--) {
     698:	2314      	movs	r3, #20
     69a:	18fb      	adds	r3, r7, r3
     69c:	881b      	ldrh	r3, [r3, #0]
     69e:	2214      	movs	r2, #20
     6a0:	18ba      	adds	r2, r7, r2
     6a2:	1e59      	subs	r1, r3, #1
     6a4:	8011      	strh	r1, [r2, #0]
     6a6:	2b00      	cmp	r3, #0
     6a8:	d1bd      	bne.n	626 <_i2c_master_read_packet+0x7a>
     6aa:	e000      	b.n	6ae <_i2c_master_read_packet+0x102>
				tmp_status = _i2c_master_wait_for_bus(module);
			}

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
				break;
     6ac:	46c0      	nop			; (mov r8, r8)
			}
		}

		if (module->send_stop) {
     6ae:	687b      	ldr	r3, [r7, #4]
     6b0:	7a9b      	ldrb	r3, [r3, #10]
     6b2:	2b00      	cmp	r3, #0
     6b4:	d00b      	beq.n	6ce <_i2c_master_read_packet+0x122>
			/* Send stop command unless arbitration is lost. */
			_i2c_master_wait_for_sync(module);
     6b6:	687b      	ldr	r3, [r7, #4]
     6b8:	0018      	movs	r0, r3
     6ba:	4b18      	ldr	r3, [pc, #96]	; (71c <_i2c_master_read_packet+0x170>)
     6bc:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     6be:	68fb      	ldr	r3, [r7, #12]
     6c0:	685b      	ldr	r3, [r3, #4]
     6c2:	22c0      	movs	r2, #192	; 0xc0
     6c4:	0292      	lsls	r2, r2, #10
     6c6:	431a      	orrs	r2, r3
     6c8:	68fb      	ldr	r3, [r7, #12]
     6ca:	605a      	str	r2, [r3, #4]
     6cc:	e00a      	b.n	6e4 <_i2c_master_read_packet+0x138>
		} else {
		  	_i2c_master_wait_for_sync(module);
     6ce:	687b      	ldr	r3, [r7, #4]
     6d0:	0018      	movs	r0, r3
     6d2:	4b12      	ldr	r3, [pc, #72]	; (71c <_i2c_master_read_packet+0x170>)
     6d4:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(1);
     6d6:	68fb      	ldr	r3, [r7, #12]
     6d8:	685b      	ldr	r3, [r3, #4]
     6da:	2280      	movs	r2, #128	; 0x80
     6dc:	0252      	lsls	r2, r2, #9
     6de:	431a      	orrs	r2, r3
     6e0:	68fb      	ldr	r3, [r7, #12]
     6e2:	605a      	str	r2, [r3, #4]
		}

		/* Save last data to buffer. */
		_i2c_master_wait_for_sync(module);
     6e4:	687b      	ldr	r3, [r7, #4]
     6e6:	0018      	movs	r0, r3
     6e8:	4b0c      	ldr	r3, [pc, #48]	; (71c <_i2c_master_read_packet+0x170>)
     6ea:	4798      	blx	r3
		packet->data[counter] = i2c_module->DATA.reg;
     6ec:	683b      	ldr	r3, [r7, #0]
     6ee:	685a      	ldr	r2, [r3, #4]
     6f0:	2312      	movs	r3, #18
     6f2:	18fb      	adds	r3, r7, r3
     6f4:	881b      	ldrh	r3, [r3, #0]
     6f6:	18d3      	adds	r3, r2, r3
     6f8:	68fa      	ldr	r2, [r7, #12]
     6fa:	7e12      	ldrb	r2, [r2, #24]
     6fc:	b2d2      	uxtb	r2, r2
     6fe:	701a      	strb	r2, [r3, #0]
	}

	return tmp_status;
     700:	2317      	movs	r3, #23
     702:	18fb      	adds	r3, r7, r3
     704:	781b      	ldrb	r3, [r3, #0]
}
     706:	0018      	movs	r0, r3
     708:	46bd      	mov	sp, r7
     70a:	b007      	add	sp, #28
     70c:	bd90      	pop	{r4, r7, pc}
     70e:	46c0      	nop			; (mov r8, r8)
     710:	0000054d 	.word	0x0000054d
     714:	fffbffff 	.word	0xfffbffff
     718:	000004ed 	.word	0x000004ed
     71c:	000001ed 	.word	0x000001ed

00000720 <i2c_master_read_packet_wait>:
 *                                      acknowledged the address
 */
enum status_code i2c_master_read_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
     720:	b580      	push	{r7, lr}
     722:	b082      	sub	sp, #8
     724:	af00      	add	r7, sp, #0
     726:	6078      	str	r0, [r7, #4]
     728:	6039      	str	r1, [r7, #0]
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job. */
	if (module->buffer_remaining > 0) {
     72a:	687b      	ldr	r3, [r7, #4]
     72c:	8b9b      	ldrh	r3, [r3, #28]
     72e:	b29b      	uxth	r3, r3
     730:	2b00      	cmp	r3, #0
     732:	d001      	beq.n	738 <i2c_master_read_packet_wait+0x18>
		return STATUS_BUSY;
     734:	2305      	movs	r3, #5
     736:	e00c      	b.n	752 <i2c_master_read_packet_wait+0x32>
	}
#endif

	module->send_stop = true;
     738:	687b      	ldr	r3, [r7, #4]
     73a:	2201      	movs	r2, #1
     73c:	729a      	strb	r2, [r3, #10]
	module->send_nack = true;
     73e:	687b      	ldr	r3, [r7, #4]
     740:	2201      	movs	r2, #1
     742:	72da      	strb	r2, [r3, #11]
	
	return _i2c_master_read_packet(module, packet);
     744:	683a      	ldr	r2, [r7, #0]
     746:	687b      	ldr	r3, [r7, #4]
     748:	0011      	movs	r1, r2
     74a:	0018      	movs	r0, r3
     74c:	4b03      	ldr	r3, [pc, #12]	; (75c <i2c_master_read_packet_wait+0x3c>)
     74e:	4798      	blx	r3
     750:	0003      	movs	r3, r0
}
     752:	0018      	movs	r0, r3
     754:	46bd      	mov	sp, r7
     756:	b002      	add	sp, #8
     758:	bd80      	pop	{r7, pc}
     75a:	46c0      	nop			; (mov r8, r8)
     75c:	000005ad 	.word	0x000005ad

00000760 <_i2c_master_write_packet>:
 *                                      acknowledged the address
 */
static enum status_code _i2c_master_write_packet(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
     760:	b590      	push	{r4, r7, lr}
     762:	b087      	sub	sp, #28
     764:	af00      	add	r7, sp, #0
     766:	6078      	str	r0, [r7, #4]
     768:	6039      	str	r1, [r7, #0]
	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     76a:	687b      	ldr	r3, [r7, #4]
     76c:	681b      	ldr	r3, [r3, #0]
     76e:	60fb      	str	r3, [r7, #12]

	/* Return value. */
	enum status_code tmp_status;
	uint16_t tmp_data_length = packet->data_length;
     770:	2314      	movs	r3, #20
     772:	18fb      	adds	r3, r7, r3
     774:	683a      	ldr	r2, [r7, #0]
     776:	8852      	ldrh	r2, [r2, #2]
     778:	801a      	strh	r2, [r3, #0]

	_i2c_master_wait_for_sync(module);
     77a:	687b      	ldr	r3, [r7, #4]
     77c:	0018      	movs	r0, r3
     77e:	4b3e      	ldr	r3, [pc, #248]	; (878 <_i2c_master_write_packet+0x118>)
     780:	4798      	blx	r3

	/* Set address and direction bit. Will send start command on bus. */
	i2c_module->ADDR.reg = (packet->address << 1) | I2C_TRANSFER_WRITE;
     782:	683b      	ldr	r3, [r7, #0]
     784:	881b      	ldrh	r3, [r3, #0]
     786:	b2db      	uxtb	r3, r3
     788:	18db      	adds	r3, r3, r3
     78a:	b2da      	uxtb	r2, r3
     78c:	68fb      	ldr	r3, [r7, #12]
     78e:	751a      	strb	r2, [r3, #20]

	/* Wait for response on bus. */
	tmp_status = _i2c_master_wait_for_bus(module);
     790:	2317      	movs	r3, #23
     792:	18fc      	adds	r4, r7, r3
     794:	687b      	ldr	r3, [r7, #4]
     796:	0018      	movs	r0, r3
     798:	4b38      	ldr	r3, [pc, #224]	; (87c <_i2c_master_write_packet+0x11c>)
     79a:	4798      	blx	r3
     79c:	0003      	movs	r3, r0
     79e:	7023      	strb	r3, [r4, #0]

	/* Check for address response error unless previous error is
	 * detected. */
	if (tmp_status == STATUS_OK) {
     7a0:	2317      	movs	r3, #23
     7a2:	18fb      	adds	r3, r7, r3
     7a4:	781b      	ldrb	r3, [r3, #0]
     7a6:	2b00      	cmp	r3, #0
     7a8:	d107      	bne.n	7ba <_i2c_master_write_packet+0x5a>
		tmp_status = _i2c_master_address_response(module);
     7aa:	2317      	movs	r3, #23
     7ac:	18fc      	adds	r4, r7, r3
     7ae:	687b      	ldr	r3, [r7, #4]
     7b0:	0018      	movs	r0, r3
     7b2:	4b33      	ldr	r3, [pc, #204]	; (880 <_i2c_master_write_packet+0x120>)
     7b4:	4798      	blx	r3
     7b6:	0003      	movs	r3, r0
     7b8:	7023      	strb	r3, [r4, #0]
	}

	/* Check that no error has occurred. */
	if (tmp_status == STATUS_OK) {
     7ba:	2317      	movs	r3, #23
     7bc:	18fb      	adds	r3, r7, r3
     7be:	781b      	ldrb	r3, [r3, #0]
     7c0:	2b00      	cmp	r3, #0
     7c2:	d151      	bne.n	868 <_i2c_master_write_packet+0x108>
		/* Buffer counter. */
		uint16_t buffer_counter = 0;
     7c4:	2312      	movs	r3, #18
     7c6:	18fb      	adds	r3, r7, r3
     7c8:	2200      	movs	r2, #0
     7ca:	801a      	strh	r2, [r3, #0]

		/* Write data buffer. */
		while (tmp_data_length--) {
     7cc:	e032      	b.n	834 <_i2c_master_write_packet+0xd4>
			/* Check that bus ownership is not lost. */
			if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
     7ce:	68fb      	ldr	r3, [r7, #12]
     7d0:	8a1b      	ldrh	r3, [r3, #16]
     7d2:	b29b      	uxth	r3, r3
     7d4:	001a      	movs	r2, r3
     7d6:	2320      	movs	r3, #32
     7d8:	4013      	ands	r3, r2
     7da:	d101      	bne.n	7e0 <_i2c_master_write_packet+0x80>
				return STATUS_ERR_PACKET_COLLISION;
     7dc:	2341      	movs	r3, #65	; 0x41
     7de:	e046      	b.n	86e <_i2c_master_write_packet+0x10e>
			}

			/* Write byte to slave. */
			_i2c_master_wait_for_sync(module);
     7e0:	687b      	ldr	r3, [r7, #4]
     7e2:	0018      	movs	r0, r3
     7e4:	4b24      	ldr	r3, [pc, #144]	; (878 <_i2c_master_write_packet+0x118>)
     7e6:	4798      	blx	r3
			i2c_module->DATA.reg = packet->data[buffer_counter++];
     7e8:	683b      	ldr	r3, [r7, #0]
     7ea:	685a      	ldr	r2, [r3, #4]
     7ec:	2312      	movs	r3, #18
     7ee:	18fb      	adds	r3, r7, r3
     7f0:	881b      	ldrh	r3, [r3, #0]
     7f2:	2112      	movs	r1, #18
     7f4:	1879      	adds	r1, r7, r1
     7f6:	1c58      	adds	r0, r3, #1
     7f8:	8008      	strh	r0, [r1, #0]
     7fa:	18d3      	adds	r3, r2, r3
     7fc:	781a      	ldrb	r2, [r3, #0]
     7fe:	68fb      	ldr	r3, [r7, #12]
     800:	761a      	strb	r2, [r3, #24]

			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);
     802:	2317      	movs	r3, #23
     804:	18fc      	adds	r4, r7, r3
     806:	687b      	ldr	r3, [r7, #4]
     808:	0018      	movs	r0, r3
     80a:	4b1c      	ldr	r3, [pc, #112]	; (87c <_i2c_master_write_packet+0x11c>)
     80c:	4798      	blx	r3
     80e:	0003      	movs	r3, r0
     810:	7023      	strb	r3, [r4, #0]

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
     812:	2317      	movs	r3, #23
     814:	18fb      	adds	r3, r7, r3
     816:	781b      	ldrb	r3, [r3, #0]
     818:	2b00      	cmp	r3, #0
     81a:	d115      	bne.n	848 <_i2c_master_write_packet+0xe8>
				break;
			}

			/* Check for NACK from slave. */
			if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
     81c:	68fb      	ldr	r3, [r7, #12]
     81e:	8a1b      	ldrh	r3, [r3, #16]
     820:	b29b      	uxth	r3, r3
     822:	001a      	movs	r2, r3
     824:	2304      	movs	r3, #4
     826:	4013      	ands	r3, r2
     828:	d004      	beq.n	834 <_i2c_master_write_packet+0xd4>
				/* Return bad data value. */
				tmp_status = STATUS_ERR_OVERFLOW;
     82a:	2317      	movs	r3, #23
     82c:	18fb      	adds	r3, r7, r3
     82e:	221e      	movs	r2, #30
     830:	701a      	strb	r2, [r3, #0]
				break;
     832:	e00a      	b.n	84a <_i2c_master_write_packet+0xea>
	if (tmp_status == STATUS_OK) {
		/* Buffer counter. */
		uint16_t buffer_counter = 0;

		/* Write data buffer. */
		while (tmp_data_length--) {
     834:	2314      	movs	r3, #20
     836:	18fb      	adds	r3, r7, r3
     838:	881b      	ldrh	r3, [r3, #0]
     83a:	2214      	movs	r2, #20
     83c:	18ba      	adds	r2, r7, r2
     83e:	1e59      	subs	r1, r3, #1
     840:	8011      	strh	r1, [r2, #0]
     842:	2b00      	cmp	r3, #0
     844:	d1c3      	bne.n	7ce <_i2c_master_write_packet+0x6e>
     846:	e000      	b.n	84a <_i2c_master_write_packet+0xea>
			/* Wait for response. */
			tmp_status = _i2c_master_wait_for_bus(module);

			/* Check for error. */
			if (tmp_status != STATUS_OK) {
				break;
     848:	46c0      	nop			; (mov r8, r8)
				tmp_status = STATUS_ERR_OVERFLOW;
				break;
			}
		}

		if (module->send_stop) {
     84a:	687b      	ldr	r3, [r7, #4]
     84c:	7a9b      	ldrb	r3, [r3, #10]
     84e:	2b00      	cmp	r3, #0
     850:	d00a      	beq.n	868 <_i2c_master_write_packet+0x108>
			/* Stop command */
			_i2c_master_wait_for_sync(module);
     852:	687b      	ldr	r3, [r7, #4]
     854:	0018      	movs	r0, r3
     856:	4b08      	ldr	r3, [pc, #32]	; (878 <_i2c_master_write_packet+0x118>)
     858:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     85a:	68fb      	ldr	r3, [r7, #12]
     85c:	685b      	ldr	r3, [r3, #4]
     85e:	22c0      	movs	r2, #192	; 0xc0
     860:	0292      	lsls	r2, r2, #10
     862:	431a      	orrs	r2, r3
     864:	68fb      	ldr	r3, [r7, #12]
     866:	605a      	str	r2, [r3, #4]
		}
	}

	return tmp_status;
     868:	2317      	movs	r3, #23
     86a:	18fb      	adds	r3, r7, r3
     86c:	781b      	ldrb	r3, [r3, #0]
}
     86e:	0018      	movs	r0, r3
     870:	46bd      	mov	sp, r7
     872:	b007      	add	sp, #28
     874:	bd90      	pop	{r4, r7, pc}
     876:	46c0      	nop			; (mov r8, r8)
     878:	000001ed 	.word	0x000001ed
     87c:	0000054d 	.word	0x0000054d
     880:	000004ed 	.word	0x000004ed

00000884 <i2c_master_write_packet_wait>:
 *                                      last data sent
 */
enum status_code i2c_master_write_packet_wait(
		struct i2c_master_module *const module,
		struct i2c_master_packet *const packet)
{
     884:	b580      	push	{r7, lr}
     886:	b082      	sub	sp, #8
     888:	af00      	add	r7, sp, #0
     88a:	6078      	str	r0, [r7, #4]
     88c:	6039      	str	r1, [r7, #0]
	Assert(module->hw);
	Assert(packet);

#if I2C_MASTER_CALLBACK_MODE == true
	/* Check if the I2C module is busy with a job */
	if (module->buffer_remaining > 0) {
     88e:	687b      	ldr	r3, [r7, #4]
     890:	8b9b      	ldrh	r3, [r3, #28]
     892:	b29b      	uxth	r3, r3
     894:	2b00      	cmp	r3, #0
     896:	d001      	beq.n	89c <i2c_master_write_packet_wait+0x18>
		return STATUS_BUSY;
     898:	2305      	movs	r3, #5
     89a:	e00c      	b.n	8b6 <i2c_master_write_packet_wait+0x32>
	}
#endif

	module->send_stop = true;
     89c:	687b      	ldr	r3, [r7, #4]
     89e:	2201      	movs	r2, #1
     8a0:	729a      	strb	r2, [r3, #10]
	module->send_nack = true;
     8a2:	687b      	ldr	r3, [r7, #4]
     8a4:	2201      	movs	r2, #1
     8a6:	72da      	strb	r2, [r3, #11]
	
	return _i2c_master_write_packet(module, packet);
     8a8:	683a      	ldr	r2, [r7, #0]
     8aa:	687b      	ldr	r3, [r7, #4]
     8ac:	0011      	movs	r1, r2
     8ae:	0018      	movs	r0, r3
     8b0:	4b03      	ldr	r3, [pc, #12]	; (8c0 <i2c_master_write_packet_wait+0x3c>)
     8b2:	4798      	blx	r3
     8b4:	0003      	movs	r3, r0
}
     8b6:	0018      	movs	r0, r3
     8b8:	46bd      	mov	sp, r7
     8ba:	b002      	add	sp, #8
     8bc:	bd80      	pop	{r7, pc}
     8be:	46c0      	nop			; (mov r8, r8)
     8c0:	00000761 	.word	0x00000761

000008c4 <i2c_master_is_syncing>:
 * \retval true   Module is busy synchronizing
 * \retval false  Module is not synchronizing
 */
static inline bool i2c_master_is_syncing (
		const struct i2c_master_module *const module)
{
     8c4:	b580      	push	{r7, lr}
     8c6:	b084      	sub	sp, #16
     8c8:	af00      	add	r7, sp, #0
     8ca:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
     8cc:	687b      	ldr	r3, [r7, #4]
     8ce:	681b      	ldr	r3, [r3, #0]
     8d0:	60fb      	str	r3, [r7, #12]

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
     8d2:	68fb      	ldr	r3, [r7, #12]
     8d4:	8a1b      	ldrh	r3, [r3, #16]
     8d6:	b29b      	uxth	r3, r3
     8d8:	001a      	movs	r2, r3
     8da:	2380      	movs	r3, #128	; 0x80
     8dc:	021b      	lsls	r3, r3, #8
     8de:	4013      	ands	r3, r2
     8e0:	1e5a      	subs	r2, r3, #1
     8e2:	4193      	sbcs	r3, r2
     8e4:	b2db      	uxtb	r3, r3
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
#else
#  error Unknown SERCOM SYNCBUSY scheme!
#endif
}
     8e6:	0018      	movs	r0, r3
     8e8:	46bd      	mov	sp, r7
     8ea:	b004      	add	sp, #16
     8ec:	bd80      	pop	{r7, pc}
     8ee:	46c0      	nop			; (mov r8, r8)

000008f0 <_i2c_master_wait_for_sync>:
 *
 * \param[in]  module  Pointer to software module structure
 */
static void _i2c_master_wait_for_sync(
		const struct i2c_master_module *const module)
{
     8f0:	b580      	push	{r7, lr}
     8f2:	b082      	sub	sp, #8
     8f4:	af00      	add	r7, sp, #0
     8f6:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
     8f8:	46c0      	nop			; (mov r8, r8)
     8fa:	687b      	ldr	r3, [r7, #4]
     8fc:	0018      	movs	r0, r3
     8fe:	4b04      	ldr	r3, [pc, #16]	; (910 <_i2c_master_wait_for_sync+0x20>)
     900:	4798      	blx	r3
     902:	1e03      	subs	r3, r0, #0
     904:	d1f9      	bne.n	8fa <_i2c_master_wait_for_sync+0xa>
		/* Wait for I2C module to sync. */
	}
}
     906:	46c0      	nop			; (mov r8, r8)
     908:	46bd      	mov	sp, r7
     90a:	b002      	add	sp, #8
     90c:	bd80      	pop	{r7, pc}
     90e:	46c0      	nop			; (mov r8, r8)
     910:	000008c5 	.word	0x000008c5

00000914 <_i2c_master_read>:
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_read(
		struct i2c_master_module *const module)
{
     914:	b580      	push	{r7, lr}
     916:	b084      	sub	sp, #16
     918:	af00      	add	r7, sp, #0
     91a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     91c:	687b      	ldr	r3, [r7, #4]
     91e:	681b      	ldr	r3, [r3, #0]
     920:	60fb      	str	r3, [r7, #12]

	/* Find index to save next value in buffer */
	uint16_t buffer_index = module->buffer_length - module->buffer_remaining;
     922:	687b      	ldr	r3, [r7, #4]
     924:	8b5b      	ldrh	r3, [r3, #26]
     926:	b299      	uxth	r1, r3
     928:	687b      	ldr	r3, [r7, #4]
     92a:	8b9b      	ldrh	r3, [r3, #28]
     92c:	b29a      	uxth	r2, r3
     92e:	230a      	movs	r3, #10
     930:	18fb      	adds	r3, r7, r3
     932:	1a8a      	subs	r2, r1, r2
     934:	801a      	strh	r2, [r3, #0]

	module->buffer_remaining--;
     936:	687b      	ldr	r3, [r7, #4]
     938:	8b9b      	ldrh	r3, [r3, #28]
     93a:	b29b      	uxth	r3, r3
     93c:	3b01      	subs	r3, #1
     93e:	b29a      	uxth	r2, r3
     940:	687b      	ldr	r3, [r7, #4]
     942:	839a      	strh	r2, [r3, #28]

	if (!module->buffer_remaining) {
     944:	687b      	ldr	r3, [r7, #4]
     946:	8b9b      	ldrh	r3, [r3, #28]
     948:	b29b      	uxth	r3, r3
     94a:	2b00      	cmp	r3, #0
     94c:	d126      	bne.n	99c <_i2c_master_read+0x88>
		/* Send nack */
	  	if (module->send_nack)
     94e:	687b      	ldr	r3, [r7, #4]
     950:	7adb      	ldrb	r3, [r3, #11]
     952:	2b00      	cmp	r3, #0
     954:	d006      	beq.n	964 <_i2c_master_read+0x50>
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
     956:	68fb      	ldr	r3, [r7, #12]
     958:	685b      	ldr	r3, [r3, #4]
     95a:	2280      	movs	r2, #128	; 0x80
     95c:	02d2      	lsls	r2, r2, #11
     95e:	431a      	orrs	r2, r3
     960:	68fb      	ldr	r3, [r7, #12]
     962:	605a      	str	r2, [r3, #4]
		if (module->send_stop) {
     964:	687b      	ldr	r3, [r7, #4]
     966:	7a9b      	ldrb	r3, [r3, #10]
     968:	2b00      	cmp	r3, #0
     96a:	d00b      	beq.n	984 <_i2c_master_read+0x70>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
     96c:	687b      	ldr	r3, [r7, #4]
     96e:	0018      	movs	r0, r3
     970:	4b16      	ldr	r3, [pc, #88]	; (9cc <_i2c_master_read+0xb8>)
     972:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     974:	68fb      	ldr	r3, [r7, #12]
     976:	685b      	ldr	r3, [r3, #4]
     978:	22c0      	movs	r2, #192	; 0xc0
     97a:	0292      	lsls	r2, r2, #10
     97c:	431a      	orrs	r2, r3
     97e:	68fb      	ldr	r3, [r7, #12]
     980:	605a      	str	r2, [r3, #4]
     982:	e011      	b.n	9a8 <_i2c_master_read+0x94>
		} else {
		  	_i2c_master_wait_for_sync(module);
     984:	687b      	ldr	r3, [r7, #4]
     986:	0018      	movs	r0, r3
     988:	4b10      	ldr	r3, [pc, #64]	; (9cc <_i2c_master_read+0xb8>)
     98a:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(1);
     98c:	68fb      	ldr	r3, [r7, #12]
     98e:	685b      	ldr	r3, [r3, #4]
     990:	2280      	movs	r2, #128	; 0x80
     992:	0252      	lsls	r2, r2, #9
     994:	431a      	orrs	r2, r3
     996:	68fb      	ldr	r3, [r7, #12]
     998:	605a      	str	r2, [r3, #4]
     99a:	e005      	b.n	9a8 <_i2c_master_read+0x94>
		}
	} else {
		i2c_module->CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
     99c:	68fb      	ldr	r3, [r7, #12]
     99e:	685b      	ldr	r3, [r3, #4]
     9a0:	4a0b      	ldr	r2, [pc, #44]	; (9d0 <_i2c_master_read+0xbc>)
     9a2:	401a      	ands	r2, r3
     9a4:	68fb      	ldr	r3, [r7, #12]
     9a6:	605a      	str	r2, [r3, #4]
	}

	/* Read byte from slave and put in buffer */
	_i2c_master_wait_for_sync(module);
     9a8:	687b      	ldr	r3, [r7, #4]
     9aa:	0018      	movs	r0, r3
     9ac:	4b07      	ldr	r3, [pc, #28]	; (9cc <_i2c_master_read+0xb8>)
     9ae:	4798      	blx	r3
	module->buffer[buffer_index] = i2c_module->DATA.reg;
     9b0:	687b      	ldr	r3, [r7, #4]
     9b2:	6a1a      	ldr	r2, [r3, #32]
     9b4:	230a      	movs	r3, #10
     9b6:	18fb      	adds	r3, r7, r3
     9b8:	881b      	ldrh	r3, [r3, #0]
     9ba:	18d3      	adds	r3, r2, r3
     9bc:	68fa      	ldr	r2, [r7, #12]
     9be:	7e12      	ldrb	r2, [r2, #24]
     9c0:	b2d2      	uxtb	r2, r2
     9c2:	701a      	strb	r2, [r3, #0]
}
     9c4:	46c0      	nop			; (mov r8, r8)
     9c6:	46bd      	mov	sp, r7
     9c8:	b004      	add	sp, #16
     9ca:	bd80      	pop	{r7, pc}
     9cc:	000008f1 	.word	0x000008f1
     9d0:	fffbffff 	.word	0xfffbffff

000009d4 <_i2c_master_write>:
 * Write next data. Used by interrupt handler to send next data byte to slave.
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_write(struct i2c_master_module *const module)
{
     9d4:	b580      	push	{r7, lr}
     9d6:	b084      	sub	sp, #16
     9d8:	af00      	add	r7, sp, #0
     9da:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     9dc:	687b      	ldr	r3, [r7, #4]
     9de:	681b      	ldr	r3, [r3, #0]
     9e0:	60fb      	str	r3, [r7, #12]

	/* Check for ack from slave */
	if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK)
     9e2:	68fb      	ldr	r3, [r7, #12]
     9e4:	8a1b      	ldrh	r3, [r3, #16]
     9e6:	b29b      	uxth	r3, r3
     9e8:	001a      	movs	r2, r3
     9ea:	2304      	movs	r3, #4
     9ec:	4013      	ands	r3, r2
     9ee:	d004      	beq.n	9fa <_i2c_master_write+0x26>
	{
		/* Set status */
		module->status = STATUS_ERR_OVERFLOW;
     9f0:	687b      	ldr	r3, [r7, #4]
     9f2:	2225      	movs	r2, #37	; 0x25
     9f4:	211e      	movs	r1, #30
     9f6:	5499      	strb	r1, [r3, r2]
		/* Do not write more data */
		return;
     9f8:	e01e      	b.n	a38 <STACK_SIZE+0x38>
	}

	/* Find index to get next byte in buffer */
	uint16_t buffer_index = module->buffer_length - module->buffer_remaining;
     9fa:	687b      	ldr	r3, [r7, #4]
     9fc:	8b5b      	ldrh	r3, [r3, #26]
     9fe:	b299      	uxth	r1, r3
     a00:	687b      	ldr	r3, [r7, #4]
     a02:	8b9b      	ldrh	r3, [r3, #28]
     a04:	b29a      	uxth	r2, r3
     a06:	230a      	movs	r3, #10
     a08:	18fb      	adds	r3, r7, r3
     a0a:	1a8a      	subs	r2, r1, r2
     a0c:	801a      	strh	r2, [r3, #0]

	module->buffer_remaining--;
     a0e:	687b      	ldr	r3, [r7, #4]
     a10:	8b9b      	ldrh	r3, [r3, #28]
     a12:	b29b      	uxth	r3, r3
     a14:	3b01      	subs	r3, #1
     a16:	b29a      	uxth	r2, r3
     a18:	687b      	ldr	r3, [r7, #4]
     a1a:	839a      	strh	r2, [r3, #28]

	/* Write byte from buffer to slave */
	_i2c_master_wait_for_sync(module);
     a1c:	687b      	ldr	r3, [r7, #4]
     a1e:	0018      	movs	r0, r3
     a20:	4b07      	ldr	r3, [pc, #28]	; (a40 <STACK_SIZE+0x40>)
     a22:	4798      	blx	r3
	i2c_module->DATA.reg = module->buffer[buffer_index];
     a24:	687b      	ldr	r3, [r7, #4]
     a26:	6a1a      	ldr	r2, [r3, #32]
     a28:	230a      	movs	r3, #10
     a2a:	18fb      	adds	r3, r7, r3
     a2c:	881b      	ldrh	r3, [r3, #0]
     a2e:	18d3      	adds	r3, r2, r3
     a30:	781b      	ldrb	r3, [r3, #0]
     a32:	b2da      	uxtb	r2, r3
     a34:	68fb      	ldr	r3, [r7, #12]
     a36:	761a      	strb	r2, [r3, #24]
}
     a38:	46bd      	mov	sp, r7
     a3a:	b004      	add	sp, #16
     a3c:	bd80      	pop	{r7, pc}
     a3e:	46c0      	nop			; (mov r8, r8)
     a40:	000008f1 	.word	0x000008f1

00000a44 <_i2c_master_async_address_response>:
 *
 * \param[in,out] module  Pointer to software module structure
 */
static void _i2c_master_async_address_response(
		struct i2c_master_module *const module)
{
     a44:	b580      	push	{r7, lr}
     a46:	b084      	sub	sp, #16
     a48:	af00      	add	r7, sp, #0
     a4a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments. */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     a4c:	687b      	ldr	r3, [r7, #4]
     a4e:	681b      	ldr	r3, [r3, #0]
     a50:	60fb      	str	r3, [r7, #12]

	/* Check for error. Ignore bus-error; workaround for bus state stuck in
	 * BUSY.
	 */
	if (i2c_module->INTFLAG.reg & SERCOM_I2CM_INTFLAG_MB)
     a52:	68fb      	ldr	r3, [r7, #12]
     a54:	7b9b      	ldrb	r3, [r3, #14]
     a56:	b2db      	uxtb	r3, r3
     a58:	001a      	movs	r2, r3
     a5a:	2301      	movs	r3, #1
     a5c:	4013      	ands	r3, r2
     a5e:	d00d      	beq.n	a7c <_i2c_master_async_address_response+0x38>
	{
		/* Clear write interrupt flag */
		i2c_module->INTFLAG.reg = SERCOM_I2CM_INTENCLR_MB;
     a60:	68fb      	ldr	r3, [r7, #12]
     a62:	2201      	movs	r2, #1
     a64:	739a      	strb	r2, [r3, #14]

		/* Check arbitration */
		if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_ARBLOST) {
     a66:	68fb      	ldr	r3, [r7, #12]
     a68:	8a1b      	ldrh	r3, [r3, #16]
     a6a:	b29b      	uxth	r3, r3
     a6c:	001a      	movs	r2, r3
     a6e:	2302      	movs	r3, #2
     a70:	4013      	ands	r3, r2
     a72:	d003      	beq.n	a7c <_i2c_master_async_address_response+0x38>
			/* Return busy */
			module->status = STATUS_ERR_PACKET_COLLISION;
     a74:	687b      	ldr	r3, [r7, #4]
     a76:	2225      	movs	r2, #37	; 0x25
     a78:	2141      	movs	r1, #65	; 0x41
     a7a:	5499      	strb	r1, [r3, r2]
		}
	}

	if (i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_RXNACK) {
     a7c:	68fb      	ldr	r3, [r7, #12]
     a7e:	8a1b      	ldrh	r3, [r3, #16]
     a80:	b29b      	uxth	r3, r3
     a82:	001a      	movs	r2, r3
     a84:	2304      	movs	r3, #4
     a86:	4013      	ands	r3, r2
     a88:	d015      	beq.n	ab6 <_i2c_master_async_address_response+0x72>
		/* Return bad address value */
		module->status           = STATUS_ERR_BAD_ADDRESS;
     a8a:	687b      	ldr	r3, [r7, #4]
     a8c:	2225      	movs	r2, #37	; 0x25
     a8e:	2118      	movs	r1, #24
     a90:	5499      	strb	r1, [r3, r2]
		module->buffer_remaining = 0;
     a92:	687b      	ldr	r3, [r7, #4]
     a94:	2200      	movs	r2, #0
     a96:	839a      	strh	r2, [r3, #28]

		if (module->send_stop) {
     a98:	687b      	ldr	r3, [r7, #4]
     a9a:	7a9b      	ldrb	r3, [r3, #10]
     a9c:	2b00      	cmp	r3, #0
     a9e:	d00a      	beq.n	ab6 <_i2c_master_async_address_response+0x72>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
     aa0:	687b      	ldr	r3, [r7, #4]
     aa2:	0018      	movs	r0, r3
     aa4:	4b13      	ldr	r3, [pc, #76]	; (af4 <_i2c_master_async_address_response+0xb0>)
     aa6:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     aa8:	68fb      	ldr	r3, [r7, #12]
     aaa:	685b      	ldr	r3, [r3, #4]
     aac:	22c0      	movs	r2, #192	; 0xc0
     aae:	0292      	lsls	r2, r2, #10
     ab0:	431a      	orrs	r2, r3
     ab2:	68fb      	ldr	r3, [r7, #12]
     ab4:	605a      	str	r2, [r3, #4]
		}
	}

	module->buffer_length = module->buffer_remaining;
     ab6:	687b      	ldr	r3, [r7, #4]
     ab8:	8b9b      	ldrh	r3, [r3, #28]
     aba:	b29a      	uxth	r2, r3
     abc:	687b      	ldr	r3, [r7, #4]
     abe:	835a      	strh	r2, [r3, #26]

	/* Check for status OK. */
	if (module->status == STATUS_BUSY) {
     ac0:	687b      	ldr	r3, [r7, #4]
     ac2:	2225      	movs	r2, #37	; 0x25
     ac4:	5c9b      	ldrb	r3, [r3, r2]
     ac6:	b2db      	uxtb	r3, r3
     ac8:	2b05      	cmp	r3, #5
     aca:	d10e      	bne.n	aea <_i2c_master_async_address_response+0xa6>
		/* Call function based on transfer direction. */
		if (module->transfer_direction == I2C_TRANSFER_WRITE) {
     acc:	687b      	ldr	r3, [r7, #4]
     ace:	2224      	movs	r2, #36	; 0x24
     ad0:	5c9b      	ldrb	r3, [r3, r2]
     ad2:	b2db      	uxtb	r3, r3
     ad4:	2b00      	cmp	r3, #0
     ad6:	d104      	bne.n	ae2 <_i2c_master_async_address_response+0x9e>
			_i2c_master_write(module);
     ad8:	687b      	ldr	r3, [r7, #4]
     ada:	0018      	movs	r0, r3
     adc:	4b06      	ldr	r3, [pc, #24]	; (af8 <_i2c_master_async_address_response+0xb4>)
     ade:	4798      	blx	r3
		} else {
			_i2c_master_read(module);
		}
	}
}
     ae0:	e003      	b.n	aea <_i2c_master_async_address_response+0xa6>
	if (module->status == STATUS_BUSY) {
		/* Call function based on transfer direction. */
		if (module->transfer_direction == I2C_TRANSFER_WRITE) {
			_i2c_master_write(module);
		} else {
			_i2c_master_read(module);
     ae2:	687b      	ldr	r3, [r7, #4]
     ae4:	0018      	movs	r0, r3
     ae6:	4b05      	ldr	r3, [pc, #20]	; (afc <_i2c_master_async_address_response+0xb8>)
     ae8:	4798      	blx	r3
		}
	}
}
     aea:	46c0      	nop			; (mov r8, r8)
     aec:	46bd      	mov	sp, r7
     aee:	b004      	add	sp, #16
     af0:	bd80      	pop	{r7, pc}
     af2:	46c0      	nop			; (mov r8, r8)
     af4:	000008f1 	.word	0x000008f1
     af8:	000009d5 	.word	0x000009d5
     afc:	00000915 	.word	0x00000915

00000b00 <_i2c_master_interrupt_handler>:
 *
 * \param[in] instance  SERCOM instance that triggered the interrupt
 */
void _i2c_master_interrupt_handler(
		uint8_t instance)
{
     b00:	b580      	push	{r7, lr}
     b02:	b086      	sub	sp, #24
     b04:	af00      	add	r7, sp, #0
     b06:	0002      	movs	r2, r0
     b08:	1dfb      	adds	r3, r7, #7
     b0a:	701a      	strb	r2, [r3, #0]
	/* Get software module for callback handling */
	struct i2c_master_module *module =
			(struct i2c_master_module*)_sercom_instances[instance];
     b0c:	1dfb      	adds	r3, r7, #7
     b0e:	781a      	ldrb	r2, [r3, #0]
 */
void _i2c_master_interrupt_handler(
		uint8_t instance)
{
	/* Get software module for callback handling */
	struct i2c_master_module *module =
     b10:	4b7f      	ldr	r3, [pc, #508]	; (d10 <_i2c_master_interrupt_handler+0x210>)
     b12:	0092      	lsls	r2, r2, #2
     b14:	58d3      	ldr	r3, [r2, r3]
     b16:	617b      	str	r3, [r7, #20]
			(struct i2c_master_module*)_sercom_instances[instance];

	Assert(module);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     b18:	697b      	ldr	r3, [r7, #20]
     b1a:	681b      	ldr	r3, [r3, #0]
     b1c:	613b      	str	r3, [r7, #16]

	/* Combine callback registered and enabled masks */
	uint8_t callback_mask = module->enabled_callback &
     b1e:	697b      	ldr	r3, [r7, #20]
     b20:	7e5b      	ldrb	r3, [r3, #25]
     b22:	b2da      	uxtb	r2, r3
			module->registered_callback;
     b24:	697b      	ldr	r3, [r7, #20]
     b26:	7e1b      	ldrb	r3, [r3, #24]
     b28:	b2d9      	uxtb	r1, r3
	Assert(module);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);

	/* Combine callback registered and enabled masks */
	uint8_t callback_mask = module->enabled_callback &
     b2a:	230f      	movs	r3, #15
     b2c:	18fb      	adds	r3, r7, r3
     b2e:	400a      	ands	r2, r1
     b30:	701a      	strb	r2, [r3, #0]
			module->registered_callback;

	/* Check if the module should respond to address ack */
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
     b32:	697b      	ldr	r3, [r7, #20]
     b34:	8b5b      	ldrh	r3, [r3, #26]
     b36:	b29b      	uxth	r3, r3
     b38:	2b00      	cmp	r3, #0
     b3a:	d109      	bne.n	b50 <_i2c_master_interrupt_handler+0x50>
     b3c:	697b      	ldr	r3, [r7, #20]
     b3e:	8b9b      	ldrh	r3, [r3, #28]
     b40:	b29b      	uxth	r3, r3
     b42:	2b00      	cmp	r3, #0
     b44:	d004      	beq.n	b50 <_i2c_master_interrupt_handler+0x50>
		/* Call function for address response */
		_i2c_master_async_address_response(module);
     b46:	697b      	ldr	r3, [r7, #20]
     b48:	0018      	movs	r0, r3
     b4a:	4b72      	ldr	r3, [pc, #456]	; (d14 <_i2c_master_interrupt_handler+0x214>)
     b4c:	4798      	blx	r3
     b4e:	e063      	b.n	c18 <_i2c_master_interrupt_handler+0x118>

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
     b50:	697b      	ldr	r3, [r7, #20]
     b52:	8b5b      	ldrh	r3, [r3, #26]
     b54:	b29b      	uxth	r3, r3
     b56:	2b00      	cmp	r3, #0
     b58:	d039      	beq.n	bce <_i2c_master_interrupt_handler+0xce>
     b5a:	697b      	ldr	r3, [r7, #20]
     b5c:	8b9b      	ldrh	r3, [r3, #28]
     b5e:	b29b      	uxth	r3, r3
     b60:	2b00      	cmp	r3, #0
     b62:	d134      	bne.n	bce <_i2c_master_interrupt_handler+0xce>
			(module->status == STATUS_BUSY) &&
     b64:	697b      	ldr	r3, [r7, #20]
     b66:	2225      	movs	r2, #37	; 0x25
     b68:	5c9b      	ldrb	r3, [r3, r2]
     b6a:	b2db      	uxtb	r3, r3
	if ((module->buffer_length <= 0) && (module->buffer_remaining > 0)) {
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
     b6c:	2b05      	cmp	r3, #5
     b6e:	d12e      	bne.n	bce <_i2c_master_interrupt_handler+0xce>
			(module->status == STATUS_BUSY) &&
			(module->transfer_direction == I2C_TRANSFER_WRITE)) {
     b70:	697b      	ldr	r3, [r7, #20]
     b72:	2224      	movs	r2, #36	; 0x24
     b74:	5c9b      	ldrb	r3, [r3, r2]
     b76:	b2db      	uxtb	r3, r3
		/* Call function for address response */
		_i2c_master_async_address_response(module);

	/* Check if buffer write is done */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
			(module->status == STATUS_BUSY) &&
     b78:	2b00      	cmp	r3, #0
     b7a:	d128      	bne.n	bce <_i2c_master_interrupt_handler+0xce>
			(module->transfer_direction == I2C_TRANSFER_WRITE)) {
		/* Stop packet operation */
		i2c_module->INTENCLR.reg =
     b7c:	693b      	ldr	r3, [r7, #16]
     b7e:	2203      	movs	r2, #3
     b80:	731a      	strb	r2, [r3, #12]
				SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;

		module->buffer_length = 0;
     b82:	697b      	ldr	r3, [r7, #20]
     b84:	2200      	movs	r2, #0
     b86:	835a      	strh	r2, [r3, #26]
		module->status        = STATUS_OK;
     b88:	697b      	ldr	r3, [r7, #20]
     b8a:	2225      	movs	r2, #37	; 0x25
     b8c:	2100      	movs	r1, #0
     b8e:	5499      	strb	r1, [r3, r2]

		if (module->send_stop) {
     b90:	697b      	ldr	r3, [r7, #20]
     b92:	7a9b      	ldrb	r3, [r3, #10]
     b94:	2b00      	cmp	r3, #0
     b96:	d00b      	beq.n	bb0 <_i2c_master_interrupt_handler+0xb0>
			/* Send stop condition */
			_i2c_master_wait_for_sync(module);
     b98:	697b      	ldr	r3, [r7, #20]
     b9a:	0018      	movs	r0, r3
     b9c:	4b5e      	ldr	r3, [pc, #376]	; (d18 <_i2c_master_interrupt_handler+0x218>)
     b9e:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
     ba0:	693b      	ldr	r3, [r7, #16]
     ba2:	685b      	ldr	r3, [r3, #4]
     ba4:	22c0      	movs	r2, #192	; 0xc0
     ba6:	0292      	lsls	r2, r2, #10
     ba8:	431a      	orrs	r2, r3
     baa:	693b      	ldr	r3, [r7, #16]
     bac:	605a      	str	r2, [r3, #4]
     bae:	e002      	b.n	bb6 <_i2c_master_interrupt_handler+0xb6>
		} else {
			/* Clear write interrupt flag */
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
     bb0:	693b      	ldr	r3, [r7, #16]
     bb2:	2201      	movs	r2, #1
     bb4:	739a      	strb	r2, [r3, #14]
		}
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE)) {
     bb6:	230f      	movs	r3, #15
     bb8:	18fb      	adds	r3, r7, r3
     bba:	781b      	ldrb	r3, [r3, #0]
     bbc:	2201      	movs	r2, #1
     bbe:	4013      	ands	r3, r2
     bc0:	d02a      	beq.n	c18 <_i2c_master_interrupt_handler+0x118>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
     bc2:	697b      	ldr	r3, [r7, #20]
     bc4:	68db      	ldr	r3, [r3, #12]
     bc6:	697a      	ldr	r2, [r7, #20]
     bc8:	0010      	movs	r0, r2
     bca:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(3);
		} else {
			/* Clear write interrupt flag */
			i2c_module->INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
		}
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE)) {
     bcc:	e024      	b.n	c18 <_i2c_master_interrupt_handler+0x118>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
		}

	/* Continue buffer write/read */
	} else if ((module->buffer_length > 0) && (module->buffer_remaining > 0)){
     bce:	697b      	ldr	r3, [r7, #20]
     bd0:	8b5b      	ldrh	r3, [r3, #26]
     bd2:	b29b      	uxth	r3, r3
     bd4:	2b00      	cmp	r3, #0
     bd6:	d01f      	beq.n	c18 <_i2c_master_interrupt_handler+0x118>
     bd8:	697b      	ldr	r3, [r7, #20]
     bda:	8b9b      	ldrh	r3, [r3, #28]
     bdc:	b29b      	uxth	r3, r3
     bde:	2b00      	cmp	r3, #0
     be0:	d01a      	beq.n	c18 <_i2c_master_interrupt_handler+0x118>
		/* Check that bus ownership is not lost */
		if (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(2))) {
     be2:	693b      	ldr	r3, [r7, #16]
     be4:	8a1b      	ldrh	r3, [r3, #16]
     be6:	b29b      	uxth	r3, r3
     be8:	001a      	movs	r2, r3
     bea:	2320      	movs	r3, #32
     bec:	4013      	ands	r3, r2
     bee:	d104      	bne.n	bfa <_i2c_master_interrupt_handler+0xfa>
			module->status = STATUS_ERR_PACKET_COLLISION;
     bf0:	697b      	ldr	r3, [r7, #20]
     bf2:	2225      	movs	r2, #37	; 0x25
     bf4:	2141      	movs	r1, #65	; 0x41
     bf6:	5499      	strb	r1, [r3, r2]
     bf8:	e00e      	b.n	c18 <_i2c_master_interrupt_handler+0x118>
		} else if (module->transfer_direction == I2C_TRANSFER_WRITE) {
     bfa:	697b      	ldr	r3, [r7, #20]
     bfc:	2224      	movs	r2, #36	; 0x24
     bfe:	5c9b      	ldrb	r3, [r3, r2]
     c00:	b2db      	uxtb	r3, r3
     c02:	2b00      	cmp	r3, #0
     c04:	d104      	bne.n	c10 <_i2c_master_interrupt_handler+0x110>
			_i2c_master_write(module);
     c06:	697b      	ldr	r3, [r7, #20]
     c08:	0018      	movs	r0, r3
     c0a:	4b44      	ldr	r3, [pc, #272]	; (d1c <_i2c_master_interrupt_handler+0x21c>)
     c0c:	4798      	blx	r3
     c0e:	e003      	b.n	c18 <_i2c_master_interrupt_handler+0x118>
		} else {
			_i2c_master_read(module);
     c10:	697b      	ldr	r3, [r7, #20]
     c12:	0018      	movs	r0, r3
     c14:	4b42      	ldr	r3, [pc, #264]	; (d20 <_i2c_master_interrupt_handler+0x220>)
     c16:	4798      	blx	r3
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
     c18:	697b      	ldr	r3, [r7, #20]
     c1a:	8b5b      	ldrh	r3, [r3, #26]
     c1c:	b29b      	uxth	r3, r3
     c1e:	2b00      	cmp	r3, #0
     c20:	d03d      	beq.n	c9e <_i2c_master_interrupt_handler+0x19e>
     c22:	697b      	ldr	r3, [r7, #20]
     c24:	8b9b      	ldrh	r3, [r3, #28]
     c26:	b29b      	uxth	r3, r3
     c28:	2b00      	cmp	r3, #0
     c2a:	d138      	bne.n	c9e <_i2c_master_interrupt_handler+0x19e>
			(module->status == STATUS_BUSY) &&
     c2c:	697b      	ldr	r3, [r7, #20]
     c2e:	2225      	movs	r2, #37	; 0x25
     c30:	5c9b      	ldrb	r3, [r3, r2]
     c32:	b2db      	uxtb	r3, r3
			_i2c_master_read(module);
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
     c34:	2b05      	cmp	r3, #5
     c36:	d132      	bne.n	c9e <_i2c_master_interrupt_handler+0x19e>
			(module->status == STATUS_BUSY) &&
			(module->transfer_direction == I2C_TRANSFER_READ)) {
     c38:	697b      	ldr	r3, [r7, #20]
     c3a:	2224      	movs	r2, #36	; 0x24
     c3c:	5c9b      	ldrb	r3, [r3, r2]
     c3e:	b2db      	uxtb	r3, r3
		}
	}

	/* Check if read buffer transfer is complete */
	if ((module->buffer_length > 0) && (module->buffer_remaining <= 0) &&
			(module->status == STATUS_BUSY) &&
     c40:	2b01      	cmp	r3, #1
     c42:	d12c      	bne.n	c9e <_i2c_master_interrupt_handler+0x19e>
			(module->transfer_direction == I2C_TRANSFER_READ)) {

		/* Stop packet operation */
		i2c_module->INTENCLR.reg =
     c44:	693b      	ldr	r3, [r7, #16]
     c46:	2203      	movs	r2, #3
     c48:	731a      	strb	r2, [r3, #12]
				SERCOM_I2CM_INTENCLR_MB | SERCOM_I2CM_INTENCLR_SB;
		module->buffer_length = 0;
     c4a:	697b      	ldr	r3, [r7, #20]
     c4c:	2200      	movs	r2, #0
     c4e:	835a      	strh	r2, [r3, #26]
		module->status        = STATUS_OK;
     c50:	697b      	ldr	r3, [r7, #20]
     c52:	2225      	movs	r2, #37	; 0x25
     c54:	2100      	movs	r1, #0
     c56:	5499      	strb	r1, [r3, r2]

		/* Call appropriate callback if enabled and registered */
		if ((callback_mask & (1 << I2C_MASTER_CALLBACK_READ_COMPLETE))
     c58:	230f      	movs	r3, #15
     c5a:	18fb      	adds	r3, r7, r3
     c5c:	781b      	ldrb	r3, [r3, #0]
     c5e:	2202      	movs	r2, #2
     c60:	4013      	ands	r3, r2
     c62:	d00b      	beq.n	c7c <_i2c_master_interrupt_handler+0x17c>
				&& (module->transfer_direction == I2C_TRANSFER_READ)) {
     c64:	697b      	ldr	r3, [r7, #20]
     c66:	2224      	movs	r2, #36	; 0x24
     c68:	5c9b      	ldrb	r3, [r3, r2]
     c6a:	b2db      	uxtb	r3, r3
     c6c:	2b01      	cmp	r3, #1
     c6e:	d105      	bne.n	c7c <_i2c_master_interrupt_handler+0x17c>
			module->callbacks[I2C_MASTER_CALLBACK_READ_COMPLETE](module);
     c70:	697b      	ldr	r3, [r7, #20]
     c72:	691b      	ldr	r3, [r3, #16]
     c74:	697a      	ldr	r2, [r7, #20]
     c76:	0010      	movs	r0, r2
     c78:	4798      	blx	r3
     c7a:	e010      	b.n	c9e <_i2c_master_interrupt_handler+0x19e>
		} else if ((callback_mask & (1 << I2C_MASTER_CALLBACK_WRITE_COMPLETE))
     c7c:	230f      	movs	r3, #15
     c7e:	18fb      	adds	r3, r7, r3
     c80:	781b      	ldrb	r3, [r3, #0]
     c82:	2201      	movs	r2, #1
     c84:	4013      	ands	r3, r2
     c86:	d00a      	beq.n	c9e <_i2c_master_interrupt_handler+0x19e>
				&& (module->transfer_direction == I2C_TRANSFER_WRITE)) {
     c88:	697b      	ldr	r3, [r7, #20]
     c8a:	2224      	movs	r2, #36	; 0x24
     c8c:	5c9b      	ldrb	r3, [r3, r2]
     c8e:	b2db      	uxtb	r3, r3
     c90:	2b00      	cmp	r3, #0
     c92:	d104      	bne.n	c9e <_i2c_master_interrupt_handler+0x19e>
			module->callbacks[I2C_MASTER_CALLBACK_WRITE_COMPLETE](module);
     c94:	697b      	ldr	r3, [r7, #20]
     c96:	68db      	ldr	r3, [r3, #12]
     c98:	697a      	ldr	r2, [r7, #20]
     c9a:	0010      	movs	r0, r2
     c9c:	4798      	blx	r3
		}
	}

	/* Check for error */
	if ((module->status != STATUS_BUSY) && (module->status != STATUS_OK)) {
     c9e:	697b      	ldr	r3, [r7, #20]
     ca0:	2225      	movs	r2, #37	; 0x25
     ca2:	5c9b      	ldrb	r3, [r3, r2]
     ca4:	b2db      	uxtb	r3, r3
     ca6:	2b05      	cmp	r3, #5
     ca8:	d02e      	beq.n	d08 <_i2c_master_interrupt_handler+0x208>
     caa:	697b      	ldr	r3, [r7, #20]
     cac:	2225      	movs	r2, #37	; 0x25
     cae:	5c9b      	ldrb	r3, [r3, r2]
     cb0:	b2db      	uxtb	r3, r3
     cb2:	2b00      	cmp	r3, #0
     cb4:	d028      	beq.n	d08 <_i2c_master_interrupt_handler+0x208>
		/* Stop packet operation */
		i2c_module->INTENCLR.reg = SERCOM_I2CM_INTENCLR_MB |
     cb6:	693b      	ldr	r3, [r7, #16]
     cb8:	2203      	movs	r2, #3
     cba:	731a      	strb	r2, [r3, #12]
				SERCOM_I2CM_INTENCLR_SB;

		module->buffer_length = 0;
     cbc:	697b      	ldr	r3, [r7, #20]
     cbe:	2200      	movs	r2, #0
     cc0:	835a      	strh	r2, [r3, #26]
		module->buffer_remaining = 0;
     cc2:	697b      	ldr	r3, [r7, #20]
     cc4:	2200      	movs	r2, #0
     cc6:	839a      	strh	r2, [r3, #28]

		/* Send nack and stop command unless arbitration is lost */
		if ((module->status != STATUS_ERR_PACKET_COLLISION) &&
     cc8:	697b      	ldr	r3, [r7, #20]
     cca:	2225      	movs	r2, #37	; 0x25
     ccc:	5c9b      	ldrb	r3, [r3, r2]
     cce:	b2db      	uxtb	r3, r3
     cd0:	2b41      	cmp	r3, #65	; 0x41
     cd2:	d00e      	beq.n	cf2 <_i2c_master_interrupt_handler+0x1f2>
				module->send_stop) {
     cd4:	697b      	ldr	r3, [r7, #20]
     cd6:	7a9b      	ldrb	r3, [r3, #10]

		module->buffer_length = 0;
		module->buffer_remaining = 0;

		/* Send nack and stop command unless arbitration is lost */
		if ((module->status != STATUS_ERR_PACKET_COLLISION) &&
     cd8:	2b00      	cmp	r3, #0
     cda:	d00a      	beq.n	cf2 <_i2c_master_interrupt_handler+0x1f2>
				module->send_stop) {
			_i2c_master_wait_for_sync(module);
     cdc:	697b      	ldr	r3, [r7, #20]
     cde:	0018      	movs	r0, r3
     ce0:	4b0d      	ldr	r3, [pc, #52]	; (d18 <_i2c_master_interrupt_handler+0x218>)
     ce2:	4798      	blx	r3
			i2c_module->CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT |
     ce4:	693b      	ldr	r3, [r7, #16]
     ce6:	685b      	ldr	r3, [r3, #4]
     ce8:	22e0      	movs	r2, #224	; 0xe0
     cea:	02d2      	lsls	r2, r2, #11
     cec:	431a      	orrs	r2, r3
     cee:	693b      	ldr	r3, [r7, #16]
     cf0:	605a      	str	r2, [r3, #4]
					SERCOM_I2CM_CTRLB_CMD(3);
		}

		/* Call error callback if enabled and registered */
		if (callback_mask & (1 << I2C_MASTER_CALLBACK_ERROR)) {
     cf2:	230f      	movs	r3, #15
     cf4:	18fb      	adds	r3, r7, r3
     cf6:	781b      	ldrb	r3, [r3, #0]
     cf8:	2204      	movs	r2, #4
     cfa:	4013      	ands	r3, r2
     cfc:	d004      	beq.n	d08 <_i2c_master_interrupt_handler+0x208>
			module->callbacks[I2C_MASTER_CALLBACK_ERROR](module);
     cfe:	697b      	ldr	r3, [r7, #20]
     d00:	695b      	ldr	r3, [r3, #20]
     d02:	697a      	ldr	r2, [r7, #20]
     d04:	0010      	movs	r0, r2
     d06:	4798      	blx	r3
		}
	}
}
     d08:	46c0      	nop			; (mov r8, r8)
     d0a:	46bd      	mov	sp, r7
     d0c:	b006      	add	sp, #24
     d0e:	bd80      	pop	{r7, pc}
     d10:	20002e54 	.word	0x20002e54
     d14:	00000a45 	.word	0x00000a45
     d18:	000008f1 	.word	0x000008f1
     d1c:	000009d5 	.word	0x000009d5
     d20:	00000915 	.word	0x00000915

00000d24 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
     d24:	b580      	push	{r7, lr}
     d26:	b082      	sub	sp, #8
     d28:	af00      	add	r7, sp, #0
     d2a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
     d2c:	687b      	ldr	r3, [r7, #4]
     d2e:	2280      	movs	r2, #128	; 0x80
     d30:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
     d32:	687b      	ldr	r3, [r7, #4]
     d34:	2200      	movs	r2, #0
     d36:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
     d38:	687b      	ldr	r3, [r7, #4]
     d3a:	2201      	movs	r2, #1
     d3c:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
     d3e:	687b      	ldr	r3, [r7, #4]
     d40:	2200      	movs	r2, #0
     d42:	70da      	strb	r2, [r3, #3]
}
     d44:	46c0      	nop			; (mov r8, r8)
     d46:	46bd      	mov	sp, r7
     d48:	b002      	add	sp, #8
     d4a:	bd80      	pop	{r7, pc}

00000d4c <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
     d4c:	b580      	push	{r7, lr}
     d4e:	b082      	sub	sp, #8
     d50:	af00      	add	r7, sp, #0
     d52:	0002      	movs	r2, r0
     d54:	1dfb      	adds	r3, r7, #7
     d56:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
     d58:	4b06      	ldr	r3, [pc, #24]	; (d74 <system_interrupt_enable+0x28>)
     d5a:	1dfa      	adds	r2, r7, #7
     d5c:	7812      	ldrb	r2, [r2, #0]
     d5e:	0011      	movs	r1, r2
     d60:	221f      	movs	r2, #31
     d62:	400a      	ands	r2, r1
     d64:	2101      	movs	r1, #1
     d66:	4091      	lsls	r1, r2
     d68:	000a      	movs	r2, r1
     d6a:	601a      	str	r2, [r3, #0]
}
     d6c:	46c0      	nop			; (mov r8, r8)
     d6e:	46bd      	mov	sp, r7
     d70:	b002      	add	sp, #8
     d72:	bd80      	pop	{r7, pc}
     d74:	e000e100 	.word	0xe000e100

00000d78 <i2c_master_is_syncing>:
 * \retval true   Module is busy synchronizing
 * \retval false  Module is not synchronizing
 */
static inline bool i2c_master_is_syncing (
		const struct i2c_master_module *const module)
{
     d78:	b580      	push	{r7, lr}
     d7a:	b084      	sub	sp, #16
     d7c:	af00      	add	r7, sp, #0
     d7e:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_hw = &(module->hw->I2CM);
     d80:	687b      	ldr	r3, [r7, #4]
     d82:	681b      	ldr	r3, [r3, #0]
     d84:	60fb      	str	r3, [r7, #12]

#if defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_1)
	return (i2c_hw->STATUS.reg & SERCOM_I2CM_STATUS_SYNCBUSY);
     d86:	68fb      	ldr	r3, [r7, #12]
     d88:	8a1b      	ldrh	r3, [r3, #16]
     d8a:	b29b      	uxth	r3, r3
     d8c:	001a      	movs	r2, r3
     d8e:	2380      	movs	r3, #128	; 0x80
     d90:	021b      	lsls	r3, r3, #8
     d92:	4013      	ands	r3, r2
     d94:	1e5a      	subs	r2, r3, #1
     d96:	4193      	sbcs	r3, r2
     d98:	b2db      	uxtb	r3, r3
#elif defined(FEATURE_SERCOM_SYNCBUSY_SCHEME_VERSION_2)
	return (i2c_hw->SYNCBUSY.reg & SERCOM_I2CM_SYNCBUSY_MASK);
#else
#  error Unknown SERCOM SYNCBUSY scheme!
#endif
}
     d9a:	0018      	movs	r0, r3
     d9c:	46bd      	mov	sp, r7
     d9e:	b004      	add	sp, #16
     da0:	bd80      	pop	{r7, pc}
     da2:	46c0      	nop			; (mov r8, r8)

00000da4 <_i2c_master_wait_for_sync>:
 *
 * \param[in]  module  Pointer to software module structure
 */
static void _i2c_master_wait_for_sync(
		const struct i2c_master_module *const module)
{
     da4:	b580      	push	{r7, lr}
     da6:	b082      	sub	sp, #8
     da8:	af00      	add	r7, sp, #0
     daa:	6078      	str	r0, [r7, #4]
	/* Sanity check */
	Assert(module);

	while (i2c_master_is_syncing(module)) {
     dac:	46c0      	nop			; (mov r8, r8)
     dae:	687b      	ldr	r3, [r7, #4]
     db0:	0018      	movs	r0, r3
     db2:	4b04      	ldr	r3, [pc, #16]	; (dc4 <_i2c_master_wait_for_sync+0x20>)
     db4:	4798      	blx	r3
     db6:	1e03      	subs	r3, r0, #0
     db8:	d1f9      	bne.n	dae <_i2c_master_wait_for_sync+0xa>
		/* Wait for I2C module to sync. */
	}
}
     dba:	46c0      	nop			; (mov r8, r8)
     dbc:	46bd      	mov	sp, r7
     dbe:	b002      	add	sp, #8
     dc0:	bd80      	pop	{r7, pc}
     dc2:	46c0      	nop			; (mov r8, r8)
     dc4:	00000d79 	.word	0x00000d79

00000dc8 <i2c_master_get_config_defaults>:
 *
 * \param[out] config  Pointer to configuration structure to be initiated
 */
static inline void i2c_master_get_config_defaults(
		struct i2c_master_config *const config)
{
     dc8:	b580      	push	{r7, lr}
     dca:	b082      	sub	sp, #8
     dcc:	af00      	add	r7, sp, #0
     dce:	6078      	str	r0, [r7, #4]
	/*Sanity check argument */
	Assert(config);
	config->baud_rate        = I2C_MASTER_BAUD_RATE_100KHZ;
     dd0:	687b      	ldr	r3, [r7, #4]
     dd2:	2264      	movs	r2, #100	; 0x64
     dd4:	601a      	str	r2, [r3, #0]
#ifdef FEATURE_I2C_FAST_MODE_PLUS_AND_HIGH_SPEED
	config->baud_rate_high_speed = I2C_MASTER_BAUD_RATE_3400KHZ;
	config->transfer_speed       = I2C_MASTER_SPEED_STANDARD_AND_FAST;
#endif
	config->generator_source = GCLK_GENERATOR_0;
     dd6:	687b      	ldr	r3, [r7, #4]
     dd8:	2200      	movs	r2, #0
     dda:	711a      	strb	r2, [r3, #4]
	config->run_in_standby   = false;
     ddc:	687b      	ldr	r3, [r7, #4]
     dde:	2200      	movs	r2, #0
     de0:	741a      	strb	r2, [r3, #16]
	config->start_hold_time  = I2C_MASTER_START_HOLD_TIME_300NS_600NS;
     de2:	687b      	ldr	r3, [r7, #4]
     de4:	2280      	movs	r2, #128	; 0x80
     de6:	0392      	lsls	r2, r2, #14
     de8:	609a      	str	r2, [r3, #8]
	config->buffer_timeout   = 65535;
     dea:	687b      	ldr	r3, [r7, #4]
     dec:	2201      	movs	r2, #1
     dee:	4252      	negs	r2, r2
     df0:	81da      	strh	r2, [r3, #14]
	config->unknown_bus_state_timeout = 65535;
     df2:	687b      	ldr	r3, [r7, #4]
     df4:	2201      	movs	r2, #1
     df6:	4252      	negs	r2, r2
     df8:	819a      	strh	r2, [r3, #12]
	config->pinmux_pad0      = PINMUX_DEFAULT;
     dfa:	687b      	ldr	r3, [r7, #4]
     dfc:	2200      	movs	r2, #0
     dfe:	615a      	str	r2, [r3, #20]
	config->pinmux_pad1      = PINMUX_DEFAULT;
     e00:	687b      	ldr	r3, [r7, #4]
     e02:	2200      	movs	r2, #0
     e04:	619a      	str	r2, [r3, #24]
	config->scl_low_timeout  = false;
     e06:	687b      	ldr	r3, [r7, #4]
     e08:	2200      	movs	r2, #0
     e0a:	771a      	strb	r2, [r3, #28]
	config->inactive_timeout = I2C_MASTER_INACTIVE_TIMEOUT_DISABLED;
     e0c:	687b      	ldr	r3, [r7, #4]
     e0e:	2200      	movs	r2, #0
     e10:	621a      	str	r2, [r3, #32]
#ifdef FEATURE_I2C_SCL_EXTEND_TIMEOUT
	config->slave_scl_low_extend_timeout   = false;
	config->master_scl_low_extend_timeout  = false;
#endif
	/* The typical value is 215ns */
	config->sda_scl_rise_time_ns = 215;
     e12:	687b      	ldr	r3, [r7, #4]
     e14:	22d7      	movs	r2, #215	; 0xd7
     e16:	849a      	strh	r2, [r3, #36]	; 0x24
}
     e18:	46c0      	nop			; (mov r8, r8)
     e1a:	46bd      	mov	sp, r7
     e1c:	b002      	add	sp, #8
     e1e:	bd80      	pop	{r7, pc}

00000e20 <i2c_master_enable>:
 *
 * \param[in]  module  Pointer to the software module struct
 */
static inline void i2c_master_enable(
		const struct i2c_master_module *const module)
{
     e20:	b580      	push	{r7, lr}
     e22:	b084      	sub	sp, #16
     e24:	af00      	add	r7, sp, #0
     e26:	6078      	str	r0, [r7, #4]
	/* Sanity check of arguments */
	Assert(module);
	Assert(module->hw);

	SercomI2cm *const i2c_module = &(module->hw->I2CM);
     e28:	687b      	ldr	r3, [r7, #4]
     e2a:	681b      	ldr	r3, [r3, #0]
     e2c:	60bb      	str	r3, [r7, #8]

	/* Timeout counter used to force bus state */
	uint32_t timeout_counter = 0;
     e2e:	2300      	movs	r3, #0
     e30:	60fb      	str	r3, [r7, #12]

	/* Wait for module to sync */
	_i2c_master_wait_for_sync(module);
     e32:	687b      	ldr	r3, [r7, #4]
     e34:	0018      	movs	r0, r3
     e36:	4b14      	ldr	r3, [pc, #80]	; (e88 <i2c_master_enable+0x68>)
     e38:	4798      	blx	r3

	/* Enable module */
	i2c_module->CTRLA.reg |= SERCOM_I2CM_CTRLA_ENABLE;
     e3a:	68bb      	ldr	r3, [r7, #8]
     e3c:	681b      	ldr	r3, [r3, #0]
     e3e:	2202      	movs	r2, #2
     e40:	431a      	orrs	r2, r3
     e42:	68bb      	ldr	r3, [r7, #8]
     e44:	601a      	str	r2, [r3, #0]

#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
     e46:	687b      	ldr	r3, [r7, #4]
     e48:	681b      	ldr	r3, [r3, #0]
     e4a:	0018      	movs	r0, r3
     e4c:	4b0f      	ldr	r3, [pc, #60]	; (e8c <i2c_master_enable+0x6c>)
     e4e:	4798      	blx	r3
     e50:	0003      	movs	r3, r0
     e52:	0018      	movs	r0, r3
     e54:	4b0e      	ldr	r3, [pc, #56]	; (e90 <i2c_master_enable+0x70>)
     e56:	4798      	blx	r3
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
     e58:	e00c      	b.n	e74 <i2c_master_enable+0x54>
		timeout_counter++;
     e5a:	68fb      	ldr	r3, [r7, #12]
     e5c:	3301      	adds	r3, #1
     e5e:	60fb      	str	r3, [r7, #12]
		if(timeout_counter >= (module->unknown_bus_state_timeout)) {
     e60:	687b      	ldr	r3, [r7, #4]
     e62:	88db      	ldrh	r3, [r3, #6]
     e64:	1e1a      	subs	r2, r3, #0
     e66:	68fb      	ldr	r3, [r7, #12]
     e68:	429a      	cmp	r2, r3
     e6a:	d803      	bhi.n	e74 <i2c_master_enable+0x54>
			/* Timeout, force bus state to idle */
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
     e6c:	68bb      	ldr	r3, [r7, #8]
     e6e:	2210      	movs	r2, #16
     e70:	821a      	strh	r2, [r3, #16]
			/* Workaround #1 */
			return;
     e72:	e006      	b.n	e82 <i2c_master_enable+0x62>
#if I2C_MASTER_CALLBACK_MODE == true
	/* Enable module interrupts */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
#endif
	/* Start timeout if bus state is unknown */
	while (!(i2c_module->STATUS.reg & SERCOM_I2CM_STATUS_BUSSTATE(1))) {
     e74:	68bb      	ldr	r3, [r7, #8]
     e76:	8a1b      	ldrh	r3, [r3, #16]
     e78:	b29b      	uxth	r3, r3
     e7a:	001a      	movs	r2, r3
     e7c:	2310      	movs	r3, #16
     e7e:	4013      	ands	r3, r2
     e80:	d0eb      	beq.n	e5a <i2c_master_enable+0x3a>
			i2c_module->STATUS.reg = SERCOM_I2CM_STATUS_BUSSTATE(1);
			/* Workaround #1 */
			return;
		}
	}
}
     e82:	46bd      	mov	sp, r7
     e84:	b004      	add	sp, #16
     e86:	bd80      	pop	{r7, pc}
     e88:	00000da5 	.word	0x00000da5
     e8c:	00002e99 	.word	0x00002e99
     e90:	00000d4d 	.word	0x00000d4d

00000e94 <configure_i2c_master>:

/*
 * i2c master module configuration function
 */
static void configure_i2c_master(void)
{
     e94:	b580      	push	{r7, lr}
     e96:	b08a      	sub	sp, #40	; 0x28
     e98:	af00      	add	r7, sp, #0
	struct i2c_master_config config_i2c_master;
	i2c_master_get_config_defaults(&config_i2c_master);
     e9a:	003b      	movs	r3, r7
     e9c:	0018      	movs	r0, r3
     e9e:	4b0e      	ldr	r3, [pc, #56]	; (ed8 <configure_i2c_master+0x44>)
     ea0:	4798      	blx	r3
	config_i2c_master.baud_rate = I2C_MASTER_BAUD_RATE_400KHZ;
     ea2:	003b      	movs	r3, r7
     ea4:	22c8      	movs	r2, #200	; 0xc8
     ea6:	0052      	lsls	r2, r2, #1
     ea8:	601a      	str	r2, [r3, #0]
	config_i2c_master.buffer_timeout = 10000;
     eaa:	003b      	movs	r3, r7
     eac:	4a0b      	ldr	r2, [pc, #44]	; (edc <configure_i2c_master+0x48>)
     eae:	81da      	strh	r2, [r3, #14]
	config_i2c_master.pinmux_pad0 = SMBUS_SDA;
     eb0:	003b      	movs	r3, r7
     eb2:	2216      	movs	r2, #22
     eb4:	615a      	str	r2, [r3, #20]
	config_i2c_master.pinmux_pad1 = SMBUS_SCL;
     eb6:	003b      	movs	r3, r7
     eb8:	2217      	movs	r2, #23
     eba:	619a      	str	r2, [r3, #24]
	i2c_master_init(&i2c_master_instance,SMBUS_MODULE,&config_i2c_master);
     ebc:	003a      	movs	r2, r7
     ebe:	4908      	ldr	r1, [pc, #32]	; (ee0 <configure_i2c_master+0x4c>)
     ec0:	4b08      	ldr	r3, [pc, #32]	; (ee4 <configure_i2c_master+0x50>)
     ec2:	0018      	movs	r0, r3
     ec4:	4b08      	ldr	r3, [pc, #32]	; (ee8 <configure_i2c_master+0x54>)
     ec6:	4798      	blx	r3
	i2c_master_enable(&i2c_master_instance);
     ec8:	4b06      	ldr	r3, [pc, #24]	; (ee4 <configure_i2c_master+0x50>)
     eca:	0018      	movs	r0, r3
     ecc:	4b07      	ldr	r3, [pc, #28]	; (eec <configure_i2c_master+0x58>)
     ece:	4798      	blx	r3
}
     ed0:	46c0      	nop			; (mov r8, r8)
     ed2:	46bd      	mov	sp, r7
     ed4:	b00a      	add	sp, #40	; 0x28
     ed6:	bd80      	pop	{r7, pc}
     ed8:	00000dc9 	.word	0x00000dc9
     edc:	00002710 	.word	0x00002710
     ee0:	42001400 	.word	0x42001400
     ee4:	20002db4 	.word	0x20002db4
     ee8:	000003b9 	.word	0x000003b9
     eec:	00000e21 	.word	0x00000e21

00000ef0 <pinmux_smbus>:

/*
 * i2c master module pinmux function
 */
static void pinmux_smbus(void)
{
     ef0:	b580      	push	{r7, lr}
     ef2:	b082      	sub	sp, #8
     ef4:	af00      	add	r7, sp, #0
	struct system_pinmux_config config_pinmux;
	system_pinmux_get_config_defaults(&config_pinmux);
     ef6:	1d3b      	adds	r3, r7, #4
     ef8:	0018      	movs	r0, r3
     efa:	4b09      	ldr	r3, [pc, #36]	; (f20 <pinmux_smbus+0x30>)
     efc:	4798      	blx	r3
	
	config_pinmux.mux_position = SMBUS_PINMUX;
     efe:	1d3b      	adds	r3, r7, #4
     f00:	2202      	movs	r2, #2
     f02:	701a      	strb	r2, [r3, #0]
	
	system_pinmux_pin_set_config(SMBUS_SCL,&config_pinmux);
     f04:	1d3b      	adds	r3, r7, #4
     f06:	0019      	movs	r1, r3
     f08:	2017      	movs	r0, #23
     f0a:	4b06      	ldr	r3, [pc, #24]	; (f24 <pinmux_smbus+0x34>)
     f0c:	4798      	blx	r3
	system_pinmux_pin_set_config(SMBUS_SDA,&config_pinmux);
     f0e:	1d3b      	adds	r3, r7, #4
     f10:	0019      	movs	r1, r3
     f12:	2016      	movs	r0, #22
     f14:	4b03      	ldr	r3, [pc, #12]	; (f24 <pinmux_smbus+0x34>)
     f16:	4798      	blx	r3
}
     f18:	46c0      	nop			; (mov r8, r8)
     f1a:	46bd      	mov	sp, r7
     f1c:	b002      	add	sp, #8
     f1e:	bd80      	pop	{r7, pc}
     f20:	00000d25 	.word	0x00000d25
     f24:	00004d95 	.word	0x00004d95

00000f28 <ssd_log_init>:

static void ssd_log_init(void)
{
     f28:	b580      	push	{r7, lr}
     f2a:	b082      	sub	sp, #8
     f2c:	af00      	add	r7, sp, #0
	uint8_t i = 0;
     f2e:	1dfb      	adds	r3, r7, #7
     f30:	2200      	movs	r2, #0
     f32:	701a      	strb	r2, [r3, #0]
	for(i = 0;i < 8;i++)
     f34:	1dfb      	adds	r3, r7, #7
     f36:	2200      	movs	r2, #0
     f38:	701a      	strb	r2, [r3, #0]
     f3a:	e034      	b.n	fa6 <ssd_log_init+0x7e>
	{
		ssd_port_log_pingpang0[0+i*ETH_SSD_LOG_LENGTH] = 0;	// means get info command
     f3c:	1dfb      	adds	r3, r7, #7
     f3e:	781b      	ldrb	r3, [r3, #0]
     f40:	2296      	movs	r2, #150	; 0x96
     f42:	4353      	muls	r3, r2
     f44:	4a22      	ldr	r2, [pc, #136]	; (fd0 <ssd_log_init+0xa8>)
     f46:	2100      	movs	r1, #0
     f48:	54d1      	strb	r1, [r2, r3]
		ssd_port_log_pingpang0[2+i*ETH_SSD_LOG_LENGTH] = i;	// means ssd port index
     f4a:	1dfb      	adds	r3, r7, #7
     f4c:	781b      	ldrb	r3, [r3, #0]
     f4e:	2296      	movs	r2, #150	; 0x96
     f50:	4353      	muls	r3, r2
     f52:	3302      	adds	r3, #2
     f54:	4a1e      	ldr	r2, [pc, #120]	; (fd0 <ssd_log_init+0xa8>)
     f56:	1df9      	adds	r1, r7, #7
     f58:	7809      	ldrb	r1, [r1, #0]
     f5a:	54d1      	strb	r1, [r2, r3]
		ssd_port_log_pingpang0[3+i*ETH_SSD_LOG_LENGTH] = 1; // means present
     f5c:	1dfb      	adds	r3, r7, #7
     f5e:	781b      	ldrb	r3, [r3, #0]
     f60:	2296      	movs	r2, #150	; 0x96
     f62:	4353      	muls	r3, r2
     f64:	3303      	adds	r3, #3
     f66:	4a1a      	ldr	r2, [pc, #104]	; (fd0 <ssd_log_init+0xa8>)
     f68:	2101      	movs	r1, #1
     f6a:	54d1      	strb	r1, [r2, r3]
		ssd_port_log_pingpang1[0+i*ETH_SSD_LOG_LENGTH] = 0;	// means get info command
     f6c:	1dfb      	adds	r3, r7, #7
     f6e:	781b      	ldrb	r3, [r3, #0]
     f70:	2296      	movs	r2, #150	; 0x96
     f72:	4353      	muls	r3, r2
     f74:	4a17      	ldr	r2, [pc, #92]	; (fd4 <ssd_log_init+0xac>)
     f76:	2100      	movs	r1, #0
     f78:	54d1      	strb	r1, [r2, r3]
		ssd_port_log_pingpang1[2+i*ETH_SSD_LOG_LENGTH] = i;	// means ssd port index
     f7a:	1dfb      	adds	r3, r7, #7
     f7c:	781b      	ldrb	r3, [r3, #0]
     f7e:	2296      	movs	r2, #150	; 0x96
     f80:	4353      	muls	r3, r2
     f82:	3302      	adds	r3, #2
     f84:	4a13      	ldr	r2, [pc, #76]	; (fd4 <ssd_log_init+0xac>)
     f86:	1df9      	adds	r1, r7, #7
     f88:	7809      	ldrb	r1, [r1, #0]
     f8a:	54d1      	strb	r1, [r2, r3]
		ssd_port_log_pingpang1[3+i*ETH_SSD_LOG_LENGTH] = 1; // means present
     f8c:	1dfb      	adds	r3, r7, #7
     f8e:	781b      	ldrb	r3, [r3, #0]
     f90:	2296      	movs	r2, #150	; 0x96
     f92:	4353      	muls	r3, r2
     f94:	3303      	adds	r3, #3
     f96:	4a0f      	ldr	r2, [pc, #60]	; (fd4 <ssd_log_init+0xac>)
     f98:	2101      	movs	r1, #1
     f9a:	54d1      	strb	r1, [r2, r3]
}

static void ssd_log_init(void)
{
	uint8_t i = 0;
	for(i = 0;i < 8;i++)
     f9c:	1dfb      	adds	r3, r7, #7
     f9e:	781a      	ldrb	r2, [r3, #0]
     fa0:	1dfb      	adds	r3, r7, #7
     fa2:	3201      	adds	r2, #1
     fa4:	701a      	strb	r2, [r3, #0]
     fa6:	1dfb      	adds	r3, r7, #7
     fa8:	781b      	ldrb	r3, [r3, #0]
     faa:	2b07      	cmp	r3, #7
     fac:	d9c6      	bls.n	f3c <ssd_log_init+0x14>
		ssd_port_log_pingpang0[3+i*ETH_SSD_LOG_LENGTH] = 1; // means present
		ssd_port_log_pingpang1[0+i*ETH_SSD_LOG_LENGTH] = 0;	// means get info command
		ssd_port_log_pingpang1[2+i*ETH_SSD_LOG_LENGTH] = i;	// means ssd port index
		ssd_port_log_pingpang1[3+i*ETH_SSD_LOG_LENGTH] = 1; // means present
	}
	aging_box_log_pingpang0[0] = 0;
     fae:	4b0a      	ldr	r3, [pc, #40]	; (fd8 <ssd_log_init+0xb0>)
     fb0:	2200      	movs	r2, #0
     fb2:	701a      	strb	r2, [r3, #0]
	aging_box_log_pingpang0[2] = 9;
     fb4:	4b08      	ldr	r3, [pc, #32]	; (fd8 <ssd_log_init+0xb0>)
     fb6:	2209      	movs	r2, #9
     fb8:	709a      	strb	r2, [r3, #2]
	aging_box_log_pingpang1[0] = 0;
     fba:	4b08      	ldr	r3, [pc, #32]	; (fdc <ssd_log_init+0xb4>)
     fbc:	2200      	movs	r2, #0
     fbe:	701a      	strb	r2, [r3, #0]
	aging_box_log_pingpang1[2] = 9;
     fc0:	4b06      	ldr	r3, [pc, #24]	; (fdc <ssd_log_init+0xb4>)
     fc2:	2209      	movs	r2, #9
     fc4:	709a      	strb	r2, [r3, #2]
}
     fc6:	46c0      	nop			; (mov r8, r8)
     fc8:	46bd      	mov	sp, r7
     fca:	b002      	add	sp, #8
     fcc:	bd80      	pop	{r7, pc}
     fce:	46c0      	nop			; (mov r8, r8)
     fd0:	20000068 	.word	0x20000068
     fd4:	20000518 	.word	0x20000518
     fd8:	200009c8 	.word	0x200009c8
     fdc:	200009e8 	.word	0x200009e8

00000fe0 <smbus_init>:
/*
 * i2c master module init function
 */
void smbus_init(void)
{
     fe0:	b580      	push	{r7, lr}
     fe2:	af00      	add	r7, sp, #0
	configure_i2c_master();
     fe4:	4b04      	ldr	r3, [pc, #16]	; (ff8 <smbus_init+0x18>)
     fe6:	4798      	blx	r3
	pinmux_smbus();
     fe8:	4b04      	ldr	r3, [pc, #16]	; (ffc <smbus_init+0x1c>)
     fea:	4798      	blx	r3
	ssd_log_init();
     fec:	4b04      	ldr	r3, [pc, #16]	; (1000 <smbus_init+0x20>)
     fee:	4798      	blx	r3
}
     ff0:	46c0      	nop			; (mov r8, r8)
     ff2:	46bd      	mov	sp, r7
     ff4:	bd80      	pop	{r7, pc}
     ff6:	46c0      	nop			; (mov r8, r8)
     ff8:	00000e95 	.word	0x00000e95
     ffc:	00000ef1 	.word	0x00000ef1
    1000:	00000f29 	.word	0x00000f29

00001004 <check_sum_generator>:
/* 
 * checksum generator function 
 */
static uint8_t check_sum_generator(uint8_t *buff,uint8_t num)
{
    1004:	b580      	push	{r7, lr}
    1006:	b084      	sub	sp, #16
    1008:	af00      	add	r7, sp, #0
    100a:	6078      	str	r0, [r7, #4]
    100c:	000a      	movs	r2, r1
    100e:	1cfb      	adds	r3, r7, #3
    1010:	701a      	strb	r2, [r3, #0]
	uint8_t i = 0;
    1012:	230f      	movs	r3, #15
    1014:	18fb      	adds	r3, r7, r3
    1016:	2200      	movs	r2, #0
    1018:	701a      	strb	r2, [r3, #0]
	uint8_t checksum = 0;
    101a:	230e      	movs	r3, #14
    101c:	18fb      	adds	r3, r7, r3
    101e:	2200      	movs	r2, #0
    1020:	701a      	strb	r2, [r3, #0]
	for(i = 0;i < num;i++)
    1022:	230f      	movs	r3, #15
    1024:	18fb      	adds	r3, r7, r3
    1026:	2200      	movs	r2, #0
    1028:	701a      	strb	r2, [r3, #0]
    102a:	e013      	b.n	1054 <check_sum_generator+0x50>
	{
		checksum = checksum + (uint8_t)(*(buff+i));
    102c:	230f      	movs	r3, #15
    102e:	18fb      	adds	r3, r7, r3
    1030:	781b      	ldrb	r3, [r3, #0]
    1032:	687a      	ldr	r2, [r7, #4]
    1034:	18d3      	adds	r3, r2, r3
    1036:	7819      	ldrb	r1, [r3, #0]
    1038:	230e      	movs	r3, #14
    103a:	18fb      	adds	r3, r7, r3
    103c:	220e      	movs	r2, #14
    103e:	18ba      	adds	r2, r7, r2
    1040:	7812      	ldrb	r2, [r2, #0]
    1042:	188a      	adds	r2, r1, r2
    1044:	701a      	strb	r2, [r3, #0]
 */
static uint8_t check_sum_generator(uint8_t *buff,uint8_t num)
{
	uint8_t i = 0;
	uint8_t checksum = 0;
	for(i = 0;i < num;i++)
    1046:	230f      	movs	r3, #15
    1048:	18fb      	adds	r3, r7, r3
    104a:	781a      	ldrb	r2, [r3, #0]
    104c:	230f      	movs	r3, #15
    104e:	18fb      	adds	r3, r7, r3
    1050:	3201      	adds	r2, #1
    1052:	701a      	strb	r2, [r3, #0]
    1054:	230f      	movs	r3, #15
    1056:	18fa      	adds	r2, r7, r3
    1058:	1cfb      	adds	r3, r7, #3
    105a:	7812      	ldrb	r2, [r2, #0]
    105c:	781b      	ldrb	r3, [r3, #0]
    105e:	429a      	cmp	r2, r3
    1060:	d3e4      	bcc.n	102c <check_sum_generator+0x28>
	{
		checksum = checksum + (uint8_t)(*(buff+i));
	}

	return checksum;
    1062:	230e      	movs	r3, #14
    1064:	18fb      	adds	r3, r7, r3
    1066:	781b      	ldrb	r3, [r3, #0]
}
    1068:	0018      	movs	r0, r3
    106a:	46bd      	mov	sp, r7
    106c:	b004      	add	sp, #16
    106e:	bd80      	pop	{r7, pc}

00001070 <smbus_read_basic_info>:
/*
 * Brief: read basic info function
 *
 */
static void smbus_read_basic_info(void)
{
    1070:	b590      	push	{r4, r7, lr}
    1072:	b089      	sub	sp, #36	; 0x24
    1074:	af00      	add	r7, sp, #0
	enum status_code err = STATUS_OK;
    1076:	231f      	movs	r3, #31
    1078:	18fb      	adds	r3, r7, r3
    107a:	2200      	movs	r2, #0
    107c:	701a      	strb	r2, [r3, #0]
	uint8_t tx_buff_basic[DATA_LENGTH] = {0x0a,0x00,0xff,0xff,0x06,0x00,0x01,0x00,0x00,0x00};
    107e:	2314      	movs	r3, #20
    1080:	18fa      	adds	r2, r7, r3
    1082:	4b56      	ldr	r3, [pc, #344]	; (11dc <smbus_read_basic_info+0x16c>)
    1084:	0010      	movs	r0, r2
    1086:	0019      	movs	r1, r3
    1088:	230a      	movs	r3, #10
    108a:	001a      	movs	r2, r3
    108c:	4b54      	ldr	r3, [pc, #336]	; (11e0 <smbus_read_basic_info+0x170>)
    108e:	4798      	blx	r3
	volatile uint16_t timeout = 0;
    1090:	2312      	movs	r3, #18
    1092:	18fb      	adds	r3, r7, r3
    1094:	2200      	movs	r2, #0
    1096:	801a      	strh	r2, [r3, #0]
	uint8_t check_sum = 0;
    1098:	231e      	movs	r3, #30
    109a:	18fb      	adds	r3, r7, r3
    109c:	2200      	movs	r2, #0
    109e:	701a      	strb	r2, [r3, #0]
	
	tx_buff_basic[DATA_LENGTH-1] = check_sum_generator((uint8_t *)tx_buff_basic,(DATA_LENGTH-1));
    10a0:	2314      	movs	r3, #20
    10a2:	18fb      	adds	r3, r7, r3
    10a4:	2109      	movs	r1, #9
    10a6:	0018      	movs	r0, r3
    10a8:	4b4e      	ldr	r3, [pc, #312]	; (11e4 <smbus_read_basic_info+0x174>)
    10aa:	4798      	blx	r3
    10ac:	0003      	movs	r3, r0
    10ae:	001a      	movs	r2, r3
    10b0:	2314      	movs	r3, #20
    10b2:	18fb      	adds	r3, r7, r3
    10b4:	725a      	strb	r2, [r3, #9]

	struct i2c_master_packet packet =
    10b6:	1d3b      	adds	r3, r7, #4
    10b8:	226a      	movs	r2, #106	; 0x6a
    10ba:	801a      	strh	r2, [r3, #0]
    10bc:	1d3b      	adds	r3, r7, #4
    10be:	220a      	movs	r2, #10
    10c0:	805a      	strh	r2, [r3, #2]
    10c2:	1d3b      	adds	r3, r7, #4
    10c4:	2214      	movs	r2, #20
    10c6:	18ba      	adds	r2, r7, r2
    10c8:	605a      	str	r2, [r3, #4]
    10ca:	1d3b      	adds	r3, r7, #4
    10cc:	2200      	movs	r2, #0
    10ce:	721a      	strb	r2, [r3, #8]
    10d0:	1d3b      	adds	r3, r7, #4
    10d2:	2200      	movs	r2, #0
    10d4:	725a      	strb	r2, [r3, #9]
    10d6:	1d3b      	adds	r3, r7, #4
    10d8:	2200      	movs	r2, #0
    10da:	729a      	strb	r2, [r3, #10]
		.ten_bit_address = false,
		.high_speed = false,
		.hs_master_code = 0x0,
	};

	err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
    10dc:	231f      	movs	r3, #31
    10de:	18fc      	adds	r4, r7, r3
    10e0:	1d3a      	adds	r2, r7, #4
    10e2:	4b41      	ldr	r3, [pc, #260]	; (11e8 <smbus_read_basic_info+0x178>)
    10e4:	0011      	movs	r1, r2
    10e6:	0018      	movs	r0, r3
    10e8:	4b40      	ldr	r3, [pc, #256]	; (11ec <smbus_read_basic_info+0x17c>)
    10ea:	4798      	blx	r3
    10ec:	0003      	movs	r3, r0
    10ee:	7023      	strb	r3, [r4, #0]
	while(err != STATUS_OK)
    10f0:	e01c      	b.n	112c <smbus_read_basic_info+0xbc>
	{
		err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
    10f2:	231f      	movs	r3, #31
    10f4:	18fc      	adds	r4, r7, r3
    10f6:	1d3a      	adds	r2, r7, #4
    10f8:	4b3b      	ldr	r3, [pc, #236]	; (11e8 <smbus_read_basic_info+0x178>)
    10fa:	0011      	movs	r1, r2
    10fc:	0018      	movs	r0, r3
    10fe:	4b3b      	ldr	r3, [pc, #236]	; (11ec <smbus_read_basic_info+0x17c>)
    1100:	4798      	blx	r3
    1102:	0003      	movs	r3, r0
    1104:	7023      	strb	r3, [r4, #0]
		timeout++;
    1106:	2312      	movs	r3, #18
    1108:	18fb      	adds	r3, r7, r3
    110a:	881b      	ldrh	r3, [r3, #0]
    110c:	b29b      	uxth	r3, r3
    110e:	3301      	adds	r3, #1
    1110:	b29a      	uxth	r2, r3
    1112:	2312      	movs	r3, #18
    1114:	18fb      	adds	r3, r7, r3
    1116:	801a      	strh	r2, [r3, #0]
		if(timeout == TIMEOUT)
    1118:	2312      	movs	r3, #18
    111a:	18fb      	adds	r3, r7, r3
    111c:	881b      	ldrh	r3, [r3, #0]
    111e:	b29b      	uxth	r3, r3
    1120:	2b64      	cmp	r3, #100	; 0x64
    1122:	d103      	bne.n	112c <smbus_read_basic_info+0xbc>
		{
			smbus_err_code = 1;	//basic info: write error
    1124:	4b32      	ldr	r3, [pc, #200]	; (11f0 <smbus_read_basic_info+0x180>)
    1126:	2201      	movs	r2, #1
    1128:	701a      	strb	r2, [r3, #0]
			return;
    112a:	e054      	b.n	11d6 <smbus_read_basic_info+0x166>
		.high_speed = false,
		.hs_master_code = 0x0,
	};

	err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
	while(err != STATUS_OK)
    112c:	231f      	movs	r3, #31
    112e:	18fb      	adds	r3, r7, r3
    1130:	781b      	ldrb	r3, [r3, #0]
    1132:	2b00      	cmp	r3, #0
    1134:	d1dd      	bne.n	10f2 <smbus_read_basic_info+0x82>
			smbus_err_code = 1;	//basic info: write error
			return;
		}
	}

	packet.data = (uint8_t *)rx_buff_basic;
    1136:	1d3b      	adds	r3, r7, #4
    1138:	4a2e      	ldr	r2, [pc, #184]	; (11f4 <smbus_read_basic_info+0x184>)
    113a:	605a      	str	r2, [r3, #4]
	packet.data_length = BASIC_INFO_BUFFER_SIZE;
    113c:	1d3b      	adds	r3, r7, #4
    113e:	2269      	movs	r2, #105	; 0x69
    1140:	805a      	strh	r2, [r3, #2]

	/* delay, waiting for i2c ready*/
	sys_delay_ms(DELAY_MS);
    1142:	2005      	movs	r0, #5
    1144:	4b2c      	ldr	r3, [pc, #176]	; (11f8 <smbus_read_basic_info+0x188>)
    1146:	4798      	blx	r3
	while(sys_delay_ms(0));
    1148:	46c0      	nop			; (mov r8, r8)
    114a:	2000      	movs	r0, #0
    114c:	4b2a      	ldr	r3, [pc, #168]	; (11f8 <smbus_read_basic_info+0x188>)
    114e:	4798      	blx	r3
    1150:	1e03      	subs	r3, r0, #0
    1152:	d1fa      	bne.n	114a <smbus_read_basic_info+0xda>
	//timeout = 30000;
	//while(timeout--);

	err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
    1154:	231f      	movs	r3, #31
    1156:	18fc      	adds	r4, r7, r3
    1158:	1d3a      	adds	r2, r7, #4
    115a:	4b23      	ldr	r3, [pc, #140]	; (11e8 <smbus_read_basic_info+0x178>)
    115c:	0011      	movs	r1, r2
    115e:	0018      	movs	r0, r3
    1160:	4b26      	ldr	r3, [pc, #152]	; (11fc <smbus_read_basic_info+0x18c>)
    1162:	4798      	blx	r3
    1164:	0003      	movs	r3, r0
    1166:	7023      	strb	r3, [r4, #0]
	while(err != STATUS_OK)
    1168:	e01c      	b.n	11a4 <smbus_read_basic_info+0x134>
	{
		err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
    116a:	231f      	movs	r3, #31
    116c:	18fc      	adds	r4, r7, r3
    116e:	1d3a      	adds	r2, r7, #4
    1170:	4b1d      	ldr	r3, [pc, #116]	; (11e8 <smbus_read_basic_info+0x178>)
    1172:	0011      	movs	r1, r2
    1174:	0018      	movs	r0, r3
    1176:	4b21      	ldr	r3, [pc, #132]	; (11fc <smbus_read_basic_info+0x18c>)
    1178:	4798      	blx	r3
    117a:	0003      	movs	r3, r0
    117c:	7023      	strb	r3, [r4, #0]
		timeout++;
    117e:	2312      	movs	r3, #18
    1180:	18fb      	adds	r3, r7, r3
    1182:	881b      	ldrh	r3, [r3, #0]
    1184:	b29b      	uxth	r3, r3
    1186:	3301      	adds	r3, #1
    1188:	b29a      	uxth	r2, r3
    118a:	2312      	movs	r3, #18
    118c:	18fb      	adds	r3, r7, r3
    118e:	801a      	strh	r2, [r3, #0]
		if(timeout == TIMEOUT)
    1190:	2312      	movs	r3, #18
    1192:	18fb      	adds	r3, r7, r3
    1194:	881b      	ldrh	r3, [r3, #0]
    1196:	b29b      	uxth	r3, r3
    1198:	2b64      	cmp	r3, #100	; 0x64
    119a:	d103      	bne.n	11a4 <smbus_read_basic_info+0x134>
		{
			smbus_err_code = 2;	//basic info: read error
    119c:	4b14      	ldr	r3, [pc, #80]	; (11f0 <smbus_read_basic_info+0x180>)
    119e:	2202      	movs	r2, #2
    11a0:	701a      	strb	r2, [r3, #0]
			return;
    11a2:	e018      	b.n	11d6 <smbus_read_basic_info+0x166>
	while(sys_delay_ms(0));
	//timeout = 30000;
	//while(timeout--);

	err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
	while(err != STATUS_OK)
    11a4:	231f      	movs	r3, #31
    11a6:	18fb      	adds	r3, r7, r3
    11a8:	781b      	ldrb	r3, [r3, #0]
    11aa:	2b00      	cmp	r3, #0
    11ac:	d1dd      	bne.n	116a <smbus_read_basic_info+0xfa>
		{
			smbus_err_code = 2;	//basic info: read error
			return;
		}
	}
	check_sum = check_sum_generator((uint8_t *)rx_buff_basic,(BASIC_INFO_BUFFER_SIZE-1));
    11ae:	231e      	movs	r3, #30
    11b0:	18fc      	adds	r4, r7, r3
    11b2:	4b10      	ldr	r3, [pc, #64]	; (11f4 <smbus_read_basic_info+0x184>)
    11b4:	2168      	movs	r1, #104	; 0x68
    11b6:	0018      	movs	r0, r3
    11b8:	4b0a      	ldr	r3, [pc, #40]	; (11e4 <smbus_read_basic_info+0x174>)
    11ba:	4798      	blx	r3
    11bc:	0003      	movs	r3, r0
    11be:	7023      	strb	r3, [r4, #0]
	if(check_sum != rx_buff_basic[BASIC_INFO_BUFFER_SIZE-1])
    11c0:	4b0c      	ldr	r3, [pc, #48]	; (11f4 <smbus_read_basic_info+0x184>)
    11c2:	2268      	movs	r2, #104	; 0x68
    11c4:	5c9b      	ldrb	r3, [r3, r2]
    11c6:	221e      	movs	r2, #30
    11c8:	18ba      	adds	r2, r7, r2
    11ca:	7812      	ldrb	r2, [r2, #0]
    11cc:	429a      	cmp	r2, r3
    11ce:	d002      	beq.n	11d6 <smbus_read_basic_info+0x166>
	{
		smbus_err_code = 3;
    11d0:	4b07      	ldr	r3, [pc, #28]	; (11f0 <smbus_read_basic_info+0x180>)
    11d2:	2203      	movs	r2, #3
    11d4:	701a      	strb	r2, [r3, #0]
	}
}
    11d6:	46bd      	mov	sp, r7
    11d8:	b009      	add	sp, #36	; 0x24
    11da:	bd90      	pop	{r4, r7, pc}
    11dc:	0000fc80 	.word	0x0000fc80
    11e0:	0000fc43 	.word	0x0000fc43
    11e4:	00001005 	.word	0x00001005
    11e8:	20002db4 	.word	0x20002db4
    11ec:	00000885 	.word	0x00000885
    11f0:	20000064 	.word	0x20000064
    11f4:	20000a08 	.word	0x20000a08
    11f8:	0000f731 	.word	0x0000f731
    11fc:	00000721 	.word	0x00000721

00001200 <smbus_read_oob_info>:
 *
 * if fail, return err;
 * if succeed, write the new oob info to "all_bi_info_buffer", and return OK
 */
static void smbus_read_oob_info(void)
{
    1200:	b590      	push	{r4, r7, lr}
    1202:	b089      	sub	sp, #36	; 0x24
    1204:	af00      	add	r7, sp, #0
	enum status_code err = STATUS_OK;
    1206:	231f      	movs	r3, #31
    1208:	18fb      	adds	r3, r7, r3
    120a:	2200      	movs	r2, #0
    120c:	701a      	strb	r2, [r3, #0]
	uint8_t tx_buff_oob[DATA_LENGTH] = {0x0a,0x00,0xff,0xff,0x06,0x00,0x02,0x00,0x00,0x00};
    120e:	2314      	movs	r3, #20
    1210:	18fa      	adds	r2, r7, r3
    1212:	4b56      	ldr	r3, [pc, #344]	; (136c <smbus_read_oob_info+0x16c>)
    1214:	0010      	movs	r0, r2
    1216:	0019      	movs	r1, r3
    1218:	230a      	movs	r3, #10
    121a:	001a      	movs	r2, r3
    121c:	4b54      	ldr	r3, [pc, #336]	; (1370 <smbus_read_oob_info+0x170>)
    121e:	4798      	blx	r3
	volatile uint16_t timeout = 0;
    1220:	2312      	movs	r3, #18
    1222:	18fb      	adds	r3, r7, r3
    1224:	2200      	movs	r2, #0
    1226:	801a      	strh	r2, [r3, #0]
	uint8_t check_sum = 0;
    1228:	231e      	movs	r3, #30
    122a:	18fb      	adds	r3, r7, r3
    122c:	2200      	movs	r2, #0
    122e:	701a      	strb	r2, [r3, #0]
	
	tx_buff_oob[DATA_LENGTH-1] = check_sum_generator((uint8_t *)tx_buff_oob,(DATA_LENGTH-1));
    1230:	2314      	movs	r3, #20
    1232:	18fb      	adds	r3, r7, r3
    1234:	2109      	movs	r1, #9
    1236:	0018      	movs	r0, r3
    1238:	4b4e      	ldr	r3, [pc, #312]	; (1374 <smbus_read_oob_info+0x174>)
    123a:	4798      	blx	r3
    123c:	0003      	movs	r3, r0
    123e:	001a      	movs	r2, r3
    1240:	2314      	movs	r3, #20
    1242:	18fb      	adds	r3, r7, r3
    1244:	725a      	strb	r2, [r3, #9]

	struct i2c_master_packet packet =
    1246:	1d3b      	adds	r3, r7, #4
    1248:	226a      	movs	r2, #106	; 0x6a
    124a:	801a      	strh	r2, [r3, #0]
    124c:	1d3b      	adds	r3, r7, #4
    124e:	220a      	movs	r2, #10
    1250:	805a      	strh	r2, [r3, #2]
    1252:	1d3b      	adds	r3, r7, #4
    1254:	2214      	movs	r2, #20
    1256:	18ba      	adds	r2, r7, r2
    1258:	605a      	str	r2, [r3, #4]
    125a:	1d3b      	adds	r3, r7, #4
    125c:	2200      	movs	r2, #0
    125e:	721a      	strb	r2, [r3, #8]
    1260:	1d3b      	adds	r3, r7, #4
    1262:	2200      	movs	r2, #0
    1264:	725a      	strb	r2, [r3, #9]
    1266:	1d3b      	adds	r3, r7, #4
    1268:	2200      	movs	r2, #0
    126a:	729a      	strb	r2, [r3, #10]
		.ten_bit_address = false,
		.high_speed = false,
		.hs_master_code = 0x0,
	};

	err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
    126c:	231f      	movs	r3, #31
    126e:	18fc      	adds	r4, r7, r3
    1270:	1d3a      	adds	r2, r7, #4
    1272:	4b41      	ldr	r3, [pc, #260]	; (1378 <smbus_read_oob_info+0x178>)
    1274:	0011      	movs	r1, r2
    1276:	0018      	movs	r0, r3
    1278:	4b40      	ldr	r3, [pc, #256]	; (137c <smbus_read_oob_info+0x17c>)
    127a:	4798      	blx	r3
    127c:	0003      	movs	r3, r0
    127e:	7023      	strb	r3, [r4, #0]
	while(err != STATUS_OK)
    1280:	e01c      	b.n	12bc <smbus_read_oob_info+0xbc>
	{
		err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
    1282:	231f      	movs	r3, #31
    1284:	18fc      	adds	r4, r7, r3
    1286:	1d3a      	adds	r2, r7, #4
    1288:	4b3b      	ldr	r3, [pc, #236]	; (1378 <smbus_read_oob_info+0x178>)
    128a:	0011      	movs	r1, r2
    128c:	0018      	movs	r0, r3
    128e:	4b3b      	ldr	r3, [pc, #236]	; (137c <smbus_read_oob_info+0x17c>)
    1290:	4798      	blx	r3
    1292:	0003      	movs	r3, r0
    1294:	7023      	strb	r3, [r4, #0]
		timeout++;
    1296:	2312      	movs	r3, #18
    1298:	18fb      	adds	r3, r7, r3
    129a:	881b      	ldrh	r3, [r3, #0]
    129c:	b29b      	uxth	r3, r3
    129e:	3301      	adds	r3, #1
    12a0:	b29a      	uxth	r2, r3
    12a2:	2312      	movs	r3, #18
    12a4:	18fb      	adds	r3, r7, r3
    12a6:	801a      	strh	r2, [r3, #0]
		if(timeout == TIMEOUT)
    12a8:	2312      	movs	r3, #18
    12aa:	18fb      	adds	r3, r7, r3
    12ac:	881b      	ldrh	r3, [r3, #0]
    12ae:	b29b      	uxth	r3, r3
    12b0:	2b64      	cmp	r3, #100	; 0x64
    12b2:	d103      	bne.n	12bc <smbus_read_oob_info+0xbc>
		{
			smbus_err_code = 11;	//oob info: write error
    12b4:	4b32      	ldr	r3, [pc, #200]	; (1380 <smbus_read_oob_info+0x180>)
    12b6:	220b      	movs	r2, #11
    12b8:	701a      	strb	r2, [r3, #0]
			return;
    12ba:	e054      	b.n	1366 <smbus_read_oob_info+0x166>
		.high_speed = false,
		.hs_master_code = 0x0,
	};

	err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
	while(err != STATUS_OK)
    12bc:	231f      	movs	r3, #31
    12be:	18fb      	adds	r3, r7, r3
    12c0:	781b      	ldrb	r3, [r3, #0]
    12c2:	2b00      	cmp	r3, #0
    12c4:	d1dd      	bne.n	1282 <smbus_read_oob_info+0x82>
			smbus_err_code = 11;	//oob info: write error
			return;
		}
	}

	packet.data = (uint8_t *)rx_buff_oob;
    12c6:	1d3b      	adds	r3, r7, #4
    12c8:	4a2e      	ldr	r2, [pc, #184]	; (1384 <smbus_read_oob_info+0x184>)
    12ca:	605a      	str	r2, [r3, #4]
	packet.data_length = OOB_INFO_BUFFER_SIZE;
    12cc:	1d3b      	adds	r3, r7, #4
    12ce:	222e      	movs	r2, #46	; 0x2e
    12d0:	805a      	strh	r2, [r3, #2]

	/* delay, waiting for i2c ready*/
	sys_delay_ms(DELAY_MS);
    12d2:	2005      	movs	r0, #5
    12d4:	4b2c      	ldr	r3, [pc, #176]	; (1388 <smbus_read_oob_info+0x188>)
    12d6:	4798      	blx	r3
	while(sys_delay_ms(0));
    12d8:	46c0      	nop			; (mov r8, r8)
    12da:	2000      	movs	r0, #0
    12dc:	4b2a      	ldr	r3, [pc, #168]	; (1388 <smbus_read_oob_info+0x188>)
    12de:	4798      	blx	r3
    12e0:	1e03      	subs	r3, r0, #0
    12e2:	d1fa      	bne.n	12da <smbus_read_oob_info+0xda>

	err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
    12e4:	231f      	movs	r3, #31
    12e6:	18fc      	adds	r4, r7, r3
    12e8:	1d3a      	adds	r2, r7, #4
    12ea:	4b23      	ldr	r3, [pc, #140]	; (1378 <smbus_read_oob_info+0x178>)
    12ec:	0011      	movs	r1, r2
    12ee:	0018      	movs	r0, r3
    12f0:	4b26      	ldr	r3, [pc, #152]	; (138c <smbus_read_oob_info+0x18c>)
    12f2:	4798      	blx	r3
    12f4:	0003      	movs	r3, r0
    12f6:	7023      	strb	r3, [r4, #0]
	while(err != STATUS_OK)
    12f8:	e01c      	b.n	1334 <smbus_read_oob_info+0x134>
	{
		err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
    12fa:	231f      	movs	r3, #31
    12fc:	18fc      	adds	r4, r7, r3
    12fe:	1d3a      	adds	r2, r7, #4
    1300:	4b1d      	ldr	r3, [pc, #116]	; (1378 <smbus_read_oob_info+0x178>)
    1302:	0011      	movs	r1, r2
    1304:	0018      	movs	r0, r3
    1306:	4b21      	ldr	r3, [pc, #132]	; (138c <smbus_read_oob_info+0x18c>)
    1308:	4798      	blx	r3
    130a:	0003      	movs	r3, r0
    130c:	7023      	strb	r3, [r4, #0]
		timeout++;
    130e:	2312      	movs	r3, #18
    1310:	18fb      	adds	r3, r7, r3
    1312:	881b      	ldrh	r3, [r3, #0]
    1314:	b29b      	uxth	r3, r3
    1316:	3301      	adds	r3, #1
    1318:	b29a      	uxth	r2, r3
    131a:	2312      	movs	r3, #18
    131c:	18fb      	adds	r3, r7, r3
    131e:	801a      	strh	r2, [r3, #0]
		if(timeout == TIMEOUT)
    1320:	2312      	movs	r3, #18
    1322:	18fb      	adds	r3, r7, r3
    1324:	881b      	ldrh	r3, [r3, #0]
    1326:	b29b      	uxth	r3, r3
    1328:	2b64      	cmp	r3, #100	; 0x64
    132a:	d103      	bne.n	1334 <smbus_read_oob_info+0x134>
		{
			smbus_err_code = 12;	//oob info: read error
    132c:	4b14      	ldr	r3, [pc, #80]	; (1380 <smbus_read_oob_info+0x180>)
    132e:	220c      	movs	r2, #12
    1330:	701a      	strb	r2, [r3, #0]
			return;
    1332:	e018      	b.n	1366 <smbus_read_oob_info+0x166>
	/* delay, waiting for i2c ready*/
	sys_delay_ms(DELAY_MS);
	while(sys_delay_ms(0));

	err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
	while(err != STATUS_OK)
    1334:	231f      	movs	r3, #31
    1336:	18fb      	adds	r3, r7, r3
    1338:	781b      	ldrb	r3, [r3, #0]
    133a:	2b00      	cmp	r3, #0
    133c:	d1dd      	bne.n	12fa <smbus_read_oob_info+0xfa>
		{
			smbus_err_code = 12;	//oob info: read error
			return;
		}
	}
	check_sum = check_sum_generator((uint8_t *)rx_buff_oob,(OOB_INFO_BUFFER_SIZE-1));
    133e:	231e      	movs	r3, #30
    1340:	18fc      	adds	r4, r7, r3
    1342:	4b10      	ldr	r3, [pc, #64]	; (1384 <smbus_read_oob_info+0x184>)
    1344:	212d      	movs	r1, #45	; 0x2d
    1346:	0018      	movs	r0, r3
    1348:	4b0a      	ldr	r3, [pc, #40]	; (1374 <smbus_read_oob_info+0x174>)
    134a:	4798      	blx	r3
    134c:	0003      	movs	r3, r0
    134e:	7023      	strb	r3, [r4, #0]
	if(check_sum != rx_buff_oob[OOB_INFO_BUFFER_SIZE-1])
    1350:	4b0c      	ldr	r3, [pc, #48]	; (1384 <smbus_read_oob_info+0x184>)
    1352:	222d      	movs	r2, #45	; 0x2d
    1354:	5c9b      	ldrb	r3, [r3, r2]
    1356:	221e      	movs	r2, #30
    1358:	18ba      	adds	r2, r7, r2
    135a:	7812      	ldrb	r2, [r2, #0]
    135c:	429a      	cmp	r2, r3
    135e:	d002      	beq.n	1366 <smbus_read_oob_info+0x166>
	{
		smbus_err_code = 13;
    1360:	4b07      	ldr	r3, [pc, #28]	; (1380 <smbus_read_oob_info+0x180>)
    1362:	220d      	movs	r2, #13
    1364:	701a      	strb	r2, [r3, #0]
	}
}
    1366:	46bd      	mov	sp, r7
    1368:	b009      	add	sp, #36	; 0x24
    136a:	bd90      	pop	{r4, r7, pc}
    136c:	0000fc8c 	.word	0x0000fc8c
    1370:	0000fc43 	.word	0x0000fc43
    1374:	00001005 	.word	0x00001005
    1378:	20002db4 	.word	0x20002db4
    137c:	00000885 	.word	0x00000885
    1380:	20000064 	.word	0x20000064
    1384:	20000a74 	.word	0x20000a74
    1388:	0000f731 	.word	0x0000f731
    138c:	00000721 	.word	0x00000721

00001390 <smbus_read_bi_info>:
 *
 * if fail, return err;
 * if succeed, write the new bi info to "all_bi_info_buffer", and return OK
 */
static void smbus_read_bi_info(void)
{
    1390:	b590      	push	{r4, r7, lr}
    1392:	b089      	sub	sp, #36	; 0x24
    1394:	af00      	add	r7, sp, #0
	enum status_code err = STATUS_OK;
    1396:	231f      	movs	r3, #31
    1398:	18fb      	adds	r3, r7, r3
    139a:	2200      	movs	r2, #0
    139c:	701a      	strb	r2, [r3, #0]
	uint8_t tx_buff_bi[DATA_LENGTH] = {0x0a,0x00,0xff,0xff,0x06,0x00,0x03,0x00,0x00,0x00};
    139e:	2314      	movs	r3, #20
    13a0:	18fa      	adds	r2, r7, r3
    13a2:	4b56      	ldr	r3, [pc, #344]	; (14fc <smbus_read_bi_info+0x16c>)
    13a4:	0010      	movs	r0, r2
    13a6:	0019      	movs	r1, r3
    13a8:	230a      	movs	r3, #10
    13aa:	001a      	movs	r2, r3
    13ac:	4b54      	ldr	r3, [pc, #336]	; (1500 <smbus_read_bi_info+0x170>)
    13ae:	4798      	blx	r3
	volatile uint16_t timeout = 0;
    13b0:	2312      	movs	r3, #18
    13b2:	18fb      	adds	r3, r7, r3
    13b4:	2200      	movs	r2, #0
    13b6:	801a      	strh	r2, [r3, #0]
	uint8_t check_sum = 0;
    13b8:	231e      	movs	r3, #30
    13ba:	18fb      	adds	r3, r7, r3
    13bc:	2200      	movs	r2, #0
    13be:	701a      	strb	r2, [r3, #0]

	tx_buff_bi[DATA_LENGTH-1] = check_sum_generator((uint8_t *)tx_buff_bi,(DATA_LENGTH-1));
    13c0:	2314      	movs	r3, #20
    13c2:	18fb      	adds	r3, r7, r3
    13c4:	2109      	movs	r1, #9
    13c6:	0018      	movs	r0, r3
    13c8:	4b4e      	ldr	r3, [pc, #312]	; (1504 <smbus_read_bi_info+0x174>)
    13ca:	4798      	blx	r3
    13cc:	0003      	movs	r3, r0
    13ce:	001a      	movs	r2, r3
    13d0:	2314      	movs	r3, #20
    13d2:	18fb      	adds	r3, r7, r3
    13d4:	725a      	strb	r2, [r3, #9]
	
	struct i2c_master_packet packet =
    13d6:	1d3b      	adds	r3, r7, #4
    13d8:	226a      	movs	r2, #106	; 0x6a
    13da:	801a      	strh	r2, [r3, #0]
    13dc:	1d3b      	adds	r3, r7, #4
    13de:	220a      	movs	r2, #10
    13e0:	805a      	strh	r2, [r3, #2]
    13e2:	1d3b      	adds	r3, r7, #4
    13e4:	2214      	movs	r2, #20
    13e6:	18ba      	adds	r2, r7, r2
    13e8:	605a      	str	r2, [r3, #4]
    13ea:	1d3b      	adds	r3, r7, #4
    13ec:	2200      	movs	r2, #0
    13ee:	721a      	strb	r2, [r3, #8]
    13f0:	1d3b      	adds	r3, r7, #4
    13f2:	2200      	movs	r2, #0
    13f4:	725a      	strb	r2, [r3, #9]
    13f6:	1d3b      	adds	r3, r7, #4
    13f8:	2200      	movs	r2, #0
    13fa:	729a      	strb	r2, [r3, #10]
		.ten_bit_address = false,
		.high_speed = false,
		.hs_master_code = 0x0,
	};

	err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
    13fc:	231f      	movs	r3, #31
    13fe:	18fc      	adds	r4, r7, r3
    1400:	1d3a      	adds	r2, r7, #4
    1402:	4b41      	ldr	r3, [pc, #260]	; (1508 <smbus_read_bi_info+0x178>)
    1404:	0011      	movs	r1, r2
    1406:	0018      	movs	r0, r3
    1408:	4b40      	ldr	r3, [pc, #256]	; (150c <smbus_read_bi_info+0x17c>)
    140a:	4798      	blx	r3
    140c:	0003      	movs	r3, r0
    140e:	7023      	strb	r3, [r4, #0]
	while(err != STATUS_OK)
    1410:	e01c      	b.n	144c <smbus_read_bi_info+0xbc>
	{
		err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
    1412:	231f      	movs	r3, #31
    1414:	18fc      	adds	r4, r7, r3
    1416:	1d3a      	adds	r2, r7, #4
    1418:	4b3b      	ldr	r3, [pc, #236]	; (1508 <smbus_read_bi_info+0x178>)
    141a:	0011      	movs	r1, r2
    141c:	0018      	movs	r0, r3
    141e:	4b3b      	ldr	r3, [pc, #236]	; (150c <smbus_read_bi_info+0x17c>)
    1420:	4798      	blx	r3
    1422:	0003      	movs	r3, r0
    1424:	7023      	strb	r3, [r4, #0]
		timeout++;
    1426:	2312      	movs	r3, #18
    1428:	18fb      	adds	r3, r7, r3
    142a:	881b      	ldrh	r3, [r3, #0]
    142c:	b29b      	uxth	r3, r3
    142e:	3301      	adds	r3, #1
    1430:	b29a      	uxth	r2, r3
    1432:	2312      	movs	r3, #18
    1434:	18fb      	adds	r3, r7, r3
    1436:	801a      	strh	r2, [r3, #0]
		if(timeout == TIMEOUT)
    1438:	2312      	movs	r3, #18
    143a:	18fb      	adds	r3, r7, r3
    143c:	881b      	ldrh	r3, [r3, #0]
    143e:	b29b      	uxth	r3, r3
    1440:	2b64      	cmp	r3, #100	; 0x64
    1442:	d103      	bne.n	144c <smbus_read_bi_info+0xbc>
		{
			smbus_err_code = 11;	//bi info: write error
    1444:	4b32      	ldr	r3, [pc, #200]	; (1510 <smbus_read_bi_info+0x180>)
    1446:	220b      	movs	r2, #11
    1448:	701a      	strb	r2, [r3, #0]
			return;
    144a:	e054      	b.n	14f6 <smbus_read_bi_info+0x166>
		.high_speed = false,
		.hs_master_code = 0x0,
	};

	err = i2c_master_write_packet_wait(&i2c_master_instance,&packet);
	while(err != STATUS_OK)
    144c:	231f      	movs	r3, #31
    144e:	18fb      	adds	r3, r7, r3
    1450:	781b      	ldrb	r3, [r3, #0]
    1452:	2b00      	cmp	r3, #0
    1454:	d1dd      	bne.n	1412 <smbus_read_bi_info+0x82>
			smbus_err_code = 11;	//bi info: write error
			return;
		}
	}

	packet.data = (uint8_t *)rx_buff_bi;
    1456:	1d3b      	adds	r3, r7, #4
    1458:	4a2e      	ldr	r2, [pc, #184]	; (1514 <smbus_read_bi_info+0x184>)
    145a:	605a      	str	r2, [r3, #4]
	packet.data_length = BI_INFO_BUFFER_SIZE;
    145c:	1d3b      	adds	r3, r7, #4
    145e:	2225      	movs	r2, #37	; 0x25
    1460:	805a      	strh	r2, [r3, #2]

	/* delay, waiting for i2c ready*/
	sys_delay_ms(DELAY_MS);
    1462:	2005      	movs	r0, #5
    1464:	4b2c      	ldr	r3, [pc, #176]	; (1518 <smbus_read_bi_info+0x188>)
    1466:	4798      	blx	r3
	while(sys_delay_ms(0));
    1468:	46c0      	nop			; (mov r8, r8)
    146a:	2000      	movs	r0, #0
    146c:	4b2a      	ldr	r3, [pc, #168]	; (1518 <smbus_read_bi_info+0x188>)
    146e:	4798      	blx	r3
    1470:	1e03      	subs	r3, r0, #0
    1472:	d1fa      	bne.n	146a <smbus_read_bi_info+0xda>

	err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
    1474:	231f      	movs	r3, #31
    1476:	18fc      	adds	r4, r7, r3
    1478:	1d3a      	adds	r2, r7, #4
    147a:	4b23      	ldr	r3, [pc, #140]	; (1508 <smbus_read_bi_info+0x178>)
    147c:	0011      	movs	r1, r2
    147e:	0018      	movs	r0, r3
    1480:	4b26      	ldr	r3, [pc, #152]	; (151c <smbus_read_bi_info+0x18c>)
    1482:	4798      	blx	r3
    1484:	0003      	movs	r3, r0
    1486:	7023      	strb	r3, [r4, #0]
	while(err != STATUS_OK)
    1488:	e01c      	b.n	14c4 <smbus_read_bi_info+0x134>
	{
		err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
    148a:	231f      	movs	r3, #31
    148c:	18fc      	adds	r4, r7, r3
    148e:	1d3a      	adds	r2, r7, #4
    1490:	4b1d      	ldr	r3, [pc, #116]	; (1508 <smbus_read_bi_info+0x178>)
    1492:	0011      	movs	r1, r2
    1494:	0018      	movs	r0, r3
    1496:	4b21      	ldr	r3, [pc, #132]	; (151c <smbus_read_bi_info+0x18c>)
    1498:	4798      	blx	r3
    149a:	0003      	movs	r3, r0
    149c:	7023      	strb	r3, [r4, #0]
		timeout++;
    149e:	2312      	movs	r3, #18
    14a0:	18fb      	adds	r3, r7, r3
    14a2:	881b      	ldrh	r3, [r3, #0]
    14a4:	b29b      	uxth	r3, r3
    14a6:	3301      	adds	r3, #1
    14a8:	b29a      	uxth	r2, r3
    14aa:	2312      	movs	r3, #18
    14ac:	18fb      	adds	r3, r7, r3
    14ae:	801a      	strh	r2, [r3, #0]
		if(timeout == TIMEOUT)
    14b0:	2312      	movs	r3, #18
    14b2:	18fb      	adds	r3, r7, r3
    14b4:	881b      	ldrh	r3, [r3, #0]
    14b6:	b29b      	uxth	r3, r3
    14b8:	2b64      	cmp	r3, #100	; 0x64
    14ba:	d103      	bne.n	14c4 <smbus_read_bi_info+0x134>
		{
			smbus_err_code = 22;	//bi info: read error
    14bc:	4b14      	ldr	r3, [pc, #80]	; (1510 <smbus_read_bi_info+0x180>)
    14be:	2216      	movs	r2, #22
    14c0:	701a      	strb	r2, [r3, #0]
			return;
    14c2:	e018      	b.n	14f6 <smbus_read_bi_info+0x166>
	/* delay, waiting for i2c ready*/
	sys_delay_ms(DELAY_MS);
	while(sys_delay_ms(0));

	err = i2c_master_read_packet_wait(&i2c_master_instance,&packet);
	while(err != STATUS_OK)
    14c4:	231f      	movs	r3, #31
    14c6:	18fb      	adds	r3, r7, r3
    14c8:	781b      	ldrb	r3, [r3, #0]
    14ca:	2b00      	cmp	r3, #0
    14cc:	d1dd      	bne.n	148a <smbus_read_bi_info+0xfa>
		{
			smbus_err_code = 22;	//bi info: read error
			return;
		}
	}
	check_sum = check_sum_generator((uint8_t *)rx_buff_bi,(BI_INFO_BUFFER_SIZE-1));
    14ce:	231e      	movs	r3, #30
    14d0:	18fc      	adds	r4, r7, r3
    14d2:	4b10      	ldr	r3, [pc, #64]	; (1514 <smbus_read_bi_info+0x184>)
    14d4:	2124      	movs	r1, #36	; 0x24
    14d6:	0018      	movs	r0, r3
    14d8:	4b0a      	ldr	r3, [pc, #40]	; (1504 <smbus_read_bi_info+0x174>)
    14da:	4798      	blx	r3
    14dc:	0003      	movs	r3, r0
    14de:	7023      	strb	r3, [r4, #0]
	if(check_sum != rx_buff_bi[BI_INFO_BUFFER_SIZE-1])
    14e0:	4b0c      	ldr	r3, [pc, #48]	; (1514 <smbus_read_bi_info+0x184>)
    14e2:	2224      	movs	r2, #36	; 0x24
    14e4:	5c9b      	ldrb	r3, [r3, r2]
    14e6:	221e      	movs	r2, #30
    14e8:	18ba      	adds	r2, r7, r2
    14ea:	7812      	ldrb	r2, [r2, #0]
    14ec:	429a      	cmp	r2, r3
    14ee:	d002      	beq.n	14f6 <smbus_read_bi_info+0x166>
	{
		smbus_err_code = 23;
    14f0:	4b07      	ldr	r3, [pc, #28]	; (1510 <smbus_read_bi_info+0x180>)
    14f2:	2217      	movs	r2, #23
    14f4:	701a      	strb	r2, [r3, #0]
	}
}
    14f6:	46bd      	mov	sp, r7
    14f8:	b009      	add	sp, #36	; 0x24
    14fa:	bd90      	pop	{r4, r7, pc}
    14fc:	0000fc98 	.word	0x0000fc98
    1500:	0000fc43 	.word	0x0000fc43
    1504:	00001005 	.word	0x00001005
    1508:	20002db4 	.word	0x20002db4
    150c:	00000885 	.word	0x00000885
    1510:	20000064 	.word	0x20000064
    1514:	20000aa4 	.word	0x20000aa4
    1518:	0000f731 	.word	0x0000f731
    151c:	00000721 	.word	0x00000721

00001520 <smbus_log_package>:
/*
 * aging log package function
 * write the aging log coming from oob to associated sram location
 */
static void smbus_log_package(void)
{
    1520:	b580      	push	{r7, lr}
    1522:	b082      	sub	sp, #8
    1524:	af00      	add	r7, sp, #0
	uint8_t i = 0;
    1526:	1dfb      	adds	r3, r7, #7
    1528:	2200      	movs	r2, #0
    152a:	701a      	strb	r2, [r3, #0]
	uint8_t j = 0;
    152c:	1dbb      	adds	r3, r7, #6
    152e:	2200      	movs	r2, #0
    1530:	701a      	strb	r2, [r3, #0]
	uint8_t *p_ssd_log;
	/* select port array and pingpang operation */
	if(smbus_log_pingpang == 0 || smbus_log_pingpang == 2)
    1532:	4baf      	ldr	r3, [pc, #700]	; (17f0 <smbus_log_package+0x2d0>)
    1534:	781b      	ldrb	r3, [r3, #0]
    1536:	2b00      	cmp	r3, #0
    1538:	d003      	beq.n	1542 <smbus_log_package+0x22>
    153a:	4bad      	ldr	r3, [pc, #692]	; (17f0 <smbus_log_package+0x2d0>)
    153c:	781b      	ldrb	r3, [r3, #0]
    153e:	2b02      	cmp	r3, #2
    1540:	d109      	bne.n	1556 <smbus_log_package+0x36>
	{
		p_ssd_log = (uint8_t *)(ssd_port_log_pingpang0+smbus_port_polling*ETH_SSD_LOG_LENGTH);
    1542:	4bac      	ldr	r3, [pc, #688]	; (17f4 <smbus_log_package+0x2d4>)
    1544:	781b      	ldrb	r3, [r3, #0]
    1546:	001a      	movs	r2, r3
    1548:	2396      	movs	r3, #150	; 0x96
    154a:	4353      	muls	r3, r2
    154c:	001a      	movs	r2, r3
    154e:	4baa      	ldr	r3, [pc, #680]	; (17f8 <smbus_log_package+0x2d8>)
    1550:	18d3      	adds	r3, r2, r3
    1552:	603b      	str	r3, [r7, #0]
    1554:	e008      	b.n	1568 <smbus_log_package+0x48>
	}
	else
	{
		p_ssd_log = (uint8_t *)(ssd_port_log_pingpang1+smbus_port_polling*ETH_SSD_LOG_LENGTH);
    1556:	4ba7      	ldr	r3, [pc, #668]	; (17f4 <smbus_log_package+0x2d4>)
    1558:	781b      	ldrb	r3, [r3, #0]
    155a:	001a      	movs	r2, r3
    155c:	2396      	movs	r3, #150	; 0x96
    155e:	4353      	muls	r3, r2
    1560:	001a      	movs	r2, r3
    1562:	4ba6      	ldr	r3, [pc, #664]	; (17fc <smbus_log_package+0x2dc>)
    1564:	18d3      	adds	r3, r2, r3
    1566:	603b      	str	r3, [r7, #0]
	}
	/* error code*/
	*(p_ssd_log+1) = smbus_err_code;
    1568:	683b      	ldr	r3, [r7, #0]
    156a:	3301      	adds	r3, #1
    156c:	4aa4      	ldr	r2, [pc, #656]	; (1800 <smbus_log_package+0x2e0>)
    156e:	7812      	ldrb	r2, [r2, #0]
    1570:	701a      	strb	r2, [r3, #0]
	/* Basic Info */
	/* serial number */
	for(i = 16,j = HEAD_LEN+TRACE_LEN;i < (16+SN_LEN);i++,j++)
    1572:	1dfb      	adds	r3, r7, #7
    1574:	2210      	movs	r2, #16
    1576:	701a      	strb	r2, [r3, #0]
    1578:	1dbb      	adds	r3, r7, #6
    157a:	2208      	movs	r2, #8
    157c:	701a      	strb	r2, [r3, #0]
    157e:	e012      	b.n	15a6 <smbus_log_package+0x86>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
    1580:	1dfb      	adds	r3, r7, #7
    1582:	781b      	ldrb	r3, [r3, #0]
    1584:	683a      	ldr	r2, [r7, #0]
    1586:	18d3      	adds	r3, r2, r3
    1588:	1dba      	adds	r2, r7, #6
    158a:	7812      	ldrb	r2, [r2, #0]
    158c:	499d      	ldr	r1, [pc, #628]	; (1804 <smbus_log_package+0x2e4>)
    158e:	5c8a      	ldrb	r2, [r1, r2]
    1590:	701a      	strb	r2, [r3, #0]
	}
	/* error code*/
	*(p_ssd_log+1) = smbus_err_code;
	/* Basic Info */
	/* serial number */
	for(i = 16,j = HEAD_LEN+TRACE_LEN;i < (16+SN_LEN);i++,j++)
    1592:	1dfb      	adds	r3, r7, #7
    1594:	781a      	ldrb	r2, [r3, #0]
    1596:	1dfb      	adds	r3, r7, #7
    1598:	3201      	adds	r2, #1
    159a:	701a      	strb	r2, [r3, #0]
    159c:	1dbb      	adds	r3, r7, #6
    159e:	781a      	ldrb	r2, [r3, #0]
    15a0:	1dbb      	adds	r3, r7, #6
    15a2:	3201      	adds	r2, #1
    15a4:	701a      	strb	r2, [r3, #0]
    15a6:	1dfb      	adds	r3, r7, #7
    15a8:	781b      	ldrb	r3, [r3, #0]
    15aa:	2b23      	cmp	r3, #35	; 0x23
    15ac:	d9e8      	bls.n	1580 <smbus_log_package+0x60>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* model number */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN);i++,j++)
    15ae:	1dbb      	adds	r3, r7, #6
    15b0:	1dba      	adds	r2, r7, #6
    15b2:	7812      	ldrb	r2, [r2, #0]
    15b4:	3204      	adds	r2, #4
    15b6:	701a      	strb	r2, [r3, #0]
    15b8:	e012      	b.n	15e0 <smbus_log_package+0xc0>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
    15ba:	1dfb      	adds	r3, r7, #7
    15bc:	781b      	ldrb	r3, [r3, #0]
    15be:	683a      	ldr	r2, [r7, #0]
    15c0:	18d3      	adds	r3, r2, r3
    15c2:	1dba      	adds	r2, r7, #6
    15c4:	7812      	ldrb	r2, [r2, #0]
    15c6:	498f      	ldr	r1, [pc, #572]	; (1804 <smbus_log_package+0x2e4>)
    15c8:	5c8a      	ldrb	r2, [r1, r2]
    15ca:	701a      	strb	r2, [r3, #0]
	for(i = 16,j = HEAD_LEN+TRACE_LEN;i < (16+SN_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* model number */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN);i++,j++)
    15cc:	1dfb      	adds	r3, r7, #7
    15ce:	781a      	ldrb	r2, [r3, #0]
    15d0:	1dfb      	adds	r3, r7, #7
    15d2:	3201      	adds	r2, #1
    15d4:	701a      	strb	r2, [r3, #0]
    15d6:	1dbb      	adds	r3, r7, #6
    15d8:	781a      	ldrb	r2, [r3, #0]
    15da:	1dbb      	adds	r3, r7, #6
    15dc:	3201      	adds	r2, #1
    15de:	701a      	strb	r2, [r3, #0]
    15e0:	1dfb      	adds	r3, r7, #7
    15e2:	781b      	ldrb	r3, [r3, #0]
    15e4:	2b4b      	cmp	r3, #75	; 0x4b
    15e6:	d9e8      	bls.n	15ba <smbus_log_package+0x9a>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* oob firmware version */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN);i++,j++)
    15e8:	1dbb      	adds	r3, r7, #6
    15ea:	1dba      	adds	r2, r7, #6
    15ec:	7812      	ldrb	r2, [r2, #0]
    15ee:	3204      	adds	r2, #4
    15f0:	701a      	strb	r2, [r3, #0]
    15f2:	e012      	b.n	161a <smbus_log_package+0xfa>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
    15f4:	1dfb      	adds	r3, r7, #7
    15f6:	781b      	ldrb	r3, [r3, #0]
    15f8:	683a      	ldr	r2, [r7, #0]
    15fa:	18d3      	adds	r3, r2, r3
    15fc:	1dba      	adds	r2, r7, #6
    15fe:	7812      	ldrb	r2, [r2, #0]
    1600:	4980      	ldr	r1, [pc, #512]	; (1804 <smbus_log_package+0x2e4>)
    1602:	5c8a      	ldrb	r2, [r1, r2]
    1604:	701a      	strb	r2, [r3, #0]
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* oob firmware version */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN);i++,j++)
    1606:	1dfb      	adds	r3, r7, #7
    1608:	781a      	ldrb	r2, [r3, #0]
    160a:	1dfb      	adds	r3, r7, #7
    160c:	3201      	adds	r2, #1
    160e:	701a      	strb	r2, [r3, #0]
    1610:	1dbb      	adds	r3, r7, #6
    1612:	781a      	ldrb	r2, [r3, #0]
    1614:	1dbb      	adds	r3, r7, #6
    1616:	3201      	adds	r2, #1
    1618:	701a      	strb	r2, [r3, #0]
    161a:	1dfb      	adds	r3, r7, #7
    161c:	781b      	ldrb	r3, [r3, #0]
    161e:	2b57      	cmp	r3, #87	; 0x57
    1620:	d9e8      	bls.n	15f4 <smbus_log_package+0xd4>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* BI firmware version */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN);i++,j++)
    1622:	1dbb      	adds	r3, r7, #6
    1624:	1dba      	adds	r2, r7, #6
    1626:	7812      	ldrb	r2, [r2, #0]
    1628:	3204      	adds	r2, #4
    162a:	701a      	strb	r2, [r3, #0]
    162c:	e012      	b.n	1654 <smbus_log_package+0x134>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
    162e:	1dfb      	adds	r3, r7, #7
    1630:	781b      	ldrb	r3, [r3, #0]
    1632:	683a      	ldr	r2, [r7, #0]
    1634:	18d3      	adds	r3, r2, r3
    1636:	1dba      	adds	r2, r7, #6
    1638:	7812      	ldrb	r2, [r2, #0]
    163a:	4972      	ldr	r1, [pc, #456]	; (1804 <smbus_log_package+0x2e4>)
    163c:	5c8a      	ldrb	r2, [r1, r2]
    163e:	701a      	strb	r2, [r3, #0]
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* BI firmware version */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN);i++,j++)
    1640:	1dfb      	adds	r3, r7, #7
    1642:	781a      	ldrb	r2, [r3, #0]
    1644:	1dfb      	adds	r3, r7, #7
    1646:	3201      	adds	r2, #1
    1648:	701a      	strb	r2, [r3, #0]
    164a:	1dbb      	adds	r3, r7, #6
    164c:	781a      	ldrb	r2, [r3, #0]
    164e:	1dbb      	adds	r3, r7, #6
    1650:	3201      	adds	r2, #1
    1652:	701a      	strb	r2, [r3, #0]
    1654:	1dfb      	adds	r3, r7, #7
    1656:	781b      	ldrb	r3, [r3, #0]
    1658:	2b63      	cmp	r3, #99	; 0x63
    165a:	d9e8      	bls.n	162e <smbus_log_package+0x10e>
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* OOB info */
	/* temperature */
	for(j=HEAD_LEN+TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN);i++,j++)
    165c:	1dbb      	adds	r3, r7, #6
    165e:	2208      	movs	r2, #8
    1660:	701a      	strb	r2, [r3, #0]
    1662:	e012      	b.n	168a <smbus_log_package+0x16a>
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
    1664:	1dfb      	adds	r3, r7, #7
    1666:	781b      	ldrb	r3, [r3, #0]
    1668:	683a      	ldr	r2, [r7, #0]
    166a:	18d3      	adds	r3, r2, r3
    166c:	1dba      	adds	r2, r7, #6
    166e:	7812      	ldrb	r2, [r2, #0]
    1670:	4965      	ldr	r1, [pc, #404]	; (1808 <smbus_log_package+0x2e8>)
    1672:	5c8a      	ldrb	r2, [r1, r2]
    1674:	701a      	strb	r2, [r3, #0]
	{
		*(p_ssd_log+i) = rx_buff_basic[j];
	}
	/* OOB info */
	/* temperature */
	for(j=HEAD_LEN+TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN);i++,j++)
    1676:	1dfb      	adds	r3, r7, #7
    1678:	781a      	ldrb	r2, [r3, #0]
    167a:	1dfb      	adds	r3, r7, #7
    167c:	3201      	adds	r2, #1
    167e:	701a      	strb	r2, [r3, #0]
    1680:	1dbb      	adds	r3, r7, #6
    1682:	781a      	ldrb	r2, [r3, #0]
    1684:	1dbb      	adds	r3, r7, #6
    1686:	3201      	adds	r2, #1
    1688:	701a      	strb	r2, [r3, #0]
    168a:	1dfb      	adds	r3, r7, #7
    168c:	781b      	ldrb	r3, [r3, #0]
    168e:	2b6d      	cmp	r3, #109	; 0x6d
    1690:	d9e8      	bls.n	1664 <smbus_log_package+0x144>
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
	}
	/* oob information*/
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN);i++,j++)
    1692:	1dbb      	adds	r3, r7, #6
    1694:	1dba      	adds	r2, r7, #6
    1696:	7812      	ldrb	r2, [r2, #0]
    1698:	3204      	adds	r2, #4
    169a:	701a      	strb	r2, [r3, #0]
    169c:	e012      	b.n	16c4 <smbus_log_package+0x1a4>
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
    169e:	1dfb      	adds	r3, r7, #7
    16a0:	781b      	ldrb	r3, [r3, #0]
    16a2:	683a      	ldr	r2, [r7, #0]
    16a4:	18d3      	adds	r3, r2, r3
    16a6:	1dba      	adds	r2, r7, #6
    16a8:	7812      	ldrb	r2, [r2, #0]
    16aa:	4957      	ldr	r1, [pc, #348]	; (1808 <smbus_log_package+0x2e8>)
    16ac:	5c8a      	ldrb	r2, [r1, r2]
    16ae:	701a      	strb	r2, [r3, #0]
	for(j=HEAD_LEN+TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
	}
	/* oob information*/
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN);i++,j++)
    16b0:	1dfb      	adds	r3, r7, #7
    16b2:	781a      	ldrb	r2, [r3, #0]
    16b4:	1dfb      	adds	r3, r7, #7
    16b6:	3201      	adds	r2, #1
    16b8:	701a      	strb	r2, [r3, #0]
    16ba:	1dbb      	adds	r3, r7, #6
    16bc:	781a      	ldrb	r2, [r3, #0]
    16be:	1dbb      	adds	r3, r7, #6
    16c0:	3201      	adds	r2, #1
    16c2:	701a      	strb	r2, [r3, #0]
    16c4:	1dfb      	adds	r3, r7, #7
    16c6:	781b      	ldrb	r3, [r3, #0]
    16c8:	b25b      	sxtb	r3, r3
    16ca:	2b00      	cmp	r3, #0
    16cc:	dae7      	bge.n	169e <smbus_log_package+0x17e>
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
	}
	/* power good */
	for(j=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN);i++,j++)
    16ce:	1dbb      	adds	r3, r7, #6
    16d0:	2204      	movs	r2, #4
    16d2:	701a      	strb	r2, [r3, #0]
    16d4:	e012      	b.n	16fc <smbus_log_package+0x1dc>
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
    16d6:	1dfb      	adds	r3, r7, #7
    16d8:	781b      	ldrb	r3, [r3, #0]
    16da:	683a      	ldr	r2, [r7, #0]
    16dc:	18d3      	adds	r3, r2, r3
    16de:	1dba      	adds	r2, r7, #6
    16e0:	7812      	ldrb	r2, [r2, #0]
    16e2:	4949      	ldr	r1, [pc, #292]	; (1808 <smbus_log_package+0x2e8>)
    16e4:	5c8a      	ldrb	r2, [r1, r2]
    16e6:	701a      	strb	r2, [r3, #0]
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
	}
	/* power good */
	for(j=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN);i++,j++)
    16e8:	1dfb      	adds	r3, r7, #7
    16ea:	781a      	ldrb	r2, [r3, #0]
    16ec:	1dfb      	adds	r3, r7, #7
    16ee:	3201      	adds	r2, #1
    16f0:	701a      	strb	r2, [r3, #0]
    16f2:	1dbb      	adds	r3, r7, #6
    16f4:	781a      	ldrb	r2, [r3, #0]
    16f6:	1dbb      	adds	r3, r7, #6
    16f8:	3201      	adds	r2, #1
    16fa:	701a      	strb	r2, [r3, #0]
    16fc:	1dfb      	adds	r3, r7, #7
    16fe:	781b      	ldrb	r3, [r3, #0]
    1700:	2b80      	cmp	r3, #128	; 0x80
    1702:	d9e8      	bls.n	16d6 <smbus_log_package+0x1b6>
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
	}
	/* BI Info */
	/* BI loop, 2 bytes*/
	for(j = HEAD_LEN+TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN);i++,j++)
    1704:	1dbb      	adds	r3, r7, #6
    1706:	2208      	movs	r2, #8
    1708:	701a      	strb	r2, [r3, #0]
    170a:	e012      	b.n	1732 <smbus_log_package+0x212>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
    170c:	1dfb      	adds	r3, r7, #7
    170e:	781b      	ldrb	r3, [r3, #0]
    1710:	683a      	ldr	r2, [r7, #0]
    1712:	18d3      	adds	r3, r2, r3
    1714:	1dba      	adds	r2, r7, #6
    1716:	7812      	ldrb	r2, [r2, #0]
    1718:	493c      	ldr	r1, [pc, #240]	; (180c <smbus_log_package+0x2ec>)
    171a:	5c8a      	ldrb	r2, [r1, r2]
    171c:	701a      	strb	r2, [r3, #0]
	{
		*(p_ssd_log+i) = rx_buff_oob[j];
	}
	/* BI Info */
	/* BI loop, 2 bytes*/
	for(j = HEAD_LEN+TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN);i++,j++)
    171e:	1dfb      	adds	r3, r7, #7
    1720:	781a      	ldrb	r2, [r3, #0]
    1722:	1dfb      	adds	r3, r7, #7
    1724:	3201      	adds	r2, #1
    1726:	701a      	strb	r2, [r3, #0]
    1728:	1dbb      	adds	r3, r7, #6
    172a:	781a      	ldrb	r2, [r3, #0]
    172c:	1dbb      	adds	r3, r7, #6
    172e:	3201      	adds	r2, #1
    1730:	701a      	strb	r2, [r3, #0]
    1732:	1dfb      	adds	r3, r7, #7
    1734:	781b      	ldrb	r3, [r3, #0]
    1736:	2b82      	cmp	r3, #130	; 0x82
    1738:	d9e8      	bls.n	170c <smbus_log_package+0x1ec>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
	}
	/* BI Error */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN);i++,j++)
    173a:	1dbb      	adds	r3, r7, #6
    173c:	1dba      	adds	r2, r7, #6
    173e:	7812      	ldrb	r2, [r2, #0]
    1740:	3204      	adds	r2, #4
    1742:	701a      	strb	r2, [r3, #0]
    1744:	e012      	b.n	176c <smbus_log_package+0x24c>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
    1746:	1dfb      	adds	r3, r7, #7
    1748:	781b      	ldrb	r3, [r3, #0]
    174a:	683a      	ldr	r2, [r7, #0]
    174c:	18d3      	adds	r3, r2, r3
    174e:	1dba      	adds	r2, r7, #6
    1750:	7812      	ldrb	r2, [r2, #0]
    1752:	492e      	ldr	r1, [pc, #184]	; (180c <smbus_log_package+0x2ec>)
    1754:	5c8a      	ldrb	r2, [r1, r2]
    1756:	701a      	strb	r2, [r3, #0]
	for(j = HEAD_LEN+TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
	}
	/* BI Error */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN);i++,j++)
    1758:	1dfb      	adds	r3, r7, #7
    175a:	781a      	ldrb	r2, [r3, #0]
    175c:	1dfb      	adds	r3, r7, #7
    175e:	3201      	adds	r2, #1
    1760:	701a      	strb	r2, [r3, #0]
    1762:	1dbb      	adds	r3, r7, #6
    1764:	781a      	ldrb	r2, [r3, #0]
    1766:	1dbb      	adds	r3, r7, #6
    1768:	3201      	adds	r2, #1
    176a:	701a      	strb	r2, [r3, #0]
    176c:	1dfb      	adds	r3, r7, #7
    176e:	781b      	ldrb	r3, [r3, #0]
    1770:	2b86      	cmp	r3, #134	; 0x86
    1772:	d9e8      	bls.n	1746 <smbus_log_package+0x226>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
	}
	/* BI log */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN+BI_LOG_LEN);i++,j++)
    1774:	1dbb      	adds	r3, r7, #6
    1776:	1dba      	adds	r2, r7, #6
    1778:	7812      	ldrb	r2, [r2, #0]
    177a:	3204      	adds	r2, #4
    177c:	701a      	strb	r2, [r3, #0]
    177e:	e012      	b.n	17a6 <smbus_log_package+0x286>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
    1780:	1dfb      	adds	r3, r7, #7
    1782:	781b      	ldrb	r3, [r3, #0]
    1784:	683a      	ldr	r2, [r7, #0]
    1786:	18d3      	adds	r3, r2, r3
    1788:	1dba      	adds	r2, r7, #6
    178a:	7812      	ldrb	r2, [r2, #0]
    178c:	491f      	ldr	r1, [pc, #124]	; (180c <smbus_log_package+0x2ec>)
    178e:	5c8a      	ldrb	r2, [r1, r2]
    1790:	701a      	strb	r2, [r3, #0]
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
	}
	/* BI log */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN+BI_LOG_LEN);i++,j++)
    1792:	1dfb      	adds	r3, r7, #7
    1794:	781a      	ldrb	r2, [r3, #0]
    1796:	1dfb      	adds	r3, r7, #7
    1798:	3201      	adds	r2, #1
    179a:	701a      	strb	r2, [r3, #0]
    179c:	1dbb      	adds	r3, r7, #6
    179e:	781a      	ldrb	r2, [r3, #0]
    17a0:	1dbb      	adds	r3, r7, #6
    17a2:	3201      	adds	r2, #1
    17a4:	701a      	strb	r2, [r3, #0]
    17a6:	1dfb      	adds	r3, r7, #7
    17a8:	781b      	ldrb	r3, [r3, #0]
    17aa:	2b8c      	cmp	r3, #140	; 0x8c
    17ac:	d9e8      	bls.n	1780 <smbus_log_package+0x260>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
	}
	/* BI elapsed */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN+BI_LOG_LEN+BI_ELA_LEN);i++,j++)
    17ae:	1dbb      	adds	r3, r7, #6
    17b0:	1dba      	adds	r2, r7, #6
    17b2:	7812      	ldrb	r2, [r2, #0]
    17b4:	3204      	adds	r2, #4
    17b6:	701a      	strb	r2, [r3, #0]
    17b8:	e012      	b.n	17e0 <smbus_log_package+0x2c0>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
    17ba:	1dfb      	adds	r3, r7, #7
    17bc:	781b      	ldrb	r3, [r3, #0]
    17be:	683a      	ldr	r2, [r7, #0]
    17c0:	18d3      	adds	r3, r2, r3
    17c2:	1dba      	adds	r2, r7, #6
    17c4:	7812      	ldrb	r2, [r2, #0]
    17c6:	4911      	ldr	r1, [pc, #68]	; (180c <smbus_log_package+0x2ec>)
    17c8:	5c8a      	ldrb	r2, [r1, r2]
    17ca:	701a      	strb	r2, [r3, #0]
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN+BI_LOG_LEN);i++,j++)
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
	}
	/* BI elapsed */
	for(j+=TRACE_LEN;i < (16+SN_LEN+MN_LEN+OOB_FW_LEN+BI_FW_LEN+TEM_LEN+OOB_INFO_LEN+PG_LEN+BI_LOOP_LEN+BI_ERR_LEN+BI_LOG_LEN+BI_ELA_LEN);i++,j++)
    17cc:	1dfb      	adds	r3, r7, #7
    17ce:	781a      	ldrb	r2, [r3, #0]
    17d0:	1dfb      	adds	r3, r7, #7
    17d2:	3201      	adds	r2, #1
    17d4:	701a      	strb	r2, [r3, #0]
    17d6:	1dbb      	adds	r3, r7, #6
    17d8:	781a      	ldrb	r2, [r3, #0]
    17da:	1dbb      	adds	r3, r7, #6
    17dc:	3201      	adds	r2, #1
    17de:	701a      	strb	r2, [r3, #0]
    17e0:	1dfb      	adds	r3, r7, #7
    17e2:	781b      	ldrb	r3, [r3, #0]
    17e4:	2b90      	cmp	r3, #144	; 0x90
    17e6:	d9e8      	bls.n	17ba <smbus_log_package+0x29a>
	{
		*(p_ssd_log+i) = rx_buff_bi[j];
	}
}
    17e8:	46c0      	nop			; (mov r8, r8)
    17ea:	46bd      	mov	sp, r7
    17ec:	b002      	add	sp, #8
    17ee:	bd80      	pop	{r7, pc}
    17f0:	20000066 	.word	0x20000066
    17f4:	20000065 	.word	0x20000065
    17f8:	20000068 	.word	0x20000068
    17fc:	20000518 	.word	0x20000518
    1800:	20000064 	.word	0x20000064
    1804:	20000a08 	.word	0x20000a08
    1808:	20000a74 	.word	0x20000a74
    180c:	20000aa4 	.word	0x20000aa4

00001810 <smbus_read_all_info>:
/*
 * read all aging log function, including basic, oob and bi information
 * get all 8 ports info at once, with pingpang operation
 */
void smbus_read_all_info(void)
{
    1810:	b580      	push	{r7, lr}
    1812:	af00      	add	r7, sp, #0
	for(smbus_port_polling = 0;smbus_port_polling < 8;smbus_port_polling++)
    1814:	4b1b      	ldr	r3, [pc, #108]	; (1884 <smbus_read_all_info+0x74>)
    1816:	2200      	movs	r2, #0
    1818:	701a      	strb	r2, [r3, #0]
    181a:	e01c      	b.n	1856 <smbus_read_all_info+0x46>
	{
		smbus_err_code = 0;
    181c:	4b1a      	ldr	r3, [pc, #104]	; (1888 <smbus_read_all_info+0x78>)
    181e:	2200      	movs	r2, #0
    1820:	701a      	strb	r2, [r3, #0]
		smbus_read_basic_info();
    1822:	4b1a      	ldr	r3, [pc, #104]	; (188c <smbus_read_all_info+0x7c>)
    1824:	4798      	blx	r3
		if(smbus_err_code)
    1826:	4b18      	ldr	r3, [pc, #96]	; (1888 <smbus_read_all_info+0x78>)
    1828:	781b      	ldrb	r3, [r3, #0]
    182a:	2b00      	cmp	r3, #0
    182c:	d108      	bne.n	1840 <smbus_read_all_info+0x30>
		{
			goto package;
		}
		smbus_read_oob_info();
    182e:	4b18      	ldr	r3, [pc, #96]	; (1890 <smbus_read_all_info+0x80>)
    1830:	4798      	blx	r3
		if(smbus_err_code)
    1832:	4b15      	ldr	r3, [pc, #84]	; (1888 <smbus_read_all_info+0x78>)
    1834:	781b      	ldrb	r3, [r3, #0]
    1836:	2b00      	cmp	r3, #0
    1838:	d104      	bne.n	1844 <smbus_read_all_info+0x34>
		{
			goto package;
		}
		smbus_read_bi_info();
    183a:	4b16      	ldr	r3, [pc, #88]	; (1894 <smbus_read_all_info+0x84>)
    183c:	4798      	blx	r3
    183e:	e002      	b.n	1846 <smbus_read_all_info+0x36>
	{
		smbus_err_code = 0;
		smbus_read_basic_info();
		if(smbus_err_code)
		{
			goto package;
    1840:	46c0      	nop			; (mov r8, r8)
    1842:	e000      	b.n	1846 <smbus_read_all_info+0x36>
		}
		smbus_read_oob_info();
		if(smbus_err_code)
		{
			goto package;
    1844:	46c0      	nop			; (mov r8, r8)
		if(smbus_err_code)
		{
			goto package;
		}
		package:
		smbus_log_package();
    1846:	4b14      	ldr	r3, [pc, #80]	; (1898 <smbus_read_all_info+0x88>)
    1848:	4798      	blx	r3
 * read all aging log function, including basic, oob and bi information
 * get all 8 ports info at once, with pingpang operation
 */
void smbus_read_all_info(void)
{
	for(smbus_port_polling = 0;smbus_port_polling < 8;smbus_port_polling++)
    184a:	4b0e      	ldr	r3, [pc, #56]	; (1884 <smbus_read_all_info+0x74>)
    184c:	781b      	ldrb	r3, [r3, #0]
    184e:	3301      	adds	r3, #1
    1850:	b2da      	uxtb	r2, r3
    1852:	4b0c      	ldr	r3, [pc, #48]	; (1884 <smbus_read_all_info+0x74>)
    1854:	701a      	strb	r2, [r3, #0]
    1856:	4b0b      	ldr	r3, [pc, #44]	; (1884 <smbus_read_all_info+0x74>)
    1858:	781b      	ldrb	r3, [r3, #0]
    185a:	2b07      	cmp	r3, #7
    185c:	d9de      	bls.n	181c <smbus_read_all_info+0xc>
		}
		package:
		smbus_log_package();
	}
	/* update pingpang flag */
	if(smbus_log_pingpang == 0 || smbus_log_pingpang == 2)
    185e:	4b0f      	ldr	r3, [pc, #60]	; (189c <smbus_read_all_info+0x8c>)
    1860:	781b      	ldrb	r3, [r3, #0]
    1862:	2b00      	cmp	r3, #0
    1864:	d003      	beq.n	186e <smbus_read_all_info+0x5e>
    1866:	4b0d      	ldr	r3, [pc, #52]	; (189c <smbus_read_all_info+0x8c>)
    1868:	781b      	ldrb	r3, [r3, #0]
    186a:	2b02      	cmp	r3, #2
    186c:	d103      	bne.n	1876 <smbus_read_all_info+0x66>
	{
		smbus_log_pingpang = 1;
    186e:	4b0b      	ldr	r3, [pc, #44]	; (189c <smbus_read_all_info+0x8c>)
    1870:	2201      	movs	r2, #1
    1872:	701a      	strb	r2, [r3, #0]
    1874:	e002      	b.n	187c <smbus_read_all_info+0x6c>
	}
	else
	{
		smbus_log_pingpang = 2;
    1876:	4b09      	ldr	r3, [pc, #36]	; (189c <smbus_read_all_info+0x8c>)
    1878:	2202      	movs	r2, #2
    187a:	701a      	strb	r2, [r3, #0]
	}
}
    187c:	46c0      	nop			; (mov r8, r8)
    187e:	46bd      	mov	sp, r7
    1880:	bd80      	pop	{r7, pc}
    1882:	46c0      	nop			; (mov r8, r8)
    1884:	20000065 	.word	0x20000065
    1888:	20000064 	.word	0x20000064
    188c:	00001071 	.word	0x00001071
    1890:	00001201 	.word	0x00001201
    1894:	00001391 	.word	0x00001391
    1898:	00001521 	.word	0x00001521
    189c:	20000066 	.word	0x20000066

000018a0 <delay_cycles>:
 *
 * \param n  Number of cycles to delay
 */
static inline void delay_cycles(
		const uint32_t n)
{
    18a0:	b580      	push	{r7, lr}
    18a2:	b082      	sub	sp, #8
    18a4:	af00      	add	r7, sp, #0
    18a6:	6078      	str	r0, [r7, #4]
	if (n > 0) {
    18a8:	687b      	ldr	r3, [r7, #4]
    18aa:	2b00      	cmp	r3, #0
    18ac:	d00c      	beq.n	18c8 <delay_cycles+0x28>
		SysTick->LOAD = n;
    18ae:	4b08      	ldr	r3, [pc, #32]	; (18d0 <delay_cycles+0x30>)
    18b0:	687a      	ldr	r2, [r7, #4]
    18b2:	605a      	str	r2, [r3, #4]
		SysTick->VAL = 0;
    18b4:	4b06      	ldr	r3, [pc, #24]	; (18d0 <delay_cycles+0x30>)
    18b6:	2200      	movs	r2, #0
    18b8:	609a      	str	r2, [r3, #8]

		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
    18ba:	46c0      	nop			; (mov r8, r8)
    18bc:	4b04      	ldr	r3, [pc, #16]	; (18d0 <delay_cycles+0x30>)
    18be:	681a      	ldr	r2, [r3, #0]
    18c0:	2380      	movs	r3, #128	; 0x80
    18c2:	025b      	lsls	r3, r3, #9
    18c4:	4013      	ands	r3, r2
    18c6:	d0f9      	beq.n	18bc <delay_cycles+0x1c>
		};
	}
}
    18c8:	46c0      	nop			; (mov r8, r8)
    18ca:	46bd      	mov	sp, r7
    18cc:	b002      	add	sp, #8
    18ce:	bd80      	pop	{r7, pc}
    18d0:	e000e010 	.word	0xe000e010

000018d4 <delay_init>:
 *
 * This must be called during start up to initialize the delay routine with
 * the current used main clock. It must run any time the main CPU clock is changed.
 */
void delay_init(void)
{
    18d4:	b580      	push	{r7, lr}
    18d6:	af00      	add	r7, sp, #0
	cycles_per_ms = system_gclk_gen_get_hz(0);
    18d8:	2000      	movs	r0, #0
    18da:	4b0f      	ldr	r3, [pc, #60]	; (1918 <delay_init+0x44>)
    18dc:	4798      	blx	r3
    18de:	0002      	movs	r2, r0
    18e0:	4b0e      	ldr	r3, [pc, #56]	; (191c <delay_init+0x48>)
    18e2:	601a      	str	r2, [r3, #0]
	cycles_per_ms /= 1000;
    18e4:	4b0d      	ldr	r3, [pc, #52]	; (191c <delay_init+0x48>)
    18e6:	6818      	ldr	r0, [r3, #0]
    18e8:	4b0d      	ldr	r3, [pc, #52]	; (1920 <delay_init+0x4c>)
    18ea:	22fa      	movs	r2, #250	; 0xfa
    18ec:	0091      	lsls	r1, r2, #2
    18ee:	4798      	blx	r3
    18f0:	0003      	movs	r3, r0
    18f2:	001a      	movs	r2, r3
    18f4:	4b09      	ldr	r3, [pc, #36]	; (191c <delay_init+0x48>)
    18f6:	601a      	str	r2, [r3, #0]
	cycles_per_us = cycles_per_ms / 1000;
    18f8:	4b08      	ldr	r3, [pc, #32]	; (191c <delay_init+0x48>)
    18fa:	6818      	ldr	r0, [r3, #0]
    18fc:	4b08      	ldr	r3, [pc, #32]	; (1920 <delay_init+0x4c>)
    18fe:	22fa      	movs	r2, #250	; 0xfa
    1900:	0091      	lsls	r1, r2, #2
    1902:	4798      	blx	r3
    1904:	0003      	movs	r3, r0
    1906:	001a      	movs	r2, r3
    1908:	4b06      	ldr	r3, [pc, #24]	; (1924 <delay_init+0x50>)
    190a:	601a      	str	r2, [r3, #0]

	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
    190c:	4b06      	ldr	r3, [pc, #24]	; (1928 <delay_init+0x54>)
    190e:	2205      	movs	r2, #5
    1910:	601a      	str	r2, [r3, #0]
}
    1912:	46c0      	nop			; (mov r8, r8)
    1914:	46bd      	mov	sp, r7
    1916:	bd80      	pop	{r7, pc}
    1918:	000049d1 	.word	0x000049d1
    191c:	20000000 	.word	0x20000000
    1920:	0000f8ed 	.word	0x0000f8ed
    1924:	20000004 	.word	0x20000004
    1928:	e000e010 	.word	0xe000e010

0000192c <delay_cycles_ms>:
 *
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
    192c:	b580      	push	{r7, lr}
    192e:	b082      	sub	sp, #8
    1930:	af00      	add	r7, sp, #0
    1932:	6078      	str	r0, [r7, #4]
	while (n--) {
    1934:	e004      	b.n	1940 <delay_cycles_ms+0x14>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
    1936:	4b07      	ldr	r3, [pc, #28]	; (1954 <delay_cycles_ms+0x28>)
    1938:	681b      	ldr	r3, [r3, #0]
    193a:	0018      	movs	r0, r3
    193c:	4b06      	ldr	r3, [pc, #24]	; (1958 <delay_cycles_ms+0x2c>)
    193e:	4798      	blx	r3
 * \param n  Number of milliseconds to wait
 */
void delay_cycles_ms(
		uint32_t n)
{
	while (n--) {
    1940:	687b      	ldr	r3, [r7, #4]
    1942:	1e5a      	subs	r2, r3, #1
    1944:	607a      	str	r2, [r7, #4]
    1946:	2b00      	cmp	r3, #0
    1948:	d1f5      	bne.n	1936 <delay_cycles_ms+0xa>
		/* Devide up to blocks of 1ms */
		delay_cycles(cycles_per_ms);
	}
}
    194a:	46c0      	nop			; (mov r8, r8)
    194c:	46bd      	mov	sp, r7
    194e:	b002      	add	sp, #8
    1950:	bd80      	pop	{r7, pc}
    1952:	46c0      	nop			; (mov r8, r8)
    1954:	20000000 	.word	0x20000000
    1958:	000018a1 	.word	0x000018a1

0000195c <cpu_irq_enter_critical>:
 */
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
    195c:	b580      	push	{r7, lr}
    195e:	b082      	sub	sp, #8
    1960:	af00      	add	r7, sp, #0
	if (cpu_irq_critical_section_counter == 0) {
    1962:	4b10      	ldr	r3, [pc, #64]	; (19a4 <cpu_irq_enter_critical+0x48>)
    1964:	681b      	ldr	r3, [r3, #0]
    1966:	2b00      	cmp	r3, #0
    1968:	d112      	bne.n	1990 <cpu_irq_enter_critical+0x34>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    196a:	f3ef 8310 	mrs	r3, PRIMASK
    196e:	607b      	str	r3, [r7, #4]
  return(result);
    1970:	687b      	ldr	r3, [r7, #4]
		if (cpu_irq_is_enabled()) {
    1972:	2b00      	cmp	r3, #0
    1974:	d109      	bne.n	198a <cpu_irq_enter_critical+0x2e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
    1976:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
    1978:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    197c:	4b0a      	ldr	r3, [pc, #40]	; (19a8 <cpu_irq_enter_critical+0x4c>)
    197e:	2200      	movs	r2, #0
    1980:	701a      	strb	r2, [r3, #0]
			cpu_irq_prev_interrupt_state = true;
    1982:	4b0a      	ldr	r3, [pc, #40]	; (19ac <cpu_irq_enter_critical+0x50>)
    1984:	2201      	movs	r2, #1
    1986:	701a      	strb	r2, [r3, #0]
    1988:	e002      	b.n	1990 <cpu_irq_enter_critical+0x34>
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    198a:	4b08      	ldr	r3, [pc, #32]	; (19ac <cpu_irq_enter_critical+0x50>)
    198c:	2200      	movs	r2, #0
    198e:	701a      	strb	r2, [r3, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    1990:	4b04      	ldr	r3, [pc, #16]	; (19a4 <cpu_irq_enter_critical+0x48>)
    1992:	681b      	ldr	r3, [r3, #0]
    1994:	1c5a      	adds	r2, r3, #1
    1996:	4b03      	ldr	r3, [pc, #12]	; (19a4 <cpu_irq_enter_critical+0x48>)
    1998:	601a      	str	r2, [r3, #0]
}
    199a:	46c0      	nop			; (mov r8, r8)
    199c:	46bd      	mov	sp, r7
    199e:	b002      	add	sp, #8
    19a0:	bd80      	pop	{r7, pc}
    19a2:	46c0      	nop			; (mov r8, r8)
    19a4:	20000acc 	.word	0x20000acc
    19a8:	20000008 	.word	0x20000008
    19ac:	20000ad0 	.word	0x20000ad0

000019b0 <cpu_irq_leave_critical>:

void cpu_irq_leave_critical(void)
{
    19b0:	b580      	push	{r7, lr}
    19b2:	af00      	add	r7, sp, #0
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    19b4:	4b0b      	ldr	r3, [pc, #44]	; (19e4 <cpu_irq_leave_critical+0x34>)
    19b6:	681b      	ldr	r3, [r3, #0]
    19b8:	1e5a      	subs	r2, r3, #1
    19ba:	4b0a      	ldr	r3, [pc, #40]	; (19e4 <cpu_irq_leave_critical+0x34>)
    19bc:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    19be:	4b09      	ldr	r3, [pc, #36]	; (19e4 <cpu_irq_leave_critical+0x34>)
    19c0:	681b      	ldr	r3, [r3, #0]
    19c2:	2b00      	cmp	r3, #0
    19c4:	d10a      	bne.n	19dc <cpu_irq_leave_critical+0x2c>
    19c6:	4b08      	ldr	r3, [pc, #32]	; (19e8 <cpu_irq_leave_critical+0x38>)
    19c8:	781b      	ldrb	r3, [r3, #0]
    19ca:	b2db      	uxtb	r3, r3
    19cc:	2b00      	cmp	r3, #0
    19ce:	d005      	beq.n	19dc <cpu_irq_leave_critical+0x2c>
		cpu_irq_enable();
    19d0:	4b06      	ldr	r3, [pc, #24]	; (19ec <cpu_irq_leave_critical+0x3c>)
    19d2:	2201      	movs	r2, #1
    19d4:	701a      	strb	r2, [r3, #0]
    19d6:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
    19da:	b662      	cpsie	i
	}
}
    19dc:	46c0      	nop			; (mov r8, r8)
    19de:	46bd      	mov	sp, r7
    19e0:	bd80      	pop	{r7, pc}
    19e2:	46c0      	nop			; (mov r8, r8)
    19e4:	20000acc 	.word	0x20000acc
    19e8:	20000ad0 	.word	0x20000ad0
    19ec:	20000008 	.word	0x20000008

000019f0 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    19f0:	b580      	push	{r7, lr}
    19f2:	b084      	sub	sp, #16
    19f4:	af00      	add	r7, sp, #0
    19f6:	0002      	movs	r2, r0
    19f8:	1dfb      	adds	r3, r7, #7
    19fa:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    19fc:	230f      	movs	r3, #15
    19fe:	18fb      	adds	r3, r7, r3
    1a00:	1dfa      	adds	r2, r7, #7
    1a02:	7812      	ldrb	r2, [r2, #0]
    1a04:	09d2      	lsrs	r2, r2, #7
    1a06:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    1a08:	230e      	movs	r3, #14
    1a0a:	18fb      	adds	r3, r7, r3
    1a0c:	1dfa      	adds	r2, r7, #7
    1a0e:	7812      	ldrb	r2, [r2, #0]
    1a10:	0952      	lsrs	r2, r2, #5
    1a12:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    1a14:	4b0d      	ldr	r3, [pc, #52]	; (1a4c <system_pinmux_get_group_from_gpio_pin+0x5c>)
    1a16:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    1a18:	230f      	movs	r3, #15
    1a1a:	18fb      	adds	r3, r7, r3
    1a1c:	781b      	ldrb	r3, [r3, #0]
    1a1e:	2b00      	cmp	r3, #0
    1a20:	d10f      	bne.n	1a42 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    1a22:	230f      	movs	r3, #15
    1a24:	18fb      	adds	r3, r7, r3
    1a26:	781b      	ldrb	r3, [r3, #0]
    1a28:	009b      	lsls	r3, r3, #2
    1a2a:	2210      	movs	r2, #16
    1a2c:	4694      	mov	ip, r2
    1a2e:	44bc      	add	ip, r7
    1a30:	4463      	add	r3, ip
    1a32:	3b08      	subs	r3, #8
    1a34:	681a      	ldr	r2, [r3, #0]
    1a36:	230e      	movs	r3, #14
    1a38:	18fb      	adds	r3, r7, r3
    1a3a:	781b      	ldrb	r3, [r3, #0]
    1a3c:	01db      	lsls	r3, r3, #7
    1a3e:	18d3      	adds	r3, r2, r3
    1a40:	e000      	b.n	1a44 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    1a42:	2300      	movs	r3, #0
	}
}
    1a44:	0018      	movs	r0, r3
    1a46:	46bd      	mov	sp, r7
    1a48:	b004      	add	sp, #16
    1a4a:	bd80      	pop	{r7, pc}
    1a4c:	41004400 	.word	0x41004400

00001a50 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    1a50:	b580      	push	{r7, lr}
    1a52:	b082      	sub	sp, #8
    1a54:	af00      	add	r7, sp, #0
    1a56:	0002      	movs	r2, r0
    1a58:	1dfb      	adds	r3, r7, #7
    1a5a:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    1a5c:	1dfb      	adds	r3, r7, #7
    1a5e:	781b      	ldrb	r3, [r3, #0]
    1a60:	0018      	movs	r0, r3
    1a62:	4b03      	ldr	r3, [pc, #12]	; (1a70 <port_get_group_from_gpio_pin+0x20>)
    1a64:	4798      	blx	r3
    1a66:	0003      	movs	r3, r0
}
    1a68:	0018      	movs	r0, r3
    1a6a:	46bd      	mov	sp, r7
    1a6c:	b002      	add	sp, #8
    1a6e:	bd80      	pop	{r7, pc}
    1a70:	000019f1 	.word	0x000019f1

00001a74 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    1a74:	b580      	push	{r7, lr}
    1a76:	b082      	sub	sp, #8
    1a78:	af00      	add	r7, sp, #0
    1a7a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    1a7c:	687b      	ldr	r3, [r7, #4]
    1a7e:	2200      	movs	r2, #0
    1a80:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    1a82:	687b      	ldr	r3, [r7, #4]
    1a84:	2201      	movs	r2, #1
    1a86:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    1a88:	687b      	ldr	r3, [r7, #4]
    1a8a:	2200      	movs	r2, #0
    1a8c:	709a      	strb	r2, [r3, #2]
}
    1a8e:	46c0      	nop			; (mov r8, r8)
    1a90:	46bd      	mov	sp, r7
    1a92:	b002      	add	sp, #8
    1a94:	bd80      	pop	{r7, pc}
    1a96:	46c0      	nop			; (mov r8, r8)

00001a98 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    1a98:	b580      	push	{r7, lr}
    1a9a:	b084      	sub	sp, #16
    1a9c:	af00      	add	r7, sp, #0
    1a9e:	0002      	movs	r2, r0
    1aa0:	1dfb      	adds	r3, r7, #7
    1aa2:	701a      	strb	r2, [r3, #0]
    1aa4:	1dbb      	adds	r3, r7, #6
    1aa6:	1c0a      	adds	r2, r1, #0
    1aa8:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    1aaa:	1dfb      	adds	r3, r7, #7
    1aac:	781b      	ldrb	r3, [r3, #0]
    1aae:	0018      	movs	r0, r3
    1ab0:	4b0d      	ldr	r3, [pc, #52]	; (1ae8 <port_pin_set_output_level+0x50>)
    1ab2:	4798      	blx	r3
    1ab4:	0003      	movs	r3, r0
    1ab6:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1ab8:	1dfb      	adds	r3, r7, #7
    1aba:	781b      	ldrb	r3, [r3, #0]
    1abc:	221f      	movs	r2, #31
    1abe:	4013      	ands	r3, r2
    1ac0:	2201      	movs	r2, #1
    1ac2:	409a      	lsls	r2, r3
    1ac4:	0013      	movs	r3, r2
    1ac6:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    1ac8:	1dbb      	adds	r3, r7, #6
    1aca:	781b      	ldrb	r3, [r3, #0]
    1acc:	2b00      	cmp	r3, #0
    1ace:	d003      	beq.n	1ad8 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    1ad0:	68fb      	ldr	r3, [r7, #12]
    1ad2:	68ba      	ldr	r2, [r7, #8]
    1ad4:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    1ad6:	e002      	b.n	1ade <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    1ad8:	68fb      	ldr	r3, [r7, #12]
    1ada:	68ba      	ldr	r2, [r7, #8]
    1adc:	615a      	str	r2, [r3, #20]
	}
}
    1ade:	46c0      	nop			; (mov r8, r8)
    1ae0:	46bd      	mov	sp, r7
    1ae2:	b004      	add	sp, #16
    1ae4:	bd80      	pop	{r7, pc}
    1ae6:	46c0      	nop			; (mov r8, r8)
    1ae8:	00001a51 	.word	0x00001a51

00001aec <system_board_init>:
void board_init(void);
#  pragma weak board_init=system_board_init
#endif

void system_board_init(void)
{
    1aec:	b580      	push	{r7, lr}
    1aee:	b082      	sub	sp, #8
    1af0:	af00      	add	r7, sp, #0
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
    1af2:	1d3b      	adds	r3, r7, #4
    1af4:	0018      	movs	r0, r3
    1af6:	4b0e      	ldr	r3, [pc, #56]	; (1b30 <system_board_init+0x44>)
    1af8:	4798      	blx	r3

	/* Configure LEDs as outputs, turn them off */
	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
    1afa:	1d3b      	adds	r3, r7, #4
    1afc:	2201      	movs	r2, #1
    1afe:	701a      	strb	r2, [r3, #0]
	port_pin_set_config(LED_0_PIN, &pin_conf);
    1b00:	1d3b      	adds	r3, r7, #4
    1b02:	0019      	movs	r1, r3
    1b04:	200e      	movs	r0, #14
    1b06:	4b0b      	ldr	r3, [pc, #44]	; (1b34 <system_board_init+0x48>)
    1b08:	4798      	blx	r3
	port_pin_set_output_level(LED_0_PIN, LED_0_INACTIVE);
    1b0a:	2101      	movs	r1, #1
    1b0c:	200e      	movs	r0, #14
    1b0e:	4b0a      	ldr	r3, [pc, #40]	; (1b38 <system_board_init+0x4c>)
    1b10:	4798      	blx	r3

	/* Set buttons as inputs */
	pin_conf.direction  = PORT_PIN_DIR_INPUT;
    1b12:	1d3b      	adds	r3, r7, #4
    1b14:	2200      	movs	r2, #0
    1b16:	701a      	strb	r2, [r3, #0]
	pin_conf.input_pull = PORT_PIN_PULL_UP;
    1b18:	1d3b      	adds	r3, r7, #4
    1b1a:	2201      	movs	r2, #1
    1b1c:	705a      	strb	r2, [r3, #1]
	port_pin_set_config(BUTTON_0_PIN, &pin_conf);
    1b1e:	1d3b      	adds	r3, r7, #4
    1b20:	0019      	movs	r1, r3
    1b22:	200f      	movs	r0, #15
    1b24:	4b03      	ldr	r3, [pc, #12]	; (1b34 <system_board_init+0x48>)
    1b26:	4798      	blx	r3

	pin_conf.direction  = PORT_PIN_DIR_INPUT;
	port_pin_set_config(AT86RFX_SPI_MISO, &pin_conf);
	
#endif
}
    1b28:	46c0      	nop			; (mov r8, r8)
    1b2a:	46bd      	mov	sp, r7
    1b2c:	b002      	add	sp, #8
    1b2e:	bd80      	pop	{r7, pc}
    1b30:	00001a75 	.word	0x00001a75
    1b34:	00002a8d 	.word	0x00002a8d
    1b38:	00001a99 	.word	0x00001a99

00001b3c <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    1b3c:	b580      	push	{r7, lr}
    1b3e:	b084      	sub	sp, #16
    1b40:	af00      	add	r7, sp, #0
    1b42:	0002      	movs	r2, r0
    1b44:	1dfb      	adds	r3, r7, #7
    1b46:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    1b48:	230f      	movs	r3, #15
    1b4a:	18fb      	adds	r3, r7, r3
    1b4c:	1dfa      	adds	r2, r7, #7
    1b4e:	7812      	ldrb	r2, [r2, #0]
    1b50:	09d2      	lsrs	r2, r2, #7
    1b52:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    1b54:	230e      	movs	r3, #14
    1b56:	18fb      	adds	r3, r7, r3
    1b58:	1dfa      	adds	r2, r7, #7
    1b5a:	7812      	ldrb	r2, [r2, #0]
    1b5c:	0952      	lsrs	r2, r2, #5
    1b5e:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    1b60:	4b0d      	ldr	r3, [pc, #52]	; (1b98 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    1b62:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    1b64:	230f      	movs	r3, #15
    1b66:	18fb      	adds	r3, r7, r3
    1b68:	781b      	ldrb	r3, [r3, #0]
    1b6a:	2b00      	cmp	r3, #0
    1b6c:	d10f      	bne.n	1b8e <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    1b6e:	230f      	movs	r3, #15
    1b70:	18fb      	adds	r3, r7, r3
    1b72:	781b      	ldrb	r3, [r3, #0]
    1b74:	009b      	lsls	r3, r3, #2
    1b76:	2210      	movs	r2, #16
    1b78:	4694      	mov	ip, r2
    1b7a:	44bc      	add	ip, r7
    1b7c:	4463      	add	r3, ip
    1b7e:	3b08      	subs	r3, #8
    1b80:	681a      	ldr	r2, [r3, #0]
    1b82:	230e      	movs	r3, #14
    1b84:	18fb      	adds	r3, r7, r3
    1b86:	781b      	ldrb	r3, [r3, #0]
    1b88:	01db      	lsls	r3, r3, #7
    1b8a:	18d3      	adds	r3, r2, r3
    1b8c:	e000      	b.n	1b90 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    1b8e:	2300      	movs	r3, #0
	}
}
    1b90:	0018      	movs	r0, r3
    1b92:	46bd      	mov	sp, r7
    1b94:	b004      	add	sp, #16
    1b96:	bd80      	pop	{r7, pc}
    1b98:	41004400 	.word	0x41004400

00001b9c <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    1b9c:	b580      	push	{r7, lr}
    1b9e:	b082      	sub	sp, #8
    1ba0:	af00      	add	r7, sp, #0
    1ba2:	0002      	movs	r2, r0
    1ba4:	1dfb      	adds	r3, r7, #7
    1ba6:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    1ba8:	1dfb      	adds	r3, r7, #7
    1baa:	781b      	ldrb	r3, [r3, #0]
    1bac:	0018      	movs	r0, r3
    1bae:	4b03      	ldr	r3, [pc, #12]	; (1bbc <port_get_group_from_gpio_pin+0x20>)
    1bb0:	4798      	blx	r3
    1bb2:	0003      	movs	r3, r0
}
    1bb4:	0018      	movs	r0, r3
    1bb6:	46bd      	mov	sp, r7
    1bb8:	b002      	add	sp, #8
    1bba:	bd80      	pop	{r7, pc}
    1bbc:	00001b3d 	.word	0x00001b3d

00001bc0 <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    1bc0:	b580      	push	{r7, lr}
    1bc2:	b082      	sub	sp, #8
    1bc4:	af00      	add	r7, sp, #0
    1bc6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    1bc8:	687b      	ldr	r3, [r7, #4]
    1bca:	2200      	movs	r2, #0
    1bcc:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    1bce:	687b      	ldr	r3, [r7, #4]
    1bd0:	2201      	movs	r2, #1
    1bd2:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    1bd4:	687b      	ldr	r3, [r7, #4]
    1bd6:	2200      	movs	r2, #0
    1bd8:	709a      	strb	r2, [r3, #2]
}
    1bda:	46c0      	nop			; (mov r8, r8)
    1bdc:	46bd      	mov	sp, r7
    1bde:	b002      	add	sp, #8
    1be0:	bd80      	pop	{r7, pc}
    1be2:	46c0      	nop			; (mov r8, r8)

00001be4 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    1be4:	b580      	push	{r7, lr}
    1be6:	b084      	sub	sp, #16
    1be8:	af00      	add	r7, sp, #0
    1bea:	0002      	movs	r2, r0
    1bec:	1dfb      	adds	r3, r7, #7
    1bee:	701a      	strb	r2, [r3, #0]
    1bf0:	1dbb      	adds	r3, r7, #6
    1bf2:	1c0a      	adds	r2, r1, #0
    1bf4:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    1bf6:	1dfb      	adds	r3, r7, #7
    1bf8:	781b      	ldrb	r3, [r3, #0]
    1bfa:	0018      	movs	r0, r3
    1bfc:	4b0d      	ldr	r3, [pc, #52]	; (1c34 <port_pin_set_output_level+0x50>)
    1bfe:	4798      	blx	r3
    1c00:	0003      	movs	r3, r0
    1c02:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    1c04:	1dfb      	adds	r3, r7, #7
    1c06:	781b      	ldrb	r3, [r3, #0]
    1c08:	221f      	movs	r2, #31
    1c0a:	4013      	ands	r3, r2
    1c0c:	2201      	movs	r2, #1
    1c0e:	409a      	lsls	r2, r3
    1c10:	0013      	movs	r3, r2
    1c12:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    1c14:	1dbb      	adds	r3, r7, #6
    1c16:	781b      	ldrb	r3, [r3, #0]
    1c18:	2b00      	cmp	r3, #0
    1c1a:	d003      	beq.n	1c24 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    1c1c:	68fb      	ldr	r3, [r7, #12]
    1c1e:	68ba      	ldr	r2, [r7, #8]
    1c20:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    1c22:	e002      	b.n	1c2a <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    1c24:	68fb      	ldr	r3, [r7, #12]
    1c26:	68ba      	ldr	r2, [r7, #8]
    1c28:	615a      	str	r2, [r3, #20]
	}
}
    1c2a:	46c0      	nop			; (mov r8, r8)
    1c2c:	46bd      	mov	sp, r7
    1c2e:	b004      	add	sp, #16
    1c30:	bd80      	pop	{r7, pc}
    1c32:	46c0      	nop			; (mov r8, r8)
    1c34:	00001b9d 	.word	0x00001b9d

00001c38 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    1c38:	b580      	push	{r7, lr}
    1c3a:	b082      	sub	sp, #8
    1c3c:	af00      	add	r7, sp, #0
    1c3e:	0002      	movs	r2, r0
    1c40:	1dfb      	adds	r3, r7, #7
    1c42:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    1c44:	4b06      	ldr	r3, [pc, #24]	; (1c60 <system_interrupt_enable+0x28>)
    1c46:	1dfa      	adds	r2, r7, #7
    1c48:	7812      	ldrb	r2, [r2, #0]
    1c4a:	0011      	movs	r1, r2
    1c4c:	221f      	movs	r2, #31
    1c4e:	400a      	ands	r2, r1
    1c50:	2101      	movs	r1, #1
    1c52:	4091      	lsls	r1, r2
    1c54:	000a      	movs	r2, r1
    1c56:	601a      	str	r2, [r3, #0]
}
    1c58:	46c0      	nop			; (mov r8, r8)
    1c5a:	46bd      	mov	sp, r7
    1c5c:	b002      	add	sp, #8
    1c5e:	bd80      	pop	{r7, pc}
    1c60:	e000e100 	.word	0xe000e100

00001c64 <spi_is_syncing>:
 * \retval false  Module synchronization is not ongoing
 *
 */
static inline bool spi_is_syncing(
		struct spi_module *const module)
{
    1c64:	b580      	push	{r7, lr}
    1c66:	b084      	sub	sp, #16
    1c68:	af00      	add	r7, sp, #0
    1c6a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1c6c:	687b      	ldr	r3, [r7, #4]
    1c6e:	681b      	ldr	r3, [r3, #0]
    1c70:	60fb      	str	r3, [r7, #12]
#  ifdef FEATURE_SPI_SYNC_SCHEME_VERSION_2
	/* Return synchronization status */
	return (spi_module->SYNCBUSY.reg);
#  else
	/* Return synchronization status */
	return (spi_module->STATUS.reg & SERCOM_SPI_STATUS_SYNCBUSY);
    1c72:	68fb      	ldr	r3, [r7, #12]
    1c74:	8a1b      	ldrh	r3, [r3, #16]
    1c76:	b29b      	uxth	r3, r3
    1c78:	001a      	movs	r2, r3
    1c7a:	2380      	movs	r3, #128	; 0x80
    1c7c:	021b      	lsls	r3, r3, #8
    1c7e:	4013      	ands	r3, r2
    1c80:	1e5a      	subs	r2, r3, #1
    1c82:	4193      	sbcs	r3, r2
    1c84:	b2db      	uxtb	r3, r3
#  endif
}
    1c86:	0018      	movs	r0, r3
    1c88:	46bd      	mov	sp, r7
    1c8a:	b004      	add	sp, #16
    1c8c:	bd80      	pop	{r7, pc}
    1c8e:	46c0      	nop			; (mov r8, r8)

00001c90 <spi_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void spi_get_config_defaults(
		struct spi_config *const config)
{
    1c90:	b580      	push	{r7, lr}
    1c92:	b082      	sub	sp, #8
    1c94:	af00      	add	r7, sp, #0
    1c96:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mode             = SPI_MODE_MASTER;
    1c98:	687b      	ldr	r3, [r7, #4]
    1c9a:	2201      	movs	r2, #1
    1c9c:	701a      	strb	r2, [r3, #0]
	config->data_order       = SPI_DATA_ORDER_MSB;
    1c9e:	687b      	ldr	r3, [r7, #4]
    1ca0:	2200      	movs	r2, #0
    1ca2:	605a      	str	r2, [r3, #4]
	config->transfer_mode    = SPI_TRANSFER_MODE_0;
    1ca4:	687b      	ldr	r3, [r7, #4]
    1ca6:	2200      	movs	r2, #0
    1ca8:	609a      	str	r2, [r3, #8]
	config->mux_setting      = SPI_SIGNAL_MUX_SETTING_D;
    1caa:	687b      	ldr	r3, [r7, #4]
    1cac:	22c0      	movs	r2, #192	; 0xc0
    1cae:	0392      	lsls	r2, r2, #14
    1cb0:	60da      	str	r2, [r3, #12]
	config->character_size   = SPI_CHARACTER_SIZE_8BIT;
    1cb2:	687b      	ldr	r3, [r7, #4]
    1cb4:	2200      	movs	r2, #0
    1cb6:	741a      	strb	r2, [r3, #16]
	config->run_in_standby   = false;
    1cb8:	687b      	ldr	r3, [r7, #4]
    1cba:	2200      	movs	r2, #0
    1cbc:	745a      	strb	r2, [r3, #17]
	config->receiver_enable  = true;
    1cbe:	687b      	ldr	r3, [r7, #4]
    1cc0:	2201      	movs	r2, #1
    1cc2:	749a      	strb	r2, [r3, #18]
	config->select_slave_low_detect_enable= true;
#  endif
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	config->master_slave_select_enable= false;
#  endif
	config->generator_source = GCLK_GENERATOR_0;
    1cc4:	687b      	ldr	r3, [r7, #4]
    1cc6:	2220      	movs	r2, #32
    1cc8:	2100      	movs	r1, #0
    1cca:	5499      	strb	r1, [r3, r2]

	/* Clear mode specific config */
	memset(&(config->mode_specific), 0, sizeof(config->mode_specific));
    1ccc:	687b      	ldr	r3, [r7, #4]
    1cce:	3314      	adds	r3, #20
    1cd0:	220c      	movs	r2, #12
    1cd2:	2100      	movs	r1, #0
    1cd4:	0018      	movs	r0, r3
    1cd6:	4b0a      	ldr	r3, [pc, #40]	; (1d00 <spi_get_config_defaults+0x70>)
    1cd8:	4798      	blx	r3

	/* Master config defaults */
	config->mode_specific.master.baudrate = 100000;
    1cda:	687b      	ldr	r3, [r7, #4]
    1cdc:	4a09      	ldr	r2, [pc, #36]	; (1d04 <spi_get_config_defaults+0x74>)
    1cde:	615a      	str	r2, [r3, #20]

	/* pinmux config defaults */
	config->pinmux_pad0 = PINMUX_DEFAULT;
    1ce0:	687b      	ldr	r3, [r7, #4]
    1ce2:	2200      	movs	r2, #0
    1ce4:	625a      	str	r2, [r3, #36]	; 0x24
	config->pinmux_pad1 = PINMUX_DEFAULT;
    1ce6:	687b      	ldr	r3, [r7, #4]
    1ce8:	2200      	movs	r2, #0
    1cea:	629a      	str	r2, [r3, #40]	; 0x28
	config->pinmux_pad2 = PINMUX_DEFAULT;
    1cec:	687b      	ldr	r3, [r7, #4]
    1cee:	2200      	movs	r2, #0
    1cf0:	62da      	str	r2, [r3, #44]	; 0x2c
	config->pinmux_pad3 = PINMUX_DEFAULT;
    1cf2:	687b      	ldr	r3, [r7, #4]
    1cf4:	2200      	movs	r2, #0
    1cf6:	631a      	str	r2, [r3, #48]	; 0x30

};
    1cf8:	46c0      	nop			; (mov r8, r8)
    1cfa:	46bd      	mov	sp, r7
    1cfc:	b002      	add	sp, #8
    1cfe:	bd80      	pop	{r7, pc}
    1d00:	0000fc55 	.word	0x0000fc55
    1d04:	000186a0 	.word	0x000186a0

00001d08 <spi_slave_inst_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void spi_slave_inst_get_config_defaults(
		struct spi_slave_inst_config *const config)
{
    1d08:	b580      	push	{r7, lr}
    1d0a:	b082      	sub	sp, #8
    1d0c:	af00      	add	r7, sp, #0
    1d0e:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->ss_pin          = 10;
    1d10:	687b      	ldr	r3, [r7, #4]
    1d12:	220a      	movs	r2, #10
    1d14:	701a      	strb	r2, [r3, #0]
	config->address_enabled = false;
    1d16:	687b      	ldr	r3, [r7, #4]
    1d18:	2200      	movs	r2, #0
    1d1a:	705a      	strb	r2, [r3, #1]
	config->address         = 0;
    1d1c:	687b      	ldr	r3, [r7, #4]
    1d1e:	2200      	movs	r2, #0
    1d20:	709a      	strb	r2, [r3, #2]
}
    1d22:	46c0      	nop			; (mov r8, r8)
    1d24:	46bd      	mov	sp, r7
    1d26:	b002      	add	sp, #8
    1d28:	bd80      	pop	{r7, pc}
    1d2a:	46c0      	nop			; (mov r8, r8)

00001d2c <spi_attach_slave>:
 *
 */
static inline void spi_attach_slave(
		struct spi_slave_inst *const slave,
		const struct spi_slave_inst_config *const config)
{
    1d2c:	b580      	push	{r7, lr}
    1d2e:	b084      	sub	sp, #16
    1d30:	af00      	add	r7, sp, #0
    1d32:	6078      	str	r0, [r7, #4]
    1d34:	6039      	str	r1, [r7, #0]
	Assert(slave);
	Assert(config);

	slave->ss_pin          = config->ss_pin;
    1d36:	683b      	ldr	r3, [r7, #0]
    1d38:	781a      	ldrb	r2, [r3, #0]
    1d3a:	687b      	ldr	r3, [r7, #4]
    1d3c:	701a      	strb	r2, [r3, #0]
	slave->address_enabled = config->address_enabled;
    1d3e:	683b      	ldr	r3, [r7, #0]
    1d40:	785a      	ldrb	r2, [r3, #1]
    1d42:	687b      	ldr	r3, [r7, #4]
    1d44:	705a      	strb	r2, [r3, #1]
	slave->address         = config->address;
    1d46:	683b      	ldr	r3, [r7, #0]
    1d48:	789a      	ldrb	r2, [r3, #2]
    1d4a:	687b      	ldr	r3, [r7, #4]
    1d4c:	709a      	strb	r2, [r3, #2]

	/* Get default config for pin */
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
    1d4e:	230c      	movs	r3, #12
    1d50:	18fb      	adds	r3, r7, r3
    1d52:	0018      	movs	r0, r3
    1d54:	4b0b      	ldr	r3, [pc, #44]	; (1d84 <spi_attach_slave+0x58>)
    1d56:	4798      	blx	r3

	/* Edit config to set the pin as output */
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
    1d58:	230c      	movs	r3, #12
    1d5a:	18fb      	adds	r3, r7, r3
    1d5c:	2201      	movs	r2, #1
    1d5e:	701a      	strb	r2, [r3, #0]

	/* Set config on Slave Select pin */
	port_pin_set_config(slave->ss_pin, &pin_conf);
    1d60:	687b      	ldr	r3, [r7, #4]
    1d62:	781b      	ldrb	r3, [r3, #0]
    1d64:	220c      	movs	r2, #12
    1d66:	18ba      	adds	r2, r7, r2
    1d68:	0011      	movs	r1, r2
    1d6a:	0018      	movs	r0, r3
    1d6c:	4b06      	ldr	r3, [pc, #24]	; (1d88 <spi_attach_slave+0x5c>)
    1d6e:	4798      	blx	r3
	port_pin_set_output_level(slave->ss_pin, true);
    1d70:	687b      	ldr	r3, [r7, #4]
    1d72:	781b      	ldrb	r3, [r3, #0]
    1d74:	2101      	movs	r1, #1
    1d76:	0018      	movs	r0, r3
    1d78:	4b04      	ldr	r3, [pc, #16]	; (1d8c <spi_attach_slave+0x60>)
    1d7a:	4798      	blx	r3
}
    1d7c:	46c0      	nop			; (mov r8, r8)
    1d7e:	46bd      	mov	sp, r7
    1d80:	b004      	add	sp, #16
    1d82:	bd80      	pop	{r7, pc}
    1d84:	00001bc1 	.word	0x00001bc1
    1d88:	00002a8d 	.word	0x00002a8d
    1d8c:	00001be5 	.word	0x00001be5

00001d90 <spi_enable>:
 *
 * \param[in,out] module  Pointer to the software instance struct
 */
static inline void spi_enable(
		struct spi_module *const module)
{
    1d90:	b580      	push	{r7, lr}
    1d92:	b084      	sub	sp, #16
    1d94:	af00      	add	r7, sp, #0
    1d96:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    1d98:	687b      	ldr	r3, [r7, #4]
    1d9a:	681b      	ldr	r3, [r3, #0]
    1d9c:	60fb      	str	r3, [r7, #12]

#  if SPI_CALLBACK_MODE == true
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    1d9e:	687b      	ldr	r3, [r7, #4]
    1da0:	681b      	ldr	r3, [r3, #0]
    1da2:	0018      	movs	r0, r3
    1da4:	4b0b      	ldr	r3, [pc, #44]	; (1dd4 <spi_enable+0x44>)
    1da6:	4798      	blx	r3
    1da8:	0003      	movs	r3, r0
    1daa:	0018      	movs	r0, r3
    1dac:	4b0a      	ldr	r3, [pc, #40]	; (1dd8 <spi_enable+0x48>)
    1dae:	4798      	blx	r3
#  endif

	while (spi_is_syncing(module)) {
    1db0:	46c0      	nop			; (mov r8, r8)
    1db2:	687b      	ldr	r3, [r7, #4]
    1db4:	0018      	movs	r0, r3
    1db6:	4b09      	ldr	r3, [pc, #36]	; (1ddc <spi_enable+0x4c>)
    1db8:	4798      	blx	r3
    1dba:	1e03      	subs	r3, r0, #0
    1dbc:	d1f9      	bne.n	1db2 <spi_enable+0x22>
		/* Wait until the synchronization is complete */
	}

	/* Enable SPI */
	spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
    1dbe:	68fb      	ldr	r3, [r7, #12]
    1dc0:	681b      	ldr	r3, [r3, #0]
    1dc2:	2202      	movs	r2, #2
    1dc4:	431a      	orrs	r2, r3
    1dc6:	68fb      	ldr	r3, [r7, #12]
    1dc8:	601a      	str	r2, [r3, #0]
}
    1dca:	46c0      	nop			; (mov r8, r8)
    1dcc:	46bd      	mov	sp, r7
    1dce:	b004      	add	sp, #16
    1dd0:	bd80      	pop	{r7, pc}
    1dd2:	46c0      	nop			; (mov r8, r8)
    1dd4:	00002e99 	.word	0x00002e99
    1dd8:	00001c39 	.word	0x00001c39
    1ddc:	00001c65 	.word	0x00001c65

00001de0 <ksz8851snl_interface_init>:
/**
 * \internal
 * \brief Initialize the hardware interface.
 */
static void ksz8851snl_interface_init(void)
{
    1de0:	b580      	push	{r7, lr}
    1de2:	b090      	sub	sp, #64	; 0x40
    1de4:	af00      	add	r7, sp, #0
	struct spi_config config;
	struct spi_slave_inst_config slave_config;

	spi_slave_inst_get_config_defaults(&slave_config);
    1de6:	2308      	movs	r3, #8
    1de8:	18fb      	adds	r3, r7, r3
    1dea:	0018      	movs	r0, r3
    1dec:	4b23      	ldr	r3, [pc, #140]	; (1e7c <ksz8851snl_interface_init+0x9c>)
    1dee:	4798      	blx	r3
	slave_config.ss_pin = ETHERNET_SPI_SS_A;//KSZ8851SNL_CS_PIN;
    1df0:	2308      	movs	r3, #8
    1df2:	18fb      	adds	r3, r7, r3
    1df4:	2221      	movs	r2, #33	; 0x21
    1df6:	701a      	strb	r2, [r3, #0]
	spi_attach_slave(&ksz8851snl_slave, &slave_config);
    1df8:	2308      	movs	r3, #8
    1dfa:	18fa      	adds	r2, r7, r3
    1dfc:	4b20      	ldr	r3, [pc, #128]	; (1e80 <ksz8851snl_interface_init+0xa0>)
    1dfe:	0011      	movs	r1, r2
    1e00:	0018      	movs	r0, r3
    1e02:	4b20      	ldr	r3, [pc, #128]	; (1e84 <ksz8851snl_interface_init+0xa4>)
    1e04:	4798      	blx	r3

	spi_get_config_defaults(&config);
    1e06:	230c      	movs	r3, #12
    1e08:	18fb      	adds	r3, r7, r3
    1e0a:	0018      	movs	r0, r3
    1e0c:	4b1e      	ldr	r3, [pc, #120]	; (1e88 <ksz8851snl_interface_init+0xa8>)
    1e0e:	4798      	blx	r3

	config.mux_setting = SPI_SIGNAL_MUX_SETTING_C;//SPI_SIGNAL_MUX_SETTING_D;//KSZ8851SNL_SPI_PINMUX_SETTING;
    1e10:	230c      	movs	r3, #12
    1e12:	18fb      	adds	r3, r7, r3
    1e14:	2280      	movs	r2, #128	; 0x80
    1e16:	0392      	lsls	r2, r2, #14
    1e18:	60da      	str	r2, [r3, #12]
	config.pinmux_pad0 = ETHERNET_SPI_MOSI;//KSZ8851SNL_SPI_PINMUX_PAD0;
    1e1a:	230c      	movs	r3, #12
    1e1c:	18fb      	adds	r3, r7, r3
    1e1e:	223e      	movs	r2, #62	; 0x3e
    1e20:	625a      	str	r2, [r3, #36]	; 0x24
	config.pinmux_pad1 = ETHERNET_SPI_SCK;//KSZ8851SNL_SPI_PINMUX_PAD1;
    1e22:	230c      	movs	r3, #12
    1e24:	18fb      	adds	r3, r7, r3
    1e26:	223f      	movs	r2, #63	; 0x3f
    1e28:	629a      	str	r2, [r3, #40]	; 0x28
	config.pinmux_pad2 = ETHERNET_SPI_MISO;//PINMUX_UNUSED;//KSZ8851SNL_SPI_PINMUX_PAD2;
    1e2a:	230c      	movs	r3, #12
    1e2c:	18fb      	adds	r3, r7, r3
    1e2e:	2220      	movs	r2, #32
    1e30:	62da      	str	r2, [r3, #44]	; 0x2c
	config.pinmux_pad3 = PINMUX_UNUSED;//ETHERNET_SPI_MISO;//KSZ8851SNL_SPI_PINMUX_PAD3;
    1e32:	230c      	movs	r3, #12
    1e34:	18fb      	adds	r3, r7, r3
    1e36:	2201      	movs	r2, #1
    1e38:	4252      	negs	r2, r2
    1e3a:	631a      	str	r2, [r3, #48]	; 0x30
	config.mode_specific.master.baudrate = KSZ8851SNL_CLOCK_SPEED;
    1e3c:	230c      	movs	r3, #12
    1e3e:	18fb      	adds	r3, r7, r3
    1e40:	4a12      	ldr	r2, [pc, #72]	; (1e8c <ksz8851snl_interface_init+0xac>)
    1e42:	615a      	str	r2, [r3, #20]

	//spi_init(&ksz8851snl_master, KSZ8851SNL_SPI, &config);
	spi_init(&ksz8851snl_master, SPI_MODULE, &config);
    1e44:	230c      	movs	r3, #12
    1e46:	18fa      	adds	r2, r7, r3
    1e48:	4911      	ldr	r1, [pc, #68]	; (1e90 <ksz8851snl_interface_init+0xb0>)
    1e4a:	4b12      	ldr	r3, [pc, #72]	; (1e94 <ksz8851snl_interface_init+0xb4>)
    1e4c:	0018      	movs	r0, r3
    1e4e:	4b12      	ldr	r3, [pc, #72]	; (1e98 <ksz8851snl_interface_init+0xb8>)
    1e50:	4798      	blx	r3
	spi_enable(&ksz8851snl_master);
    1e52:	4b10      	ldr	r3, [pc, #64]	; (1e94 <ksz8851snl_interface_init+0xb4>)
    1e54:	0018      	movs	r0, r3
    1e56:	4b11      	ldr	r3, [pc, #68]	; (1e9c <ksz8851snl_interface_init+0xbc>)
    1e58:	4798      	blx	r3

	/* Configure RSTN pin. */
	struct port_config pin;
	port_get_config_defaults(&pin);
    1e5a:	1d3b      	adds	r3, r7, #4
    1e5c:	0018      	movs	r0, r3
    1e5e:	4b10      	ldr	r3, [pc, #64]	; (1ea0 <ksz8851snl_interface_init+0xc0>)
    1e60:	4798      	blx	r3
	pin.direction = PORT_PIN_DIR_OUTPUT;
    1e62:	1d3b      	adds	r3, r7, #4
    1e64:	2201      	movs	r2, #1
    1e66:	701a      	strb	r2, [r3, #0]
	//port_pin_set_config(KSZ8851SNL_RSTN_PIN, &pin);
	port_pin_set_config(ETHERNET_RST_N, &pin);
    1e68:	1d3b      	adds	r3, r7, #4
    1e6a:	0019      	movs	r1, r3
    1e6c:	2023      	movs	r0, #35	; 0x23
    1e6e:	4b0d      	ldr	r3, [pc, #52]	; (1ea4 <ksz8851snl_interface_init+0xc4>)
    1e70:	4798      	blx	r3
}
    1e72:	46c0      	nop			; (mov r8, r8)
    1e74:	46bd      	mov	sp, r7
    1e76:	b010      	add	sp, #64	; 0x40
    1e78:	bd80      	pop	{r7, pc}
    1e7a:	46c0      	nop			; (mov r8, r8)
    1e7c:	00001d09 	.word	0x00001d09
    1e80:	20002e10 	.word	0x20002e10
    1e84:	00001d2d 	.word	0x00001d2d
    1e88:	00001c91 	.word	0x00001c91
    1e8c:	00989680 	.word	0x00989680
    1e90:	42001c00 	.word	0x42001c00
    1e94:	20002ddc 	.word	0x20002ddc
    1e98:	00003445 	.word	0x00003445
    1e9c:	00001d91 	.word	0x00001d91
    1ea0:	00001bc1 	.word	0x00001bc1
    1ea4:	00002a8d 	.word	0x00002a8d

00001ea8 <ksz8851snl_hard_reset>:
/**
 * \internal
 * \brief Perform hardware reset of the PHY.
 */
static inline void ksz8851snl_hard_reset(void)
{
    1ea8:	b580      	push	{r7, lr}
    1eaa:	af00      	add	r7, sp, #0
	/* Perform hardware reset with respect to the reset timing from the datasheet. */
	//port_pin_set_output_level(KSZ8851SNL_RSTN_PIN, false);
	port_pin_set_output_level(ETHERNET_RST_N, false);
    1eac:	2100      	movs	r1, #0
    1eae:	2023      	movs	r0, #35	; 0x23
    1eb0:	4b07      	ldr	r3, [pc, #28]	; (1ed0 <ksz8851snl_hard_reset+0x28>)
    1eb2:	4798      	blx	r3
	delay_ms(100);
    1eb4:	2064      	movs	r0, #100	; 0x64
    1eb6:	4b07      	ldr	r3, [pc, #28]	; (1ed4 <ksz8851snl_hard_reset+0x2c>)
    1eb8:	4798      	blx	r3
	//port_pin_set_output_level(KSZ8851SNL_RSTN_PIN, true);
	port_pin_set_output_level(ETHERNET_RST_N, true);
    1eba:	2101      	movs	r1, #1
    1ebc:	2023      	movs	r0, #35	; 0x23
    1ebe:	4b04      	ldr	r3, [pc, #16]	; (1ed0 <ksz8851snl_hard_reset+0x28>)
    1ec0:	4798      	blx	r3
	delay_ms(100);
    1ec2:	2064      	movs	r0, #100	; 0x64
    1ec4:	4b03      	ldr	r3, [pc, #12]	; (1ed4 <ksz8851snl_hard_reset+0x2c>)
    1ec6:	4798      	blx	r3
}
    1ec8:	46c0      	nop			; (mov r8, r8)
    1eca:	46bd      	mov	sp, r7
    1ecc:	bd80      	pop	{r7, pc}
    1ece:	46c0      	nop			; (mov r8, r8)
    1ed0:	00001be5 	.word	0x00001be5
    1ed4:	0000192d 	.word	0x0000192d

00001ed8 <configure_intn>:
 * \brief Configure the INTN interrupt.
 *
 * \param p_handler callback pointer to use when INTN interrupt raises.
 */
void configure_intn(void (*p_handler) (void))
{
    1ed8:	b580      	push	{r7, lr}
    1eda:	b086      	sub	sp, #24
    1edc:	af00      	add	r7, sp, #0
    1ede:	6078      	str	r0, [r7, #4]
	struct extint_chan_conf eic_conf;

	/* Configure the external interrupt channel. */
	extint_chan_get_config_defaults(&eic_conf);
    1ee0:	230c      	movs	r3, #12
    1ee2:	18fb      	adds	r3, r7, r3
    1ee4:	0018      	movs	r0, r3
    1ee6:	4b15      	ldr	r3, [pc, #84]	; (1f3c <configure_intn+0x64>)
    1ee8:	4798      	blx	r3
	eic_conf.gpio_pin            = ETHERNET_IRQ;//KSZ8851SNL_INTN_EIC_PIN;
    1eea:	230c      	movs	r3, #12
    1eec:	18fb      	adds	r3, r7, r3
    1eee:	221b      	movs	r2, #27
    1ef0:	601a      	str	r2, [r3, #0]
	eic_conf.gpio_pin_mux        = EICINT_PINMUX;//KSZ8851SNL_INTN_EIC_PIN_MUX;
    1ef2:	230c      	movs	r3, #12
    1ef4:	18fb      	adds	r3, r7, r3
    1ef6:	2200      	movs	r2, #0
    1ef8:	605a      	str	r2, [r3, #4]
	eic_conf.gpio_pin_pull       = EXTINT_PULL_UP;
    1efa:	230c      	movs	r3, #12
    1efc:	18fb      	adds	r3, r7, r3
    1efe:	2201      	movs	r2, #1
    1f00:	721a      	strb	r2, [r3, #8]
	eic_conf.detection_criteria  = EXTINT_DETECT_FALLING;
    1f02:	230c      	movs	r3, #12
    1f04:	18fb      	adds	r3, r7, r3
    1f06:	2202      	movs	r2, #2
    1f08:	72da      	strb	r2, [r3, #11]
	eic_conf.filter_input_signal = true;
    1f0a:	230c      	movs	r3, #12
    1f0c:	18fb      	adds	r3, r7, r3
    1f0e:	2201      	movs	r2, #1
    1f10:	729a      	strb	r2, [r3, #10]
	//extint_chan_set_config(KSZ8851SNL_INTN_EIC_CHANNEL, &eic_conf);
	extint_chan_set_config(EICINT_CHANNEL, &eic_conf);
    1f12:	230c      	movs	r3, #12
    1f14:	18fb      	adds	r3, r7, r3
    1f16:	0019      	movs	r1, r3
    1f18:	200f      	movs	r0, #15
    1f1a:	4b09      	ldr	r3, [pc, #36]	; (1f40 <configure_intn+0x68>)
    1f1c:	4798      	blx	r3
	//extint_register_callback(p_handler,
			//KSZ8851SNL_INTN_EIC_CHANNEL,
			//EXTINT_CALLBACK_TYPE_DETECT);
	//extint_chan_enable_callback(KSZ8851SNL_INTN_EIC_CHANNEL,
			//EXTINT_CALLBACK_TYPE_DETECT);
	extint_register_callback(p_handler,
    1f1e:	687b      	ldr	r3, [r7, #4]
    1f20:	2200      	movs	r2, #0
    1f22:	210f      	movs	r1, #15
    1f24:	0018      	movs	r0, r3
    1f26:	4b07      	ldr	r3, [pc, #28]	; (1f44 <configure_intn+0x6c>)
    1f28:	4798      	blx	r3
			EICINT_CHANNEL,
			EXTINT_CALLBACK_TYPE_DETECT);
	extint_chan_enable_callback(EICINT_CHANNEL,
    1f2a:	2100      	movs	r1, #0
    1f2c:	200f      	movs	r0, #15
    1f2e:	4b06      	ldr	r3, [pc, #24]	; (1f48 <configure_intn+0x70>)
    1f30:	4798      	blx	r3
			EXTINT_CALLBACK_TYPE_DETECT);
}
    1f32:	46c0      	nop			; (mov r8, r8)
    1f34:	46bd      	mov	sp, r7
    1f36:	b006      	add	sp, #24
    1f38:	bd80      	pop	{r7, pc}
    1f3a:	46c0      	nop			; (mov r8, r8)
    1f3c:	00002935 	.word	0x00002935
    1f40:	00002969 	.word	0x00002969
    1f44:	0000257d 	.word	0x0000257d
    1f48:	000025e1 	.word	0x000025e1

00001f4c <ksz8851_fifo_read>:
 *
 * \param buf the buffer to store the data from the fifo buffer.
 * \param len the amount of data to read.
 */
void ksz8851_fifo_read(uint8_t *buf, uint32_t len)
{
    1f4c:	b590      	push	{r4, r7, lr}
    1f4e:	b087      	sub	sp, #28
    1f50:	af00      	add	r7, sp, #0
    1f52:	6078      	str	r0, [r7, #4]
    1f54:	6039      	str	r1, [r7, #0]
	uint8_t tmpbuf[11];

	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, true);
    1f56:	491e      	ldr	r1, [pc, #120]	; (1fd0 <ksz8851_fifo_read+0x84>)
    1f58:	4b1e      	ldr	r3, [pc, #120]	; (1fd4 <ksz8851_fifo_read+0x88>)
    1f5a:	2201      	movs	r2, #1
    1f5c:	0018      	movs	r0, r3
    1f5e:	4b1e      	ldr	r3, [pc, #120]	; (1fd8 <ksz8851_fifo_read+0x8c>)
    1f60:	4798      	blx	r3

	tmpbuf[0] = FIFO_READ;
    1f62:	230c      	movs	r3, #12
    1f64:	18fb      	adds	r3, r7, r3
    1f66:	2280      	movs	r2, #128	; 0x80
    1f68:	701a      	strb	r2, [r3, #0]

	/* Perform SPI transfer. */
	spi_transceive_buffer_wait(&ksz8851snl_master, tmpbuf, tmpbuf, 11);
    1f6a:	230c      	movs	r3, #12
    1f6c:	18fa      	adds	r2, r7, r3
    1f6e:	230c      	movs	r3, #12
    1f70:	18f9      	adds	r1, r7, r3
    1f72:	4818      	ldr	r0, [pc, #96]	; (1fd4 <ksz8851_fifo_read+0x88>)
    1f74:	230b      	movs	r3, #11
    1f76:	4c19      	ldr	r4, [pc, #100]	; (1fdc <ksz8851_fifo_read+0x90>)
    1f78:	47a0      	blx	r4
	spi_read_buffer_wait(&ksz8851snl_master, buf, len, 0xff);
    1f7a:	683b      	ldr	r3, [r7, #0]
    1f7c:	b29a      	uxth	r2, r3
    1f7e:	6879      	ldr	r1, [r7, #4]
    1f80:	4814      	ldr	r0, [pc, #80]	; (1fd4 <ksz8851_fifo_read+0x88>)
    1f82:	23ff      	movs	r3, #255	; 0xff
    1f84:	4c16      	ldr	r4, [pc, #88]	; (1fe0 <ksz8851_fifo_read+0x94>)
    1f86:	47a0      	blx	r4

	/* Read CRC (don't care). */
	spi_read_buffer_wait(&ksz8851snl_master, tmpbuf, 4, 0xff);
    1f88:	230c      	movs	r3, #12
    1f8a:	18f9      	adds	r1, r7, r3
    1f8c:	4811      	ldr	r0, [pc, #68]	; (1fd4 <ksz8851_fifo_read+0x88>)
    1f8e:	23ff      	movs	r3, #255	; 0xff
    1f90:	2204      	movs	r2, #4
    1f92:	4c13      	ldr	r4, [pc, #76]	; (1fe0 <ksz8851_fifo_read+0x94>)
    1f94:	47a0      	blx	r4
	len += 4;
    1f96:	683b      	ldr	r3, [r7, #0]
    1f98:	3304      	adds	r3, #4
    1f9a:	603b      	str	r3, [r7, #0]

	/* Keep internal memory alignment. */
	len &= 3;
    1f9c:	683b      	ldr	r3, [r7, #0]
    1f9e:	2203      	movs	r2, #3
    1fa0:	4013      	ands	r3, r2
    1fa2:	603b      	str	r3, [r7, #0]
	if (len) {
    1fa4:	683b      	ldr	r3, [r7, #0]
    1fa6:	2b00      	cmp	r3, #0
    1fa8:	d007      	beq.n	1fba <ksz8851_fifo_read+0x6e>
		spi_read_buffer_wait(&ksz8851snl_master, tmpbuf, len, 0xff);
    1faa:	683b      	ldr	r3, [r7, #0]
    1fac:	b29a      	uxth	r2, r3
    1fae:	230c      	movs	r3, #12
    1fb0:	18f9      	adds	r1, r7, r3
    1fb2:	4808      	ldr	r0, [pc, #32]	; (1fd4 <ksz8851_fifo_read+0x88>)
    1fb4:	23ff      	movs	r3, #255	; 0xff
    1fb6:	4c0a      	ldr	r4, [pc, #40]	; (1fe0 <ksz8851_fifo_read+0x94>)
    1fb8:	47a0      	blx	r4
	}

	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, false);
    1fba:	4905      	ldr	r1, [pc, #20]	; (1fd0 <ksz8851_fifo_read+0x84>)
    1fbc:	4b05      	ldr	r3, [pc, #20]	; (1fd4 <ksz8851_fifo_read+0x88>)
    1fbe:	2200      	movs	r2, #0
    1fc0:	0018      	movs	r0, r3
    1fc2:	4b05      	ldr	r3, [pc, #20]	; (1fd8 <ksz8851_fifo_read+0x8c>)
    1fc4:	4798      	blx	r3
}
    1fc6:	46c0      	nop			; (mov r8, r8)
    1fc8:	46bd      	mov	sp, r7
    1fca:	b007      	add	sp, #28
    1fcc:	bd90      	pop	{r4, r7, pc}
    1fce:	46c0      	nop			; (mov r8, r8)
    1fd0:	20002e10 	.word	0x20002e10
    1fd4:	20002ddc 	.word	0x20002ddc
    1fd8:	00003709 	.word	0x00003709
    1fdc:	00003939 	.word	0x00003939
    1fe0:	000035d5 	.word	0x000035d5

00001fe4 <ksz8851_fifo_write_begin>:
 * \brief Start to write internal fifo buffer.
 *
 * \param tot_len the total amount of data to write.
 */
void ksz8851_fifo_write_begin(uint32_t tot_len)
{
    1fe4:	b580      	push	{r7, lr}
    1fe6:	b084      	sub	sp, #16
    1fe8:	af00      	add	r7, sp, #0
    1fea:	6078      	str	r0, [r7, #4]
	uint8_t	outbuf[5];
	static uint8_t frameID = 0;

	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, true);
    1fec:	4917      	ldr	r1, [pc, #92]	; (204c <ksz8851_fifo_write_begin+0x68>)
    1fee:	4b18      	ldr	r3, [pc, #96]	; (2050 <ksz8851_fifo_write_begin+0x6c>)
    1ff0:	2201      	movs	r2, #1
    1ff2:	0018      	movs	r0, r3
    1ff4:	4b17      	ldr	r3, [pc, #92]	; (2054 <ksz8851_fifo_write_begin+0x70>)
    1ff6:	4798      	blx	r3

	/* Prepare control word and byte count. */
	outbuf[0] = FIFO_WRITE;
    1ff8:	2308      	movs	r3, #8
    1ffa:	18fb      	adds	r3, r7, r3
    1ffc:	22c0      	movs	r2, #192	; 0xc0
    1ffe:	701a      	strb	r2, [r3, #0]
	outbuf[1] = frameID++ & 0x3f;
    2000:	4b15      	ldr	r3, [pc, #84]	; (2058 <ksz8851_fifo_write_begin+0x74>)
    2002:	781b      	ldrb	r3, [r3, #0]
    2004:	1c5a      	adds	r2, r3, #1
    2006:	b2d1      	uxtb	r1, r2
    2008:	4a13      	ldr	r2, [pc, #76]	; (2058 <ksz8851_fifo_write_begin+0x74>)
    200a:	7011      	strb	r1, [r2, #0]
    200c:	223f      	movs	r2, #63	; 0x3f
    200e:	4013      	ands	r3, r2
    2010:	b2da      	uxtb	r2, r3
    2012:	2308      	movs	r3, #8
    2014:	18fb      	adds	r3, r7, r3
    2016:	705a      	strb	r2, [r3, #1]
	outbuf[2] = 0;
    2018:	2308      	movs	r3, #8
    201a:	18fb      	adds	r3, r7, r3
    201c:	2200      	movs	r2, #0
    201e:	709a      	strb	r2, [r3, #2]
	outbuf[3] = tot_len & 0xff;
    2020:	687b      	ldr	r3, [r7, #4]
    2022:	b2da      	uxtb	r2, r3
    2024:	2308      	movs	r3, #8
    2026:	18fb      	adds	r3, r7, r3
    2028:	70da      	strb	r2, [r3, #3]
	outbuf[4] = tot_len >> 8;
    202a:	687b      	ldr	r3, [r7, #4]
    202c:	0a1b      	lsrs	r3, r3, #8
    202e:	b2da      	uxtb	r2, r3
    2030:	2308      	movs	r3, #8
    2032:	18fb      	adds	r3, r7, r3
    2034:	711a      	strb	r2, [r3, #4]

	/* Perform SPI transfer. */
	spi_write_buffer_wait(&ksz8851snl_master, outbuf, 5);
    2036:	2308      	movs	r3, #8
    2038:	18f9      	adds	r1, r7, r3
    203a:	4b05      	ldr	r3, [pc, #20]	; (2050 <ksz8851_fifo_write_begin+0x6c>)
    203c:	2205      	movs	r2, #5
    203e:	0018      	movs	r0, r3
    2040:	4b06      	ldr	r3, [pc, #24]	; (205c <ksz8851_fifo_write_begin+0x78>)
    2042:	4798      	blx	r3
}
    2044:	46c0      	nop			; (mov r8, r8)
    2046:	46bd      	mov	sp, r7
    2048:	b004      	add	sp, #16
    204a:	bd80      	pop	{r7, pc}
    204c:	20002e10 	.word	0x20002e10
    2050:	20002ddc 	.word	0x20002ddc
    2054:	00003709 	.word	0x00003709
    2058:	20000ad1 	.word	0x20000ad1
    205c:	000037ed 	.word	0x000037ed

00002060 <ksz8851_fifo_write>:
 *
 * \param buf the buffer to send to the fifo buffer.
 * \param len the size of the pbuf element to write.
 */
void ksz8851_fifo_write(uint8_t *buf, uint32_t len)
{
    2060:	b580      	push	{r7, lr}
    2062:	b082      	sub	sp, #8
    2064:	af00      	add	r7, sp, #0
    2066:	6078      	str	r0, [r7, #4]
    2068:	6039      	str	r1, [r7, #0]
	/* Perform SPI transfer. */
	spi_write_buffer_wait(&ksz8851snl_master, buf, len);
    206a:	683b      	ldr	r3, [r7, #0]
    206c:	b29a      	uxth	r2, r3
    206e:	6879      	ldr	r1, [r7, #4]
    2070:	4b03      	ldr	r3, [pc, #12]	; (2080 <ksz8851_fifo_write+0x20>)
    2072:	0018      	movs	r0, r3
    2074:	4b03      	ldr	r3, [pc, #12]	; (2084 <ksz8851_fifo_write+0x24>)
    2076:	4798      	blx	r3
}
    2078:	46c0      	nop			; (mov r8, r8)
    207a:	46bd      	mov	sp, r7
    207c:	b002      	add	sp, #8
    207e:	bd80      	pop	{r7, pc}
    2080:	20002ddc 	.word	0x20002ddc
    2084:	000037ed 	.word	0x000037ed

00002088 <ksz8851_fifo_write_end>:
 *
 * \param pad amount of dummy data (bytes) to write to keep 32 bits alignment
 * in the internal FIFO.
 */
void ksz8851_fifo_write_end(uint32_t pad)
{
    2088:	b580      	push	{r7, lr}
    208a:	b084      	sub	sp, #16
    208c:	af00      	add	r7, sp, #0
    208e:	6078      	str	r0, [r7, #4]
	uint8_t	outbuf[5];

	if (pad > 0) {
    2090:	687b      	ldr	r3, [r7, #4]
    2092:	2b00      	cmp	r3, #0
    2094:	d00a      	beq.n	20ac <ksz8851_fifo_write_end+0x24>
		spi_write_buffer_wait(&ksz8851snl_master, outbuf, 4 - pad);
    2096:	687b      	ldr	r3, [r7, #4]
    2098:	b29b      	uxth	r3, r3
    209a:	2204      	movs	r2, #4
    209c:	1ad3      	subs	r3, r2, r3
    209e:	b29a      	uxth	r2, r3
    20a0:	2308      	movs	r3, #8
    20a2:	18f9      	adds	r1, r7, r3
    20a4:	4b06      	ldr	r3, [pc, #24]	; (20c0 <ksz8851_fifo_write_end+0x38>)
    20a6:	0018      	movs	r0, r3
    20a8:	4b06      	ldr	r3, [pc, #24]	; (20c4 <ksz8851_fifo_write_end+0x3c>)
    20aa:	4798      	blx	r3
	}
	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, false);
    20ac:	4906      	ldr	r1, [pc, #24]	; (20c8 <ksz8851_fifo_write_end+0x40>)
    20ae:	4b04      	ldr	r3, [pc, #16]	; (20c0 <ksz8851_fifo_write_end+0x38>)
    20b0:	2200      	movs	r2, #0
    20b2:	0018      	movs	r0, r3
    20b4:	4b05      	ldr	r3, [pc, #20]	; (20cc <ksz8851_fifo_write_end+0x44>)
    20b6:	4798      	blx	r3
}
    20b8:	46c0      	nop			; (mov r8, r8)
    20ba:	46bd      	mov	sp, r7
    20bc:	b004      	add	sp, #16
    20be:	bd80      	pop	{r7, pc}
    20c0:	20002ddc 	.word	0x20002ddc
    20c4:	000037ed 	.word	0x000037ed
    20c8:	20002e10 	.word	0x20002e10
    20cc:	00003709 	.word	0x00003709

000020d0 <ksz8851_reg_read>:
 * \param reg the register address to modify.
 *
 * \return the register value.
 */
uint16_t ksz8851_reg_read(uint16_t reg)
{
    20d0:	b590      	push	{r4, r7, lr}
    20d2:	b087      	sub	sp, #28
    20d4:	af00      	add	r7, sp, #0
    20d6:	0002      	movs	r2, r0
    20d8:	1dbb      	adds	r3, r7, #6
    20da:	801a      	strh	r2, [r3, #0]
	uint8_t	inbuf[4];
	uint8_t	outbuf[4];
	uint16_t cmd = 0;
    20dc:	2316      	movs	r3, #22
    20de:	18fb      	adds	r3, r7, r3
    20e0:	2200      	movs	r2, #0
    20e2:	801a      	strh	r2, [r3, #0]
	uint16_t res = 0;
    20e4:	2314      	movs	r3, #20
    20e6:	18fb      	adds	r3, r7, r3
    20e8:	2200      	movs	r2, #0
    20ea:	801a      	strh	r2, [r3, #0]

	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, true);
    20ec:	4934      	ldr	r1, [pc, #208]	; (21c0 <ksz8851_reg_read+0xf0>)
    20ee:	4b35      	ldr	r3, [pc, #212]	; (21c4 <ksz8851_reg_read+0xf4>)
    20f0:	2201      	movs	r2, #1
    20f2:	0018      	movs	r0, r3
    20f4:	4b34      	ldr	r3, [pc, #208]	; (21c8 <ksz8851_reg_read+0xf8>)
    20f6:	4798      	blx	r3

	/* Move register address to cmd bits 9-2, make 32-bit address. */
	cmd = (reg << 2) & REG_ADDR_MASK;
    20f8:	1dbb      	adds	r3, r7, #6
    20fa:	881b      	ldrh	r3, [r3, #0]
    20fc:	009b      	lsls	r3, r3, #2
    20fe:	b299      	uxth	r1, r3
    2100:	2316      	movs	r3, #22
    2102:	18fb      	adds	r3, r7, r3
    2104:	22fc      	movs	r2, #252	; 0xfc
    2106:	0092      	lsls	r2, r2, #2
    2108:	400a      	ands	r2, r1
    210a:	801a      	strh	r2, [r3, #0]

	/* Last 2 bits still under "don't care bits" handled with byte enable. */
	/* Select byte enable for command. */
	if (reg & 2) {
    210c:	1dbb      	adds	r3, r7, #6
    210e:	881b      	ldrh	r3, [r3, #0]
    2110:	2202      	movs	r2, #2
    2112:	4013      	ands	r3, r2
    2114:	d009      	beq.n	212a <ksz8851_reg_read+0x5a>
		/* Odd word address writes bytes 2 and 3 */
		cmd |= (0xc << 10);
    2116:	2316      	movs	r3, #22
    2118:	18fb      	adds	r3, r7, r3
    211a:	2216      	movs	r2, #22
    211c:	18ba      	adds	r2, r7, r2
    211e:	8812      	ldrh	r2, [r2, #0]
    2120:	21c0      	movs	r1, #192	; 0xc0
    2122:	0189      	lsls	r1, r1, #6
    2124:	430a      	orrs	r2, r1
    2126:	801a      	strh	r2, [r3, #0]
    2128:	e008      	b.n	213c <ksz8851_reg_read+0x6c>
	} else {
		/* Even word address write bytes 0 and 1 */
		cmd |= (0x3 << 10);
    212a:	2316      	movs	r3, #22
    212c:	18fb      	adds	r3, r7, r3
    212e:	2216      	movs	r2, #22
    2130:	18ba      	adds	r2, r7, r2
    2132:	8812      	ldrh	r2, [r2, #0]
    2134:	21c0      	movs	r1, #192	; 0xc0
    2136:	0109      	lsls	r1, r1, #4
    2138:	430a      	orrs	r2, r1
    213a:	801a      	strh	r2, [r3, #0]
	}

	/* Add command read code. */
	cmd |= CMD_READ;
    213c:	2316      	movs	r3, #22
    213e:	18fb      	adds	r3, r7, r3
    2140:	2216      	movs	r2, #22
    2142:	18ba      	adds	r2, r7, r2
    2144:	8812      	ldrh	r2, [r2, #0]
    2146:	801a      	strh	r2, [r3, #0]
	outbuf[0] = cmd >> 8;
    2148:	2316      	movs	r3, #22
    214a:	18fb      	adds	r3, r7, r3
    214c:	881b      	ldrh	r3, [r3, #0]
    214e:	0a1b      	lsrs	r3, r3, #8
    2150:	b29b      	uxth	r3, r3
    2152:	b2da      	uxtb	r2, r3
    2154:	230c      	movs	r3, #12
    2156:	18fb      	adds	r3, r7, r3
    2158:	701a      	strb	r2, [r3, #0]
	outbuf[1] = cmd & 0xff;
    215a:	2316      	movs	r3, #22
    215c:	18fb      	adds	r3, r7, r3
    215e:	881b      	ldrh	r3, [r3, #0]
    2160:	b2da      	uxtb	r2, r3
    2162:	230c      	movs	r3, #12
    2164:	18fb      	adds	r3, r7, r3
    2166:	705a      	strb	r2, [r3, #1]
	outbuf[2] = 0xff;
    2168:	230c      	movs	r3, #12
    216a:	18fb      	adds	r3, r7, r3
    216c:	22ff      	movs	r2, #255	; 0xff
    216e:	709a      	strb	r2, [r3, #2]
	outbuf[3] = 0xff;
    2170:	230c      	movs	r3, #12
    2172:	18fb      	adds	r3, r7, r3
    2174:	22ff      	movs	r2, #255	; 0xff
    2176:	70da      	strb	r2, [r3, #3]

	/* Perform SPI transfer. */
	spi_transceive_buffer_wait(&ksz8851snl_master, outbuf, inbuf, 4);
    2178:	2310      	movs	r3, #16
    217a:	18fa      	adds	r2, r7, r3
    217c:	230c      	movs	r3, #12
    217e:	18f9      	adds	r1, r7, r3
    2180:	4810      	ldr	r0, [pc, #64]	; (21c4 <ksz8851_reg_read+0xf4>)
    2182:	2304      	movs	r3, #4
    2184:	4c11      	ldr	r4, [pc, #68]	; (21cc <ksz8851_reg_read+0xfc>)
    2186:	47a0      	blx	r4

	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, false);
    2188:	490d      	ldr	r1, [pc, #52]	; (21c0 <ksz8851_reg_read+0xf0>)
    218a:	4b0e      	ldr	r3, [pc, #56]	; (21c4 <ksz8851_reg_read+0xf4>)
    218c:	2200      	movs	r2, #0
    218e:	0018      	movs	r0, r3
    2190:	4b0d      	ldr	r3, [pc, #52]	; (21c8 <ksz8851_reg_read+0xf8>)
    2192:	4798      	blx	r3

	res = (inbuf[3] << 8) | inbuf[2];
    2194:	2310      	movs	r3, #16
    2196:	18fb      	adds	r3, r7, r3
    2198:	78db      	ldrb	r3, [r3, #3]
    219a:	021b      	lsls	r3, r3, #8
    219c:	b21a      	sxth	r2, r3
    219e:	2310      	movs	r3, #16
    21a0:	18fb      	adds	r3, r7, r3
    21a2:	789b      	ldrb	r3, [r3, #2]
    21a4:	b21b      	sxth	r3, r3
    21a6:	4313      	orrs	r3, r2
    21a8:	b21a      	sxth	r2, r3
    21aa:	2314      	movs	r3, #20
    21ac:	18fb      	adds	r3, r7, r3
    21ae:	801a      	strh	r2, [r3, #0]
	return res;
    21b0:	2314      	movs	r3, #20
    21b2:	18fb      	adds	r3, r7, r3
    21b4:	881b      	ldrh	r3, [r3, #0]
}
    21b6:	0018      	movs	r0, r3
    21b8:	46bd      	mov	sp, r7
    21ba:	b007      	add	sp, #28
    21bc:	bd90      	pop	{r4, r7, pc}
    21be:	46c0      	nop			; (mov r8, r8)
    21c0:	20002e10 	.word	0x20002e10
    21c4:	20002ddc 	.word	0x20002ddc
    21c8:	00003709 	.word	0x00003709
    21cc:	00003939 	.word	0x00003939

000021d0 <ksz8851_reg_write>:
 *
 * \param reg the register address to modify.
 * \param wrdata the new register value.
 */
void ksz8851_reg_write(uint16_t reg, uint16_t wrdata)
{
    21d0:	b590      	push	{r4, r7, lr}
    21d2:	b087      	sub	sp, #28
    21d4:	af00      	add	r7, sp, #0
    21d6:	0002      	movs	r2, r0
    21d8:	1dbb      	adds	r3, r7, #6
    21da:	801a      	strh	r2, [r3, #0]
    21dc:	1d3b      	adds	r3, r7, #4
    21de:	1c0a      	adds	r2, r1, #0
    21e0:	801a      	strh	r2, [r3, #0]
	uint8_t	inbuf[4];
	uint8_t	outbuf[4];
	uint16_t cmd = 0;
    21e2:	2316      	movs	r3, #22
    21e4:	18fb      	adds	r3, r7, r3
    21e6:	2200      	movs	r2, #0
    21e8:	801a      	strh	r2, [r3, #0]

	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, true);
    21ea:	4930      	ldr	r1, [pc, #192]	; (22ac <ksz8851_reg_write+0xdc>)
    21ec:	4b30      	ldr	r3, [pc, #192]	; (22b0 <ksz8851_reg_write+0xe0>)
    21ee:	2201      	movs	r2, #1
    21f0:	0018      	movs	r0, r3
    21f2:	4b30      	ldr	r3, [pc, #192]	; (22b4 <ksz8851_reg_write+0xe4>)
    21f4:	4798      	blx	r3

	/* Move register address to cmd bits 9-2, make 32-bit address. */
	cmd = (reg << 2) & REG_ADDR_MASK;
    21f6:	1dbb      	adds	r3, r7, #6
    21f8:	881b      	ldrh	r3, [r3, #0]
    21fa:	009b      	lsls	r3, r3, #2
    21fc:	b299      	uxth	r1, r3
    21fe:	2316      	movs	r3, #22
    2200:	18fb      	adds	r3, r7, r3
    2202:	22fc      	movs	r2, #252	; 0xfc
    2204:	0092      	lsls	r2, r2, #2
    2206:	400a      	ands	r2, r1
    2208:	801a      	strh	r2, [r3, #0]

	/* Last 2 bits still under "don't care bits" handled with byte enable. */
	/* Select byte enable for command. */
	if (reg & 2) {
    220a:	1dbb      	adds	r3, r7, #6
    220c:	881b      	ldrh	r3, [r3, #0]
    220e:	2202      	movs	r2, #2
    2210:	4013      	ands	r3, r2
    2212:	d009      	beq.n	2228 <ksz8851_reg_write+0x58>
		/* Odd word address writes bytes 2 and 3 */
		cmd |= (0xc << 10);
    2214:	2316      	movs	r3, #22
    2216:	18fb      	adds	r3, r7, r3
    2218:	2216      	movs	r2, #22
    221a:	18ba      	adds	r2, r7, r2
    221c:	8812      	ldrh	r2, [r2, #0]
    221e:	21c0      	movs	r1, #192	; 0xc0
    2220:	0189      	lsls	r1, r1, #6
    2222:	430a      	orrs	r2, r1
    2224:	801a      	strh	r2, [r3, #0]
    2226:	e008      	b.n	223a <ksz8851_reg_write+0x6a>
	} else {
		/* Even word address write bytes 0 and 1 */
		cmd |= (0x3 << 10);
    2228:	2316      	movs	r3, #22
    222a:	18fb      	adds	r3, r7, r3
    222c:	2216      	movs	r2, #22
    222e:	18ba      	adds	r2, r7, r2
    2230:	8812      	ldrh	r2, [r2, #0]
    2232:	21c0      	movs	r1, #192	; 0xc0
    2234:	0109      	lsls	r1, r1, #4
    2236:	430a      	orrs	r2, r1
    2238:	801a      	strh	r2, [r3, #0]
	}

	/* Add command write code. */
	cmd |= CMD_WRITE;
    223a:	2316      	movs	r3, #22
    223c:	18fb      	adds	r3, r7, r3
    223e:	2216      	movs	r2, #22
    2240:	18ba      	adds	r2, r7, r2
    2242:	8812      	ldrh	r2, [r2, #0]
    2244:	2180      	movs	r1, #128	; 0x80
    2246:	01c9      	lsls	r1, r1, #7
    2248:	430a      	orrs	r2, r1
    224a:	801a      	strh	r2, [r3, #0]
	outbuf[0] = cmd >> 8;
    224c:	2316      	movs	r3, #22
    224e:	18fb      	adds	r3, r7, r3
    2250:	881b      	ldrh	r3, [r3, #0]
    2252:	0a1b      	lsrs	r3, r3, #8
    2254:	b29b      	uxth	r3, r3
    2256:	b2da      	uxtb	r2, r3
    2258:	230c      	movs	r3, #12
    225a:	18fb      	adds	r3, r7, r3
    225c:	701a      	strb	r2, [r3, #0]
	outbuf[1] = cmd & 0xff;
    225e:	2316      	movs	r3, #22
    2260:	18fb      	adds	r3, r7, r3
    2262:	881b      	ldrh	r3, [r3, #0]
    2264:	b2da      	uxtb	r2, r3
    2266:	230c      	movs	r3, #12
    2268:	18fb      	adds	r3, r7, r3
    226a:	705a      	strb	r2, [r3, #1]
	outbuf[2] = wrdata & 0xff;
    226c:	1d3b      	adds	r3, r7, #4
    226e:	881b      	ldrh	r3, [r3, #0]
    2270:	b2da      	uxtb	r2, r3
    2272:	230c      	movs	r3, #12
    2274:	18fb      	adds	r3, r7, r3
    2276:	709a      	strb	r2, [r3, #2]
	outbuf[3] = wrdata >> 8;
    2278:	1d3b      	adds	r3, r7, #4
    227a:	881b      	ldrh	r3, [r3, #0]
    227c:	0a1b      	lsrs	r3, r3, #8
    227e:	b29b      	uxth	r3, r3
    2280:	b2da      	uxtb	r2, r3
    2282:	230c      	movs	r3, #12
    2284:	18fb      	adds	r3, r7, r3
    2286:	70da      	strb	r2, [r3, #3]

	/* Perform SPI transfer. */
	spi_transceive_buffer_wait(&ksz8851snl_master, outbuf, inbuf, 4);
    2288:	2310      	movs	r3, #16
    228a:	18fa      	adds	r2, r7, r3
    228c:	230c      	movs	r3, #12
    228e:	18f9      	adds	r1, r7, r3
    2290:	4807      	ldr	r0, [pc, #28]	; (22b0 <ksz8851_reg_write+0xe0>)
    2292:	2304      	movs	r3, #4
    2294:	4c08      	ldr	r4, [pc, #32]	; (22b8 <ksz8851_reg_write+0xe8>)
    2296:	47a0      	blx	r4

	spi_select_slave(&ksz8851snl_master, &ksz8851snl_slave, false);
    2298:	4904      	ldr	r1, [pc, #16]	; (22ac <ksz8851_reg_write+0xdc>)
    229a:	4b05      	ldr	r3, [pc, #20]	; (22b0 <ksz8851_reg_write+0xe0>)
    229c:	2200      	movs	r2, #0
    229e:	0018      	movs	r0, r3
    22a0:	4b04      	ldr	r3, [pc, #16]	; (22b4 <ksz8851_reg_write+0xe4>)
    22a2:	4798      	blx	r3
}
    22a4:	46c0      	nop			; (mov r8, r8)
    22a6:	46bd      	mov	sp, r7
    22a8:	b007      	add	sp, #28
    22aa:	bd90      	pop	{r4, r7, pc}
    22ac:	20002e10 	.word	0x20002e10
    22b0:	20002ddc 	.word	0x20002ddc
    22b4:	00003709 	.word	0x00003709
    22b8:	00003939 	.word	0x00003939

000022bc <ksz8851_reg_setbits>:
 *
 * \param reg the register address to modify.
 * \param bits_to_set bitmask to apply.
 */
void ksz8851_reg_setbits(uint16_t reg, uint16_t bits_to_set)
{
    22bc:	b590      	push	{r4, r7, lr}
    22be:	b085      	sub	sp, #20
    22c0:	af00      	add	r7, sp, #0
    22c2:	0002      	movs	r2, r0
    22c4:	1dbb      	adds	r3, r7, #6
    22c6:	801a      	strh	r2, [r3, #0]
    22c8:	1d3b      	adds	r3, r7, #4
    22ca:	1c0a      	adds	r2, r1, #0
    22cc:	801a      	strh	r2, [r3, #0]
   uint16_t	temp;

   temp = ksz8851_reg_read(reg);
    22ce:	230e      	movs	r3, #14
    22d0:	18fc      	adds	r4, r7, r3
    22d2:	1dbb      	adds	r3, r7, #6
    22d4:	881b      	ldrh	r3, [r3, #0]
    22d6:	0018      	movs	r0, r3
    22d8:	4b0c      	ldr	r3, [pc, #48]	; (230c <ksz8851_reg_setbits+0x50>)
    22da:	4798      	blx	r3
    22dc:	0003      	movs	r3, r0
    22de:	8023      	strh	r3, [r4, #0]
   temp |= bits_to_set;
    22e0:	230e      	movs	r3, #14
    22e2:	18fb      	adds	r3, r7, r3
    22e4:	220e      	movs	r2, #14
    22e6:	18b9      	adds	r1, r7, r2
    22e8:	1d3a      	adds	r2, r7, #4
    22ea:	8809      	ldrh	r1, [r1, #0]
    22ec:	8812      	ldrh	r2, [r2, #0]
    22ee:	430a      	orrs	r2, r1
    22f0:	801a      	strh	r2, [r3, #0]
   ksz8851_reg_write(reg, temp);
    22f2:	230e      	movs	r3, #14
    22f4:	18fb      	adds	r3, r7, r3
    22f6:	881a      	ldrh	r2, [r3, #0]
    22f8:	1dbb      	adds	r3, r7, #6
    22fa:	881b      	ldrh	r3, [r3, #0]
    22fc:	0011      	movs	r1, r2
    22fe:	0018      	movs	r0, r3
    2300:	4b03      	ldr	r3, [pc, #12]	; (2310 <ksz8851_reg_setbits+0x54>)
    2302:	4798      	blx	r3
}
    2304:	46c0      	nop			; (mov r8, r8)
    2306:	46bd      	mov	sp, r7
    2308:	b005      	add	sp, #20
    230a:	bd90      	pop	{r4, r7, pc}
    230c:	000020d1 	.word	0x000020d1
    2310:	000021d1 	.word	0x000021d1

00002314 <ksz8851_reg_clrbits>:
 *
 * \param reg the register address to modify.
 * \param bits_to_set bitmask to apply.
 */
void ksz8851_reg_clrbits(uint16_t reg, uint16_t bits_to_clr)
{
    2314:	b590      	push	{r4, r7, lr}
    2316:	b085      	sub	sp, #20
    2318:	af00      	add	r7, sp, #0
    231a:	0002      	movs	r2, r0
    231c:	1dbb      	adds	r3, r7, #6
    231e:	801a      	strh	r2, [r3, #0]
    2320:	1d3b      	adds	r3, r7, #4
    2322:	1c0a      	adds	r2, r1, #0
    2324:	801a      	strh	r2, [r3, #0]
   uint16_t	temp;

   temp = ksz8851_reg_read(reg);
    2326:	230e      	movs	r3, #14
    2328:	18fc      	adds	r4, r7, r3
    232a:	1dbb      	adds	r3, r7, #6
    232c:	881b      	ldrh	r3, [r3, #0]
    232e:	0018      	movs	r0, r3
    2330:	4b0d      	ldr	r3, [pc, #52]	; (2368 <ksz8851_reg_clrbits+0x54>)
    2332:	4798      	blx	r3
    2334:	0003      	movs	r3, r0
    2336:	8023      	strh	r3, [r4, #0]
   temp &= ~(uint32_t) bits_to_clr;
    2338:	1d3b      	adds	r3, r7, #4
    233a:	881b      	ldrh	r3, [r3, #0]
    233c:	43db      	mvns	r3, r3
    233e:	b29a      	uxth	r2, r3
    2340:	230e      	movs	r3, #14
    2342:	18fb      	adds	r3, r7, r3
    2344:	210e      	movs	r1, #14
    2346:	1879      	adds	r1, r7, r1
    2348:	8809      	ldrh	r1, [r1, #0]
    234a:	400a      	ands	r2, r1
    234c:	801a      	strh	r2, [r3, #0]
   ksz8851_reg_write(reg, temp);
    234e:	230e      	movs	r3, #14
    2350:	18fb      	adds	r3, r7, r3
    2352:	881a      	ldrh	r2, [r3, #0]
    2354:	1dbb      	adds	r3, r7, #6
    2356:	881b      	ldrh	r3, [r3, #0]
    2358:	0011      	movs	r1, r2
    235a:	0018      	movs	r0, r3
    235c:	4b03      	ldr	r3, [pc, #12]	; (236c <ksz8851_reg_clrbits+0x58>)
    235e:	4798      	blx	r3
}
    2360:	46c0      	nop			; (mov r8, r8)
    2362:	46bd      	mov	sp, r7
    2364:	b005      	add	sp, #20
    2366:	bd90      	pop	{r4, r7, pc}
    2368:	000020d1 	.word	0x000020d1
    236c:	000021d1 	.word	0x000021d1

00002370 <ksz8851snl_init>:
 * Call this function to initialize the hardware interface and the PHY
 * controller. When initialization is done the PHY is turned on and ready
 * to receive data.
 */
uint32_t ksz8851snl_init(void)
{
    2370:	b590      	push	{r4, r7, lr}
    2372:	b083      	sub	sp, #12
    2374:	af00      	add	r7, sp, #0
	uint32_t count = 0;
    2376:	2300      	movs	r3, #0
    2378:	607b      	str	r3, [r7, #4]
	uint16_t dev_id = 0;
    237a:	1cbb      	adds	r3, r7, #2
    237c:	2200      	movs	r2, #0
    237e:	801a      	strh	r2, [r3, #0]

	/* Initialize delay routine. */
	delay_init();
    2380:	4b3e      	ldr	r3, [pc, #248]	; (247c <ksz8851snl_init+0x10c>)
    2382:	4798      	blx	r3

	/* Initialize the SPI interface. */
	ksz8851snl_interface_init();
    2384:	4b3e      	ldr	r3, [pc, #248]	; (2480 <ksz8851snl_init+0x110>)
    2386:	4798      	blx	r3

	/* Reset the Micrel in a proper state. */
	do {
		ksz8851snl_hard_reset();
    2388:	4b3e      	ldr	r3, [pc, #248]	; (2484 <ksz8851snl_init+0x114>)
    238a:	4798      	blx	r3

		/* Init step1: read chip ID. */
		dev_id = ksz8851_reg_read(REG_CHIP_ID);
    238c:	1cbc      	adds	r4, r7, #2
    238e:	20c0      	movs	r0, #192	; 0xc0
    2390:	4b3d      	ldr	r3, [pc, #244]	; (2488 <ksz8851snl_init+0x118>)
    2392:	4798      	blx	r3
    2394:	0003      	movs	r3, r0
    2396:	8023      	strh	r3, [r4, #0]
		if (++count > 10)
    2398:	687b      	ldr	r3, [r7, #4]
    239a:	3301      	adds	r3, #1
    239c:	607b      	str	r3, [r7, #4]
    239e:	687b      	ldr	r3, [r7, #4]
    23a0:	2b0a      	cmp	r3, #10
    23a2:	d901      	bls.n	23a8 <ksz8851snl_init+0x38>
			return 1;
    23a4:	2301      	movs	r3, #1
    23a6:	e064      	b.n	2472 <ksz8851snl_init+0x102>
	} while ((dev_id & 0xFFF0) != CHIP_ID_8851_16);
    23a8:	1cbb      	adds	r3, r7, #2
    23aa:	881b      	ldrh	r3, [r3, #0]
    23ac:	4a37      	ldr	r2, [pc, #220]	; (248c <ksz8851snl_init+0x11c>)
    23ae:	4013      	ands	r3, r2
    23b0:	4a37      	ldr	r2, [pc, #220]	; (2490 <ksz8851snl_init+0x120>)
    23b2:	4293      	cmp	r3, r2
    23b4:	d1e8      	bne.n	2388 <ksz8851snl_init+0x18>

	/* Init step2-4: write QMU MAC address (low, middle then high). */
	ksz8851_reg_write(REG_MAC_ADDR_0, (ETHERNET_CONF_ETHADDR4 << 8) | ETHERNET_CONF_ETHADDR5);
    23b6:	4b37      	ldr	r3, [pc, #220]	; (2494 <ksz8851snl_init+0x124>)
    23b8:	0019      	movs	r1, r3
    23ba:	2010      	movs	r0, #16
    23bc:	4b36      	ldr	r3, [pc, #216]	; (2498 <ksz8851snl_init+0x128>)
    23be:	4798      	blx	r3
	ksz8851_reg_write(REG_MAC_ADDR_2, (ETHERNET_CONF_ETHADDR2 << 8) | ETHERNET_CONF_ETHADDR3);
    23c0:	4b36      	ldr	r3, [pc, #216]	; (249c <ksz8851snl_init+0x12c>)
    23c2:	0019      	movs	r1, r3
    23c4:	2012      	movs	r0, #18
    23c6:	4b34      	ldr	r3, [pc, #208]	; (2498 <ksz8851snl_init+0x128>)
    23c8:	4798      	blx	r3
	ksz8851_reg_write(REG_MAC_ADDR_4, (ETHERNET_CONF_ETHADDR0 << 8) | ETHERNET_CONF_ETHADDR1);
    23ca:	2104      	movs	r1, #4
    23cc:	2014      	movs	r0, #20
    23ce:	4b32      	ldr	r3, [pc, #200]	; (2498 <ksz8851snl_init+0x128>)
    23d0:	4798      	blx	r3

	/* Init step5: enable QMU Transmit Frame Data Pointer Auto Increment. */
	ksz8851_reg_write(REG_TX_ADDR_PTR, ADDR_PTR_AUTO_INC);
    23d2:	2380      	movs	r3, #128	; 0x80
    23d4:	01db      	lsls	r3, r3, #7
    23d6:	0019      	movs	r1, r3
    23d8:	2084      	movs	r0, #132	; 0x84
    23da:	4b2f      	ldr	r3, [pc, #188]	; (2498 <ksz8851snl_init+0x128>)
    23dc:	4798      	blx	r3

	/* Init step6: configure QMU transmit control register. */
	ksz8851_reg_write(REG_TX_CTRL,
    23de:	23f7      	movs	r3, #247	; 0xf7
    23e0:	005b      	lsls	r3, r3, #1
    23e2:	0019      	movs	r1, r3
    23e4:	2070      	movs	r0, #112	; 0x70
    23e6:	4b2c      	ldr	r3, [pc, #176]	; (2498 <ksz8851snl_init+0x128>)
    23e8:	4798      	blx	r3
			TX_CTRL_PAD_ENABLE |
			TX_CTRL_CRC_ENABLE
		);

	/* Init step7: enable QMU Receive Frame Data Pointer Auto Increment. */
	ksz8851_reg_write(REG_RX_ADDR_PTR, ADDR_PTR_AUTO_INC);
    23ea:	2380      	movs	r3, #128	; 0x80
    23ec:	01db      	lsls	r3, r3, #7
    23ee:	0019      	movs	r1, r3
    23f0:	2086      	movs	r0, #134	; 0x86
    23f2:	4b29      	ldr	r3, [pc, #164]	; (2498 <ksz8851snl_init+0x128>)
    23f4:	4798      	blx	r3

	/* Init step8: configure QMU Receive Frame Threshold for one frame. */
	ksz8851_reg_write(REG_RX_FRAME_CNT_THRES, 1);
    23f6:	2101      	movs	r1, #1
    23f8:	209c      	movs	r0, #156	; 0x9c
    23fa:	4b27      	ldr	r3, [pc, #156]	; (2498 <ksz8851snl_init+0x128>)
    23fc:	4798      	blx	r3

	/* Init step9: configure QMU receive control register1. */
	ksz8851_reg_write(REG_RX_CTRL1,
    23fe:	4b28      	ldr	r3, [pc, #160]	; (24a0 <ksz8851snl_init+0x130>)
    2400:	0019      	movs	r1, r3
    2402:	2074      	movs	r0, #116	; 0x74
    2404:	4b24      	ldr	r3, [pc, #144]	; (2498 <ksz8851snl_init+0x128>)
    2406:	4798      	blx	r3
			RX_CTRL_BROADCAST |
			RX_CTRL_ALL_MULTICAST|
			RX_CTRL_UNICAST);

	/* Init step10: configure QMU receive control register2. */
	ksz8851_reg_write(REG_RX_CTRL2,
    2408:	2196      	movs	r1, #150	; 0x96
    240a:	2076      	movs	r0, #118	; 0x76
    240c:	4b22      	ldr	r3, [pc, #136]	; (2498 <ksz8851snl_init+0x128>)
    240e:	4798      	blx	r3
			RX_CTRL_UDP_LITE_CHECKSUM |
            RX_CTRL_ICMP_CHECKSUM |
			RX_CTRL_BURST_LEN_FRAME);

	/* Init step11: configure QMU receive queue: trigger INT and auto-dequeue frame. */
	ksz8851_reg_write(REG_RXQ_CMD, RXQ_CMD_CNTL | RXQ_TWOBYTE_OFFSET);
    2410:	238c      	movs	r3, #140	; 0x8c
    2412:	009b      	lsls	r3, r3, #2
    2414:	0019      	movs	r1, r3
    2416:	2082      	movs	r0, #130	; 0x82
    2418:	4b1f      	ldr	r3, [pc, #124]	; (2498 <ksz8851snl_init+0x128>)
    241a:	4798      	blx	r3

	/* Init step12: adjust SPI data output delay. */
	ksz8851_reg_write(REG_BUS_CLOCK_CTRL, BUS_CLOCK_166 | BUS_CLOCK_DIVIDEDBY_1);
    241c:	2104      	movs	r1, #4
    241e:	2020      	movs	r0, #32
    2420:	4b1d      	ldr	r3, [pc, #116]	; (2498 <ksz8851snl_init+0x128>)
    2422:	4798      	blx	r3

	/* Init step13: restart auto-negotiation. */
	ksz8851_reg_setbits(REG_PORT_CTRL, PORT_AUTO_NEG_RESTART);
    2424:	2380      	movs	r3, #128	; 0x80
    2426:	019b      	lsls	r3, r3, #6
    2428:	0019      	movs	r1, r3
    242a:	20f6      	movs	r0, #246	; 0xf6
    242c:	4b1d      	ldr	r3, [pc, #116]	; (24a4 <ksz8851snl_init+0x134>)
    242e:	4798      	blx	r3

	/* Init step13.1: force link in half duplex if auto-negotiation failed. */
	if ((ksz8851_reg_read(REG_PORT_CTRL) & PORT_AUTO_NEG_RESTART) != PORT_AUTO_NEG_RESTART)
    2430:	20f6      	movs	r0, #246	; 0xf6
    2432:	4b15      	ldr	r3, [pc, #84]	; (2488 <ksz8851snl_init+0x118>)
    2434:	4798      	blx	r3
    2436:	0003      	movs	r3, r0
    2438:	001a      	movs	r2, r3
    243a:	2380      	movs	r3, #128	; 0x80
    243c:	019b      	lsls	r3, r3, #6
    243e:	4013      	ands	r3, r2
    2440:	d103      	bne.n	244a <ksz8851snl_init+0xda>
	{
		ksz8851_reg_clrbits(REG_PORT_CTRL, PORT_FORCE_FULL_DUPLEX);
    2442:	2120      	movs	r1, #32
    2444:	20f6      	movs	r0, #246	; 0xf6
    2446:	4b18      	ldr	r3, [pc, #96]	; (24a8 <ksz8851snl_init+0x138>)
    2448:	4798      	blx	r3
	}

	/* Init step14: clear interrupt status. */
	ksz8851_reg_write(REG_INT_STATUS, 0xFFFF);
    244a:	4b18      	ldr	r3, [pc, #96]	; (24ac <ksz8851snl_init+0x13c>)
    244c:	0019      	movs	r1, r3
    244e:	2092      	movs	r0, #146	; 0x92
    2450:	4b11      	ldr	r3, [pc, #68]	; (2498 <ksz8851snl_init+0x128>)
    2452:	4798      	blx	r3

	/* Init step15: set interrupt mask. */
	ksz8851_reg_write(REG_INT_MASK, INT_RX);
    2454:	2380      	movs	r3, #128	; 0x80
    2456:	019b      	lsls	r3, r3, #6
    2458:	0019      	movs	r1, r3
    245a:	2090      	movs	r0, #144	; 0x90
    245c:	4b0e      	ldr	r3, [pc, #56]	; (2498 <ksz8851snl_init+0x128>)
    245e:	4798      	blx	r3

	/* Init step16: enable QMU Transmit. */
	ksz8851_reg_setbits(REG_TX_CTRL, TX_CTRL_ENABLE);
    2460:	2101      	movs	r1, #1
    2462:	2070      	movs	r0, #112	; 0x70
    2464:	4b0f      	ldr	r3, [pc, #60]	; (24a4 <ksz8851snl_init+0x134>)
    2466:	4798      	blx	r3

	/* Init step17: enable QMU Receive. */
	ksz8851_reg_setbits(REG_RX_CTRL1, RX_CTRL_ENABLE);
    2468:	2101      	movs	r1, #1
    246a:	2074      	movs	r0, #116	; 0x74
    246c:	4b0d      	ldr	r3, [pc, #52]	; (24a4 <ksz8851snl_init+0x134>)
    246e:	4798      	blx	r3

	return 0;
    2470:	2300      	movs	r3, #0
}
    2472:	0018      	movs	r0, r3
    2474:	46bd      	mov	sp, r7
    2476:	b003      	add	sp, #12
    2478:	bd90      	pop	{r4, r7, pc}
    247a:	46c0      	nop			; (mov r8, r8)
    247c:	000018d5 	.word	0x000018d5
    2480:	00001de1 	.word	0x00001de1
    2484:	00001ea9 	.word	0x00001ea9
    2488:	000020d1 	.word	0x000020d1
    248c:	0000fff0 	.word	0x0000fff0
    2490:	00008870 	.word	0x00008870
    2494:	00001c3b 	.word	0x00001c3b
    2498:	000021d1 	.word	0x000021d1
    249c:	00002519 	.word	0x00002519
    24a0:	00007ce0 	.word	0x00007ce0
    24a4:	000022bd 	.word	0x000022bd
    24a8:	00002315 	.word	0x00002315
    24ac:	0000ffff 	.word	0x0000ffff

000024b0 <_extint_get_eic_from_channel>:
 *
 * \return Base address of the associated EIC module.
 */
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
    24b0:	b580      	push	{r7, lr}
    24b2:	b084      	sub	sp, #16
    24b4:	af00      	add	r7, sp, #0
    24b6:	0002      	movs	r2, r0
    24b8:	1dfb      	adds	r3, r7, #7
    24ba:	701a      	strb	r2, [r3, #0]
	uint8_t eic_index = (channel / 32);
    24bc:	230f      	movs	r3, #15
    24be:	18fb      	adds	r3, r7, r3
    24c0:	1dfa      	adds	r2, r7, #7
    24c2:	7812      	ldrb	r2, [r2, #0]
    24c4:	0952      	lsrs	r2, r2, #5
    24c6:	701a      	strb	r2, [r3, #0]

	if (eic_index < EIC_INST_NUM) {
    24c8:	230f      	movs	r3, #15
    24ca:	18fb      	adds	r3, r7, r3
    24cc:	781b      	ldrb	r3, [r3, #0]
    24ce:	2b00      	cmp	r3, #0
    24d0:	d10c      	bne.n	24ec <_extint_get_eic_from_channel+0x3c>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    24d2:	4b09      	ldr	r3, [pc, #36]	; (24f8 <_extint_get_eic_from_channel+0x48>)
    24d4:	60bb      	str	r3, [r7, #8]

		return eics[eic_index];
    24d6:	230f      	movs	r3, #15
    24d8:	18fb      	adds	r3, r7, r3
    24da:	781b      	ldrb	r3, [r3, #0]
    24dc:	009b      	lsls	r3, r3, #2
    24de:	2210      	movs	r2, #16
    24e0:	4694      	mov	ip, r2
    24e2:	44bc      	add	ip, r7
    24e4:	4463      	add	r3, ip
    24e6:	3b08      	subs	r3, #8
    24e8:	681b      	ldr	r3, [r3, #0]
    24ea:	e000      	b.n	24ee <_extint_get_eic_from_channel+0x3e>
	} else {
		Assert(false);
		return NULL;
    24ec:	2300      	movs	r3, #0
	}
}
    24ee:	0018      	movs	r0, r3
    24f0:	46bd      	mov	sp, r7
    24f2:	b004      	add	sp, #16
    24f4:	bd80      	pop	{r7, pc}
    24f6:	46c0      	nop			; (mov r8, r8)
    24f8:	40001800 	.word	0x40001800

000024fc <extint_chan_is_detected>:
 *  \retval true   If the channel's edge/level detection criteria was met
 *  \retval false  If the channel has not detected its configured criteria
 */
static inline bool extint_chan_is_detected(
		const uint8_t channel)
{
    24fc:	b580      	push	{r7, lr}
    24fe:	b084      	sub	sp, #16
    2500:	af00      	add	r7, sp, #0
    2502:	0002      	movs	r2, r0
    2504:	1dfb      	adds	r3, r7, #7
    2506:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
    2508:	1dfb      	adds	r3, r7, #7
    250a:	781b      	ldrb	r3, [r3, #0]
    250c:	0018      	movs	r0, r3
    250e:	4b0b      	ldr	r3, [pc, #44]	; (253c <extint_chan_is_detected+0x40>)
    2510:	4798      	blx	r3
    2512:	0003      	movs	r3, r0
    2514:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
    2516:	1dfb      	adds	r3, r7, #7
    2518:	781b      	ldrb	r3, [r3, #0]
    251a:	221f      	movs	r2, #31
    251c:	4013      	ands	r3, r2
    251e:	2201      	movs	r2, #1
    2520:	409a      	lsls	r2, r3
    2522:	0013      	movs	r3, r2
    2524:	60bb      	str	r3, [r7, #8]

	return (eic_module->INTFLAG.reg & eic_mask);
    2526:	68fb      	ldr	r3, [r7, #12]
    2528:	691b      	ldr	r3, [r3, #16]
    252a:	68ba      	ldr	r2, [r7, #8]
    252c:	4013      	ands	r3, r2
    252e:	1e5a      	subs	r2, r3, #1
    2530:	4193      	sbcs	r3, r2
    2532:	b2db      	uxtb	r3, r3
}
    2534:	0018      	movs	r0, r3
    2536:	46bd      	mov	sp, r7
    2538:	b004      	add	sp, #16
    253a:	bd80      	pop	{r7, pc}
    253c:	000024b1 	.word	0x000024b1

00002540 <extint_chan_clear_detected>:
 *
 *  \param[in] channel  External Interrupt channel index to check
 */
static inline void extint_chan_clear_detected(
		const uint8_t channel)
{
    2540:	b580      	push	{r7, lr}
    2542:	b084      	sub	sp, #16
    2544:	af00      	add	r7, sp, #0
    2546:	0002      	movs	r2, r0
    2548:	1dfb      	adds	r3, r7, #7
    254a:	701a      	strb	r2, [r3, #0]
	Eic *const eic_module = _extint_get_eic_from_channel(channel);
    254c:	1dfb      	adds	r3, r7, #7
    254e:	781b      	ldrb	r3, [r3, #0]
    2550:	0018      	movs	r0, r3
    2552:	4b09      	ldr	r3, [pc, #36]	; (2578 <extint_chan_clear_detected+0x38>)
    2554:	4798      	blx	r3
    2556:	0003      	movs	r3, r0
    2558:	60fb      	str	r3, [r7, #12]
	uint32_t eic_mask   = (1UL << (channel % 32));
    255a:	1dfb      	adds	r3, r7, #7
    255c:	781b      	ldrb	r3, [r3, #0]
    255e:	221f      	movs	r2, #31
    2560:	4013      	ands	r3, r2
    2562:	2201      	movs	r2, #1
    2564:	409a      	lsls	r2, r3
    2566:	0013      	movs	r3, r2
    2568:	60bb      	str	r3, [r7, #8]

	eic_module->INTFLAG.reg = eic_mask;
    256a:	68fb      	ldr	r3, [r7, #12]
    256c:	68ba      	ldr	r2, [r7, #8]
    256e:	611a      	str	r2, [r3, #16]
}
    2570:	46c0      	nop			; (mov r8, r8)
    2572:	46bd      	mov	sp, r7
    2574:	b004      	add	sp, #16
    2576:	bd80      	pop	{r7, pc}
    2578:	000024b1 	.word	0x000024b1

0000257c <extint_register_callback>:
 */
enum status_code extint_register_callback(
	const extint_callback_t callback,
	const uint8_t channel,
	const enum extint_callback_type type)
{
    257c:	b580      	push	{r7, lr}
    257e:	b082      	sub	sp, #8
    2580:	af00      	add	r7, sp, #0
    2582:	6078      	str	r0, [r7, #4]
    2584:	0008      	movs	r0, r1
    2586:	0011      	movs	r1, r2
    2588:	1cfb      	adds	r3, r7, #3
    258a:	1c02      	adds	r2, r0, #0
    258c:	701a      	strb	r2, [r3, #0]
    258e:	1cbb      	adds	r3, r7, #2
    2590:	1c0a      	adds	r2, r1, #0
    2592:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(callback);

	if (type != EXTINT_CALLBACK_TYPE_DETECT) {
    2594:	1cbb      	adds	r3, r7, #2
    2596:	781b      	ldrb	r3, [r3, #0]
    2598:	2b00      	cmp	r3, #0
    259a:	d001      	beq.n	25a0 <extint_register_callback+0x24>
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    259c:	2317      	movs	r3, #23
    259e:	e019      	b.n	25d4 <extint_register_callback+0x58>
	}

	if (_extint_dev.callbacks[channel] == NULL) {
    25a0:	1cfb      	adds	r3, r7, #3
    25a2:	781a      	ldrb	r2, [r3, #0]
    25a4:	4b0d      	ldr	r3, [pc, #52]	; (25dc <extint_register_callback+0x60>)
    25a6:	0092      	lsls	r2, r2, #2
    25a8:	58d3      	ldr	r3, [r2, r3]
    25aa:	2b00      	cmp	r3, #0
    25ac:	d107      	bne.n	25be <extint_register_callback+0x42>
		_extint_dev.callbacks[channel] = callback;
    25ae:	1cfb      	adds	r3, r7, #3
    25b0:	781a      	ldrb	r2, [r3, #0]
    25b2:	4b0a      	ldr	r3, [pc, #40]	; (25dc <extint_register_callback+0x60>)
    25b4:	0092      	lsls	r2, r2, #2
    25b6:	6879      	ldr	r1, [r7, #4]
    25b8:	50d1      	str	r1, [r2, r3]
		return STATUS_OK;
    25ba:	2300      	movs	r3, #0
    25bc:	e00a      	b.n	25d4 <extint_register_callback+0x58>
	} else if (_extint_dev.callbacks[channel] == callback) {
    25be:	1cfb      	adds	r3, r7, #3
    25c0:	781a      	ldrb	r2, [r3, #0]
    25c2:	4b06      	ldr	r3, [pc, #24]	; (25dc <extint_register_callback+0x60>)
    25c4:	0092      	lsls	r2, r2, #2
    25c6:	58d2      	ldr	r2, [r2, r3]
    25c8:	687b      	ldr	r3, [r7, #4]
    25ca:	429a      	cmp	r2, r3
    25cc:	d101      	bne.n	25d2 <extint_register_callback+0x56>
		return STATUS_OK;
    25ce:	2300      	movs	r3, #0
    25d0:	e000      	b.n	25d4 <extint_register_callback+0x58>
	}

	return STATUS_ERR_ALREADY_INITIALIZED;
    25d2:	231d      	movs	r3, #29
}
    25d4:	0018      	movs	r0, r3
    25d6:	46bd      	mov	sp, r7
    25d8:	b002      	add	sp, #8
    25da:	bd80      	pop	{r7, pc}
    25dc:	20002e14 	.word	0x20002e14

000025e0 <extint_chan_enable_callback>:
 * \retval STATUS_ERR_INVALID_ARG  If an invalid callback type was supplied
 */
enum status_code extint_chan_enable_callback(
	const uint8_t channel,
	const enum extint_callback_type type)
{
    25e0:	b580      	push	{r7, lr}
    25e2:	b084      	sub	sp, #16
    25e4:	af00      	add	r7, sp, #0
    25e6:	0002      	movs	r2, r0
    25e8:	1dfb      	adds	r3, r7, #7
    25ea:	701a      	strb	r2, [r3, #0]
    25ec:	1dbb      	adds	r3, r7, #6
    25ee:	1c0a      	adds	r2, r1, #0
    25f0:	701a      	strb	r2, [r3, #0]
	if (type == EXTINT_CALLBACK_TYPE_DETECT) {
    25f2:	1dbb      	adds	r3, r7, #6
    25f4:	781b      	ldrb	r3, [r3, #0]
    25f6:	2b00      	cmp	r3, #0
    25f8:	d10e      	bne.n	2618 <extint_chan_enable_callback+0x38>
		Eic *const eic = _extint_get_eic_from_channel(channel);
    25fa:	1dfb      	adds	r3, r7, #7
    25fc:	781b      	ldrb	r3, [r3, #0]
    25fe:	0018      	movs	r0, r3
    2600:	4b08      	ldr	r3, [pc, #32]	; (2624 <extint_chan_enable_callback+0x44>)
    2602:	4798      	blx	r3
    2604:	0003      	movs	r3, r0
    2606:	60fb      	str	r3, [r7, #12]

		eic->INTENSET.reg = (1UL << channel);
    2608:	1dfb      	adds	r3, r7, #7
    260a:	781b      	ldrb	r3, [r3, #0]
    260c:	2201      	movs	r2, #1
    260e:	409a      	lsls	r2, r3
    2610:	68fb      	ldr	r3, [r7, #12]
    2612:	60da      	str	r2, [r3, #12]
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
	}

	return STATUS_OK;
    2614:	2300      	movs	r3, #0
    2616:	e000      	b.n	261a <extint_chan_enable_callback+0x3a>

		eic->INTENSET.reg = (1UL << channel);
	}
	else {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    2618:	2317      	movs	r3, #23
	}

	return STATUS_OK;
}
    261a:	0018      	movs	r0, r3
    261c:	46bd      	mov	sp, r7
    261e:	b004      	add	sp, #16
    2620:	bd80      	pop	{r7, pc}
    2622:	46c0      	nop			; (mov r8, r8)
    2624:	000024b1 	.word	0x000024b1

00002628 <EIC_Handler>:
	return _current_channel;
}

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
    2628:	b580      	push	{r7, lr}
    262a:	af00      	add	r7, sp, #0
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    262c:	4b15      	ldr	r3, [pc, #84]	; (2684 <EIC_Handler+0x5c>)
    262e:	2200      	movs	r2, #0
    2630:	701a      	strb	r2, [r3, #0]
    2632:	e020      	b.n	2676 <EIC_Handler+0x4e>
		if (extint_chan_is_detected(_current_channel)) {
    2634:	4b13      	ldr	r3, [pc, #76]	; (2684 <EIC_Handler+0x5c>)
    2636:	781b      	ldrb	r3, [r3, #0]
    2638:	0018      	movs	r0, r3
    263a:	4b13      	ldr	r3, [pc, #76]	; (2688 <EIC_Handler+0x60>)
    263c:	4798      	blx	r3
    263e:	1e03      	subs	r3, r0, #0
    2640:	d013      	beq.n	266a <EIC_Handler+0x42>
			/* Clear flag */
			extint_chan_clear_detected(_current_channel);
    2642:	4b10      	ldr	r3, [pc, #64]	; (2684 <EIC_Handler+0x5c>)
    2644:	781b      	ldrb	r3, [r3, #0]
    2646:	0018      	movs	r0, r3
    2648:	4b10      	ldr	r3, [pc, #64]	; (268c <EIC_Handler+0x64>)
    264a:	4798      	blx	r3
			/* Find any associated callback entries in the callback table */
			if (_extint_dev.callbacks[_current_channel] != NULL) {
    264c:	4b0d      	ldr	r3, [pc, #52]	; (2684 <EIC_Handler+0x5c>)
    264e:	781b      	ldrb	r3, [r3, #0]
    2650:	001a      	movs	r2, r3
    2652:	4b0f      	ldr	r3, [pc, #60]	; (2690 <EIC_Handler+0x68>)
    2654:	0092      	lsls	r2, r2, #2
    2656:	58d3      	ldr	r3, [r2, r3]
    2658:	2b00      	cmp	r3, #0
    265a:	d006      	beq.n	266a <EIC_Handler+0x42>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
    265c:	4b09      	ldr	r3, [pc, #36]	; (2684 <EIC_Handler+0x5c>)
    265e:	781b      	ldrb	r3, [r3, #0]
    2660:	001a      	movs	r2, r3
    2662:	4b0b      	ldr	r3, [pc, #44]	; (2690 <EIC_Handler+0x68>)
    2664:	0092      	lsls	r2, r2, #2
    2666:	58d3      	ldr	r3, [r2, r3]
    2668:	4798      	blx	r3

/** Handler for the EXTINT hardware module interrupt. */
void EIC_Handler(void)
{
	/* Find any triggered channels, run associated callback handlers */
	for (_current_channel = 0; _current_channel < EIC_NUMBER_OF_INTERRUPTS ; _current_channel++) {
    266a:	4b06      	ldr	r3, [pc, #24]	; (2684 <EIC_Handler+0x5c>)
    266c:	781b      	ldrb	r3, [r3, #0]
    266e:	3301      	adds	r3, #1
    2670:	b2da      	uxtb	r2, r3
    2672:	4b04      	ldr	r3, [pc, #16]	; (2684 <EIC_Handler+0x5c>)
    2674:	701a      	strb	r2, [r3, #0]
    2676:	4b03      	ldr	r3, [pc, #12]	; (2684 <EIC_Handler+0x5c>)
    2678:	781b      	ldrb	r3, [r3, #0]
    267a:	2b0f      	cmp	r3, #15
    267c:	d9da      	bls.n	2634 <EIC_Handler+0xc>
				/* Run the registered callback */
				_extint_dev.callbacks[_current_channel]();
			}
		}
	}
}
    267e:	46c0      	nop			; (mov r8, r8)
    2680:	46bd      	mov	sp, r7
    2682:	bd80      	pop	{r7, pc}
    2684:	20002e13 	.word	0x20002e13
    2688:	000024fd 	.word	0x000024fd
    268c:	00002541 	.word	0x00002541
    2690:	20002e14 	.word	0x20002e14

00002694 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    2694:	b580      	push	{r7, lr}
    2696:	b082      	sub	sp, #8
    2698:	af00      	add	r7, sp, #0
    269a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    269c:	687b      	ldr	r3, [r7, #4]
    269e:	2200      	movs	r2, #0
    26a0:	701a      	strb	r2, [r3, #0]
}
    26a2:	46c0      	nop			; (mov r8, r8)
    26a4:	46bd      	mov	sp, r7
    26a6:	b002      	add	sp, #8
    26a8:	bd80      	pop	{r7, pc}
    26aa:	46c0      	nop			; (mov r8, r8)

000026ac <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    26ac:	b580      	push	{r7, lr}
    26ae:	b082      	sub	sp, #8
    26b0:	af00      	add	r7, sp, #0
    26b2:	0002      	movs	r2, r0
    26b4:	6039      	str	r1, [r7, #0]
    26b6:	1dfb      	adds	r3, r7, #7
    26b8:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    26ba:	1dfb      	adds	r3, r7, #7
    26bc:	781b      	ldrb	r3, [r3, #0]
    26be:	2b01      	cmp	r3, #1
    26c0:	d00a      	beq.n	26d8 <system_apb_clock_set_mask+0x2c>
    26c2:	2b02      	cmp	r3, #2
    26c4:	d00f      	beq.n	26e6 <system_apb_clock_set_mask+0x3a>
    26c6:	2b00      	cmp	r3, #0
    26c8:	d114      	bne.n	26f4 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    26ca:	4b0e      	ldr	r3, [pc, #56]	; (2704 <system_apb_clock_set_mask+0x58>)
    26cc:	4a0d      	ldr	r2, [pc, #52]	; (2704 <system_apb_clock_set_mask+0x58>)
    26ce:	6991      	ldr	r1, [r2, #24]
    26d0:	683a      	ldr	r2, [r7, #0]
    26d2:	430a      	orrs	r2, r1
    26d4:	619a      	str	r2, [r3, #24]
			break;
    26d6:	e00f      	b.n	26f8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    26d8:	4b0a      	ldr	r3, [pc, #40]	; (2704 <system_apb_clock_set_mask+0x58>)
    26da:	4a0a      	ldr	r2, [pc, #40]	; (2704 <system_apb_clock_set_mask+0x58>)
    26dc:	69d1      	ldr	r1, [r2, #28]
    26de:	683a      	ldr	r2, [r7, #0]
    26e0:	430a      	orrs	r2, r1
    26e2:	61da      	str	r2, [r3, #28]
			break;
    26e4:	e008      	b.n	26f8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    26e6:	4b07      	ldr	r3, [pc, #28]	; (2704 <system_apb_clock_set_mask+0x58>)
    26e8:	4a06      	ldr	r2, [pc, #24]	; (2704 <system_apb_clock_set_mask+0x58>)
    26ea:	6a11      	ldr	r1, [r2, #32]
    26ec:	683a      	ldr	r2, [r7, #0]
    26ee:	430a      	orrs	r2, r1
    26f0:	621a      	str	r2, [r3, #32]
			break;
    26f2:	e001      	b.n	26f8 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    26f4:	2317      	movs	r3, #23
    26f6:	e000      	b.n	26fa <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    26f8:	2300      	movs	r3, #0
}
    26fa:	0018      	movs	r0, r3
    26fc:	46bd      	mov	sp, r7
    26fe:	b002      	add	sp, #8
    2700:	bd80      	pop	{r7, pc}
    2702:	46c0      	nop			; (mov r8, r8)
    2704:	40000400 	.word	0x40000400

00002708 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    2708:	b580      	push	{r7, lr}
    270a:	b082      	sub	sp, #8
    270c:	af00      	add	r7, sp, #0
    270e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    2710:	687b      	ldr	r3, [r7, #4]
    2712:	2280      	movs	r2, #128	; 0x80
    2714:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    2716:	687b      	ldr	r3, [r7, #4]
    2718:	2200      	movs	r2, #0
    271a:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    271c:	687b      	ldr	r3, [r7, #4]
    271e:	2201      	movs	r2, #1
    2720:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    2722:	687b      	ldr	r3, [r7, #4]
    2724:	2200      	movs	r2, #0
    2726:	70da      	strb	r2, [r3, #3]
}
    2728:	46c0      	nop			; (mov r8, r8)
    272a:	46bd      	mov	sp, r7
    272c:	b002      	add	sp, #8
    272e:	bd80      	pop	{r7, pc}

00002730 <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    2730:	b580      	push	{r7, lr}
    2732:	b082      	sub	sp, #8
    2734:	af00      	add	r7, sp, #0
    2736:	0002      	movs	r2, r0
    2738:	1dfb      	adds	r3, r7, #7
    273a:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    273c:	4b06      	ldr	r3, [pc, #24]	; (2758 <system_interrupt_enable+0x28>)
    273e:	1dfa      	adds	r2, r7, #7
    2740:	7812      	ldrb	r2, [r2, #0]
    2742:	0011      	movs	r1, r2
    2744:	221f      	movs	r2, #31
    2746:	400a      	ands	r2, r1
    2748:	2101      	movs	r1, #1
    274a:	4091      	lsls	r1, r2
    274c:	000a      	movs	r2, r1
    274e:	601a      	str	r2, [r3, #0]
}
    2750:	46c0      	nop			; (mov r8, r8)
    2752:	46bd      	mov	sp, r7
    2754:	b002      	add	sp, #8
    2756:	bd80      	pop	{r7, pc}
    2758:	e000e100 	.word	0xe000e100

0000275c <_extint_get_eic_from_channel>:
 *
 * \return Base address of the associated EIC module.
 */
static inline Eic * _extint_get_eic_from_channel(
		const uint8_t channel)
{
    275c:	b580      	push	{r7, lr}
    275e:	b084      	sub	sp, #16
    2760:	af00      	add	r7, sp, #0
    2762:	0002      	movs	r2, r0
    2764:	1dfb      	adds	r3, r7, #7
    2766:	701a      	strb	r2, [r3, #0]
	uint8_t eic_index = (channel / 32);
    2768:	230f      	movs	r3, #15
    276a:	18fb      	adds	r3, r7, r3
    276c:	1dfa      	adds	r2, r7, #7
    276e:	7812      	ldrb	r2, [r2, #0]
    2770:	0952      	lsrs	r2, r2, #5
    2772:	701a      	strb	r2, [r3, #0]

	if (eic_index < EIC_INST_NUM) {
    2774:	230f      	movs	r3, #15
    2776:	18fb      	adds	r3, r7, r3
    2778:	781b      	ldrb	r3, [r3, #0]
    277a:	2b00      	cmp	r3, #0
    277c:	d10c      	bne.n	2798 <_extint_get_eic_from_channel+0x3c>
		/* Array of available EICs */
		Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    277e:	4b09      	ldr	r3, [pc, #36]	; (27a4 <_extint_get_eic_from_channel+0x48>)
    2780:	60bb      	str	r3, [r7, #8]

		return eics[eic_index];
    2782:	230f      	movs	r3, #15
    2784:	18fb      	adds	r3, r7, r3
    2786:	781b      	ldrb	r3, [r3, #0]
    2788:	009b      	lsls	r3, r3, #2
    278a:	2210      	movs	r2, #16
    278c:	4694      	mov	ip, r2
    278e:	44bc      	add	ip, r7
    2790:	4463      	add	r3, ip
    2792:	3b08      	subs	r3, #8
    2794:	681b      	ldr	r3, [r3, #0]
    2796:	e000      	b.n	279a <_extint_get_eic_from_channel+0x3e>
	} else {
		Assert(false);
		return NULL;
    2798:	2300      	movs	r3, #0
	}
}
    279a:	0018      	movs	r0, r3
    279c:	46bd      	mov	sp, r7
    279e:	b004      	add	sp, #16
    27a0:	bd80      	pop	{r7, pc}
    27a2:	46c0      	nop			; (mov r8, r8)
    27a4:	40001800 	.word	0x40001800

000027a8 <extint_is_syncing>:
 *
 * \retval true  If the module synchronization is ongoing
 * \retval false If the module has completed synchronization
 */
static inline bool extint_is_syncing(void)
{
    27a8:	b580      	push	{r7, lr}
    27aa:	b082      	sub	sp, #8
    27ac:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    27ae:	4b0f      	ldr	r3, [pc, #60]	; (27ec <extint_is_syncing+0x44>)
    27b0:	603b      	str	r3, [r7, #0]

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    27b2:	2300      	movs	r3, #0
    27b4:	607b      	str	r3, [r7, #4]
    27b6:	e011      	b.n	27dc <extint_is_syncing+0x34>
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    27b8:	687b      	ldr	r3, [r7, #4]
    27ba:	009b      	lsls	r3, r3, #2
    27bc:	2208      	movs	r2, #8
    27be:	4694      	mov	ip, r2
    27c0:	44bc      	add	ip, r7
    27c2:	4463      	add	r3, ip
    27c4:	3b08      	subs	r3, #8
    27c6:	681b      	ldr	r3, [r3, #0]
    27c8:	785b      	ldrb	r3, [r3, #1]
    27ca:	b2db      	uxtb	r3, r3
    27cc:	b25b      	sxtb	r3, r3
    27ce:	2b00      	cmp	r3, #0
    27d0:	da01      	bge.n	27d6 <extint_is_syncing+0x2e>
			return true;
    27d2:	2301      	movs	r3, #1
    27d4:	e006      	b.n	27e4 <extint_is_syncing+0x3c>
 */
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    27d6:	687b      	ldr	r3, [r7, #4]
    27d8:	3301      	adds	r3, #1
    27da:	607b      	str	r3, [r7, #4]
    27dc:	687b      	ldr	r3, [r7, #4]
    27de:	2b00      	cmp	r3, #0
    27e0:	d0ea      	beq.n	27b8 <extint_is_syncing+0x10>
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
			return true;
		}
	}
	return false;
    27e2:	2300      	movs	r3, #0
}
    27e4:	0018      	movs	r0, r3
    27e6:	46bd      	mov	sp, r7
    27e8:	b002      	add	sp, #8
    27ea:	bd80      	pop	{r7, pc}
    27ec:	40001800 	.word	0x40001800

000027f0 <_system_extint_init>:
 * \note When SYSTEM module is used, this function will be invoked by
 * \ref system_init() automatically if the module is included.
 */
void _system_extint_init(void);
void _system_extint_init(void)
{
    27f0:	b580      	push	{r7, lr}
    27f2:	b084      	sub	sp, #16
    27f4:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    27f6:	4b2d      	ldr	r3, [pc, #180]	; (28ac <_system_extint_init+0xbc>)
    27f8:	607b      	str	r3, [r7, #4]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_EIC);
    27fa:	2140      	movs	r1, #64	; 0x40
    27fc:	2000      	movs	r0, #0
    27fe:	4b2c      	ldr	r3, [pc, #176]	; (28b0 <_system_extint_init+0xc0>)
    2800:	4798      	blx	r3

	/* Configure the generic clock for the module and enable it */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    2802:	003b      	movs	r3, r7
    2804:	0018      	movs	r0, r3
    2806:	4b2b      	ldr	r3, [pc, #172]	; (28b4 <_system_extint_init+0xc4>)
    2808:	4798      	blx	r3
	gclk_chan_conf.source_generator = EXTINT_CLOCK_SOURCE;
    280a:	003b      	movs	r3, r7
    280c:	2200      	movs	r2, #0
    280e:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    2810:	003b      	movs	r3, r7
    2812:	0019      	movs	r1, r3
    2814:	2003      	movs	r0, #3
    2816:	4b28      	ldr	r3, [pc, #160]	; (28b8 <_system_extint_init+0xc8>)
    2818:	4798      	blx	r3

	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);
    281a:	2003      	movs	r0, #3
    281c:	4b27      	ldr	r3, [pc, #156]	; (28bc <_system_extint_init+0xcc>)
    281e:	4798      	blx	r3

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    2820:	2300      	movs	r3, #0
    2822:	60fb      	str	r3, [r7, #12]
    2824:	e018      	b.n	2858 <_system_extint_init+0x68>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    2826:	68fb      	ldr	r3, [r7, #12]
    2828:	009b      	lsls	r3, r3, #2
    282a:	2210      	movs	r2, #16
    282c:	4694      	mov	ip, r2
    282e:	44bc      	add	ip, r7
    2830:	4463      	add	r3, ip
    2832:	3b0c      	subs	r3, #12
    2834:	681a      	ldr	r2, [r3, #0]
    2836:	68fb      	ldr	r3, [r7, #12]
    2838:	009b      	lsls	r3, r3, #2
    283a:	2110      	movs	r1, #16
    283c:	468c      	mov	ip, r1
    283e:	44bc      	add	ip, r7
    2840:	4463      	add	r3, ip
    2842:	3b0c      	subs	r3, #12
    2844:	681b      	ldr	r3, [r3, #0]
    2846:	781b      	ldrb	r3, [r3, #0]
    2848:	b2db      	uxtb	r3, r3
    284a:	2101      	movs	r1, #1
    284c:	430b      	orrs	r3, r1
    284e:	b2db      	uxtb	r3, r3
    2850:	7013      	strb	r3, [r2, #0]
	/* Enable the clock anyway, since when needed it will be requested
	 * by External Interrupt driver */
	system_gclk_chan_enable(EIC_GCLK_ID);

	/* Reset all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    2852:	68fb      	ldr	r3, [r7, #12]
    2854:	3301      	adds	r3, #1
    2856:	60fb      	str	r3, [r7, #12]
    2858:	68fb      	ldr	r3, [r7, #12]
    285a:	2b00      	cmp	r3, #0
    285c:	d0e3      	beq.n	2826 <_system_extint_init+0x36>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
	}

	while (extint_is_syncing()) {
    285e:	46c0      	nop			; (mov r8, r8)
    2860:	4b17      	ldr	r3, [pc, #92]	; (28c0 <_system_extint_init+0xd0>)
    2862:	4798      	blx	r3
    2864:	1e03      	subs	r3, r0, #0
    2866:	d1fb      	bne.n	2860 <_system_extint_init+0x70>
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    2868:	230b      	movs	r3, #11
    286a:	18fb      	adds	r3, r7, r3
    286c:	2200      	movs	r2, #0
    286e:	701a      	strb	r2, [r3, #0]
    2870:	e00d      	b.n	288e <_system_extint_init+0x9e>
		_extint_dev.callbacks[j] = NULL;
    2872:	230b      	movs	r3, #11
    2874:	18fb      	adds	r3, r7, r3
    2876:	781a      	ldrb	r2, [r3, #0]
    2878:	4b12      	ldr	r3, [pc, #72]	; (28c4 <_system_extint_init+0xd4>)
    287a:	0092      	lsls	r2, r2, #2
    287c:	2100      	movs	r1, #0
    287e:	50d1      	str	r1, [r2, r3]
	}

	/* Reset the software module */
#if EXTINT_CALLBACK_MODE == true
	/* Clear callback registration table */
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    2880:	230b      	movs	r3, #11
    2882:	18fb      	adds	r3, r7, r3
    2884:	781a      	ldrb	r2, [r3, #0]
    2886:	230b      	movs	r3, #11
    2888:	18fb      	adds	r3, r7, r3
    288a:	3201      	adds	r2, #1
    288c:	701a      	strb	r2, [r3, #0]
    288e:	230b      	movs	r3, #11
    2890:	18fb      	adds	r3, r7, r3
    2892:	781b      	ldrb	r3, [r3, #0]
    2894:	2b0f      	cmp	r3, #15
    2896:	d9ec      	bls.n	2872 <_system_extint_init+0x82>
		_extint_dev.callbacks[j] = NULL;
	}
	system_interrupt_enable(SYSTEM_INTERRUPT_MODULE_EIC);
    2898:	2004      	movs	r0, #4
    289a:	4b0b      	ldr	r3, [pc, #44]	; (28c8 <_system_extint_init+0xd8>)
    289c:	4798      	blx	r3
#endif

	/* Enables the driver for further use */
	_extint_enable();
    289e:	4b0b      	ldr	r3, [pc, #44]	; (28cc <_system_extint_init+0xdc>)
    28a0:	4798      	blx	r3
}
    28a2:	46c0      	nop			; (mov r8, r8)
    28a4:	46bd      	mov	sp, r7
    28a6:	b004      	add	sp, #16
    28a8:	bd80      	pop	{r7, pc}
    28aa:	46c0      	nop			; (mov r8, r8)
    28ac:	40001800 	.word	0x40001800
    28b0:	000026ad 	.word	0x000026ad
    28b4:	00002695 	.word	0x00002695
    28b8:	00004aa9 	.word	0x00004aa9
    28bc:	00004aed 	.word	0x00004aed
    28c0:	000027a9 	.word	0x000027a9
    28c4:	20002e14 	.word	0x20002e14
    28c8:	00002731 	.word	0x00002731
    28cc:	000028d1 	.word	0x000028d1

000028d0 <_extint_enable>:
 *
 * Enables EIC modules.
 * Registered callback list will not be affected if callback mode is used.
 */
void _extint_enable(void)
{
    28d0:	b580      	push	{r7, lr}
    28d2:	b082      	sub	sp, #8
    28d4:	af00      	add	r7, sp, #0
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;
    28d6:	4b15      	ldr	r3, [pc, #84]	; (292c <_extint_enable+0x5c>)
    28d8:	603b      	str	r3, [r7, #0]

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    28da:	2300      	movs	r3, #0
    28dc:	607b      	str	r3, [r7, #4]
    28de:	e018      	b.n	2912 <_extint_enable+0x42>
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    28e0:	687b      	ldr	r3, [r7, #4]
    28e2:	009b      	lsls	r3, r3, #2
    28e4:	2208      	movs	r2, #8
    28e6:	4694      	mov	ip, r2
    28e8:	44bc      	add	ip, r7
    28ea:	4463      	add	r3, ip
    28ec:	3b08      	subs	r3, #8
    28ee:	681a      	ldr	r2, [r3, #0]
    28f0:	687b      	ldr	r3, [r7, #4]
    28f2:	009b      	lsls	r3, r3, #2
    28f4:	2108      	movs	r1, #8
    28f6:	468c      	mov	ip, r1
    28f8:	44bc      	add	ip, r7
    28fa:	4463      	add	r3, ip
    28fc:	3b08      	subs	r3, #8
    28fe:	681b      	ldr	r3, [r3, #0]
    2900:	781b      	ldrb	r3, [r3, #0]
    2902:	b2db      	uxtb	r3, r3
    2904:	2102      	movs	r1, #2
    2906:	430b      	orrs	r3, r1
    2908:	b2db      	uxtb	r3, r3
    290a:	7013      	strb	r3, [r2, #0]
void _extint_enable(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
    290c:	687b      	ldr	r3, [r7, #4]
    290e:	3301      	adds	r3, #1
    2910:	607b      	str	r3, [r7, #4]
    2912:	687b      	ldr	r3, [r7, #4]
    2914:	2b00      	cmp	r3, #0
    2916:	d0e3      	beq.n	28e0 <_extint_enable+0x10>
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
	}

	while (extint_is_syncing()) {
    2918:	46c0      	nop			; (mov r8, r8)
    291a:	4b05      	ldr	r3, [pc, #20]	; (2930 <_extint_enable+0x60>)
    291c:	4798      	blx	r3
    291e:	1e03      	subs	r3, r0, #0
    2920:	d1fb      	bne.n	291a <_extint_enable+0x4a>
		/* Wait for all hardware modules to complete synchronization */
	}
}
    2922:	46c0      	nop			; (mov r8, r8)
    2924:	46bd      	mov	sp, r7
    2926:	b002      	add	sp, #8
    2928:	bd80      	pop	{r7, pc}
    292a:	46c0      	nop			; (mov r8, r8)
    292c:	40001800 	.word	0x40001800
    2930:	000027a9 	.word	0x000027a9

00002934 <extint_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
void extint_chan_get_config_defaults(
		struct extint_chan_conf *const config)
{
    2934:	b580      	push	{r7, lr}
    2936:	b082      	sub	sp, #8
    2938:	af00      	add	r7, sp, #0
    293a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->gpio_pin            = 0;
    293c:	687b      	ldr	r3, [r7, #4]
    293e:	2200      	movs	r2, #0
    2940:	601a      	str	r2, [r3, #0]
	config->gpio_pin_mux        = 0;
    2942:	687b      	ldr	r3, [r7, #4]
    2944:	2200      	movs	r2, #0
    2946:	605a      	str	r2, [r3, #4]
	config->gpio_pin_pull       = EXTINT_PULL_UP;
    2948:	687b      	ldr	r3, [r7, #4]
    294a:	2201      	movs	r2, #1
    294c:	721a      	strb	r2, [r3, #8]
	config->wake_if_sleeping    = true;
    294e:	687b      	ldr	r3, [r7, #4]
    2950:	2201      	movs	r2, #1
    2952:	725a      	strb	r2, [r3, #9]
	config->filter_input_signal = false;
    2954:	687b      	ldr	r3, [r7, #4]
    2956:	2200      	movs	r2, #0
    2958:	729a      	strb	r2, [r3, #10]
	config->detection_criteria  = EXTINT_DETECT_FALLING;
    295a:	687b      	ldr	r3, [r7, #4]
    295c:	2202      	movs	r2, #2
    295e:	72da      	strb	r2, [r3, #11]
}
    2960:	46c0      	nop			; (mov r8, r8)
    2962:	46bd      	mov	sp, r7
    2964:	b002      	add	sp, #8
    2966:	bd80      	pop	{r7, pc}

00002968 <extint_chan_set_config>:

 */
void extint_chan_set_config(
		const uint8_t channel,
		const struct extint_chan_conf *const config)
{
    2968:	b580      	push	{r7, lr}
    296a:	b086      	sub	sp, #24
    296c:	af00      	add	r7, sp, #0
    296e:	0002      	movs	r2, r0
    2970:	6039      	str	r1, [r7, #0]
    2972:	1dfb      	adds	r3, r7, #7
    2974:	701a      	strb	r2, [r3, #0]
	Assert(!(!system_gclk_gen_is_enabled(EXTINT_CLOCK_SOURCE) &&
		_extint_is_gclk_required(config->filter_input_signal,
			config->detection_criteria)));

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
    2976:	2308      	movs	r3, #8
    2978:	18fb      	adds	r3, r7, r3
    297a:	0018      	movs	r0, r3
    297c:	4b36      	ldr	r3, [pc, #216]	; (2a58 <extint_chan_set_config+0xf0>)
    297e:	4798      	blx	r3

	pinmux_config.mux_position = config->gpio_pin_mux;
    2980:	683b      	ldr	r3, [r7, #0]
    2982:	685b      	ldr	r3, [r3, #4]
    2984:	b2da      	uxtb	r2, r3
    2986:	2308      	movs	r3, #8
    2988:	18fb      	adds	r3, r7, r3
    298a:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    298c:	2308      	movs	r3, #8
    298e:	18fb      	adds	r3, r7, r3
    2990:	2200      	movs	r2, #0
    2992:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->gpio_pin_pull;
    2994:	683b      	ldr	r3, [r7, #0]
    2996:	7a1a      	ldrb	r2, [r3, #8]
    2998:	2308      	movs	r3, #8
    299a:	18fb      	adds	r3, r7, r3
    299c:	709a      	strb	r2, [r3, #2]
	system_pinmux_pin_set_config(config->gpio_pin, &pinmux_config);
    299e:	683b      	ldr	r3, [r7, #0]
    29a0:	681b      	ldr	r3, [r3, #0]
    29a2:	b2db      	uxtb	r3, r3
    29a4:	2208      	movs	r2, #8
    29a6:	18ba      	adds	r2, r7, r2
    29a8:	0011      	movs	r1, r2
    29aa:	0018      	movs	r0, r3
    29ac:	4b2b      	ldr	r3, [pc, #172]	; (2a5c <extint_chan_set_config+0xf4>)
    29ae:	4798      	blx	r3

	/* Get a pointer to the module hardware instance */
	Eic *const EIC_module = _extint_get_eic_from_channel(channel);
    29b0:	1dfb      	adds	r3, r7, #7
    29b2:	781b      	ldrb	r3, [r3, #0]
    29b4:	0018      	movs	r0, r3
    29b6:	4b2a      	ldr	r3, [pc, #168]	; (2a60 <extint_chan_set_config+0xf8>)
    29b8:	4798      	blx	r3
    29ba:	0003      	movs	r3, r0
    29bc:	613b      	str	r3, [r7, #16]

	uint32_t config_pos = (4 * (channel % 8));
    29be:	1dfb      	adds	r3, r7, #7
    29c0:	781b      	ldrb	r3, [r3, #0]
    29c2:	2207      	movs	r2, #7
    29c4:	4013      	ands	r3, r2
    29c6:	009b      	lsls	r3, r3, #2
    29c8:	60fb      	str	r3, [r7, #12]
	uint32_t new_config;

	/* Determine the channel's new edge detection configuration */
	new_config = (config->detection_criteria << EIC_CONFIG_SENSE0_Pos);
    29ca:	683b      	ldr	r3, [r7, #0]
    29cc:	7adb      	ldrb	r3, [r3, #11]
    29ce:	617b      	str	r3, [r7, #20]

	/* Enable the hardware signal filter if requested in the config */
	if (config->filter_input_signal) {
    29d0:	683b      	ldr	r3, [r7, #0]
    29d2:	7a9b      	ldrb	r3, [r3, #10]
    29d4:	2b00      	cmp	r3, #0
    29d6:	d003      	beq.n	29e0 <extint_chan_set_config+0x78>
		new_config |= EIC_CONFIG_FILTEN0;
    29d8:	697b      	ldr	r3, [r7, #20]
    29da:	2208      	movs	r2, #8
    29dc:	4313      	orrs	r3, r2
    29de:	617b      	str	r3, [r7, #20]
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
    29e0:	1dfb      	adds	r3, r7, #7
    29e2:	781b      	ldrb	r3, [r3, #0]
    29e4:	08db      	lsrs	r3, r3, #3
    29e6:	b2db      	uxtb	r3, r3
    29e8:	0018      	movs	r0, r3
		= (EIC_module->CONFIG[channel / 8].reg &
    29ea:	1dfb      	adds	r3, r7, #7
    29ec:	781b      	ldrb	r3, [r3, #0]
    29ee:	08db      	lsrs	r3, r3, #3
    29f0:	b2db      	uxtb	r3, r3
    29f2:	001a      	movs	r2, r3
    29f4:	693b      	ldr	r3, [r7, #16]
    29f6:	3206      	adds	r2, #6
    29f8:	0092      	lsls	r2, r2, #2
    29fa:	58d3      	ldr	r3, [r2, r3]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    29fc:	210f      	movs	r1, #15
    29fe:	68fa      	ldr	r2, [r7, #12]
    2a00:	4091      	lsls	r1, r2
    2a02:	000a      	movs	r2, r1
    2a04:	43d2      	mvns	r2, r2
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    2a06:	401a      	ands	r2, r3
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);
    2a08:	6979      	ldr	r1, [r7, #20]
    2a0a:	68fb      	ldr	r3, [r7, #12]
    2a0c:	4099      	lsls	r1, r3
    2a0e:	000b      	movs	r3, r1
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
    2a10:	431a      	orrs	r2, r3
    2a12:	0011      	movs	r1, r2
		new_config |= EIC_CONFIG_FILTEN0;
	}

	/* Clear the existing and set the new channel configuration */
	EIC_module->CONFIG[channel / 8].reg
		= (EIC_module->CONFIG[channel / 8].reg &
    2a14:	693b      	ldr	r3, [r7, #16]
    2a16:	1d82      	adds	r2, r0, #6
    2a18:	0092      	lsls	r2, r2, #2
    2a1a:	50d1      	str	r1, [r2, r3]
			~((EIC_CONFIG_SENSE0_Msk | EIC_CONFIG_FILTEN0) << config_pos)) |
			(new_config << config_pos);

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
    2a1c:	683b      	ldr	r3, [r7, #0]
    2a1e:	7a5b      	ldrb	r3, [r3, #9]
    2a20:	2b00      	cmp	r3, #0
    2a22:	d00a      	beq.n	2a3a <extint_chan_set_config+0xd2>
		EIC_module->WAKEUP.reg |=  (1UL << channel);
    2a24:	693b      	ldr	r3, [r7, #16]
    2a26:	695a      	ldr	r2, [r3, #20]
    2a28:	1dfb      	adds	r3, r7, #7
    2a2a:	781b      	ldrb	r3, [r3, #0]
    2a2c:	2101      	movs	r1, #1
    2a2e:	4099      	lsls	r1, r3
    2a30:	000b      	movs	r3, r1
    2a32:	431a      	orrs	r2, r3
    2a34:	693b      	ldr	r3, [r7, #16]
    2a36:	615a      	str	r2, [r3, #20]
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
	}
}
    2a38:	e00a      	b.n	2a50 <extint_chan_set_config+0xe8>

	/* Set the channel's new wake up mode setting */
	if (config->wake_if_sleeping) {
		EIC_module->WAKEUP.reg |=  (1UL << channel);
	} else {
		EIC_module->WAKEUP.reg &= ~(1UL << channel);
    2a3a:	693b      	ldr	r3, [r7, #16]
    2a3c:	695b      	ldr	r3, [r3, #20]
    2a3e:	1dfa      	adds	r2, r7, #7
    2a40:	7812      	ldrb	r2, [r2, #0]
    2a42:	2101      	movs	r1, #1
    2a44:	4091      	lsls	r1, r2
    2a46:	000a      	movs	r2, r1
    2a48:	43d2      	mvns	r2, r2
    2a4a:	401a      	ands	r2, r3
    2a4c:	693b      	ldr	r3, [r7, #16]
    2a4e:	615a      	str	r2, [r3, #20]
	}
}
    2a50:	46c0      	nop			; (mov r8, r8)
    2a52:	46bd      	mov	sp, r7
    2a54:	b006      	add	sp, #24
    2a56:	bd80      	pop	{r7, pc}
    2a58:	00002709 	.word	0x00002709
    2a5c:	00004d95 	.word	0x00004d95
    2a60:	0000275d 	.word	0x0000275d

00002a64 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    2a64:	b580      	push	{r7, lr}
    2a66:	b082      	sub	sp, #8
    2a68:	af00      	add	r7, sp, #0
    2a6a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    2a6c:	687b      	ldr	r3, [r7, #4]
    2a6e:	2280      	movs	r2, #128	; 0x80
    2a70:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    2a72:	687b      	ldr	r3, [r7, #4]
    2a74:	2200      	movs	r2, #0
    2a76:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    2a78:	687b      	ldr	r3, [r7, #4]
    2a7a:	2201      	movs	r2, #1
    2a7c:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    2a7e:	687b      	ldr	r3, [r7, #4]
    2a80:	2200      	movs	r2, #0
    2a82:	70da      	strb	r2, [r3, #3]
}
    2a84:	46c0      	nop			; (mov r8, r8)
    2a86:	46bd      	mov	sp, r7
    2a88:	b002      	add	sp, #8
    2a8a:	bd80      	pop	{r7, pc}

00002a8c <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    2a8c:	b580      	push	{r7, lr}
    2a8e:	b084      	sub	sp, #16
    2a90:	af00      	add	r7, sp, #0
    2a92:	0002      	movs	r2, r0
    2a94:	6039      	str	r1, [r7, #0]
    2a96:	1dfb      	adds	r3, r7, #7
    2a98:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);
    2a9a:	230c      	movs	r3, #12
    2a9c:	18fb      	adds	r3, r7, r3
    2a9e:	0018      	movs	r0, r3
    2aa0:	4b10      	ldr	r3, [pc, #64]	; (2ae4 <port_pin_set_config+0x58>)
    2aa2:	4798      	blx	r3

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
    2aa4:	230c      	movs	r3, #12
    2aa6:	18fb      	adds	r3, r7, r3
    2aa8:	2280      	movs	r2, #128	; 0x80
    2aaa:	701a      	strb	r2, [r3, #0]
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    2aac:	683b      	ldr	r3, [r7, #0]
    2aae:	781a      	ldrb	r2, [r3, #0]
    2ab0:	230c      	movs	r3, #12
    2ab2:	18fb      	adds	r3, r7, r3
    2ab4:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    2ab6:	683b      	ldr	r3, [r7, #0]
    2ab8:	785a      	ldrb	r2, [r3, #1]
    2aba:	230c      	movs	r3, #12
    2abc:	18fb      	adds	r3, r7, r3
    2abe:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    2ac0:	683b      	ldr	r3, [r7, #0]
    2ac2:	789a      	ldrb	r2, [r3, #2]
    2ac4:	230c      	movs	r3, #12
    2ac6:	18fb      	adds	r3, r7, r3
    2ac8:	70da      	strb	r2, [r3, #3]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    2aca:	230c      	movs	r3, #12
    2acc:	18fa      	adds	r2, r7, r3
    2ace:	1dfb      	adds	r3, r7, #7
    2ad0:	781b      	ldrb	r3, [r3, #0]
    2ad2:	0011      	movs	r1, r2
    2ad4:	0018      	movs	r0, r3
    2ad6:	4b04      	ldr	r3, [pc, #16]	; (2ae8 <port_pin_set_config+0x5c>)
    2ad8:	4798      	blx	r3
}
    2ada:	46c0      	nop			; (mov r8, r8)
    2adc:	46bd      	mov	sp, r7
    2ade:	b004      	add	sp, #16
    2ae0:	bd80      	pop	{r7, pc}
    2ae2:	46c0      	nop			; (mov r8, r8)
    2ae4:	00002a65 	.word	0x00002a65
    2ae8:	00004d95 	.word	0x00004d95

00002aec <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    2aec:	b580      	push	{r7, lr}
    2aee:	b082      	sub	sp, #8
    2af0:	af00      	add	r7, sp, #0
    2af2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    2af4:	687b      	ldr	r3, [r7, #4]
    2af6:	2200      	movs	r2, #0
    2af8:	701a      	strb	r2, [r3, #0]
}
    2afa:	46c0      	nop			; (mov r8, r8)
    2afc:	46bd      	mov	sp, r7
    2afe:	b002      	add	sp, #8
    2b00:	bd80      	pop	{r7, pc}
    2b02:	46c0      	nop			; (mov r8, r8)

00002b04 <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    2b04:	b580      	push	{r7, lr}
    2b06:	b086      	sub	sp, #24
    2b08:	af00      	add	r7, sp, #0
    2b0a:	60f8      	str	r0, [r7, #12]
    2b0c:	60b9      	str	r1, [r7, #8]
    2b0e:	607a      	str	r2, [r7, #4]
	/* Baud value variable */
	uint16_t baud_calculated = 0;
    2b10:	2316      	movs	r3, #22
    2b12:	18fb      	adds	r3, r7, r3
    2b14:	2200      	movs	r2, #0
    2b16:	801a      	strh	r2, [r3, #0]
	uint32_t clock_value = external_clock;
    2b18:	68bb      	ldr	r3, [r7, #8]
    2b1a:	613b      	str	r3, [r7, #16]


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    2b1c:	68bb      	ldr	r3, [r7, #8]
    2b1e:	085a      	lsrs	r2, r3, #1
    2b20:	68fb      	ldr	r3, [r7, #12]
    2b22:	429a      	cmp	r2, r3
    2b24:	d201      	bcs.n	2b2a <_sercom_get_sync_baud_val+0x26>
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    2b26:	2340      	movs	r3, #64	; 0x40
    2b28:	e026      	b.n	2b78 <_sercom_get_sync_baud_val+0x74>
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
    2b2a:	68bb      	ldr	r3, [r7, #8]
    2b2c:	085b      	lsrs	r3, r3, #1
    2b2e:	613b      	str	r3, [r7, #16]
	while (clock_value >= baudrate) {
    2b30:	e00a      	b.n	2b48 <_sercom_get_sync_baud_val+0x44>
		clock_value = clock_value - baudrate;
    2b32:	693a      	ldr	r2, [r7, #16]
    2b34:	68fb      	ldr	r3, [r7, #12]
    2b36:	1ad3      	subs	r3, r2, r3
    2b38:	613b      	str	r3, [r7, #16]
		baud_calculated++;
    2b3a:	2316      	movs	r3, #22
    2b3c:	18fb      	adds	r3, r7, r3
    2b3e:	881a      	ldrh	r2, [r3, #0]
    2b40:	2316      	movs	r3, #22
    2b42:	18fb      	adds	r3, r7, r3
    2b44:	3201      	adds	r2, #1
    2b46:	801a      	strh	r2, [r3, #0]
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	}

	/* Calculate BAUD value from clock frequency and baudrate */
	clock_value = external_clock / 2;
	while (clock_value >= baudrate) {
    2b48:	693a      	ldr	r2, [r7, #16]
    2b4a:	68fb      	ldr	r3, [r7, #12]
    2b4c:	429a      	cmp	r2, r3
    2b4e:	d2f0      	bcs.n	2b32 <_sercom_get_sync_baud_val+0x2e>
		clock_value = clock_value - baudrate;
		baud_calculated++;
	}
	baud_calculated = baud_calculated - 1;
    2b50:	2316      	movs	r3, #22
    2b52:	18fb      	adds	r3, r7, r3
    2b54:	2216      	movs	r2, #22
    2b56:	18ba      	adds	r2, r7, r2
    2b58:	8812      	ldrh	r2, [r2, #0]
    2b5a:	3a01      	subs	r2, #1
    2b5c:	801a      	strh	r2, [r3, #0]

	/* Check if BAUD value is more than 255, which is maximum
	 * for synchronous mode */
	if (baud_calculated > 0xFF) {
    2b5e:	2316      	movs	r3, #22
    2b60:	18fb      	adds	r3, r7, r3
    2b62:	881b      	ldrh	r3, [r3, #0]
    2b64:	2bff      	cmp	r3, #255	; 0xff
    2b66:	d901      	bls.n	2b6c <_sercom_get_sync_baud_val+0x68>
		/* Return with an error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    2b68:	2340      	movs	r3, #64	; 0x40
    2b6a:	e005      	b.n	2b78 <_sercom_get_sync_baud_val+0x74>
	} else {
		*baudvalue = baud_calculated;
    2b6c:	687b      	ldr	r3, [r7, #4]
    2b6e:	2216      	movs	r2, #22
    2b70:	18ba      	adds	r2, r7, r2
    2b72:	8812      	ldrh	r2, [r2, #0]
    2b74:	801a      	strh	r2, [r3, #0]
		return STATUS_OK;
    2b76:	2300      	movs	r3, #0
	}
}
    2b78:	0018      	movs	r0, r3
    2b7a:	46bd      	mov	sp, r7
    2b7c:	b006      	add	sp, #24
    2b7e:	bd80      	pop	{r7, pc}

00002b80 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    2b80:	b580      	push	{r7, lr}
    2b82:	b084      	sub	sp, #16
    2b84:	af00      	add	r7, sp, #0
    2b86:	0002      	movs	r2, r0
    2b88:	1dfb      	adds	r3, r7, #7
    2b8a:	701a      	strb	r2, [r3, #0]
    2b8c:	1dbb      	adds	r3, r7, #6
    2b8e:	1c0a      	adds	r2, r1, #0
    2b90:	701a      	strb	r2, [r3, #0]
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    2b92:	4b1a      	ldr	r3, [pc, #104]	; (2bfc <sercom_set_gclk_generator+0x7c>)
    2b94:	781b      	ldrb	r3, [r3, #0]
    2b96:	2201      	movs	r2, #1
    2b98:	4053      	eors	r3, r2
    2b9a:	b2db      	uxtb	r3, r3
    2b9c:	2b00      	cmp	r3, #0
    2b9e:	d103      	bne.n	2ba8 <sercom_set_gclk_generator+0x28>
    2ba0:	1dbb      	adds	r3, r7, #6
    2ba2:	781b      	ldrb	r3, [r3, #0]
    2ba4:	2b00      	cmp	r3, #0
    2ba6:	d01b      	beq.n	2be0 <sercom_set_gclk_generator+0x60>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    2ba8:	230c      	movs	r3, #12
    2baa:	18fb      	adds	r3, r7, r3
    2bac:	0018      	movs	r0, r3
    2bae:	4b14      	ldr	r3, [pc, #80]	; (2c00 <sercom_set_gclk_generator+0x80>)
    2bb0:	4798      	blx	r3
		gclk_chan_conf.source_generator = generator_source;
    2bb2:	230c      	movs	r3, #12
    2bb4:	18fb      	adds	r3, r7, r3
    2bb6:	1dfa      	adds	r2, r7, #7
    2bb8:	7812      	ldrb	r2, [r2, #0]
    2bba:	701a      	strb	r2, [r3, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    2bbc:	230c      	movs	r3, #12
    2bbe:	18fb      	adds	r3, r7, r3
    2bc0:	0019      	movs	r1, r3
    2bc2:	200c      	movs	r0, #12
    2bc4:	4b0f      	ldr	r3, [pc, #60]	; (2c04 <sercom_set_gclk_generator+0x84>)
    2bc6:	4798      	blx	r3
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    2bc8:	200c      	movs	r0, #12
    2bca:	4b0f      	ldr	r3, [pc, #60]	; (2c08 <sercom_set_gclk_generator+0x88>)
    2bcc:	4798      	blx	r3

		/* Save config */
		_sercom_config.generator_source = generator_source;
    2bce:	4b0b      	ldr	r3, [pc, #44]	; (2bfc <sercom_set_gclk_generator+0x7c>)
    2bd0:	1dfa      	adds	r2, r7, #7
    2bd2:	7812      	ldrb	r2, [r2, #0]
    2bd4:	705a      	strb	r2, [r3, #1]
		_sercom_config.generator_is_set = true;
    2bd6:	4b09      	ldr	r3, [pc, #36]	; (2bfc <sercom_set_gclk_generator+0x7c>)
    2bd8:	2201      	movs	r2, #1
    2bda:	701a      	strb	r2, [r3, #0]

		return STATUS_OK;
    2bdc:	2300      	movs	r3, #0
    2bde:	e008      	b.n	2bf2 <sercom_set_gclk_generator+0x72>
	} else if (generator_source == _sercom_config.generator_source) {
    2be0:	4b06      	ldr	r3, [pc, #24]	; (2bfc <sercom_set_gclk_generator+0x7c>)
    2be2:	785b      	ldrb	r3, [r3, #1]
    2be4:	1dfa      	adds	r2, r7, #7
    2be6:	7812      	ldrb	r2, [r2, #0]
    2be8:	429a      	cmp	r2, r3
    2bea:	d101      	bne.n	2bf0 <sercom_set_gclk_generator+0x70>
		/* Return status OK if same config */
		return STATUS_OK;
    2bec:	2300      	movs	r3, #0
    2bee:	e000      	b.n	2bf2 <sercom_set_gclk_generator+0x72>
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
    2bf0:	231d      	movs	r3, #29
}
    2bf2:	0018      	movs	r0, r3
    2bf4:	46bd      	mov	sp, r7
    2bf6:	b004      	add	sp, #16
    2bf8:	bd80      	pop	{r7, pc}
    2bfa:	46c0      	nop			; (mov r8, r8)
    2bfc:	20000ad4 	.word	0x20000ad4
    2c00:	00002aed 	.word	0x00002aed
    2c04:	00004aa9 	.word	0x00004aa9
    2c08:	00004aed 	.word	0x00004aed

00002c0c <_sercom_get_default_pad>:
 *
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
    2c0c:	b580      	push	{r7, lr}
    2c0e:	b082      	sub	sp, #8
    2c10:	af00      	add	r7, sp, #0
    2c12:	6078      	str	r0, [r7, #4]
    2c14:	000a      	movs	r2, r1
    2c16:	1cfb      	adds	r3, r7, #3
    2c18:	701a      	strb	r2, [r3, #0]
	switch ((uintptr_t)sercom_module) {
    2c1a:	687b      	ldr	r3, [r7, #4]
    2c1c:	4a4d      	ldr	r2, [pc, #308]	; (2d54 <_sercom_get_default_pad+0x148>)
    2c1e:	4293      	cmp	r3, r2
    2c20:	d03f      	beq.n	2ca2 <_sercom_get_default_pad+0x96>
    2c22:	4a4c      	ldr	r2, [pc, #304]	; (2d54 <_sercom_get_default_pad+0x148>)
    2c24:	4293      	cmp	r3, r2
    2c26:	d806      	bhi.n	2c36 <_sercom_get_default_pad+0x2a>
    2c28:	4a4b      	ldr	r2, [pc, #300]	; (2d58 <_sercom_get_default_pad+0x14c>)
    2c2a:	4293      	cmp	r3, r2
    2c2c:	d00f      	beq.n	2c4e <_sercom_get_default_pad+0x42>
    2c2e:	4a4b      	ldr	r2, [pc, #300]	; (2d5c <_sercom_get_default_pad+0x150>)
    2c30:	4293      	cmp	r3, r2
    2c32:	d021      	beq.n	2c78 <_sercom_get_default_pad+0x6c>
    2c34:	e089      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2c36:	4a4a      	ldr	r2, [pc, #296]	; (2d60 <_sercom_get_default_pad+0x154>)
    2c38:	4293      	cmp	r3, r2
    2c3a:	d100      	bne.n	2c3e <_sercom_get_default_pad+0x32>
    2c3c:	e05b      	b.n	2cf6 <_sercom_get_default_pad+0xea>
    2c3e:	4a49      	ldr	r2, [pc, #292]	; (2d64 <_sercom_get_default_pad+0x158>)
    2c40:	4293      	cmp	r3, r2
    2c42:	d100      	bne.n	2c46 <_sercom_get_default_pad+0x3a>
    2c44:	e06c      	b.n	2d20 <_sercom_get_default_pad+0x114>
    2c46:	4a48      	ldr	r2, [pc, #288]	; (2d68 <_sercom_get_default_pad+0x15c>)
    2c48:	4293      	cmp	r3, r2
    2c4a:	d03f      	beq.n	2ccc <_sercom_get_default_pad+0xc0>
    2c4c:	e07d      	b.n	2d4a <_sercom_get_default_pad+0x13e>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    2c4e:	1cfb      	adds	r3, r7, #3
    2c50:	781b      	ldrb	r3, [r3, #0]
    2c52:	2b01      	cmp	r3, #1
    2c54:	d00a      	beq.n	2c6c <_sercom_get_default_pad+0x60>
    2c56:	dc02      	bgt.n	2c5e <_sercom_get_default_pad+0x52>
    2c58:	2b00      	cmp	r3, #0
    2c5a:	d005      	beq.n	2c68 <_sercom_get_default_pad+0x5c>
    2c5c:	e075      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2c5e:	2b02      	cmp	r3, #2
    2c60:	d006      	beq.n	2c70 <_sercom_get_default_pad+0x64>
    2c62:	2b03      	cmp	r3, #3
    2c64:	d006      	beq.n	2c74 <_sercom_get_default_pad+0x68>
    2c66:	e070      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2c68:	4b40      	ldr	r3, [pc, #256]	; (2d6c <_sercom_get_default_pad+0x160>)
    2c6a:	e06f      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2c6c:	4b40      	ldr	r3, [pc, #256]	; (2d70 <_sercom_get_default_pad+0x164>)
    2c6e:	e06d      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2c70:	4b40      	ldr	r3, [pc, #256]	; (2d74 <_sercom_get_default_pad+0x168>)
    2c72:	e06b      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2c74:	4b40      	ldr	r3, [pc, #256]	; (2d78 <_sercom_get_default_pad+0x16c>)
    2c76:	e069      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2c78:	1cfb      	adds	r3, r7, #3
    2c7a:	781b      	ldrb	r3, [r3, #0]
    2c7c:	2b01      	cmp	r3, #1
    2c7e:	d00a      	beq.n	2c96 <_sercom_get_default_pad+0x8a>
    2c80:	dc02      	bgt.n	2c88 <_sercom_get_default_pad+0x7c>
    2c82:	2b00      	cmp	r3, #0
    2c84:	d005      	beq.n	2c92 <_sercom_get_default_pad+0x86>
    2c86:	e060      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2c88:	2b02      	cmp	r3, #2
    2c8a:	d006      	beq.n	2c9a <_sercom_get_default_pad+0x8e>
    2c8c:	2b03      	cmp	r3, #3
    2c8e:	d006      	beq.n	2c9e <_sercom_get_default_pad+0x92>
    2c90:	e05b      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2c92:	2303      	movs	r3, #3
    2c94:	e05a      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2c96:	4b39      	ldr	r3, [pc, #228]	; (2d7c <_sercom_get_default_pad+0x170>)
    2c98:	e058      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2c9a:	4b39      	ldr	r3, [pc, #228]	; (2d80 <_sercom_get_default_pad+0x174>)
    2c9c:	e056      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2c9e:	4b39      	ldr	r3, [pc, #228]	; (2d84 <_sercom_get_default_pad+0x178>)
    2ca0:	e054      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2ca2:	1cfb      	adds	r3, r7, #3
    2ca4:	781b      	ldrb	r3, [r3, #0]
    2ca6:	2b01      	cmp	r3, #1
    2ca8:	d00a      	beq.n	2cc0 <_sercom_get_default_pad+0xb4>
    2caa:	dc02      	bgt.n	2cb2 <_sercom_get_default_pad+0xa6>
    2cac:	2b00      	cmp	r3, #0
    2cae:	d005      	beq.n	2cbc <_sercom_get_default_pad+0xb0>
    2cb0:	e04b      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2cb2:	2b02      	cmp	r3, #2
    2cb4:	d006      	beq.n	2cc4 <_sercom_get_default_pad+0xb8>
    2cb6:	2b03      	cmp	r3, #3
    2cb8:	d006      	beq.n	2cc8 <_sercom_get_default_pad+0xbc>
    2cba:	e046      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2cbc:	4b32      	ldr	r3, [pc, #200]	; (2d88 <_sercom_get_default_pad+0x17c>)
    2cbe:	e045      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2cc0:	4b32      	ldr	r3, [pc, #200]	; (2d8c <_sercom_get_default_pad+0x180>)
    2cc2:	e043      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2cc4:	4b32      	ldr	r3, [pc, #200]	; (2d90 <_sercom_get_default_pad+0x184>)
    2cc6:	e041      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2cc8:	4b32      	ldr	r3, [pc, #200]	; (2d94 <_sercom_get_default_pad+0x188>)
    2cca:	e03f      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2ccc:	1cfb      	adds	r3, r7, #3
    2cce:	781b      	ldrb	r3, [r3, #0]
    2cd0:	2b01      	cmp	r3, #1
    2cd2:	d00a      	beq.n	2cea <_sercom_get_default_pad+0xde>
    2cd4:	dc02      	bgt.n	2cdc <_sercom_get_default_pad+0xd0>
    2cd6:	2b00      	cmp	r3, #0
    2cd8:	d005      	beq.n	2ce6 <_sercom_get_default_pad+0xda>
    2cda:	e036      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2cdc:	2b02      	cmp	r3, #2
    2cde:	d006      	beq.n	2cee <_sercom_get_default_pad+0xe2>
    2ce0:	2b03      	cmp	r3, #3
    2ce2:	d006      	beq.n	2cf2 <_sercom_get_default_pad+0xe6>
    2ce4:	e031      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2ce6:	4b2c      	ldr	r3, [pc, #176]	; (2d98 <_sercom_get_default_pad+0x18c>)
    2ce8:	e030      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2cea:	4b2c      	ldr	r3, [pc, #176]	; (2d9c <_sercom_get_default_pad+0x190>)
    2cec:	e02e      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2cee:	4b2c      	ldr	r3, [pc, #176]	; (2da0 <_sercom_get_default_pad+0x194>)
    2cf0:	e02c      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2cf2:	4b2c      	ldr	r3, [pc, #176]	; (2da4 <_sercom_get_default_pad+0x198>)
    2cf4:	e02a      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2cf6:	1cfb      	adds	r3, r7, #3
    2cf8:	781b      	ldrb	r3, [r3, #0]
    2cfa:	2b01      	cmp	r3, #1
    2cfc:	d00a      	beq.n	2d14 <_sercom_get_default_pad+0x108>
    2cfe:	dc02      	bgt.n	2d06 <_sercom_get_default_pad+0xfa>
    2d00:	2b00      	cmp	r3, #0
    2d02:	d005      	beq.n	2d10 <_sercom_get_default_pad+0x104>
    2d04:	e021      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2d06:	2b02      	cmp	r3, #2
    2d08:	d006      	beq.n	2d18 <_sercom_get_default_pad+0x10c>
    2d0a:	2b03      	cmp	r3, #3
    2d0c:	d006      	beq.n	2d1c <_sercom_get_default_pad+0x110>
    2d0e:	e01c      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2d10:	4b25      	ldr	r3, [pc, #148]	; (2da8 <_sercom_get_default_pad+0x19c>)
    2d12:	e01b      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2d14:	4b25      	ldr	r3, [pc, #148]	; (2dac <_sercom_get_default_pad+0x1a0>)
    2d16:	e019      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2d18:	4b25      	ldr	r3, [pc, #148]	; (2db0 <_sercom_get_default_pad+0x1a4>)
    2d1a:	e017      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2d1c:	4b25      	ldr	r3, [pc, #148]	; (2db4 <_sercom_get_default_pad+0x1a8>)
    2d1e:	e015      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2d20:	1cfb      	adds	r3, r7, #3
    2d22:	781b      	ldrb	r3, [r3, #0]
    2d24:	2b01      	cmp	r3, #1
    2d26:	d00a      	beq.n	2d3e <_sercom_get_default_pad+0x132>
    2d28:	dc02      	bgt.n	2d30 <_sercom_get_default_pad+0x124>
    2d2a:	2b00      	cmp	r3, #0
    2d2c:	d005      	beq.n	2d3a <_sercom_get_default_pad+0x12e>
    2d2e:	e00c      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2d30:	2b02      	cmp	r3, #2
    2d32:	d006      	beq.n	2d42 <_sercom_get_default_pad+0x136>
    2d34:	2b03      	cmp	r3, #3
    2d36:	d006      	beq.n	2d46 <_sercom_get_default_pad+0x13a>
    2d38:	e007      	b.n	2d4a <_sercom_get_default_pad+0x13e>
    2d3a:	4b1f      	ldr	r3, [pc, #124]	; (2db8 <_sercom_get_default_pad+0x1ac>)
    2d3c:	e006      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2d3e:	4b1f      	ldr	r3, [pc, #124]	; (2dbc <_sercom_get_default_pad+0x1b0>)
    2d40:	e004      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2d42:	4b1f      	ldr	r3, [pc, #124]	; (2dc0 <_sercom_get_default_pad+0x1b4>)
    2d44:	e002      	b.n	2d4c <_sercom_get_default_pad+0x140>
    2d46:	4b1f      	ldr	r3, [pc, #124]	; (2dc4 <_sercom_get_default_pad+0x1b8>)
    2d48:	e000      	b.n	2d4c <_sercom_get_default_pad+0x140>
	}

	Assert(false);
	return 0;
    2d4a:	2300      	movs	r3, #0
}
    2d4c:	0018      	movs	r0, r3
    2d4e:	46bd      	mov	sp, r7
    2d50:	b002      	add	sp, #8
    2d52:	bd80      	pop	{r7, pc}
    2d54:	42001000 	.word	0x42001000
    2d58:	42000800 	.word	0x42000800
    2d5c:	42000c00 	.word	0x42000c00
    2d60:	42001800 	.word	0x42001800
    2d64:	42001c00 	.word	0x42001c00
    2d68:	42001400 	.word	0x42001400
    2d6c:	00040003 	.word	0x00040003
    2d70:	00050003 	.word	0x00050003
    2d74:	00060003 	.word	0x00060003
    2d78:	00070003 	.word	0x00070003
    2d7c:	00010003 	.word	0x00010003
    2d80:	001e0003 	.word	0x001e0003
    2d84:	001f0003 	.word	0x001f0003
    2d88:	00080003 	.word	0x00080003
    2d8c:	00090003 	.word	0x00090003
    2d90:	000a0003 	.word	0x000a0003
    2d94:	000b0003 	.word	0x000b0003
    2d98:	00100003 	.word	0x00100003
    2d9c:	00110003 	.word	0x00110003
    2da0:	00120003 	.word	0x00120003
    2da4:	00130003 	.word	0x00130003
    2da8:	000c0003 	.word	0x000c0003
    2dac:	000d0003 	.word	0x000d0003
    2db0:	000e0003 	.word	0x000e0003
    2db4:	000f0003 	.word	0x000f0003
    2db8:	00160003 	.word	0x00160003
    2dbc:	00170003 	.word	0x00170003
    2dc0:	00180003 	.word	0x00180003
    2dc4:	00190003 	.word	0x00190003

00002dc8 <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    2dc8:	b590      	push	{r4, r7, lr}
    2dca:	b08b      	sub	sp, #44	; 0x2c
    2dcc:	af00      	add	r7, sp, #0
    2dce:	6078      	str	r0, [r7, #4]
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    2dd0:	230c      	movs	r3, #12
    2dd2:	18fb      	adds	r3, r7, r3
    2dd4:	4a0f      	ldr	r2, [pc, #60]	; (2e14 <_sercom_get_sercom_inst_index+0x4c>)
    2dd6:	ca13      	ldmia	r2!, {r0, r1, r4}
    2dd8:	c313      	stmia	r3!, {r0, r1, r4}
    2dda:	ca13      	ldmia	r2!, {r0, r1, r4}
    2ddc:	c313      	stmia	r3!, {r0, r1, r4}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    2dde:	2300      	movs	r3, #0
    2de0:	627b      	str	r3, [r7, #36]	; 0x24
    2de2:	e00e      	b.n	2e02 <_sercom_get_sercom_inst_index+0x3a>
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    2de4:	230c      	movs	r3, #12
    2de6:	18fb      	adds	r3, r7, r3
    2de8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    2dea:	0092      	lsls	r2, r2, #2
    2dec:	58d3      	ldr	r3, [r2, r3]
    2dee:	1e1a      	subs	r2, r3, #0
    2df0:	687b      	ldr	r3, [r7, #4]
    2df2:	429a      	cmp	r2, r3
    2df4:	d102      	bne.n	2dfc <_sercom_get_sercom_inst_index+0x34>
			return i;
    2df6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2df8:	b2db      	uxtb	r3, r3
    2dfa:	e006      	b.n	2e0a <_sercom_get_sercom_inst_index+0x42>
{
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    2dfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2dfe:	3301      	adds	r3, #1
    2e00:	627b      	str	r3, [r7, #36]	; 0x24
    2e02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2e04:	2b05      	cmp	r3, #5
    2e06:	d9ed      	bls.n	2de4 <_sercom_get_sercom_inst_index+0x1c>
		}
	}

	/* Invalid data given */
	Assert(false);
	return 0;
    2e08:	2300      	movs	r3, #0
}
    2e0a:	0018      	movs	r0, r3
    2e0c:	46bd      	mov	sp, r7
    2e0e:	b00b      	add	sp, #44	; 0x2c
    2e10:	bd90      	pop	{r4, r7, pc}
    2e12:	46c0      	nop			; (mov r8, r8)
    2e14:	0000fca4 	.word	0x0000fca4

00002e18 <_sercom_default_handler>:
 *
 * \param[in] instance SERCOM instance used.
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
    2e18:	b580      	push	{r7, lr}
    2e1a:	b082      	sub	sp, #8
    2e1c:	af00      	add	r7, sp, #0
    2e1e:	0002      	movs	r2, r0
    2e20:	1dfb      	adds	r3, r7, #7
    2e22:	701a      	strb	r2, [r3, #0]
	Assert(false);
}
    2e24:	46c0      	nop			; (mov r8, r8)
    2e26:	46bd      	mov	sp, r7
    2e28:	b002      	add	sp, #8
    2e2a:	bd80      	pop	{r7, pc}

00002e2c <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    2e2c:	b580      	push	{r7, lr}
    2e2e:	b084      	sub	sp, #16
    2e30:	af00      	add	r7, sp, #0
    2e32:	0002      	movs	r2, r0
    2e34:	6039      	str	r1, [r7, #0]
    2e36:	1dfb      	adds	r3, r7, #7
    2e38:	701a      	strb	r2, [r3, #0]
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    2e3a:	4b13      	ldr	r3, [pc, #76]	; (2e88 <_sercom_set_handler+0x5c>)
    2e3c:	781b      	ldrb	r3, [r3, #0]
    2e3e:	2201      	movs	r2, #1
    2e40:	4053      	eors	r3, r2
    2e42:	b2db      	uxtb	r3, r3
    2e44:	2b00      	cmp	r3, #0
    2e46:	d015      	beq.n	2e74 <_sercom_set_handler+0x48>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    2e48:	2300      	movs	r3, #0
    2e4a:	60fb      	str	r3, [r7, #12]
    2e4c:	e00c      	b.n	2e68 <_sercom_set_handler+0x3c>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    2e4e:	4b0f      	ldr	r3, [pc, #60]	; (2e8c <_sercom_set_handler+0x60>)
    2e50:	68fa      	ldr	r2, [r7, #12]
    2e52:	0092      	lsls	r2, r2, #2
    2e54:	490e      	ldr	r1, [pc, #56]	; (2e90 <_sercom_set_handler+0x64>)
    2e56:	50d1      	str	r1, [r2, r3]
			_sercom_instances[i] = NULL;
    2e58:	4b0e      	ldr	r3, [pc, #56]	; (2e94 <_sercom_set_handler+0x68>)
    2e5a:	68fa      	ldr	r2, [r7, #12]
    2e5c:	0092      	lsls	r2, r2, #2
    2e5e:	2100      	movs	r1, #0
    2e60:	50d1      	str	r1, [r2, r3]
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    2e62:	68fb      	ldr	r3, [r7, #12]
    2e64:	3301      	adds	r3, #1
    2e66:	60fb      	str	r3, [r7, #12]
    2e68:	68fb      	ldr	r3, [r7, #12]
    2e6a:	2b05      	cmp	r3, #5
    2e6c:	d9ef      	bls.n	2e4e <_sercom_set_handler+0x22>
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
		}

		_handler_table_initialized = true;
    2e6e:	4b06      	ldr	r3, [pc, #24]	; (2e88 <_sercom_set_handler+0x5c>)
    2e70:	2201      	movs	r2, #1
    2e72:	701a      	strb	r2, [r3, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;
    2e74:	1dfb      	adds	r3, r7, #7
    2e76:	781a      	ldrb	r2, [r3, #0]
    2e78:	4b04      	ldr	r3, [pc, #16]	; (2e8c <_sercom_set_handler+0x60>)
    2e7a:	0092      	lsls	r2, r2, #2
    2e7c:	6839      	ldr	r1, [r7, #0]
    2e7e:	50d1      	str	r1, [r2, r3]
}
    2e80:	46c0      	nop			; (mov r8, r8)
    2e82:	46bd      	mov	sp, r7
    2e84:	b004      	add	sp, #16
    2e86:	bd80      	pop	{r7, pc}
    2e88:	20000ad6 	.word	0x20000ad6
    2e8c:	20000ad8 	.word	0x20000ad8
    2e90:	00002e19 	.word	0x00002e19
    2e94:	20002e54 	.word	0x20002e54

00002e98 <_sercom_get_interrupt_vector>:
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM6
 * \retval SYSTEM_INTERRUPT_MODULE_SERCOM7
 */
enum system_interrupt_vector _sercom_get_interrupt_vector(
		Sercom *const sercom_instance)
{
    2e98:	b590      	push	{r4, r7, lr}
    2e9a:	b085      	sub	sp, #20
    2e9c:	af00      	add	r7, sp, #0
    2e9e:	6078      	str	r0, [r7, #4]
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    2ea0:	2308      	movs	r3, #8
    2ea2:	18fa      	adds	r2, r7, r3
    2ea4:	4b0c      	ldr	r3, [pc, #48]	; (2ed8 <_sercom_get_interrupt_vector+0x40>)
    2ea6:	0010      	movs	r0, r2
    2ea8:	0019      	movs	r1, r3
    2eaa:	2306      	movs	r3, #6
    2eac:	001a      	movs	r2, r3
    2eae:	4b0b      	ldr	r3, [pc, #44]	; (2edc <_sercom_get_interrupt_vector+0x44>)
    2eb0:	4798      	blx	r3
		{
			MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_VECT_NUM, ~)
		};

	/* Retrieve the index of the SERCOM being requested */
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    2eb2:	230f      	movs	r3, #15
    2eb4:	18fc      	adds	r4, r7, r3
    2eb6:	687b      	ldr	r3, [r7, #4]
    2eb8:	0018      	movs	r0, r3
    2eba:	4b09      	ldr	r3, [pc, #36]	; (2ee0 <_sercom_get_interrupt_vector+0x48>)
    2ebc:	4798      	blx	r3
    2ebe:	0003      	movs	r3, r0
    2ec0:	7023      	strb	r3, [r4, #0]

	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    2ec2:	230f      	movs	r3, #15
    2ec4:	18fb      	adds	r3, r7, r3
    2ec6:	781b      	ldrb	r3, [r3, #0]
    2ec8:	2208      	movs	r2, #8
    2eca:	18ba      	adds	r2, r7, r2
    2ecc:	5cd3      	ldrb	r3, [r2, r3]
    2ece:	b25b      	sxtb	r3, r3
}
    2ed0:	0018      	movs	r0, r3
    2ed2:	46bd      	mov	sp, r7
    2ed4:	b005      	add	sp, #20
    2ed6:	bd90      	pop	{r4, r7, pc}
    2ed8:	0000fcbc 	.word	0x0000fcbc
    2edc:	0000fc43 	.word	0x0000fc43
    2ee0:	00002dc9 	.word	0x00002dc9

00002ee4 <SERCOM0_Handler>:

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    2ee4:	b580      	push	{r7, lr}
    2ee6:	af00      	add	r7, sp, #0
    2ee8:	4b03      	ldr	r3, [pc, #12]	; (2ef8 <SERCOM0_Handler+0x14>)
    2eea:	681b      	ldr	r3, [r3, #0]
    2eec:	2000      	movs	r0, #0
    2eee:	4798      	blx	r3
    2ef0:	46c0      	nop			; (mov r8, r8)
    2ef2:	46bd      	mov	sp, r7
    2ef4:	bd80      	pop	{r7, pc}
    2ef6:	46c0      	nop			; (mov r8, r8)
    2ef8:	20000ad8 	.word	0x20000ad8

00002efc <SERCOM1_Handler>:
    2efc:	b580      	push	{r7, lr}
    2efe:	af00      	add	r7, sp, #0
    2f00:	4b03      	ldr	r3, [pc, #12]	; (2f10 <SERCOM1_Handler+0x14>)
    2f02:	685b      	ldr	r3, [r3, #4]
    2f04:	2001      	movs	r0, #1
    2f06:	4798      	blx	r3
    2f08:	46c0      	nop			; (mov r8, r8)
    2f0a:	46bd      	mov	sp, r7
    2f0c:	bd80      	pop	{r7, pc}
    2f0e:	46c0      	nop			; (mov r8, r8)
    2f10:	20000ad8 	.word	0x20000ad8

00002f14 <SERCOM2_Handler>:
    2f14:	b580      	push	{r7, lr}
    2f16:	af00      	add	r7, sp, #0
    2f18:	4b03      	ldr	r3, [pc, #12]	; (2f28 <SERCOM2_Handler+0x14>)
    2f1a:	689b      	ldr	r3, [r3, #8]
    2f1c:	2002      	movs	r0, #2
    2f1e:	4798      	blx	r3
    2f20:	46c0      	nop			; (mov r8, r8)
    2f22:	46bd      	mov	sp, r7
    2f24:	bd80      	pop	{r7, pc}
    2f26:	46c0      	nop			; (mov r8, r8)
    2f28:	20000ad8 	.word	0x20000ad8

00002f2c <SERCOM3_Handler>:
    2f2c:	b580      	push	{r7, lr}
    2f2e:	af00      	add	r7, sp, #0
    2f30:	4b03      	ldr	r3, [pc, #12]	; (2f40 <SERCOM3_Handler+0x14>)
    2f32:	68db      	ldr	r3, [r3, #12]
    2f34:	2003      	movs	r0, #3
    2f36:	4798      	blx	r3
    2f38:	46c0      	nop			; (mov r8, r8)
    2f3a:	46bd      	mov	sp, r7
    2f3c:	bd80      	pop	{r7, pc}
    2f3e:	46c0      	nop			; (mov r8, r8)
    2f40:	20000ad8 	.word	0x20000ad8

00002f44 <SERCOM4_Handler>:
    2f44:	b580      	push	{r7, lr}
    2f46:	af00      	add	r7, sp, #0
    2f48:	4b03      	ldr	r3, [pc, #12]	; (2f58 <SERCOM4_Handler+0x14>)
    2f4a:	691b      	ldr	r3, [r3, #16]
    2f4c:	2004      	movs	r0, #4
    2f4e:	4798      	blx	r3
    2f50:	46c0      	nop			; (mov r8, r8)
    2f52:	46bd      	mov	sp, r7
    2f54:	bd80      	pop	{r7, pc}
    2f56:	46c0      	nop			; (mov r8, r8)
    2f58:	20000ad8 	.word	0x20000ad8

00002f5c <SERCOM5_Handler>:
    2f5c:	b580      	push	{r7, lr}
    2f5e:	af00      	add	r7, sp, #0
    2f60:	4b03      	ldr	r3, [pc, #12]	; (2f70 <SERCOM5_Handler+0x14>)
    2f62:	695b      	ldr	r3, [r3, #20]
    2f64:	2005      	movs	r0, #5
    2f66:	4798      	blx	r3
    2f68:	46c0      	nop			; (mov r8, r8)
    2f6a:	46bd      	mov	sp, r7
    2f6c:	bd80      	pop	{r7, pc}
    2f6e:	46c0      	nop			; (mov r8, r8)
    2f70:	20000ad8 	.word	0x20000ad8

00002f74 <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    2f74:	b580      	push	{r7, lr}
    2f76:	b082      	sub	sp, #8
    2f78:	af00      	add	r7, sp, #0
    2f7a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    2f7c:	687b      	ldr	r3, [r7, #4]
    2f7e:	2280      	movs	r2, #128	; 0x80
    2f80:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    2f82:	687b      	ldr	r3, [r7, #4]
    2f84:	2200      	movs	r2, #0
    2f86:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    2f88:	687b      	ldr	r3, [r7, #4]
    2f8a:	2201      	movs	r2, #1
    2f8c:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    2f8e:	687b      	ldr	r3, [r7, #4]
    2f90:	2200      	movs	r2, #0
    2f92:	70da      	strb	r2, [r3, #3]
}
    2f94:	46c0      	nop			; (mov r8, r8)
    2f96:	46bd      	mov	sp, r7
    2f98:	b002      	add	sp, #8
    2f9a:	bd80      	pop	{r7, pc}

00002f9c <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    2f9c:	b580      	push	{r7, lr}
    2f9e:	b084      	sub	sp, #16
    2fa0:	af00      	add	r7, sp, #0
    2fa2:	0002      	movs	r2, r0
    2fa4:	1dfb      	adds	r3, r7, #7
    2fa6:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    2fa8:	230f      	movs	r3, #15
    2faa:	18fb      	adds	r3, r7, r3
    2fac:	1dfa      	adds	r2, r7, #7
    2fae:	7812      	ldrb	r2, [r2, #0]
    2fb0:	09d2      	lsrs	r2, r2, #7
    2fb2:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    2fb4:	230e      	movs	r3, #14
    2fb6:	18fb      	adds	r3, r7, r3
    2fb8:	1dfa      	adds	r2, r7, #7
    2fba:	7812      	ldrb	r2, [r2, #0]
    2fbc:	0952      	lsrs	r2, r2, #5
    2fbe:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    2fc0:	4b0d      	ldr	r3, [pc, #52]	; (2ff8 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    2fc2:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    2fc4:	230f      	movs	r3, #15
    2fc6:	18fb      	adds	r3, r7, r3
    2fc8:	781b      	ldrb	r3, [r3, #0]
    2fca:	2b00      	cmp	r3, #0
    2fcc:	d10f      	bne.n	2fee <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    2fce:	230f      	movs	r3, #15
    2fd0:	18fb      	adds	r3, r7, r3
    2fd2:	781b      	ldrb	r3, [r3, #0]
    2fd4:	009b      	lsls	r3, r3, #2
    2fd6:	2210      	movs	r2, #16
    2fd8:	4694      	mov	ip, r2
    2fda:	44bc      	add	ip, r7
    2fdc:	4463      	add	r3, ip
    2fde:	3b08      	subs	r3, #8
    2fe0:	681a      	ldr	r2, [r3, #0]
    2fe2:	230e      	movs	r3, #14
    2fe4:	18fb      	adds	r3, r7, r3
    2fe6:	781b      	ldrb	r3, [r3, #0]
    2fe8:	01db      	lsls	r3, r3, #7
    2fea:	18d3      	adds	r3, r2, r3
    2fec:	e000      	b.n	2ff0 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    2fee:	2300      	movs	r3, #0
	}
}
    2ff0:	0018      	movs	r0, r3
    2ff2:	46bd      	mov	sp, r7
    2ff4:	b004      	add	sp, #16
    2ff6:	bd80      	pop	{r7, pc}
    2ff8:	41004400 	.word	0x41004400

00002ffc <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    2ffc:	b580      	push	{r7, lr}
    2ffe:	b082      	sub	sp, #8
    3000:	af00      	add	r7, sp, #0
    3002:	0002      	movs	r2, r0
    3004:	1dfb      	adds	r3, r7, #7
    3006:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    3008:	1dfb      	adds	r3, r7, #7
    300a:	781b      	ldrb	r3, [r3, #0]
    300c:	0018      	movs	r0, r3
    300e:	4b03      	ldr	r3, [pc, #12]	; (301c <port_get_group_from_gpio_pin+0x20>)
    3010:	4798      	blx	r3
    3012:	0003      	movs	r3, r0
}
    3014:	0018      	movs	r0, r3
    3016:	46bd      	mov	sp, r7
    3018:	b002      	add	sp, #8
    301a:	bd80      	pop	{r7, pc}
    301c:	00002f9d 	.word	0x00002f9d

00003020 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    3020:	b580      	push	{r7, lr}
    3022:	b084      	sub	sp, #16
    3024:	af00      	add	r7, sp, #0
    3026:	0002      	movs	r2, r0
    3028:	1dfb      	adds	r3, r7, #7
    302a:	701a      	strb	r2, [r3, #0]
    302c:	1dbb      	adds	r3, r7, #6
    302e:	1c0a      	adds	r2, r1, #0
    3030:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    3032:	1dfb      	adds	r3, r7, #7
    3034:	781b      	ldrb	r3, [r3, #0]
    3036:	0018      	movs	r0, r3
    3038:	4b0d      	ldr	r3, [pc, #52]	; (3070 <port_pin_set_output_level+0x50>)
    303a:	4798      	blx	r3
    303c:	0003      	movs	r3, r0
    303e:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    3040:	1dfb      	adds	r3, r7, #7
    3042:	781b      	ldrb	r3, [r3, #0]
    3044:	221f      	movs	r2, #31
    3046:	4013      	ands	r3, r2
    3048:	2201      	movs	r2, #1
    304a:	409a      	lsls	r2, r3
    304c:	0013      	movs	r3, r2
    304e:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    3050:	1dbb      	adds	r3, r7, #6
    3052:	781b      	ldrb	r3, [r3, #0]
    3054:	2b00      	cmp	r3, #0
    3056:	d003      	beq.n	3060 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    3058:	68fb      	ldr	r3, [r7, #12]
    305a:	68ba      	ldr	r2, [r7, #8]
    305c:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    305e:	e002      	b.n	3066 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    3060:	68fb      	ldr	r3, [r7, #12]
    3062:	68ba      	ldr	r2, [r7, #8]
    3064:	615a      	str	r2, [r3, #20]
	}
}
    3066:	46c0      	nop			; (mov r8, r8)
    3068:	46bd      	mov	sp, r7
    306a:	b004      	add	sp, #16
    306c:	bd80      	pop	{r7, pc}
    306e:	46c0      	nop			; (mov r8, r8)
    3070:	00002ffd 	.word	0x00002ffd

00003074 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    3074:	b580      	push	{r7, lr}
    3076:	b082      	sub	sp, #8
    3078:	af00      	add	r7, sp, #0
    307a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    307c:	687b      	ldr	r3, [r7, #4]
    307e:	2200      	movs	r2, #0
    3080:	701a      	strb	r2, [r3, #0]
}
    3082:	46c0      	nop			; (mov r8, r8)
    3084:	46bd      	mov	sp, r7
    3086:	b002      	add	sp, #8
    3088:	bd80      	pop	{r7, pc}
    308a:	46c0      	nop			; (mov r8, r8)

0000308c <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    308c:	b580      	push	{r7, lr}
    308e:	b082      	sub	sp, #8
    3090:	af00      	add	r7, sp, #0
    3092:	0002      	movs	r2, r0
    3094:	6039      	str	r1, [r7, #0]
    3096:	1dfb      	adds	r3, r7, #7
    3098:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    309a:	1dfb      	adds	r3, r7, #7
    309c:	781b      	ldrb	r3, [r3, #0]
    309e:	2b01      	cmp	r3, #1
    30a0:	d00a      	beq.n	30b8 <system_apb_clock_set_mask+0x2c>
    30a2:	2b02      	cmp	r3, #2
    30a4:	d00f      	beq.n	30c6 <system_apb_clock_set_mask+0x3a>
    30a6:	2b00      	cmp	r3, #0
    30a8:	d114      	bne.n	30d4 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    30aa:	4b0e      	ldr	r3, [pc, #56]	; (30e4 <system_apb_clock_set_mask+0x58>)
    30ac:	4a0d      	ldr	r2, [pc, #52]	; (30e4 <system_apb_clock_set_mask+0x58>)
    30ae:	6991      	ldr	r1, [r2, #24]
    30b0:	683a      	ldr	r2, [r7, #0]
    30b2:	430a      	orrs	r2, r1
    30b4:	619a      	str	r2, [r3, #24]
			break;
    30b6:	e00f      	b.n	30d8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    30b8:	4b0a      	ldr	r3, [pc, #40]	; (30e4 <system_apb_clock_set_mask+0x58>)
    30ba:	4a0a      	ldr	r2, [pc, #40]	; (30e4 <system_apb_clock_set_mask+0x58>)
    30bc:	69d1      	ldr	r1, [r2, #28]
    30be:	683a      	ldr	r2, [r7, #0]
    30c0:	430a      	orrs	r2, r1
    30c2:	61da      	str	r2, [r3, #28]
			break;
    30c4:	e008      	b.n	30d8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    30c6:	4b07      	ldr	r3, [pc, #28]	; (30e4 <system_apb_clock_set_mask+0x58>)
    30c8:	4a06      	ldr	r2, [pc, #24]	; (30e4 <system_apb_clock_set_mask+0x58>)
    30ca:	6a11      	ldr	r1, [r2, #32]
    30cc:	683a      	ldr	r2, [r7, #0]
    30ce:	430a      	orrs	r2, r1
    30d0:	621a      	str	r2, [r3, #32]
			break;
    30d2:	e001      	b.n	30d8 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    30d4:	2317      	movs	r3, #23
    30d6:	e000      	b.n	30da <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    30d8:	2300      	movs	r3, #0
}
    30da:	0018      	movs	r0, r3
    30dc:	46bd      	mov	sp, r7
    30de:	b002      	add	sp, #8
    30e0:	bd80      	pop	{r7, pc}
    30e2:	46c0      	nop			; (mov r8, r8)
    30e4:	40000400 	.word	0x40000400

000030e8 <system_is_debugger_present>:
 * \retval true  Debugger is connected to the system
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
    30e8:	b580      	push	{r7, lr}
    30ea:	af00      	add	r7, sp, #0
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    30ec:	4b05      	ldr	r3, [pc, #20]	; (3104 <system_is_debugger_present+0x1c>)
    30ee:	789b      	ldrb	r3, [r3, #2]
    30f0:	b2db      	uxtb	r3, r3
    30f2:	001a      	movs	r2, r3
    30f4:	2302      	movs	r3, #2
    30f6:	4013      	ands	r3, r2
    30f8:	1e5a      	subs	r2, r3, #1
    30fa:	4193      	sbcs	r3, r2
    30fc:	b2db      	uxtb	r3, r3
}
    30fe:	0018      	movs	r0, r3
    3100:	46bd      	mov	sp, r7
    3102:	bd80      	pop	{r7, pc}
    3104:	41002000 	.word	0x41002000

00003108 <spi_is_write_complete>:
 *                has been drawn high for SPI slave
 * \retval false  If the SPI master module has not shifted out data
 */
static inline bool spi_is_write_complete(
		struct spi_module *const module)
{
    3108:	b580      	push	{r7, lr}
    310a:	b084      	sub	sp, #16
    310c:	af00      	add	r7, sp, #0
    310e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    3110:	687b      	ldr	r3, [r7, #4]
    3112:	681b      	ldr	r3, [r3, #0]
    3114:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_TXC);
    3116:	68fb      	ldr	r3, [r7, #12]
    3118:	7b9b      	ldrb	r3, [r3, #14]
    311a:	b2db      	uxtb	r3, r3
    311c:	001a      	movs	r2, r3
    311e:	2302      	movs	r3, #2
    3120:	4013      	ands	r3, r2
    3122:	1e5a      	subs	r2, r3, #1
    3124:	4193      	sbcs	r3, r2
    3126:	b2db      	uxtb	r3, r3
}
    3128:	0018      	movs	r0, r3
    312a:	46bd      	mov	sp, r7
    312c:	b004      	add	sp, #16
    312e:	bd80      	pop	{r7, pc}

00003130 <spi_is_ready_to_write>:
 * \retval true   If the SPI module is ready to write data
 * \retval false  If the SPI module is not ready to write data
 */
static inline bool spi_is_ready_to_write(
		struct spi_module *const module)
{
    3130:	b580      	push	{r7, lr}
    3132:	b084      	sub	sp, #16
    3134:	af00      	add	r7, sp, #0
    3136:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    3138:	687b      	ldr	r3, [r7, #4]
    313a:	681b      	ldr	r3, [r3, #0]
    313c:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_DRE);
    313e:	68fb      	ldr	r3, [r7, #12]
    3140:	7b9b      	ldrb	r3, [r3, #14]
    3142:	b2db      	uxtb	r3, r3
    3144:	001a      	movs	r2, r3
    3146:	2301      	movs	r3, #1
    3148:	4013      	ands	r3, r2
    314a:	1e5a      	subs	r2, r3, #1
    314c:	4193      	sbcs	r3, r2
    314e:	b2db      	uxtb	r3, r3
}
    3150:	0018      	movs	r0, r3
    3152:	46bd      	mov	sp, r7
    3154:	b004      	add	sp, #16
    3156:	bd80      	pop	{r7, pc}

00003158 <spi_is_ready_to_read>:
 * \retval true   If the SPI module is ready to read data
 * \retval false  If the SPI module is not ready to read data
 */
static inline bool spi_is_ready_to_read(
		struct spi_module *const module)
{
    3158:	b580      	push	{r7, lr}
    315a:	b084      	sub	sp, #16
    315c:	af00      	add	r7, sp, #0
    315e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    3160:	687b      	ldr	r3, [r7, #4]
    3162:	681b      	ldr	r3, [r3, #0]
    3164:	60fb      	str	r3, [r7, #12]

	/* Check interrupt flag */
	return (spi_module->INTFLAG.reg & SERCOM_SPI_INTFLAG_RXC);
    3166:	68fb      	ldr	r3, [r7, #12]
    3168:	7b9b      	ldrb	r3, [r3, #14]
    316a:	b2db      	uxtb	r3, r3
    316c:	001a      	movs	r2, r3
    316e:	2304      	movs	r3, #4
    3170:	4013      	ands	r3, r2
    3172:	1e5a      	subs	r2, r3, #1
    3174:	4193      	sbcs	r3, r2
    3176:	b2db      	uxtb	r3, r3
}
    3178:	0018      	movs	r0, r3
    317a:	46bd      	mov	sp, r7
    317c:	b004      	add	sp, #16
    317e:	bd80      	pop	{r7, pc}

00003180 <spi_write>:
 * \retval STATUS_BUSY  If the last write was not completed
 */
static inline enum status_code spi_write(
		struct spi_module *module,
		uint16_t tx_data)
{
    3180:	b580      	push	{r7, lr}
    3182:	b084      	sub	sp, #16
    3184:	af00      	add	r7, sp, #0
    3186:	6078      	str	r0, [r7, #4]
    3188:	000a      	movs	r2, r1
    318a:	1cbb      	adds	r3, r7, #2
    318c:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    318e:	687b      	ldr	r3, [r7, #4]
    3190:	681b      	ldr	r3, [r3, #0]
    3192:	60fb      	str	r3, [r7, #12]

	/* Check if the data register has been copied to the shift register */
	if (!spi_is_ready_to_write(module)) {
    3194:	687b      	ldr	r3, [r7, #4]
    3196:	0018      	movs	r0, r3
    3198:	4b0b      	ldr	r3, [pc, #44]	; (31c8 <spi_write+0x48>)
    319a:	4798      	blx	r3
    319c:	0003      	movs	r3, r0
    319e:	001a      	movs	r2, r3
    31a0:	2301      	movs	r3, #1
    31a2:	4053      	eors	r3, r2
    31a4:	b2db      	uxtb	r3, r3
    31a6:	2b00      	cmp	r3, #0
    31a8:	d001      	beq.n	31ae <spi_write+0x2e>
		/* Data register has not been copied to the shift register, return */
		return STATUS_BUSY;
    31aa:	2305      	movs	r3, #5
    31ac:	e007      	b.n	31be <spi_write+0x3e>
	}

	/* Write the character to the DATA register */
	spi_module->DATA.reg = tx_data & SERCOM_SPI_DATA_MASK;
    31ae:	1cbb      	adds	r3, r7, #2
    31b0:	881b      	ldrh	r3, [r3, #0]
    31b2:	05db      	lsls	r3, r3, #23
    31b4:	0ddb      	lsrs	r3, r3, #23
    31b6:	b29a      	uxth	r2, r3
    31b8:	68fb      	ldr	r3, [r7, #12]
    31ba:	831a      	strh	r2, [r3, #24]

	return STATUS_OK;
    31bc:	2300      	movs	r3, #0
}
    31be:	0018      	movs	r0, r3
    31c0:	46bd      	mov	sp, r7
    31c2:	b004      	add	sp, #16
    31c4:	bd80      	pop	{r7, pc}
    31c6:	46c0      	nop			; (mov r8, r8)
    31c8:	00003131 	.word	0x00003131

000031cc <spi_read>:
 * \retval STATUS_ERR_OVERFLOW  If the data is overflown
 */
static inline enum status_code spi_read(
		struct spi_module *const module,
		uint16_t *rx_data)
{
    31cc:	b580      	push	{r7, lr}
    31ce:	b084      	sub	sp, #16
    31d0:	af00      	add	r7, sp, #0
    31d2:	6078      	str	r0, [r7, #4]
    31d4:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    31d6:	687b      	ldr	r3, [r7, #4]
    31d8:	681b      	ldr	r3, [r3, #0]
    31da:	60bb      	str	r3, [r7, #8]

	/* Check if data is ready to be read */
	if (!spi_is_ready_to_read(module)) {
    31dc:	687b      	ldr	r3, [r7, #4]
    31de:	0018      	movs	r0, r3
    31e0:	4b1e      	ldr	r3, [pc, #120]	; (325c <spi_read+0x90>)
    31e2:	4798      	blx	r3
    31e4:	0003      	movs	r3, r0
    31e6:	001a      	movs	r2, r3
    31e8:	2301      	movs	r3, #1
    31ea:	4053      	eors	r3, r2
    31ec:	b2db      	uxtb	r3, r3
    31ee:	2b00      	cmp	r3, #0
    31f0:	d001      	beq.n	31f6 <spi_read+0x2a>
		/* No data has been received, return */
		return STATUS_ERR_IO;
    31f2:	2310      	movs	r3, #16
    31f4:	e02e      	b.n	3254 <spi_read+0x88>
	}

	/* Return value */
	enum status_code retval = STATUS_OK;
    31f6:	230f      	movs	r3, #15
    31f8:	18fb      	adds	r3, r7, r3
    31fa:	2200      	movs	r2, #0
    31fc:	701a      	strb	r2, [r3, #0]

	/* Check if data is overflown */
	if (spi_module->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    31fe:	68bb      	ldr	r3, [r7, #8]
    3200:	8a1b      	ldrh	r3, [r3, #16]
    3202:	b29b      	uxth	r3, r3
    3204:	001a      	movs	r2, r3
    3206:	2304      	movs	r3, #4
    3208:	4013      	ands	r3, r2
    320a:	d00b      	beq.n	3224 <spi_read+0x58>
		retval = STATUS_ERR_OVERFLOW;
    320c:	230f      	movs	r3, #15
    320e:	18fb      	adds	r3, r7, r3
    3210:	221e      	movs	r2, #30
    3212:	701a      	strb	r2, [r3, #0]
		/* Clear overflow flag */
		spi_module->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    3214:	68bb      	ldr	r3, [r7, #8]
    3216:	8a1b      	ldrh	r3, [r3, #16]
    3218:	b29b      	uxth	r3, r3
    321a:	2204      	movs	r2, #4
    321c:	4313      	orrs	r3, r2
    321e:	b29a      	uxth	r2, r3
    3220:	68bb      	ldr	r3, [r7, #8]
    3222:	821a      	strh	r2, [r3, #16]
	}

	/* Read the character from the DATA register */
	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    3224:	687b      	ldr	r3, [r7, #4]
    3226:	799b      	ldrb	r3, [r3, #6]
    3228:	2b01      	cmp	r3, #1
    322a:	d108      	bne.n	323e <spi_read+0x72>
		*rx_data = (spi_module->DATA.reg & SERCOM_SPI_DATA_MASK);
    322c:	68bb      	ldr	r3, [r7, #8]
    322e:	8b1b      	ldrh	r3, [r3, #24]
    3230:	b29b      	uxth	r3, r3
    3232:	05db      	lsls	r3, r3, #23
    3234:	0ddb      	lsrs	r3, r3, #23
    3236:	b29a      	uxth	r2, r3
    3238:	683b      	ldr	r3, [r7, #0]
    323a:	801a      	strh	r2, [r3, #0]
    323c:	e007      	b.n	324e <spi_read+0x82>
	} else {
		*rx_data = (uint8_t)spi_module->DATA.reg;
    323e:	68bb      	ldr	r3, [r7, #8]
    3240:	8b1b      	ldrh	r3, [r3, #24]
    3242:	b29b      	uxth	r3, r3
    3244:	22ff      	movs	r2, #255	; 0xff
    3246:	4013      	ands	r3, r2
    3248:	b29a      	uxth	r2, r3
    324a:	683b      	ldr	r3, [r7, #0]
    324c:	801a      	strh	r2, [r3, #0]
	}

	return retval;
    324e:	230f      	movs	r3, #15
    3250:	18fb      	adds	r3, r7, r3
    3252:	781b      	ldrb	r3, [r3, #0]
}
    3254:	0018      	movs	r0, r3
    3256:	46bd      	mov	sp, r7
    3258:	b004      	add	sp, #16
    325a:	bd80      	pop	{r7, pc}
    325c:	00003159 	.word	0x00003159

00003260 <_spi_set_config>:
 * \retval STATUS_OK               If the configuration was written
 */
static enum status_code _spi_set_config(
		struct spi_module *const module,
		const struct spi_config *const config)
{
    3260:	b590      	push	{r4, r7, lr}
    3262:	b093      	sub	sp, #76	; 0x4c
    3264:	af00      	add	r7, sp, #0
    3266:	6078      	str	r0, [r7, #4]
    3268:	6039      	str	r1, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(config);
	Assert(module->hw);

	SercomSpi *const spi_module = &(module->hw->SPI);
    326a:	687b      	ldr	r3, [r7, #4]
    326c:	681b      	ldr	r3, [r3, #0]
    326e:	637b      	str	r3, [r7, #52]	; 0x34
	Sercom *const hw = module->hw;
    3270:	687b      	ldr	r3, [r7, #4]
    3272:	681b      	ldr	r3, [r3, #0]
    3274:	633b      	str	r3, [r7, #48]	; 0x30

	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
    3276:	231c      	movs	r3, #28
    3278:	18fb      	adds	r3, r7, r3
    327a:	0018      	movs	r0, r3
    327c:	4b6a      	ldr	r3, [pc, #424]	; (3428 <_spi_set_config+0x1c8>)
    327e:	4798      	blx	r3
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
    3280:	231c      	movs	r3, #28
    3282:	18fb      	adds	r3, r7, r3
    3284:	2200      	movs	r2, #0
    3286:	705a      	strb	r2, [r3, #1]
	if(config->mode == SPI_MODE_SLAVE) {
    3288:	683b      	ldr	r3, [r7, #0]
    328a:	781b      	ldrb	r3, [r3, #0]
    328c:	2b00      	cmp	r3, #0
    328e:	d103      	bne.n	3298 <_spi_set_config+0x38>
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    3290:	231c      	movs	r3, #28
    3292:	18fb      	adds	r3, r7, r3
    3294:	2200      	movs	r2, #0
    3296:	709a      	strb	r2, [r3, #2]
	}

	uint32_t pad_pinmuxes[] = {
			config->pinmux_pad0, config->pinmux_pad1,
    3298:	683b      	ldr	r3, [r7, #0]
    329a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
    329c:	230c      	movs	r3, #12
    329e:	18fb      	adds	r3, r7, r3
    32a0:	601a      	str	r2, [r3, #0]
			config->pinmux_pad0, config->pinmux_pad1,
    32a2:	683b      	ldr	r3, [r7, #0]
    32a4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
    32a6:	230c      	movs	r3, #12
    32a8:	18fb      	adds	r3, r7, r3
    32aa:	605a      	str	r2, [r3, #4]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
    32ac:	683b      	ldr	r3, [r7, #0]
    32ae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
    32b0:	230c      	movs	r3, #12
    32b2:	18fb      	adds	r3, r7, r3
    32b4:	609a      	str	r2, [r3, #8]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
    32b6:	683b      	ldr	r3, [r7, #0]
    32b8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	if(config->mode == SPI_MODE_SLAVE) {
		pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
	}

	uint32_t pad_pinmuxes[] = {
    32ba:	230c      	movs	r3, #12
    32bc:	18fb      	adds	r3, r7, r3
    32be:	60da      	str	r2, [r3, #12]
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    32c0:	2347      	movs	r3, #71	; 0x47
    32c2:	18fb      	adds	r3, r7, r3
    32c4:	2200      	movs	r2, #0
    32c6:	701a      	strb	r2, [r3, #0]
    32c8:	e02c      	b.n	3324 <_spi_set_config+0xc4>
		uint32_t current_pinmux = pad_pinmuxes[pad];
    32ca:	2347      	movs	r3, #71	; 0x47
    32cc:	18fb      	adds	r3, r7, r3
    32ce:	781a      	ldrb	r2, [r3, #0]
    32d0:	230c      	movs	r3, #12
    32d2:	18fb      	adds	r3, r7, r3
    32d4:	0092      	lsls	r2, r2, #2
    32d6:	58d3      	ldr	r3, [r2, r3]
    32d8:	643b      	str	r3, [r7, #64]	; 0x40

		if (current_pinmux == PINMUX_DEFAULT) {
    32da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    32dc:	2b00      	cmp	r3, #0
    32de:	d109      	bne.n	32f4 <_spi_set_config+0x94>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    32e0:	2347      	movs	r3, #71	; 0x47
    32e2:	18fb      	adds	r3, r7, r3
    32e4:	781a      	ldrb	r2, [r3, #0]
    32e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    32e8:	0011      	movs	r1, r2
    32ea:	0018      	movs	r0, r3
    32ec:	4b4f      	ldr	r3, [pc, #316]	; (342c <_spi_set_config+0x1cc>)
    32ee:	4798      	blx	r3
    32f0:	0003      	movs	r3, r0
    32f2:	643b      	str	r3, [r7, #64]	; 0x40
		}

		if (current_pinmux != PINMUX_UNUSED) {
    32f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    32f6:	3301      	adds	r3, #1
    32f8:	d00d      	beq.n	3316 <_spi_set_config+0xb6>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    32fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    32fc:	b2da      	uxtb	r2, r3
    32fe:	231c      	movs	r3, #28
    3300:	18fb      	adds	r3, r7, r3
    3302:	701a      	strb	r2, [r3, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    3304:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    3306:	0c1b      	lsrs	r3, r3, #16
    3308:	b2db      	uxtb	r3, r3
    330a:	221c      	movs	r2, #28
    330c:	18ba      	adds	r2, r7, r2
    330e:	0011      	movs	r1, r2
    3310:	0018      	movs	r0, r3
    3312:	4b47      	ldr	r3, [pc, #284]	; (3430 <_spi_set_config+0x1d0>)
    3314:	4798      	blx	r3
			config->pinmux_pad0, config->pinmux_pad1,
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
    3316:	2347      	movs	r3, #71	; 0x47
    3318:	18fb      	adds	r3, r7, r3
    331a:	781a      	ldrb	r2, [r3, #0]
    331c:	2347      	movs	r3, #71	; 0x47
    331e:	18fb      	adds	r3, r7, r3
    3320:	3201      	adds	r2, #1
    3322:	701a      	strb	r2, [r3, #0]
    3324:	2347      	movs	r3, #71	; 0x47
    3326:	18fb      	adds	r3, r7, r3
    3328:	781b      	ldrb	r3, [r3, #0]
    332a:	2b03      	cmp	r3, #3
    332c:	d9cd      	bls.n	32ca <_spi_set_config+0x6a>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
		}
	}

	module->mode             = config->mode;
    332e:	683b      	ldr	r3, [r7, #0]
    3330:	781a      	ldrb	r2, [r3, #0]
    3332:	687b      	ldr	r3, [r7, #4]
    3334:	715a      	strb	r2, [r3, #5]
	module->character_size   = config->character_size;
    3336:	683b      	ldr	r3, [r7, #0]
    3338:	7c1a      	ldrb	r2, [r3, #16]
    333a:	687b      	ldr	r3, [r7, #4]
    333c:	719a      	strb	r2, [r3, #6]
	module->receiver_enabled = config->receiver_enable;
    333e:	683b      	ldr	r3, [r7, #0]
    3340:	7c9a      	ldrb	r2, [r3, #18]
    3342:	687b      	ldr	r3, [r7, #4]
    3344:	71da      	strb	r2, [r3, #7]
	module->master_slave_select_enable = config->master_slave_select_enable;
#  endif

#  if CONF_SPI_MASTER_ENABLE == true
	/* Value to write to BAUD register */
	uint16_t baud = 0;
    3346:	230a      	movs	r3, #10
    3348:	18fb      	adds	r3, r7, r3
    334a:	2200      	movs	r2, #0
    334c:	801a      	strh	r2, [r3, #0]
#  endif
	/* Value to write to CTRLA register */
	uint32_t ctrla = 0;
    334e:	2300      	movs	r3, #0
    3350:	63fb      	str	r3, [r7, #60]	; 0x3c
	/* Value to write to CTRLB register */
	uint32_t ctrlb = 0;
    3352:	2300      	movs	r3, #0
    3354:	63bb      	str	r3, [r7, #56]	; 0x38

# if CONF_SPI_MASTER_ENABLE == true
	/* Find baud value and write it */
	if (config->mode == SPI_MODE_MASTER) {
    3356:	683b      	ldr	r3, [r7, #0]
    3358:	781b      	ldrb	r3, [r3, #0]
    335a:	2b01      	cmp	r3, #1
    335c:	d129      	bne.n	33b2 <_spi_set_config+0x152>
		/* Find frequency of the internal SERCOMi_GCLK_ID_CORE */
		uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    335e:	687b      	ldr	r3, [r7, #4]
    3360:	681b      	ldr	r3, [r3, #0]
    3362:	0018      	movs	r0, r3
    3364:	4b33      	ldr	r3, [pc, #204]	; (3434 <_spi_set_config+0x1d4>)
    3366:	4798      	blx	r3
    3368:	0003      	movs	r3, r0
    336a:	62fb      	str	r3, [r7, #44]	; 0x2c
		uint32_t gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    336c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    336e:	330d      	adds	r3, #13
    3370:	62bb      	str	r3, [r7, #40]	; 0x28
		uint32_t internal_clock = system_gclk_chan_get_hz(gclk_index);
    3372:	6abb      	ldr	r3, [r7, #40]	; 0x28
    3374:	b2db      	uxtb	r3, r3
    3376:	0018      	movs	r0, r3
    3378:	4b2f      	ldr	r3, [pc, #188]	; (3438 <_spi_set_config+0x1d8>)
    337a:	4798      	blx	r3
    337c:	0003      	movs	r3, r0
    337e:	627b      	str	r3, [r7, #36]	; 0x24

		/* Get baud value, based on baudrate and the internal clock frequency */
		enum status_code error_code = _sercom_get_sync_baud_val(
    3380:	683b      	ldr	r3, [r7, #0]
    3382:	695b      	ldr	r3, [r3, #20]
    3384:	2223      	movs	r2, #35	; 0x23
    3386:	18bc      	adds	r4, r7, r2
    3388:	220a      	movs	r2, #10
    338a:	18ba      	adds	r2, r7, r2
    338c:	6a79      	ldr	r1, [r7, #36]	; 0x24
    338e:	0018      	movs	r0, r3
    3390:	4b2a      	ldr	r3, [pc, #168]	; (343c <_spi_set_config+0x1dc>)
    3392:	4798      	blx	r3
    3394:	0003      	movs	r3, r0
    3396:	7023      	strb	r3, [r4, #0]
				config->mode_specific.master.baudrate,
				internal_clock, &baud);

		if (error_code != STATUS_OK) {
    3398:	2323      	movs	r3, #35	; 0x23
    339a:	18fb      	adds	r3, r7, r3
    339c:	781b      	ldrb	r3, [r3, #0]
    339e:	2b00      	cmp	r3, #0
    33a0:	d001      	beq.n	33a6 <_spi_set_config+0x146>
			/* Baud rate calculation error, return status code */
			return STATUS_ERR_INVALID_ARG;
    33a2:	2317      	movs	r3, #23
    33a4:	e03c      	b.n	3420 <_spi_set_config+0x1c0>
		}

		spi_module->BAUD.reg = (uint8_t)baud;
    33a6:	230a      	movs	r3, #10
    33a8:	18fb      	adds	r3, r7, r3
    33aa:	881b      	ldrh	r3, [r3, #0]
    33ac:	b2da      	uxtb	r2, r3
    33ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    33b0:	729a      	strb	r2, [r3, #10]
			ctrlb |= SERCOM_SPI_CTRLB_PLOADEN;
		}
	}
# endif
	/* Set data order */
	ctrla |= config->data_order;
    33b2:	683b      	ldr	r3, [r7, #0]
    33b4:	685b      	ldr	r3, [r3, #4]
    33b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    33b8:	4313      	orrs	r3, r2
    33ba:	63fb      	str	r3, [r7, #60]	; 0x3c

	/* Set clock polarity and clock phase */
	ctrla |= config->transfer_mode;
    33bc:	683b      	ldr	r3, [r7, #0]
    33be:	689b      	ldr	r3, [r3, #8]
    33c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    33c2:	4313      	orrs	r3, r2
    33c4:	63fb      	str	r3, [r7, #60]	; 0x3c

	/* Set MUX setting */
	ctrla |= config->mux_setting;
    33c6:	683b      	ldr	r3, [r7, #0]
    33c8:	68db      	ldr	r3, [r3, #12]
    33ca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    33cc:	4313      	orrs	r3, r2
    33ce:	63fb      	str	r3, [r7, #60]	; 0x3c

	/* Set SPI character size */
	ctrlb |= config->character_size;
    33d0:	683b      	ldr	r3, [r7, #0]
    33d2:	7c1b      	ldrb	r3, [r3, #16]
    33d4:	001a      	movs	r2, r3
    33d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    33d8:	4313      	orrs	r3, r2
    33da:	63bb      	str	r3, [r7, #56]	; 0x38

	/* Set whether module should run in standby. */
	if (config->run_in_standby || system_is_debugger_present()) {
    33dc:	683b      	ldr	r3, [r7, #0]
    33de:	7c5b      	ldrb	r3, [r3, #17]
    33e0:	2b00      	cmp	r3, #0
    33e2:	d103      	bne.n	33ec <_spi_set_config+0x18c>
    33e4:	4b16      	ldr	r3, [pc, #88]	; (3440 <_spi_set_config+0x1e0>)
    33e6:	4798      	blx	r3
    33e8:	1e03      	subs	r3, r0, #0
    33ea:	d003      	beq.n	33f4 <_spi_set_config+0x194>
		ctrla |= SERCOM_SPI_CTRLA_RUNSTDBY;
    33ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    33ee:	2280      	movs	r2, #128	; 0x80
    33f0:	4313      	orrs	r3, r2
    33f2:	63fb      	str	r3, [r7, #60]	; 0x3c
	}

	if (config->receiver_enable) {
    33f4:	683b      	ldr	r3, [r7, #0]
    33f6:	7c9b      	ldrb	r3, [r3, #18]
    33f8:	2b00      	cmp	r3, #0
    33fa:	d004      	beq.n	3406 <_spi_set_config+0x1a6>
		/* Enable receiver */
		ctrlb |= SERCOM_SPI_CTRLB_RXEN;
    33fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    33fe:	2280      	movs	r2, #128	; 0x80
    3400:	0292      	lsls	r2, r2, #10
    3402:	4313      	orrs	r3, r2
    3404:	63bb      	str	r3, [r7, #56]	; 0x38
		/* Enable Master Slave Select */
		ctrlb |= SERCOM_SPI_CTRLB_MSSEN;
	}
#  endif
	/* Write CTRLA register */
	spi_module->CTRLA.reg |= ctrla;
    3406:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    3408:	681a      	ldr	r2, [r3, #0]
    340a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    340c:	431a      	orrs	r2, r3
    340e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    3410:	601a      	str	r2, [r3, #0]

	/* Write CTRLB register */
	spi_module->CTRLB.reg |= ctrlb;
    3412:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    3414:	685a      	ldr	r2, [r3, #4]
    3416:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    3418:	431a      	orrs	r2, r3
    341a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    341c:	605a      	str	r2, [r3, #4]

	return STATUS_OK;
    341e:	2300      	movs	r3, #0
}
    3420:	0018      	movs	r0, r3
    3422:	46bd      	mov	sp, r7
    3424:	b013      	add	sp, #76	; 0x4c
    3426:	bd90      	pop	{r4, r7, pc}
    3428:	00002f75 	.word	0x00002f75
    342c:	00002c0d 	.word	0x00002c0d
    3430:	00004d95 	.word	0x00004d95
    3434:	00002dc9 	.word	0x00002dc9
    3438:	00004bcd 	.word	0x00004bcd
    343c:	00002b05 	.word	0x00002b05
    3440:	000030e9 	.word	0x000030e9

00003444 <spi_init>:
 */
enum status_code spi_init(
		struct spi_module *const module,
		Sercom *const hw,
		const struct spi_config *const config)
{
    3444:	b590      	push	{r4, r7, lr}
    3446:	b08b      	sub	sp, #44	; 0x2c
    3448:	af00      	add	r7, sp, #0
    344a:	60f8      	str	r0, [r7, #12]
    344c:	60b9      	str	r1, [r7, #8]
    344e:	607a      	str	r2, [r7, #4]
	Assert(module);
	Assert(hw);
	Assert(config);

	/* Initialize device instance */
	module->hw = hw;
    3450:	68fb      	ldr	r3, [r7, #12]
    3452:	68ba      	ldr	r2, [r7, #8]
    3454:	601a      	str	r2, [r3, #0]

	SercomSpi *const spi_module = &(module->hw->SPI);
    3456:	68fb      	ldr	r3, [r7, #12]
    3458:	681b      	ldr	r3, [r3, #0]
    345a:	623b      	str	r3, [r7, #32]

	/* Check if module is enabled. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_ENABLE) {
    345c:	6a3b      	ldr	r3, [r7, #32]
    345e:	681b      	ldr	r3, [r3, #0]
    3460:	2202      	movs	r2, #2
    3462:	4013      	ands	r3, r2
    3464:	d001      	beq.n	346a <spi_init+0x26>
#  if SPI_CALLBACK_MODE == false
		/* Check if config is valid */
		return _spi_check_config(module, config);
#  else
		return STATUS_ERR_DENIED;
    3466:	231c      	movs	r3, #28
    3468:	e09c      	b.n	35a4 <spi_init+0x160>
#  endif
	}

	/* Check if reset is in progress. */
	if (spi_module->CTRLA.reg & SERCOM_SPI_CTRLA_SWRST){
    346a:	6a3b      	ldr	r3, [r7, #32]
    346c:	681b      	ldr	r3, [r3, #0]
    346e:	2201      	movs	r2, #1
    3470:	4013      	ands	r3, r2
    3472:	d001      	beq.n	3478 <spi_init+0x34>
		return STATUS_BUSY;
    3474:	2305      	movs	r3, #5
    3476:	e095      	b.n	35a4 <spi_init+0x160>
	}

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    3478:	68fb      	ldr	r3, [r7, #12]
    347a:	681b      	ldr	r3, [r3, #0]
    347c:	0018      	movs	r0, r3
    347e:	4b4b      	ldr	r3, [pc, #300]	; (35ac <spi_init+0x168>)
    3480:	4798      	blx	r3
    3482:	0003      	movs	r3, r0
    3484:	61fb      	str	r3, [r7, #28]
	}
#elif (SAMC20)
	pm_index     = sercom_index + MCLK_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    3486:	69fb      	ldr	r3, [r7, #28]
    3488:	3302      	adds	r3, #2
    348a:	61bb      	str	r3, [r7, #24]
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
    348c:	69fb      	ldr	r3, [r7, #28]
    348e:	330d      	adds	r3, #13
    3490:	617b      	str	r3, [r7, #20]
#  endif
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    3492:	2201      	movs	r2, #1
    3494:	69bb      	ldr	r3, [r7, #24]
    3496:	409a      	lsls	r2, r3
    3498:	0013      	movs	r3, r2
    349a:	0019      	movs	r1, r3
    349c:	2002      	movs	r0, #2
    349e:	4b44      	ldr	r3, [pc, #272]	; (35b0 <spi_init+0x16c>)
    34a0:	4798      	blx	r3
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
    34a2:	2310      	movs	r3, #16
    34a4:	18fb      	adds	r3, r7, r3
    34a6:	0018      	movs	r0, r3
    34a8:	4b42      	ldr	r3, [pc, #264]	; (35b4 <spi_init+0x170>)
    34aa:	4798      	blx	r3
	gclk_chan_conf.source_generator = config->generator_source;
    34ac:	687b      	ldr	r3, [r7, #4]
    34ae:	2220      	movs	r2, #32
    34b0:	5c9a      	ldrb	r2, [r3, r2]
    34b2:	2310      	movs	r3, #16
    34b4:	18fb      	adds	r3, r7, r3
    34b6:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    34b8:	697b      	ldr	r3, [r7, #20]
    34ba:	b2db      	uxtb	r3, r3
    34bc:	2210      	movs	r2, #16
    34be:	18ba      	adds	r2, r7, r2
    34c0:	0011      	movs	r1, r2
    34c2:	0018      	movs	r0, r3
    34c4:	4b3c      	ldr	r3, [pc, #240]	; (35b8 <spi_init+0x174>)
    34c6:	4798      	blx	r3
	system_gclk_chan_enable(gclk_index);
    34c8:	697b      	ldr	r3, [r7, #20]
    34ca:	b2db      	uxtb	r3, r3
    34cc:	0018      	movs	r0, r3
    34ce:	4b3b      	ldr	r3, [pc, #236]	; (35bc <spi_init+0x178>)
    34d0:	4798      	blx	r3
	sercom_set_gclk_generator(config->generator_source, false);
    34d2:	687b      	ldr	r3, [r7, #4]
    34d4:	2220      	movs	r2, #32
    34d6:	5c9b      	ldrb	r3, [r3, r2]
    34d8:	2100      	movs	r1, #0
    34da:	0018      	movs	r0, r3
    34dc:	4b38      	ldr	r3, [pc, #224]	; (35c0 <spi_init+0x17c>)
    34de:	4798      	blx	r3

#  if CONF_SPI_MASTER_ENABLE == true
	if (config->mode == SPI_MODE_MASTER) {
    34e0:	687b      	ldr	r3, [r7, #4]
    34e2:	781b      	ldrb	r3, [r3, #0]
    34e4:	2b01      	cmp	r3, #1
    34e6:	d105      	bne.n	34f4 <spi_init+0xb0>
		/* Set the SERCOM in SPI master mode */
		spi_module->CTRLA.reg |= SERCOM_SPI_CTRLA_MODE(0x3);
    34e8:	6a3b      	ldr	r3, [r7, #32]
    34ea:	681b      	ldr	r3, [r3, #0]
    34ec:	220c      	movs	r2, #12
    34ee:	431a      	orrs	r2, r3
    34f0:	6a3b      	ldr	r3, [r7, #32]
    34f2:	601a      	str	r2, [r3, #0]
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    34f4:	2327      	movs	r3, #39	; 0x27
    34f6:	18fb      	adds	r3, r7, r3
    34f8:	2200      	movs	r2, #0
    34fa:	701a      	strb	r2, [r3, #0]
    34fc:	e010      	b.n	3520 <spi_init+0xdc>
		module->callback[i]        = NULL;
    34fe:	2327      	movs	r3, #39	; 0x27
    3500:	18fb      	adds	r3, r7, r3
    3502:	781b      	ldrb	r3, [r3, #0]
    3504:	68fa      	ldr	r2, [r7, #12]
    3506:	3302      	adds	r3, #2
    3508:	009b      	lsls	r3, r3, #2
    350a:	18d3      	adds	r3, r2, r3
    350c:	3304      	adds	r3, #4
    350e:	2200      	movs	r2, #0
    3510:	601a      	str	r2, [r3, #0]
	/* Temporary variables */
	uint8_t i;
	uint8_t instance_index;

	/* Initialize parameters */
	for (i = 0; i < SPI_CALLBACK_N; i++) {
    3512:	2327      	movs	r3, #39	; 0x27
    3514:	18fb      	adds	r3, r7, r3
    3516:	781a      	ldrb	r2, [r3, #0]
    3518:	2327      	movs	r3, #39	; 0x27
    351a:	18fb      	adds	r3, r7, r3
    351c:	3201      	adds	r2, #1
    351e:	701a      	strb	r2, [r3, #0]
    3520:	2327      	movs	r3, #39	; 0x27
    3522:	18fb      	adds	r3, r7, r3
    3524:	781b      	ldrb	r3, [r3, #0]
    3526:	2b04      	cmp	r3, #4
    3528:	d9e9      	bls.n	34fe <spi_init+0xba>
		module->callback[i]        = NULL;
	}
	module->tx_buffer_ptr              = NULL;
    352a:	68fb      	ldr	r3, [r7, #12]
    352c:	2200      	movs	r2, #0
    352e:	625a      	str	r2, [r3, #36]	; 0x24
	module->rx_buffer_ptr              = NULL;
    3530:	68fb      	ldr	r3, [r7, #12]
    3532:	2200      	movs	r2, #0
    3534:	621a      	str	r2, [r3, #32]
	module->remaining_tx_buffer_length = 0x0000;
    3536:	68fb      	ldr	r3, [r7, #12]
    3538:	2200      	movs	r2, #0
    353a:	859a      	strh	r2, [r3, #44]	; 0x2c
	module->remaining_rx_buffer_length = 0x0000;
    353c:	68fb      	ldr	r3, [r7, #12]
    353e:	2200      	movs	r2, #0
    3540:	851a      	strh	r2, [r3, #40]	; 0x28
	module->registered_callback        = 0x00;
    3542:	68fb      	ldr	r3, [r7, #12]
    3544:	222e      	movs	r2, #46	; 0x2e
    3546:	2100      	movs	r1, #0
    3548:	5499      	strb	r1, [r3, r2]
	module->enabled_callback           = 0x00;
    354a:	68fb      	ldr	r3, [r7, #12]
    354c:	222f      	movs	r2, #47	; 0x2f
    354e:	2100      	movs	r1, #0
    3550:	5499      	strb	r1, [r3, r2]
	module->status                     = STATUS_OK;
    3552:	68fb      	ldr	r3, [r7, #12]
    3554:	2230      	movs	r2, #48	; 0x30
    3556:	2100      	movs	r1, #0
    3558:	5499      	strb	r1, [r3, r2]
	module->dir                        = SPI_DIRECTION_IDLE;
    355a:	68fb      	ldr	r3, [r7, #12]
    355c:	2203      	movs	r2, #3
    355e:	721a      	strb	r2, [r3, #8]
	module->locked                     = false;
    3560:	68fb      	ldr	r3, [r7, #12]
    3562:	2200      	movs	r2, #0
    3564:	711a      	strb	r2, [r3, #4]
	/*
	 * Set interrupt handler and register SPI software module struct in
	 * look-up table
	 */
	instance_index = _sercom_get_sercom_inst_index(module->hw);
    3566:	68fb      	ldr	r3, [r7, #12]
    3568:	681b      	ldr	r3, [r3, #0]
    356a:	2213      	movs	r2, #19
    356c:	18bc      	adds	r4, r7, r2
    356e:	0018      	movs	r0, r3
    3570:	4b0e      	ldr	r3, [pc, #56]	; (35ac <spi_init+0x168>)
    3572:	4798      	blx	r3
    3574:	0003      	movs	r3, r0
    3576:	7023      	strb	r3, [r4, #0]
	_sercom_set_handler(instance_index, _spi_interrupt_handler);
    3578:	4a12      	ldr	r2, [pc, #72]	; (35c4 <spi_init+0x180>)
    357a:	2313      	movs	r3, #19
    357c:	18fb      	adds	r3, r7, r3
    357e:	781b      	ldrb	r3, [r3, #0]
    3580:	0011      	movs	r1, r2
    3582:	0018      	movs	r0, r3
    3584:	4b10      	ldr	r3, [pc, #64]	; (35c8 <spi_init+0x184>)
    3586:	4798      	blx	r3
	_sercom_instances[instance_index] = module;
    3588:	2313      	movs	r3, #19
    358a:	18fb      	adds	r3, r7, r3
    358c:	781a      	ldrb	r2, [r3, #0]
    358e:	4b0f      	ldr	r3, [pc, #60]	; (35cc <spi_init+0x188>)
    3590:	0092      	lsls	r2, r2, #2
    3592:	68f9      	ldr	r1, [r7, #12]
    3594:	50d1      	str	r1, [r2, r3]
#endif

	/* Write configuration to module and return status code */
	return _spi_set_config(module, config);
    3596:	687a      	ldr	r2, [r7, #4]
    3598:	68fb      	ldr	r3, [r7, #12]
    359a:	0011      	movs	r1, r2
    359c:	0018      	movs	r0, r3
    359e:	4b0c      	ldr	r3, [pc, #48]	; (35d0 <spi_init+0x18c>)
    35a0:	4798      	blx	r3
    35a2:	0003      	movs	r3, r0
}
    35a4:	0018      	movs	r0, r3
    35a6:	46bd      	mov	sp, r7
    35a8:	b00b      	add	sp, #44	; 0x2c
    35aa:	bd90      	pop	{r4, r7, pc}
    35ac:	00002dc9 	.word	0x00002dc9
    35b0:	0000308d 	.word	0x0000308d
    35b4:	00003075 	.word	0x00003075
    35b8:	00004aa9 	.word	0x00004aa9
    35bc:	00004aed 	.word	0x00004aed
    35c0:	00002b81 	.word	0x00002b81
    35c4:	00003c4d 	.word	0x00003c4d
    35c8:	00002e2d 	.word	0x00002e2d
    35cc:	20002e54 	.word	0x20002e54
    35d0:	00003261 	.word	0x00003261

000035d4 <spi_read_buffer_wait>:
enum status_code spi_read_buffer_wait(
		struct spi_module *const module,
		uint8_t *rx_data,
		uint16_t length,
		uint16_t dummy)
{
    35d4:	b590      	push	{r4, r7, lr}
    35d6:	b087      	sub	sp, #28
    35d8:	af00      	add	r7, sp, #0
    35da:	60f8      	str	r0, [r7, #12]
    35dc:	60b9      	str	r1, [r7, #8]
    35de:	0019      	movs	r1, r3
    35e0:	1dbb      	adds	r3, r7, #6
    35e2:	801a      	strh	r2, [r3, #0]
    35e4:	1d3b      	adds	r3, r7, #4
    35e6:	1c0a      	adds	r2, r1, #0
    35e8:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
    35ea:	68fb      	ldr	r3, [r7, #12]
    35ec:	2230      	movs	r2, #48	; 0x30
    35ee:	5c9b      	ldrb	r3, [r3, r2]
    35f0:	b2db      	uxtb	r3, r3
    35f2:	2b05      	cmp	r3, #5
    35f4:	d101      	bne.n	35fa <spi_read_buffer_wait+0x26>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
    35f6:	2305      	movs	r3, #5
    35f8:	e07a      	b.n	36f0 <spi_read_buffer_wait+0x11c>
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
    35fa:	1dbb      	adds	r3, r7, #6
    35fc:	881b      	ldrh	r3, [r3, #0]
    35fe:	2b00      	cmp	r3, #0
    3600:	d101      	bne.n	3606 <spi_read_buffer_wait+0x32>
		return STATUS_ERR_INVALID_ARG;
    3602:	2317      	movs	r3, #23
    3604:	e074      	b.n	36f0 <spi_read_buffer_wait+0x11c>
	}

	if (!(module->receiver_enabled)) {
    3606:	68fb      	ldr	r3, [r7, #12]
    3608:	79db      	ldrb	r3, [r3, #7]
    360a:	2201      	movs	r2, #1
    360c:	4053      	eors	r3, r2
    360e:	b2db      	uxtb	r3, r3
    3610:	2b00      	cmp	r3, #0
    3612:	d001      	beq.n	3618 <spi_read_buffer_wait+0x44>
		return STATUS_ERR_DENIED;
    3614:	231c      	movs	r3, #28
    3616:	e06b      	b.n	36f0 <spi_read_buffer_wait+0x11c>
	if ((module->mode == SPI_MODE_SLAVE) && (spi_is_write_complete(module))) {
		/* Clear TX complete flag */
		_spi_clear_tx_complete_flag(module);
	}
#  endif
	uint16_t rx_pos = 0;
    3618:	2316      	movs	r3, #22
    361a:	18fb      	adds	r3, r7, r3
    361c:	2200      	movs	r2, #0
    361e:	801a      	strh	r2, [r3, #0]

	while (length--) {
    3620:	e05e      	b.n	36e0 <spi_read_buffer_wait+0x10c>
#  if CONF_SPI_MASTER_ENABLE == true
		if (module->mode == SPI_MODE_MASTER) {
    3622:	68fb      	ldr	r3, [r7, #12]
    3624:	795b      	ldrb	r3, [r3, #5]
    3626:	2b01      	cmp	r3, #1
    3628:	d112      	bne.n	3650 <spi_read_buffer_wait+0x7c>
			/* Wait until the module is ready to write a character */
			while (!spi_is_ready_to_write(module)) {
    362a:	46c0      	nop			; (mov r8, r8)
    362c:	68fb      	ldr	r3, [r7, #12]
    362e:	0018      	movs	r0, r3
    3630:	4b31      	ldr	r3, [pc, #196]	; (36f8 <spi_read_buffer_wait+0x124>)
    3632:	4798      	blx	r3
    3634:	0003      	movs	r3, r0
    3636:	001a      	movs	r2, r3
    3638:	2301      	movs	r3, #1
    363a:	4053      	eors	r3, r2
    363c:	b2db      	uxtb	r3, r3
    363e:	2b00      	cmp	r3, #0
    3640:	d1f4      	bne.n	362c <spi_read_buffer_wait+0x58>
			}

			/* Send dummy SPI character to read in master mode */
			spi_write(module, dummy);
    3642:	1d3b      	adds	r3, r7, #4
    3644:	881a      	ldrh	r2, [r3, #0]
    3646:	68fb      	ldr	r3, [r7, #12]
    3648:	0011      	movs	r1, r2
    364a:	0018      	movs	r0, r3
    364c:	4b2b      	ldr	r3, [pc, #172]	; (36fc <spi_read_buffer_wait+0x128>)
    364e:	4798      	blx	r3
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
    3650:	46c0      	nop			; (mov r8, r8)
    3652:	68fb      	ldr	r3, [r7, #12]
    3654:	0018      	movs	r0, r3
    3656:	4b2a      	ldr	r3, [pc, #168]	; (3700 <spi_read_buffer_wait+0x12c>)
    3658:	4798      	blx	r3
    365a:	0003      	movs	r3, r0
    365c:	001a      	movs	r2, r3
    365e:	2301      	movs	r3, #1
    3660:	4053      	eors	r3, r2
    3662:	b2db      	uxtb	r3, r3
    3664:	2b00      	cmp	r3, #0
    3666:	d1f4      	bne.n	3652 <spi_read_buffer_wait+0x7e>
		}

		uint16_t received_data = 0;
    3668:	2312      	movs	r3, #18
    366a:	18fb      	adds	r3, r7, r3
    366c:	2200      	movs	r2, #0
    366e:	801a      	strh	r2, [r3, #0]
		enum status_code retval = spi_read(module, &received_data);
    3670:	2315      	movs	r3, #21
    3672:	18fc      	adds	r4, r7, r3
    3674:	2312      	movs	r3, #18
    3676:	18fa      	adds	r2, r7, r3
    3678:	68fb      	ldr	r3, [r7, #12]
    367a:	0011      	movs	r1, r2
    367c:	0018      	movs	r0, r3
    367e:	4b21      	ldr	r3, [pc, #132]	; (3704 <spi_read_buffer_wait+0x130>)
    3680:	4798      	blx	r3
    3682:	0003      	movs	r3, r0
    3684:	7023      	strb	r3, [r4, #0]

		if (retval != STATUS_OK) {
    3686:	2315      	movs	r3, #21
    3688:	18fb      	adds	r3, r7, r3
    368a:	781b      	ldrb	r3, [r3, #0]
    368c:	2b00      	cmp	r3, #0
    368e:	d003      	beq.n	3698 <spi_read_buffer_wait+0xc4>
			/* Overflow, abort */
			return retval;
    3690:	2315      	movs	r3, #21
    3692:	18fb      	adds	r3, r7, r3
    3694:	781b      	ldrb	r3, [r3, #0]
    3696:	e02b      	b.n	36f0 <spi_read_buffer_wait+0x11c>
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
    3698:	2316      	movs	r3, #22
    369a:	18fb      	adds	r3, r7, r3
    369c:	881b      	ldrh	r3, [r3, #0]
    369e:	2216      	movs	r2, #22
    36a0:	18ba      	adds	r2, r7, r2
    36a2:	1c59      	adds	r1, r3, #1
    36a4:	8011      	strh	r1, [r2, #0]
    36a6:	001a      	movs	r2, r3
    36a8:	68bb      	ldr	r3, [r7, #8]
    36aa:	189b      	adds	r3, r3, r2
    36ac:	2212      	movs	r2, #18
    36ae:	18ba      	adds	r2, r7, r2
    36b0:	8812      	ldrh	r2, [r2, #0]
    36b2:	b2d2      	uxtb	r2, r2
    36b4:	701a      	strb	r2, [r3, #0]

		/* If 9-bit data, write next received byte to the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    36b6:	68fb      	ldr	r3, [r7, #12]
    36b8:	799b      	ldrb	r3, [r3, #6]
    36ba:	2b01      	cmp	r3, #1
    36bc:	d110      	bne.n	36e0 <spi_read_buffer_wait+0x10c>
			rx_data[rx_pos++] = (received_data >> 8);
    36be:	2316      	movs	r3, #22
    36c0:	18fb      	adds	r3, r7, r3
    36c2:	881b      	ldrh	r3, [r3, #0]
    36c4:	2216      	movs	r2, #22
    36c6:	18ba      	adds	r2, r7, r2
    36c8:	1c59      	adds	r1, r3, #1
    36ca:	8011      	strh	r1, [r2, #0]
    36cc:	001a      	movs	r2, r3
    36ce:	68bb      	ldr	r3, [r7, #8]
    36d0:	189b      	adds	r3, r3, r2
    36d2:	2212      	movs	r2, #18
    36d4:	18ba      	adds	r2, r7, r2
    36d6:	8812      	ldrh	r2, [r2, #0]
    36d8:	0a12      	lsrs	r2, r2, #8
    36da:	b292      	uxth	r2, r2
    36dc:	b2d2      	uxtb	r2, r2
    36de:	701a      	strb	r2, [r3, #0]
		_spi_clear_tx_complete_flag(module);
	}
#  endif
	uint16_t rx_pos = 0;

	while (length--) {
    36e0:	1dbb      	adds	r3, r7, #6
    36e2:	881b      	ldrh	r3, [r3, #0]
    36e4:	1dba      	adds	r2, r7, #6
    36e6:	1e59      	subs	r1, r3, #1
    36e8:	8011      	strh	r1, [r2, #0]
    36ea:	2b00      	cmp	r3, #0
    36ec:	d199      	bne.n	3622 <spi_read_buffer_wait+0x4e>
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
			rx_data[rx_pos++] = (received_data >> 8);
		}
	}

	return STATUS_OK;
    36ee:	2300      	movs	r3, #0
}
    36f0:	0018      	movs	r0, r3
    36f2:	46bd      	mov	sp, r7
    36f4:	b007      	add	sp, #28
    36f6:	bd90      	pop	{r4, r7, pc}
    36f8:	00003131 	.word	0x00003131
    36fc:	00003181 	.word	0x00003181
    3700:	00003159 	.word	0x00003159
    3704:	000031cd 	.word	0x000031cd

00003708 <spi_select_slave>:
 */
enum status_code spi_select_slave(
		struct spi_module *const module,
		struct spi_slave_inst *const slave,
		const bool select)
{
    3708:	b580      	push	{r7, lr}
    370a:	b086      	sub	sp, #24
    370c:	af00      	add	r7, sp, #0
    370e:	60f8      	str	r0, [r7, #12]
    3710:	60b9      	str	r1, [r7, #8]
    3712:	1dfb      	adds	r3, r7, #7
    3714:	701a      	strb	r2, [r3, #0]
	Assert(module);
	Assert(module->hw);
	Assert(slave);

	/* Check that the SPI module is operating in master mode */
	if (module->mode != SPI_MODE_MASTER) {
    3716:	68fb      	ldr	r3, [r7, #12]
    3718:	795b      	ldrb	r3, [r3, #5]
    371a:	2b01      	cmp	r3, #1
    371c:	d001      	beq.n	3722 <spi_select_slave+0x1a>
		return STATUS_ERR_UNSUPPORTED_DEV;
    371e:	2315      	movs	r3, #21
    3720:	e055      	b.n	37ce <spi_select_slave+0xc6>
	}
#  ifdef FEATURE_SPI_HARDWARE_SLAVE_SELECT
	if(!(module->master_slave_select_enable))
#  endif
	{
		if (select) {
    3722:	1dfb      	adds	r3, r7, #7
    3724:	781b      	ldrb	r3, [r3, #0]
    3726:	2b00      	cmp	r3, #0
    3728:	d04a      	beq.n	37c0 <spi_select_slave+0xb8>
			/* Check if address recognition is enabled */
			if (slave->address_enabled) {
    372a:	68bb      	ldr	r3, [r7, #8]
    372c:	785b      	ldrb	r3, [r3, #1]
    372e:	2b00      	cmp	r3, #0
    3730:	d03f      	beq.n	37b2 <spi_select_slave+0xaa>
				/* Check if the module is ready to write the address */
				if (!spi_is_ready_to_write(module)) {
    3732:	68fb      	ldr	r3, [r7, #12]
    3734:	0018      	movs	r0, r3
    3736:	4b28      	ldr	r3, [pc, #160]	; (37d8 <spi_select_slave+0xd0>)
    3738:	4798      	blx	r3
    373a:	0003      	movs	r3, r0
    373c:	001a      	movs	r2, r3
    373e:	2301      	movs	r3, #1
    3740:	4053      	eors	r3, r2
    3742:	b2db      	uxtb	r3, r3
    3744:	2b00      	cmp	r3, #0
    3746:	d007      	beq.n	3758 <spi_select_slave+0x50>
					/* Not ready, do not select slave and return */
					port_pin_set_output_level(slave->ss_pin, true);
    3748:	68bb      	ldr	r3, [r7, #8]
    374a:	781b      	ldrb	r3, [r3, #0]
    374c:	2101      	movs	r1, #1
    374e:	0018      	movs	r0, r3
    3750:	4b22      	ldr	r3, [pc, #136]	; (37dc <spi_select_slave+0xd4>)
    3752:	4798      	blx	r3
					return STATUS_BUSY;
    3754:	2305      	movs	r3, #5
    3756:	e03a      	b.n	37ce <spi_select_slave+0xc6>
				}

				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    3758:	68bb      	ldr	r3, [r7, #8]
    375a:	781b      	ldrb	r3, [r3, #0]
    375c:	2100      	movs	r1, #0
    375e:	0018      	movs	r0, r3
    3760:	4b1e      	ldr	r3, [pc, #120]	; (37dc <spi_select_slave+0xd4>)
    3762:	4798      	blx	r3

				/* Write address to slave */
				spi_write(module, slave->address);
    3764:	68bb      	ldr	r3, [r7, #8]
    3766:	789b      	ldrb	r3, [r3, #2]
    3768:	b29a      	uxth	r2, r3
    376a:	68fb      	ldr	r3, [r7, #12]
    376c:	0011      	movs	r1, r2
    376e:	0018      	movs	r0, r3
    3770:	4b1b      	ldr	r3, [pc, #108]	; (37e0 <spi_select_slave+0xd8>)
    3772:	4798      	blx	r3

				if (!(module->receiver_enabled)) {
    3774:	68fb      	ldr	r3, [r7, #12]
    3776:	79db      	ldrb	r3, [r3, #7]
    3778:	2201      	movs	r2, #1
    377a:	4053      	eors	r3, r2
    377c:	b2db      	uxtb	r3, r3
    377e:	2b00      	cmp	r3, #0
    3780:	d024      	beq.n	37cc <spi_select_slave+0xc4>
					/* Flush contents of shift register shifted back from slave */
					while (!spi_is_ready_to_read(module)) {
    3782:	46c0      	nop			; (mov r8, r8)
    3784:	68fb      	ldr	r3, [r7, #12]
    3786:	0018      	movs	r0, r3
    3788:	4b16      	ldr	r3, [pc, #88]	; (37e4 <spi_select_slave+0xdc>)
    378a:	4798      	blx	r3
    378c:	0003      	movs	r3, r0
    378e:	001a      	movs	r2, r3
    3790:	2301      	movs	r3, #1
    3792:	4053      	eors	r3, r2
    3794:	b2db      	uxtb	r3, r3
    3796:	2b00      	cmp	r3, #0
    3798:	d1f4      	bne.n	3784 <spi_select_slave+0x7c>
					}
					uint16_t flush = 0;
    379a:	2316      	movs	r3, #22
    379c:	18fb      	adds	r3, r7, r3
    379e:	2200      	movs	r2, #0
    37a0:	801a      	strh	r2, [r3, #0]
					spi_read(module, &flush);
    37a2:	2316      	movs	r3, #22
    37a4:	18fa      	adds	r2, r7, r3
    37a6:	68fb      	ldr	r3, [r7, #12]
    37a8:	0011      	movs	r1, r2
    37aa:	0018      	movs	r0, r3
    37ac:	4b0e      	ldr	r3, [pc, #56]	; (37e8 <spi_select_slave+0xe0>)
    37ae:	4798      	blx	r3
    37b0:	e00c      	b.n	37cc <spi_select_slave+0xc4>
				}
			} else {
				/* Drive Slave Select low */
				port_pin_set_output_level(slave->ss_pin, false);
    37b2:	68bb      	ldr	r3, [r7, #8]
    37b4:	781b      	ldrb	r3, [r3, #0]
    37b6:	2100      	movs	r1, #0
    37b8:	0018      	movs	r0, r3
    37ba:	4b08      	ldr	r3, [pc, #32]	; (37dc <spi_select_slave+0xd4>)
    37bc:	4798      	blx	r3
    37be:	e005      	b.n	37cc <spi_select_slave+0xc4>
			}
		} else {
			/* Drive Slave Select high */
			port_pin_set_output_level(slave->ss_pin, true);
    37c0:	68bb      	ldr	r3, [r7, #8]
    37c2:	781b      	ldrb	r3, [r3, #0]
    37c4:	2101      	movs	r1, #1
    37c6:	0018      	movs	r0, r3
    37c8:	4b04      	ldr	r3, [pc, #16]	; (37dc <spi_select_slave+0xd4>)
    37ca:	4798      	blx	r3
		}
	}
	return STATUS_OK;
    37cc:	2300      	movs	r3, #0
}
    37ce:	0018      	movs	r0, r3
    37d0:	46bd      	mov	sp, r7
    37d2:	b006      	add	sp, #24
    37d4:	bd80      	pop	{r7, pc}
    37d6:	46c0      	nop			; (mov r8, r8)
    37d8:	00003131 	.word	0x00003131
    37dc:	00003021 	.word	0x00003021
    37e0:	00003181 	.word	0x00003181
    37e4:	00003159 	.word	0x00003159
    37e8:	000031cd 	.word	0x000031cd

000037ec <spi_write_buffer_wait>:
 */
enum status_code spi_write_buffer_wait(
		struct spi_module *const module,
		const uint8_t *tx_data,
		uint16_t length)
{
    37ec:	b580      	push	{r7, lr}
    37ee:	b086      	sub	sp, #24
    37f0:	af00      	add	r7, sp, #0
    37f2:	60f8      	str	r0, [r7, #12]
    37f4:	60b9      	str	r1, [r7, #8]
    37f6:	1dbb      	adds	r3, r7, #6
    37f8:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
    37fa:	68fb      	ldr	r3, [r7, #12]
    37fc:	2230      	movs	r2, #48	; 0x30
    37fe:	5c9b      	ldrb	r3, [r3, r2]
    3800:	b2db      	uxtb	r3, r3
    3802:	2b05      	cmp	r3, #5
    3804:	d101      	bne.n	380a <spi_write_buffer_wait+0x1e>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
    3806:	2305      	movs	r3, #5
    3808:	e087      	b.n	391a <spi_write_buffer_wait+0x12e>
	}
#  endif

	if (length == 0) {
    380a:	1dbb      	adds	r3, r7, #6
    380c:	881b      	ldrh	r3, [r3, #0]
    380e:	2b00      	cmp	r3, #0
    3810:	d101      	bne.n	3816 <spi_write_buffer_wait+0x2a>
		return STATUS_ERR_INVALID_ARG;
    3812:	2317      	movs	r3, #23
    3814:	e081      	b.n	391a <spi_write_buffer_wait+0x12e>
		/* Clear TX complete flag */
		_spi_clear_tx_complete_flag(module);
	}
#  endif

	uint16_t tx_pos = 0;
    3816:	2316      	movs	r3, #22
    3818:	18fb      	adds	r3, r7, r3
    381a:	2200      	movs	r2, #0
    381c:	801a      	strh	r2, [r3, #0]
	uint16_t flush_length = length;
    381e:	2314      	movs	r3, #20
    3820:	18fb      	adds	r3, r7, r3
    3822:	1dba      	adds	r2, r7, #6
    3824:	8812      	ldrh	r2, [r2, #0]
    3826:	801a      	strh	r2, [r3, #0]

	/* Write block */
	while (length--) {
    3828:	e05f      	b.n	38ea <spi_write_buffer_wait+0xfe>
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    382a:	46c0      	nop			; (mov r8, r8)
    382c:	68fb      	ldr	r3, [r7, #12]
    382e:	0018      	movs	r0, r3
    3830:	4b3c      	ldr	r3, [pc, #240]	; (3924 <spi_write_buffer_wait+0x138>)
    3832:	4798      	blx	r3
    3834:	0003      	movs	r3, r0
    3836:	001a      	movs	r2, r3
    3838:	2301      	movs	r3, #1
    383a:	4053      	eors	r3, r2
    383c:	b2db      	uxtb	r3, r3
    383e:	2b00      	cmp	r3, #0
    3840:	d1f4      	bne.n	382c <spi_write_buffer_wait+0x40>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    3842:	2316      	movs	r3, #22
    3844:	18fb      	adds	r3, r7, r3
    3846:	881b      	ldrh	r3, [r3, #0]
    3848:	2216      	movs	r2, #22
    384a:	18ba      	adds	r2, r7, r2
    384c:	1c59      	adds	r1, r3, #1
    384e:	8011      	strh	r1, [r2, #0]
    3850:	001a      	movs	r2, r3
    3852:	68bb      	ldr	r3, [r7, #8]
    3854:	189b      	adds	r3, r3, r2
    3856:	781a      	ldrb	r2, [r3, #0]
    3858:	2312      	movs	r3, #18
    385a:	18fb      	adds	r3, r7, r3
    385c:	801a      	strh	r2, [r3, #0]

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    385e:	68fb      	ldr	r3, [r7, #12]
    3860:	799b      	ldrb	r3, [r3, #6]
    3862:	2b01      	cmp	r3, #1
    3864:	d115      	bne.n	3892 <spi_write_buffer_wait+0xa6>
			data_to_send |= (tx_data[tx_pos++] << 8);
    3866:	2316      	movs	r3, #22
    3868:	18fb      	adds	r3, r7, r3
    386a:	881b      	ldrh	r3, [r3, #0]
    386c:	2216      	movs	r2, #22
    386e:	18ba      	adds	r2, r7, r2
    3870:	1c59      	adds	r1, r3, #1
    3872:	8011      	strh	r1, [r2, #0]
    3874:	001a      	movs	r2, r3
    3876:	68bb      	ldr	r3, [r7, #8]
    3878:	189b      	adds	r3, r3, r2
    387a:	781b      	ldrb	r3, [r3, #0]
    387c:	021b      	lsls	r3, r3, #8
    387e:	b21a      	sxth	r2, r3
    3880:	2312      	movs	r3, #18
    3882:	18fb      	adds	r3, r7, r3
    3884:	2100      	movs	r1, #0
    3886:	5e5b      	ldrsh	r3, [r3, r1]
    3888:	4313      	orrs	r3, r2
    388a:	b21a      	sxth	r2, r3
    388c:	2312      	movs	r3, #18
    388e:	18fb      	adds	r3, r7, r3
    3890:	801a      	strh	r2, [r3, #0]
		}

		/* Write the data to send */
		spi_write(module, data_to_send);
    3892:	2312      	movs	r3, #18
    3894:	18fb      	adds	r3, r7, r3
    3896:	881a      	ldrh	r2, [r3, #0]
    3898:	68fb      	ldr	r3, [r7, #12]
    389a:	0011      	movs	r1, r2
    389c:	0018      	movs	r0, r3
    389e:	4b22      	ldr	r3, [pc, #136]	; (3928 <spi_write_buffer_wait+0x13c>)
    38a0:	4798      	blx	r3

		if (module->receiver_enabled) {
    38a2:	68fb      	ldr	r3, [r7, #12]
    38a4:	79db      	ldrb	r3, [r3, #7]
    38a6:	2214      	movs	r2, #20
    38a8:	18ba      	adds	r2, r7, r2
    38aa:	2114      	movs	r1, #20
    38ac:	1879      	adds	r1, r7, r1
    38ae:	8809      	ldrh	r1, [r1, #0]
    38b0:	8011      	strh	r1, [r2, #0]
    38b2:	2b00      	cmp	r3, #0
    38b4:	d019      	beq.n	38ea <spi_write_buffer_wait+0xfe>
					return STATUS_ERR_TIMEOUT;
				}
			}
#  endif

			while (!spi_is_ready_to_read(module)) {
    38b6:	46c0      	nop			; (mov r8, r8)
    38b8:	68fb      	ldr	r3, [r7, #12]
    38ba:	0018      	movs	r0, r3
    38bc:	4b1b      	ldr	r3, [pc, #108]	; (392c <spi_write_buffer_wait+0x140>)
    38be:	4798      	blx	r3
    38c0:	0003      	movs	r3, r0
    38c2:	001a      	movs	r2, r3
    38c4:	2301      	movs	r3, #1
    38c6:	4053      	eors	r3, r2
    38c8:	b2db      	uxtb	r3, r3
    38ca:	2b00      	cmp	r3, #0
    38cc:	d1f4      	bne.n	38b8 <spi_write_buffer_wait+0xcc>
			}

			/* Flush read buffer */
			uint16_t flush;
			spi_read(module, &flush);
    38ce:	2310      	movs	r3, #16
    38d0:	18fa      	adds	r2, r7, r3
    38d2:	68fb      	ldr	r3, [r7, #12]
    38d4:	0011      	movs	r1, r2
    38d6:	0018      	movs	r0, r3
    38d8:	4b15      	ldr	r3, [pc, #84]	; (3930 <spi_write_buffer_wait+0x144>)
    38da:	4798      	blx	r3
			flush_length--;
    38dc:	2314      	movs	r3, #20
    38de:	18fb      	adds	r3, r7, r3
    38e0:	881a      	ldrh	r2, [r3, #0]
    38e2:	2314      	movs	r3, #20
    38e4:	18fb      	adds	r3, r7, r3
    38e6:	3a01      	subs	r2, #1
    38e8:	801a      	strh	r2, [r3, #0]

	uint16_t tx_pos = 0;
	uint16_t flush_length = length;

	/* Write block */
	while (length--) {
    38ea:	1dbb      	adds	r3, r7, #6
    38ec:	881b      	ldrh	r3, [r3, #0]
    38ee:	1dba      	adds	r2, r7, #6
    38f0:	1e59      	subs	r1, r3, #1
    38f2:	8011      	strh	r1, [r2, #0]
    38f4:	2b00      	cmp	r3, #0
    38f6:	d198      	bne.n	382a <spi_write_buffer_wait+0x3e>
			flush_length--;
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    38f8:	68fb      	ldr	r3, [r7, #12]
    38fa:	795b      	ldrb	r3, [r3, #5]
    38fc:	2b01      	cmp	r3, #1
    38fe:	d10b      	bne.n	3918 <spi_write_buffer_wait+0x12c>
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
    3900:	46c0      	nop			; (mov r8, r8)
    3902:	68fb      	ldr	r3, [r7, #12]
    3904:	0018      	movs	r0, r3
    3906:	4b0b      	ldr	r3, [pc, #44]	; (3934 <spi_write_buffer_wait+0x148>)
    3908:	4798      	blx	r3
    390a:	0003      	movs	r3, r0
    390c:	001a      	movs	r2, r3
    390e:	2301      	movs	r3, #1
    3910:	4053      	eors	r3, r2
    3912:	b2db      	uxtb	r3, r3
    3914:	2b00      	cmp	r3, #0
    3916:	d1f4      	bne.n	3902 <spi_write_buffer_wait+0x116>
				flush_length--;
			}
		}
	}
#  endif
	return STATUS_OK;
    3918:	2300      	movs	r3, #0
}
    391a:	0018      	movs	r0, r3
    391c:	46bd      	mov	sp, r7
    391e:	b006      	add	sp, #24
    3920:	bd80      	pop	{r7, pc}
    3922:	46c0      	nop			; (mov r8, r8)
    3924:	00003131 	.word	0x00003131
    3928:	00003181 	.word	0x00003181
    392c:	00003159 	.word	0x00003159
    3930:	000031cd 	.word	0x000031cd
    3934:	00003109 	.word	0x00003109

00003938 <spi_transceive_buffer_wait>:
enum status_code spi_transceive_buffer_wait(
		struct spi_module *const module,
		uint8_t *tx_data,
		uint8_t *rx_data,
		uint16_t length)
{
    3938:	b590      	push	{r4, r7, lr}
    393a:	b089      	sub	sp, #36	; 0x24
    393c:	af00      	add	r7, sp, #0
    393e:	60f8      	str	r0, [r7, #12]
    3940:	60b9      	str	r1, [r7, #8]
    3942:	607a      	str	r2, [r7, #4]
    3944:	001a      	movs	r2, r3
    3946:	1cbb      	adds	r3, r7, #2
    3948:	801a      	strh	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);

#  if SPI_CALLBACK_MODE == true
	if (module->status == STATUS_BUSY) {
    394a:	68fb      	ldr	r3, [r7, #12]
    394c:	2230      	movs	r2, #48	; 0x30
    394e:	5c9b      	ldrb	r3, [r3, r2]
    3950:	b2db      	uxtb	r3, r3
    3952:	2b05      	cmp	r3, #5
    3954:	d101      	bne.n	395a <spi_transceive_buffer_wait+0x22>
		/* Check if the SPI module is busy with a job */
		return STATUS_BUSY;
    3956:	2305      	movs	r3, #5
    3958:	e0c0      	b.n	3adc <spi_transceive_buffer_wait+0x1a4>
	}
#  endif

	/* Sanity check arguments */
	if (length == 0) {
    395a:	1cbb      	adds	r3, r7, #2
    395c:	881b      	ldrh	r3, [r3, #0]
    395e:	2b00      	cmp	r3, #0
    3960:	d101      	bne.n	3966 <spi_transceive_buffer_wait+0x2e>
		return STATUS_ERR_INVALID_ARG;
    3962:	2317      	movs	r3, #23
    3964:	e0ba      	b.n	3adc <spi_transceive_buffer_wait+0x1a4>
	}

	if (!(module->receiver_enabled)) {
    3966:	68fb      	ldr	r3, [r7, #12]
    3968:	79db      	ldrb	r3, [r3, #7]
    396a:	2201      	movs	r2, #1
    396c:	4053      	eors	r3, r2
    396e:	b2db      	uxtb	r3, r3
    3970:	2b00      	cmp	r3, #0
    3972:	d001      	beq.n	3978 <spi_transceive_buffer_wait+0x40>
		return STATUS_ERR_DENIED;
    3974:	231c      	movs	r3, #28
    3976:	e0b1      	b.n	3adc <spi_transceive_buffer_wait+0x1a4>
		/* Clear TX complete flag */
		_spi_clear_tx_complete_flag(module);
	}
#  endif

	uint16_t tx_pos = 0;
    3978:	231e      	movs	r3, #30
    397a:	18fb      	adds	r3, r7, r3
    397c:	2200      	movs	r2, #0
    397e:	801a      	strh	r2, [r3, #0]
	uint16_t rx_pos = 0;
    3980:	231c      	movs	r3, #28
    3982:	18fb      	adds	r3, r7, r3
    3984:	2200      	movs	r2, #0
    3986:	801a      	strh	r2, [r3, #0]
	uint16_t rx_length = length;
    3988:	231a      	movs	r3, #26
    398a:	18fb      	adds	r3, r7, r3
    398c:	1cba      	adds	r2, r7, #2
    398e:	8812      	ldrh	r2, [r2, #0]
    3990:	801a      	strh	r2, [r3, #0]

	/* Send and receive buffer */
	while (length--) {
    3992:	e08a      	b.n	3aaa <spi_transceive_buffer_wait+0x172>
			}
		}
#  endif

		/* Wait until the module is ready to write a character */
		while (!spi_is_ready_to_write(module)) {
    3994:	46c0      	nop			; (mov r8, r8)
    3996:	68fb      	ldr	r3, [r7, #12]
    3998:	0018      	movs	r0, r3
    399a:	4b52      	ldr	r3, [pc, #328]	; (3ae4 <spi_transceive_buffer_wait+0x1ac>)
    399c:	4798      	blx	r3
    399e:	0003      	movs	r3, r0
    39a0:	001a      	movs	r2, r3
    39a2:	2301      	movs	r3, #1
    39a4:	4053      	eors	r3, r2
    39a6:	b2db      	uxtb	r3, r3
    39a8:	2b00      	cmp	r3, #0
    39aa:	d1f4      	bne.n	3996 <spi_transceive_buffer_wait+0x5e>
		}

		/* Write value will be at least 8-bits long */
		uint16_t data_to_send = tx_data[tx_pos++];
    39ac:	231e      	movs	r3, #30
    39ae:	18fb      	adds	r3, r7, r3
    39b0:	881b      	ldrh	r3, [r3, #0]
    39b2:	221e      	movs	r2, #30
    39b4:	18ba      	adds	r2, r7, r2
    39b6:	1c59      	adds	r1, r3, #1
    39b8:	8011      	strh	r1, [r2, #0]
    39ba:	001a      	movs	r2, r3
    39bc:	68bb      	ldr	r3, [r7, #8]
    39be:	189b      	adds	r3, r3, r2
    39c0:	781a      	ldrb	r2, [r3, #0]
    39c2:	2318      	movs	r3, #24
    39c4:	18fb      	adds	r3, r7, r3
    39c6:	801a      	strh	r2, [r3, #0]

		/* If 9-bit data, get next byte to send from the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    39c8:	68fb      	ldr	r3, [r7, #12]
    39ca:	799b      	ldrb	r3, [r3, #6]
    39cc:	2b01      	cmp	r3, #1
    39ce:	d115      	bne.n	39fc <spi_transceive_buffer_wait+0xc4>
			data_to_send |= (tx_data[tx_pos++] << 8);
    39d0:	231e      	movs	r3, #30
    39d2:	18fb      	adds	r3, r7, r3
    39d4:	881b      	ldrh	r3, [r3, #0]
    39d6:	221e      	movs	r2, #30
    39d8:	18ba      	adds	r2, r7, r2
    39da:	1c59      	adds	r1, r3, #1
    39dc:	8011      	strh	r1, [r2, #0]
    39de:	001a      	movs	r2, r3
    39e0:	68bb      	ldr	r3, [r7, #8]
    39e2:	189b      	adds	r3, r3, r2
    39e4:	781b      	ldrb	r3, [r3, #0]
    39e6:	021b      	lsls	r3, r3, #8
    39e8:	b21a      	sxth	r2, r3
    39ea:	2318      	movs	r3, #24
    39ec:	18fb      	adds	r3, r7, r3
    39ee:	2100      	movs	r1, #0
    39f0:	5e5b      	ldrsh	r3, [r3, r1]
    39f2:	4313      	orrs	r3, r2
    39f4:	b21a      	sxth	r2, r3
    39f6:	2318      	movs	r3, #24
    39f8:	18fb      	adds	r3, r7, r3
    39fa:	801a      	strh	r2, [r3, #0]
		}

		/* Write the data to send */
		spi_write(module, data_to_send);
    39fc:	2318      	movs	r3, #24
    39fe:	18fb      	adds	r3, r7, r3
    3a00:	881a      	ldrh	r2, [r3, #0]
    3a02:	68fb      	ldr	r3, [r7, #12]
    3a04:	0011      	movs	r1, r2
    3a06:	0018      	movs	r0, r3
    3a08:	4b37      	ldr	r3, [pc, #220]	; (3ae8 <spi_transceive_buffer_wait+0x1b0>)
    3a0a:	4798      	blx	r3
			}
		}
#  endif

		/* Wait until the module is ready to read a character */
		while (!spi_is_ready_to_read(module)) {
    3a0c:	46c0      	nop			; (mov r8, r8)
    3a0e:	68fb      	ldr	r3, [r7, #12]
    3a10:	0018      	movs	r0, r3
    3a12:	4b36      	ldr	r3, [pc, #216]	; (3aec <spi_transceive_buffer_wait+0x1b4>)
    3a14:	4798      	blx	r3
    3a16:	0003      	movs	r3, r0
    3a18:	001a      	movs	r2, r3
    3a1a:	2301      	movs	r3, #1
    3a1c:	4053      	eors	r3, r2
    3a1e:	b2db      	uxtb	r3, r3
    3a20:	2b00      	cmp	r3, #0
    3a22:	d1f4      	bne.n	3a0e <spi_transceive_buffer_wait+0xd6>
		}

		enum status_code retval;
		uint16_t received_data = 0;
    3a24:	2314      	movs	r3, #20
    3a26:	18fb      	adds	r3, r7, r3
    3a28:	2200      	movs	r2, #0
    3a2a:	801a      	strh	r2, [r3, #0]
		rx_length--;
    3a2c:	231a      	movs	r3, #26
    3a2e:	18fb      	adds	r3, r7, r3
    3a30:	881a      	ldrh	r2, [r3, #0]
    3a32:	231a      	movs	r3, #26
    3a34:	18fb      	adds	r3, r7, r3
    3a36:	3a01      	subs	r2, #1
    3a38:	801a      	strh	r2, [r3, #0]

		retval = spi_read(module, &received_data);
    3a3a:	2317      	movs	r3, #23
    3a3c:	18fc      	adds	r4, r7, r3
    3a3e:	2314      	movs	r3, #20
    3a40:	18fa      	adds	r2, r7, r3
    3a42:	68fb      	ldr	r3, [r7, #12]
    3a44:	0011      	movs	r1, r2
    3a46:	0018      	movs	r0, r3
    3a48:	4b29      	ldr	r3, [pc, #164]	; (3af0 <spi_transceive_buffer_wait+0x1b8>)
    3a4a:	4798      	blx	r3
    3a4c:	0003      	movs	r3, r0
    3a4e:	7023      	strb	r3, [r4, #0]

		if (retval != STATUS_OK) {
    3a50:	2317      	movs	r3, #23
    3a52:	18fb      	adds	r3, r7, r3
    3a54:	781b      	ldrb	r3, [r3, #0]
    3a56:	2b00      	cmp	r3, #0
    3a58:	d003      	beq.n	3a62 <spi_transceive_buffer_wait+0x12a>
			/* Overflow, abort */
			return retval;
    3a5a:	2317      	movs	r3, #23
    3a5c:	18fb      	adds	r3, r7, r3
    3a5e:	781b      	ldrb	r3, [r3, #0]
    3a60:	e03c      	b.n	3adc <spi_transceive_buffer_wait+0x1a4>
		}

		/* Read value will be at least 8-bits long */
		rx_data[rx_pos++] = received_data;
    3a62:	231c      	movs	r3, #28
    3a64:	18fb      	adds	r3, r7, r3
    3a66:	881b      	ldrh	r3, [r3, #0]
    3a68:	221c      	movs	r2, #28
    3a6a:	18ba      	adds	r2, r7, r2
    3a6c:	1c59      	adds	r1, r3, #1
    3a6e:	8011      	strh	r1, [r2, #0]
    3a70:	001a      	movs	r2, r3
    3a72:	687b      	ldr	r3, [r7, #4]
    3a74:	189b      	adds	r3, r3, r2
    3a76:	2214      	movs	r2, #20
    3a78:	18ba      	adds	r2, r7, r2
    3a7a:	8812      	ldrh	r2, [r2, #0]
    3a7c:	b2d2      	uxtb	r2, r2
    3a7e:	701a      	strb	r2, [r3, #0]

		/* If 9-bit data, write next received byte to the buffer */
		if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    3a80:	68fb      	ldr	r3, [r7, #12]
    3a82:	799b      	ldrb	r3, [r3, #6]
    3a84:	2b01      	cmp	r3, #1
    3a86:	d110      	bne.n	3aaa <spi_transceive_buffer_wait+0x172>
			rx_data[rx_pos++] = (received_data >> 8);
    3a88:	231c      	movs	r3, #28
    3a8a:	18fb      	adds	r3, r7, r3
    3a8c:	881b      	ldrh	r3, [r3, #0]
    3a8e:	221c      	movs	r2, #28
    3a90:	18ba      	adds	r2, r7, r2
    3a92:	1c59      	adds	r1, r3, #1
    3a94:	8011      	strh	r1, [r2, #0]
    3a96:	001a      	movs	r2, r3
    3a98:	687b      	ldr	r3, [r7, #4]
    3a9a:	189b      	adds	r3, r3, r2
    3a9c:	2214      	movs	r2, #20
    3a9e:	18ba      	adds	r2, r7, r2
    3aa0:	8812      	ldrh	r2, [r2, #0]
    3aa2:	0a12      	lsrs	r2, r2, #8
    3aa4:	b292      	uxth	r2, r2
    3aa6:	b2d2      	uxtb	r2, r2
    3aa8:	701a      	strb	r2, [r3, #0]
	uint16_t tx_pos = 0;
	uint16_t rx_pos = 0;
	uint16_t rx_length = length;

	/* Send and receive buffer */
	while (length--) {
    3aaa:	1cbb      	adds	r3, r7, #2
    3aac:	881b      	ldrh	r3, [r3, #0]
    3aae:	1cba      	adds	r2, r7, #2
    3ab0:	1e59      	subs	r1, r3, #1
    3ab2:	8011      	strh	r1, [r2, #0]
    3ab4:	2b00      	cmp	r3, #0
    3ab6:	d000      	beq.n	3aba <spi_transceive_buffer_wait+0x182>
    3ab8:	e76c      	b.n	3994 <spi_transceive_buffer_wait+0x5c>
			rx_data[rx_pos++] = (received_data >> 8);
		}
	}

#  if CONF_SPI_MASTER_ENABLE == true
	if (module->mode == SPI_MODE_MASTER) {
    3aba:	68fb      	ldr	r3, [r7, #12]
    3abc:	795b      	ldrb	r3, [r3, #5]
    3abe:	2b01      	cmp	r3, #1
    3ac0:	d10b      	bne.n	3ada <spi_transceive_buffer_wait+0x1a2>
		/* Wait for last byte to be transferred */
		while (!spi_is_write_complete(module)) {
    3ac2:	46c0      	nop			; (mov r8, r8)
    3ac4:	68fb      	ldr	r3, [r7, #12]
    3ac6:	0018      	movs	r0, r3
    3ac8:	4b0a      	ldr	r3, [pc, #40]	; (3af4 <spi_transceive_buffer_wait+0x1bc>)
    3aca:	4798      	blx	r3
    3acc:	0003      	movs	r3, r0
    3ace:	001a      	movs	r2, r3
    3ad0:	2301      	movs	r3, #1
    3ad2:	4053      	eors	r3, r2
    3ad4:	b2db      	uxtb	r3, r3
    3ad6:	2b00      	cmp	r3, #0
    3ad8:	d1f4      	bne.n	3ac4 <spi_transceive_buffer_wait+0x18c>
				rx_data[rx_pos++] = (received_data >> 8);
			}
		}
	}
#  endif
	return STATUS_OK;
    3ada:	2300      	movs	r3, #0
}
    3adc:	0018      	movs	r0, r3
    3ade:	46bd      	mov	sp, r7
    3ae0:	b009      	add	sp, #36	; 0x24
    3ae2:	bd90      	pop	{r4, r7, pc}
    3ae4:	00003131 	.word	0x00003131
    3ae8:	00003181 	.word	0x00003181
    3aec:	00003159 	.word	0x00003159
    3af0:	000031cd 	.word	0x000031cd
    3af4:	00003109 	.word	0x00003109

00003af8 <_spi_write>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_write(
		struct spi_module *const module)
{
    3af8:	b580      	push	{r7, lr}
    3afa:	b084      	sub	sp, #16
    3afc:	af00      	add	r7, sp, #0
    3afe:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    3b00:	687b      	ldr	r3, [r7, #4]
    3b02:	681b      	ldr	r3, [r3, #0]
    3b04:	60bb      	str	r3, [r7, #8]

	/* Write value will be at least 8-bits long */
	uint16_t data_to_send = *(module->tx_buffer_ptr);
    3b06:	687b      	ldr	r3, [r7, #4]
    3b08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3b0a:	781b      	ldrb	r3, [r3, #0]
    3b0c:	b2da      	uxtb	r2, r3
    3b0e:	230e      	movs	r3, #14
    3b10:	18fb      	adds	r3, r7, r3
    3b12:	801a      	strh	r2, [r3, #0]
	/* Increment 8-bit pointer */
	(module->tx_buffer_ptr)++;
    3b14:	687b      	ldr	r3, [r7, #4]
    3b16:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3b18:	1c5a      	adds	r2, r3, #1
    3b1a:	687b      	ldr	r3, [r7, #4]
    3b1c:	625a      	str	r2, [r3, #36]	; 0x24

	if (module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    3b1e:	687b      	ldr	r3, [r7, #4]
    3b20:	799b      	ldrb	r3, [r3, #6]
    3b22:	2b01      	cmp	r3, #1
    3b24:	d113      	bne.n	3b4e <_spi_write+0x56>
		data_to_send |= ((*(module->tx_buffer_ptr)) << 8);
    3b26:	687b      	ldr	r3, [r7, #4]
    3b28:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3b2a:	781b      	ldrb	r3, [r3, #0]
    3b2c:	b2db      	uxtb	r3, r3
    3b2e:	021b      	lsls	r3, r3, #8
    3b30:	b21a      	sxth	r2, r3
    3b32:	230e      	movs	r3, #14
    3b34:	18fb      	adds	r3, r7, r3
    3b36:	2100      	movs	r1, #0
    3b38:	5e5b      	ldrsh	r3, [r3, r1]
    3b3a:	4313      	orrs	r3, r2
    3b3c:	b21a      	sxth	r2, r3
    3b3e:	230e      	movs	r3, #14
    3b40:	18fb      	adds	r3, r7, r3
    3b42:	801a      	strh	r2, [r3, #0]
		/* Increment 8-bit pointer */
		(module->tx_buffer_ptr)++;
    3b44:	687b      	ldr	r3, [r7, #4]
    3b46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    3b48:	1c5a      	adds	r2, r3, #1
    3b4a:	687b      	ldr	r3, [r7, #4]
    3b4c:	625a      	str	r2, [r3, #36]	; 0x24
	}

	/* Write the data to send*/
	spi_hw->DATA.reg = data_to_send & SERCOM_SPI_DATA_MASK;
    3b4e:	230e      	movs	r3, #14
    3b50:	18fb      	adds	r3, r7, r3
    3b52:	881b      	ldrh	r3, [r3, #0]
    3b54:	05db      	lsls	r3, r3, #23
    3b56:	0ddb      	lsrs	r3, r3, #23
    3b58:	b29a      	uxth	r2, r3
    3b5a:	68bb      	ldr	r3, [r7, #8]
    3b5c:	831a      	strh	r2, [r3, #24]

	/* Decrement remaining buffer length */
	(module->remaining_tx_buffer_length)--;
    3b5e:	687b      	ldr	r3, [r7, #4]
    3b60:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    3b62:	b29b      	uxth	r3, r3
    3b64:	3b01      	subs	r3, #1
    3b66:	b29a      	uxth	r2, r3
    3b68:	687b      	ldr	r3, [r7, #4]
    3b6a:	859a      	strh	r2, [r3, #44]	; 0x2c
}
    3b6c:	46c0      	nop			; (mov r8, r8)
    3b6e:	46bd      	mov	sp, r7
    3b70:	b004      	add	sp, #16
    3b72:	bd80      	pop	{r7, pc}

00003b74 <_spi_write_dummy>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_write_dummy(
		struct spi_module *const module)
{
    3b74:	b580      	push	{r7, lr}
    3b76:	b084      	sub	sp, #16
    3b78:	af00      	add	r7, sp, #0
    3b7a:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    3b7c:	687b      	ldr	r3, [r7, #4]
    3b7e:	681b      	ldr	r3, [r3, #0]
    3b80:	60fb      	str	r3, [r7, #12]

	/* Write dummy byte */
	spi_hw->DATA.reg = dummy_write;
    3b82:	4b07      	ldr	r3, [pc, #28]	; (3ba0 <_spi_write_dummy+0x2c>)
    3b84:	881a      	ldrh	r2, [r3, #0]
    3b86:	68fb      	ldr	r3, [r7, #12]
    3b88:	831a      	strh	r2, [r3, #24]

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    3b8a:	687b      	ldr	r3, [r7, #4]
    3b8c:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    3b8e:	b29b      	uxth	r3, r3
    3b90:	3b01      	subs	r3, #1
    3b92:	b29a      	uxth	r2, r3
    3b94:	687b      	ldr	r3, [r7, #4]
    3b96:	855a      	strh	r2, [r3, #42]	; 0x2a
}
    3b98:	46c0      	nop			; (mov r8, r8)
    3b9a:	46bd      	mov	sp, r7
    3b9c:	b004      	add	sp, #16
    3b9e:	bd80      	pop	{r7, pc}
    3ba0:	20002e6c 	.word	0x20002e6c

00003ba4 <_spi_read_dummy>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_read_dummy(
		struct spi_module *const module)
{
    3ba4:	b580      	push	{r7, lr}
    3ba6:	b084      	sub	sp, #16
    3ba8:	af00      	add	r7, sp, #0
    3baa:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    3bac:	687b      	ldr	r3, [r7, #4]
    3bae:	681b      	ldr	r3, [r3, #0]
    3bb0:	60fb      	str	r3, [r7, #12]
	uint16_t flush = 0;
    3bb2:	230a      	movs	r3, #10
    3bb4:	18fb      	adds	r3, r7, r3
    3bb6:	2200      	movs	r2, #0
    3bb8:	801a      	strh	r2, [r3, #0]

	/* Read dummy byte */
	flush = spi_hw->DATA.reg;
    3bba:	230a      	movs	r3, #10
    3bbc:	18fb      	adds	r3, r7, r3
    3bbe:	68fa      	ldr	r2, [r7, #12]
    3bc0:	8b12      	ldrh	r2, [r2, #24]
    3bc2:	801a      	strh	r2, [r3, #0]
	UNUSED(flush);

	/* Decrement remaining dummy buffer length */
	module->remaining_dummy_buffer_length--;
    3bc4:	687b      	ldr	r3, [r7, #4]
    3bc6:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    3bc8:	b29b      	uxth	r3, r3
    3bca:	3b01      	subs	r3, #1
    3bcc:	b29a      	uxth	r2, r3
    3bce:	687b      	ldr	r3, [r7, #4]
    3bd0:	855a      	strh	r2, [r3, #42]	; 0x2a
}
    3bd2:	46c0      	nop			; (mov r8, r8)
    3bd4:	46bd      	mov	sp, r7
    3bd6:	b004      	add	sp, #16
    3bd8:	bd80      	pop	{r7, pc}
    3bda:	46c0      	nop			; (mov r8, r8)

00003bdc <_spi_read>:
 *
 * \param[in,out]  module  Pointer to SPI software instance struct
 */
static void _spi_read(
		struct spi_module *const module)
{
    3bdc:	b580      	push	{r7, lr}
    3bde:	b084      	sub	sp, #16
    3be0:	af00      	add	r7, sp, #0
    3be2:	6078      	str	r0, [r7, #4]
	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    3be4:	687b      	ldr	r3, [r7, #4]
    3be6:	681b      	ldr	r3, [r3, #0]
    3be8:	60fb      	str	r3, [r7, #12]

	uint16_t received_data = (spi_hw->DATA.reg & SERCOM_SPI_DATA_MASK);
    3bea:	68fb      	ldr	r3, [r7, #12]
    3bec:	8b1b      	ldrh	r3, [r3, #24]
    3bee:	b29a      	uxth	r2, r3
    3bf0:	230a      	movs	r3, #10
    3bf2:	18fb      	adds	r3, r7, r3
    3bf4:	05d2      	lsls	r2, r2, #23
    3bf6:	0dd2      	lsrs	r2, r2, #23
    3bf8:	801a      	strh	r2, [r3, #0]

	/* Read value will be at least 8-bits long */
	*(module->rx_buffer_ptr) = received_data;
    3bfa:	687b      	ldr	r3, [r7, #4]
    3bfc:	6a1b      	ldr	r3, [r3, #32]
    3bfe:	220a      	movs	r2, #10
    3c00:	18ba      	adds	r2, r7, r2
    3c02:	8812      	ldrh	r2, [r2, #0]
    3c04:	b2d2      	uxtb	r2, r2
    3c06:	701a      	strb	r2, [r3, #0]
	/* Increment 8-bit pointer */
	module->rx_buffer_ptr += 1;
    3c08:	687b      	ldr	r3, [r7, #4]
    3c0a:	6a1b      	ldr	r3, [r3, #32]
    3c0c:	1c5a      	adds	r2, r3, #1
    3c0e:	687b      	ldr	r3, [r7, #4]
    3c10:	621a      	str	r2, [r3, #32]

	if(module->character_size == SPI_CHARACTER_SIZE_9BIT) {
    3c12:	687b      	ldr	r3, [r7, #4]
    3c14:	799b      	ldrb	r3, [r3, #6]
    3c16:	2b01      	cmp	r3, #1
    3c18:	d10d      	bne.n	3c36 <_spi_read+0x5a>
		/* 9-bit data, write next received byte to the buffer */
		*(module->rx_buffer_ptr) = (received_data >> 8);
    3c1a:	687b      	ldr	r3, [r7, #4]
    3c1c:	6a1b      	ldr	r3, [r3, #32]
    3c1e:	220a      	movs	r2, #10
    3c20:	18ba      	adds	r2, r7, r2
    3c22:	8812      	ldrh	r2, [r2, #0]
    3c24:	0a12      	lsrs	r2, r2, #8
    3c26:	b292      	uxth	r2, r2
    3c28:	b2d2      	uxtb	r2, r2
    3c2a:	701a      	strb	r2, [r3, #0]
		/* Increment 8-bit pointer */
		module->rx_buffer_ptr += 1;
    3c2c:	687b      	ldr	r3, [r7, #4]
    3c2e:	6a1b      	ldr	r3, [r3, #32]
    3c30:	1c5a      	adds	r2, r3, #1
    3c32:	687b      	ldr	r3, [r7, #4]
    3c34:	621a      	str	r2, [r3, #32]
	}

	/* Decrement length of the remaining buffer */
	module->remaining_rx_buffer_length--;
    3c36:	687b      	ldr	r3, [r7, #4]
    3c38:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    3c3a:	b29b      	uxth	r3, r3
    3c3c:	3b01      	subs	r3, #1
    3c3e:	b29a      	uxth	r2, r3
    3c40:	687b      	ldr	r3, [r7, #4]
    3c42:	851a      	strh	r2, [r3, #40]	; 0x28
}
    3c44:	46c0      	nop			; (mov r8, r8)
    3c46:	46bd      	mov	sp, r7
    3c48:	b004      	add	sp, #16
    3c4a:	bd80      	pop	{r7, pc}

00003c4c <_spi_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
    3c4c:	b580      	push	{r7, lr}
    3c4e:	b086      	sub	sp, #24
    3c50:	af00      	add	r7, sp, #0
    3c52:	0002      	movs	r2, r0
    3c54:	1dfb      	adds	r3, r7, #7
    3c56:	701a      	strb	r2, [r3, #0]
	/* Get device instance from the look-up table */
	struct spi_module *module
		= (struct spi_module *)_sercom_instances[instance];
    3c58:	1dfb      	adds	r3, r7, #7
    3c5a:	781a      	ldrb	r2, [r3, #0]
 */
void _spi_interrupt_handler(
		uint8_t instance)
{
	/* Get device instance from the look-up table */
	struct spi_module *module
    3c5c:	4b8d      	ldr	r3, [pc, #564]	; (3e94 <_spi_interrupt_handler+0x248>)
    3c5e:	0092      	lsls	r2, r2, #2
    3c60:	58d3      	ldr	r3, [r2, r3]
    3c62:	617b      	str	r3, [r7, #20]
		= (struct spi_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);
    3c64:	697b      	ldr	r3, [r7, #20]
    3c66:	681b      	ldr	r3, [r3, #0]
    3c68:	613b      	str	r3, [r7, #16]

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
			module->enabled_callback & module->registered_callback;
    3c6a:	697b      	ldr	r3, [r7, #20]
    3c6c:	222f      	movs	r2, #47	; 0x2f
    3c6e:	5c9a      	ldrb	r2, [r3, r2]
    3c70:	697b      	ldr	r3, [r7, #20]
    3c72:	212e      	movs	r1, #46	; 0x2e
    3c74:	5c59      	ldrb	r1, [r3, r1]

	/* Pointer to the hardware module instance */
	SercomSpi *const spi_hw = &(module->hw->SPI);

	/* Combine callback registered and enabled masks. */
	uint8_t callback_mask =
    3c76:	230f      	movs	r3, #15
    3c78:	18fb      	adds	r3, r7, r3
    3c7a:	400a      	ands	r2, r1
    3c7c:	701a      	strb	r2, [r3, #0]
			module->enabled_callback & module->registered_callback;

	/* Read and mask interrupt flag register */
	uint16_t interrupt_status = spi_hw->INTFLAG.reg;
    3c7e:	693b      	ldr	r3, [r7, #16]
    3c80:	7b9b      	ldrb	r3, [r3, #14]
    3c82:	b2da      	uxtb	r2, r3
    3c84:	230c      	movs	r3, #12
    3c86:	18fb      	adds	r3, r7, r3
    3c88:	801a      	strh	r2, [r3, #0]
	interrupt_status &= spi_hw->INTENSET.reg;
    3c8a:	693b      	ldr	r3, [r7, #16]
    3c8c:	7b5b      	ldrb	r3, [r3, #13]
    3c8e:	b2db      	uxtb	r3, r3
    3c90:	b29a      	uxth	r2, r3
    3c92:	230c      	movs	r3, #12
    3c94:	18fb      	adds	r3, r7, r3
    3c96:	210c      	movs	r1, #12
    3c98:	1879      	adds	r1, r7, r1
    3c9a:	8809      	ldrh	r1, [r1, #0]
    3c9c:	400a      	ands	r2, r1
    3c9e:	801a      	strh	r2, [r3, #0]

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
    3ca0:	230c      	movs	r3, #12
    3ca2:	18fb      	adds	r3, r7, r3
    3ca4:	881b      	ldrh	r3, [r3, #0]
    3ca6:	2201      	movs	r2, #1
    3ca8:	4013      	ands	r3, r2
    3caa:	d038      	beq.n	3d1e <_spi_interrupt_handler+0xd2>
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    3cac:	697b      	ldr	r3, [r7, #20]
    3cae:	795b      	ldrb	r3, [r3, #5]
    3cb0:	2b01      	cmp	r3, #1
    3cb2:	d110      	bne.n	3cd6 <_spi_interrupt_handler+0x8a>
			(module->dir == SPI_DIRECTION_READ)) {
    3cb4:	697b      	ldr	r3, [r7, #20]
    3cb6:	7a1b      	ldrb	r3, [r3, #8]
    3cb8:	b2db      	uxtb	r3, r3
	interrupt_status &= spi_hw->INTENSET.reg;

	/* Data register empty interrupt */
	if (interrupt_status & SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY) {
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    3cba:	2b00      	cmp	r3, #0
    3cbc:	d10b      	bne.n	3cd6 <_spi_interrupt_handler+0x8a>
			(module->dir == SPI_DIRECTION_READ)) {
			/* Send dummy byte when reading in master mode */
			_spi_write_dummy(module);
    3cbe:	697b      	ldr	r3, [r7, #20]
    3cc0:	0018      	movs	r0, r3
    3cc2:	4b75      	ldr	r3, [pc, #468]	; (3e98 <_spi_interrupt_handler+0x24c>)
    3cc4:	4798      	blx	r3
			if (module->remaining_dummy_buffer_length == 0) {
    3cc6:	697b      	ldr	r3, [r7, #20]
    3cc8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    3cca:	b29b      	uxth	r3, r3
    3ccc:	2b00      	cmp	r3, #0
    3cce:	d102      	bne.n	3cd6 <_spi_interrupt_handler+0x8a>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    3cd0:	693b      	ldr	r3, [r7, #16]
    3cd2:	2201      	movs	r2, #1
    3cd4:	731a      	strb	r2, [r3, #12]
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    3cd6:	697b      	ldr	r3, [r7, #20]
    3cd8:	795b      	ldrb	r3, [r3, #5]
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
			}
		}
#  endif

		if (0
    3cda:	2b01      	cmp	r3, #1
    3cdc:	d11f      	bne.n	3d1e <_spi_interrupt_handler+0xd2>
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
			(module->dir != SPI_DIRECTION_READ))
    3cde:	697b      	ldr	r3, [r7, #20]
    3ce0:	7a1b      	ldrb	r3, [r3, #8]
    3ce2:	b2db      	uxtb	r3, r3
		}
#  endif

		if (0
#  if CONF_SPI_MASTER_ENABLE == true
		|| ((module->mode == SPI_MODE_MASTER) &&
    3ce4:	2b00      	cmp	r3, #0
    3ce6:	d01a      	beq.n	3d1e <_spi_interrupt_handler+0xd2>
		|| ((module->mode == SPI_MODE_SLAVE) &&
			(module->dir != SPI_DIRECTION_READ))
#  endif
		) {
			/* Write next byte from buffer */
			_spi_write(module);
    3ce8:	697b      	ldr	r3, [r7, #20]
    3cea:	0018      	movs	r0, r3
    3cec:	4b6b      	ldr	r3, [pc, #428]	; (3e9c <_spi_interrupt_handler+0x250>)
    3cee:	4798      	blx	r3
			if (module->remaining_tx_buffer_length == 0) {
    3cf0:	697b      	ldr	r3, [r7, #20]
    3cf2:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    3cf4:	b29b      	uxth	r3, r3
    3cf6:	2b00      	cmp	r3, #0
    3cf8:	d111      	bne.n	3d1e <_spi_interrupt_handler+0xd2>
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
    3cfa:	693b      	ldr	r3, [r7, #16]
    3cfc:	2201      	movs	r2, #1
    3cfe:	731a      	strb	r2, [r3, #12]

				if (module->dir == SPI_DIRECTION_WRITE &&
    3d00:	697b      	ldr	r3, [r7, #20]
    3d02:	7a1b      	ldrb	r3, [r3, #8]
    3d04:	b2db      	uxtb	r3, r3
    3d06:	2b01      	cmp	r3, #1
    3d08:	d109      	bne.n	3d1e <_spi_interrupt_handler+0xd2>
						!(module->receiver_enabled)) {
    3d0a:	697b      	ldr	r3, [r7, #20]
    3d0c:	79db      	ldrb	r3, [r3, #7]
    3d0e:	2201      	movs	r2, #1
    3d10:	4053      	eors	r3, r2
    3d12:	b2db      	uxtb	r3, r3
			if (module->remaining_tx_buffer_length == 0) {
				/* Disable the Data Register Empty Interrupt */
				spi_hw->INTENCLR.reg
						= SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;

				if (module->dir == SPI_DIRECTION_WRITE &&
    3d14:	2b00      	cmp	r3, #0
    3d16:	d002      	beq.n	3d1e <_spi_interrupt_handler+0xd2>
						!(module->receiver_enabled)) {
					/* Enable the Data Register transmit complete Interrupt */
					spi_hw->INTENSET.reg = SPI_INTERRUPT_FLAG_TX_COMPLETE;
    3d18:	693b      	ldr	r3, [r7, #16]
    3d1a:	2202      	movs	r2, #2
    3d1c:	735a      	strb	r2, [r3, #13]
			}
		}
	}

	/* Receive complete interrupt*/
	if (interrupt_status & SPI_INTERRUPT_FLAG_RX_COMPLETE) {
    3d1e:	230c      	movs	r3, #12
    3d20:	18fb      	adds	r3, r7, r3
    3d22:	881b      	ldrh	r3, [r3, #0]
    3d24:	2204      	movs	r2, #4
    3d26:	4013      	ands	r3, r2
    3d28:	d100      	bne.n	3d2c <_spi_interrupt_handler+0xe0>
    3d2a:	e083      	b.n	3e34 <_spi_interrupt_handler+0x1e8>
		/* Check for overflow */
		if (spi_hw->STATUS.reg & SERCOM_SPI_STATUS_BUFOVF) {
    3d2c:	693b      	ldr	r3, [r7, #16]
    3d2e:	8a1b      	ldrh	r3, [r3, #16]
    3d30:	b29b      	uxth	r3, r3
    3d32:	001a      	movs	r2, r3
    3d34:	2304      	movs	r3, #4
    3d36:	4013      	ands	r3, r2
    3d38:	d027      	beq.n	3d8a <_spi_interrupt_handler+0x13e>
			if (module->dir != SPI_DIRECTION_WRITE) {
    3d3a:	697b      	ldr	r3, [r7, #20]
    3d3c:	7a1b      	ldrb	r3, [r3, #8]
    3d3e:	b2db      	uxtb	r3, r3
    3d40:	2b01      	cmp	r3, #1
    3d42:	d014      	beq.n	3d6e <_spi_interrupt_handler+0x122>
				/* Store the error code */
				module->status = STATUS_ERR_OVERFLOW;
    3d44:	697b      	ldr	r3, [r7, #20]
    3d46:	2230      	movs	r2, #48	; 0x30
    3d48:	211e      	movs	r1, #30
    3d4a:	5499      	strb	r1, [r3, r2]

				/* End transaction */
				module->dir = SPI_DIRECTION_IDLE;
    3d4c:	697b      	ldr	r3, [r7, #20]
    3d4e:	2203      	movs	r2, #3
    3d50:	721a      	strb	r2, [r3, #8]

				spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE |
    3d52:	693b      	ldr	r3, [r7, #16]
    3d54:	2205      	movs	r2, #5
    3d56:	731a      	strb	r2, [r3, #12]
						SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY;
				/* Run callback if registered and enabled */
				if (callback_mask & (1 << SPI_CALLBACK_ERROR)) {
    3d58:	230f      	movs	r3, #15
    3d5a:	18fb      	adds	r3, r7, r3
    3d5c:	781b      	ldrb	r3, [r3, #0]
    3d5e:	2208      	movs	r2, #8
    3d60:	4013      	ands	r3, r2
    3d62:	d004      	beq.n	3d6e <_spi_interrupt_handler+0x122>
					(module->callback[SPI_CALLBACK_ERROR])(module);
    3d64:	697b      	ldr	r3, [r7, #20]
    3d66:	699b      	ldr	r3, [r3, #24]
    3d68:	697a      	ldr	r2, [r7, #20]
    3d6a:	0010      	movs	r0, r2
    3d6c:	4798      	blx	r3
				}
			}
			/* Flush */
			uint16_t flush = spi_hw->DATA.reg;
    3d6e:	230a      	movs	r3, #10
    3d70:	18fb      	adds	r3, r7, r3
    3d72:	693a      	ldr	r2, [r7, #16]
    3d74:	8b12      	ldrh	r2, [r2, #24]
    3d76:	801a      	strh	r2, [r3, #0]
			UNUSED(flush);
			/* Clear overflow flag */
			spi_hw->STATUS.reg |= SERCOM_SPI_STATUS_BUFOVF;
    3d78:	693b      	ldr	r3, [r7, #16]
    3d7a:	8a1b      	ldrh	r3, [r3, #16]
    3d7c:	b29b      	uxth	r3, r3
    3d7e:	2204      	movs	r2, #4
    3d80:	4313      	orrs	r3, r2
    3d82:	b29a      	uxth	r2, r3
    3d84:	693b      	ldr	r3, [r7, #16]
    3d86:	821a      	strh	r2, [r3, #16]
    3d88:	e054      	b.n	3e34 <_spi_interrupt_handler+0x1e8>
		} else {
			if (module->dir == SPI_DIRECTION_WRITE) {
    3d8a:	697b      	ldr	r3, [r7, #20]
    3d8c:	7a1b      	ldrb	r3, [r3, #8]
    3d8e:	b2db      	uxtb	r3, r3
    3d90:	2b01      	cmp	r3, #1
    3d92:	d11e      	bne.n	3dd2 <_spi_interrupt_handler+0x186>
				/* Flush receive buffer when writing */
				_spi_read_dummy(module);
    3d94:	697b      	ldr	r3, [r7, #20]
    3d96:	0018      	movs	r0, r3
    3d98:	4b41      	ldr	r3, [pc, #260]	; (3ea0 <_spi_interrupt_handler+0x254>)
    3d9a:	4798      	blx	r3
				if (module->remaining_dummy_buffer_length == 0) {
    3d9c:	697b      	ldr	r3, [r7, #20]
    3d9e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    3da0:	b29b      	uxth	r3, r3
    3da2:	2b00      	cmp	r3, #0
    3da4:	d146      	bne.n	3e34 <_spi_interrupt_handler+0x1e8>
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    3da6:	693b      	ldr	r3, [r7, #16]
    3da8:	2204      	movs	r2, #4
    3daa:	731a      	strb	r2, [r3, #12]
					module->status = STATUS_OK;
    3dac:	697b      	ldr	r3, [r7, #20]
    3dae:	2230      	movs	r2, #48	; 0x30
    3db0:	2100      	movs	r1, #0
    3db2:	5499      	strb	r1, [r3, r2]
					module->dir = SPI_DIRECTION_IDLE;
    3db4:	697b      	ldr	r3, [r7, #20]
    3db6:	2203      	movs	r2, #3
    3db8:	721a      	strb	r2, [r3, #8]
					/* Run callback if registered and enabled */
					if (callback_mask &
    3dba:	230f      	movs	r3, #15
    3dbc:	18fb      	adds	r3, r7, r3
    3dbe:	781b      	ldrb	r3, [r3, #0]
    3dc0:	2201      	movs	r2, #1
    3dc2:	4013      	ands	r3, r2
    3dc4:	d036      	beq.n	3e34 <_spi_interrupt_handler+0x1e8>
							(1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
						(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])(module);
    3dc6:	697b      	ldr	r3, [r7, #20]
    3dc8:	68db      	ldr	r3, [r3, #12]
    3dca:	697a      	ldr	r2, [r7, #20]
    3dcc:	0010      	movs	r0, r2
    3dce:	4798      	blx	r3
    3dd0:	e030      	b.n	3e34 <_spi_interrupt_handler+0x1e8>
					}
				}
			} else {
				/* Read data register */
				_spi_read(module);
    3dd2:	697b      	ldr	r3, [r7, #20]
    3dd4:	0018      	movs	r0, r3
    3dd6:	4b33      	ldr	r3, [pc, #204]	; (3ea4 <_spi_interrupt_handler+0x258>)
    3dd8:	4798      	blx	r3

				/* Check if the last character have been received */
				if (module->remaining_rx_buffer_length == 0) {
    3dda:	697b      	ldr	r3, [r7, #20]
    3ddc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    3dde:	b29b      	uxth	r3, r3
    3de0:	2b00      	cmp	r3, #0
    3de2:	d127      	bne.n	3e34 <_spi_interrupt_handler+0x1e8>
					module->status = STATUS_OK;
    3de4:	697b      	ldr	r3, [r7, #20]
    3de6:	2230      	movs	r2, #48	; 0x30
    3de8:	2100      	movs	r1, #0
    3dea:	5499      	strb	r1, [r3, r2]
					/* Disable RX Complete Interrupt and set status */
					spi_hw->INTENCLR.reg = SPI_INTERRUPT_FLAG_RX_COMPLETE;
    3dec:	693b      	ldr	r3, [r7, #16]
    3dee:	2204      	movs	r2, #4
    3df0:	731a      	strb	r2, [r3, #12]
					if(module->dir == SPI_DIRECTION_BOTH) {
    3df2:	697b      	ldr	r3, [r7, #20]
    3df4:	7a1b      	ldrb	r3, [r3, #8]
    3df6:	b2db      	uxtb	r3, r3
    3df8:	2b02      	cmp	r3, #2
    3dfa:	d10b      	bne.n	3e14 <_spi_interrupt_handler+0x1c8>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSCEIVED)) {
    3dfc:	230f      	movs	r3, #15
    3dfe:	18fb      	adds	r3, r7, r3
    3e00:	781b      	ldrb	r3, [r3, #0]
    3e02:	2204      	movs	r2, #4
    3e04:	4013      	ands	r3, r2
    3e06:	d015      	beq.n	3e34 <_spi_interrupt_handler+0x1e8>
							(module->callback[SPI_CALLBACK_BUFFER_TRANSCEIVED])(module);
    3e08:	697b      	ldr	r3, [r7, #20]
    3e0a:	695b      	ldr	r3, [r3, #20]
    3e0c:	697a      	ldr	r2, [r7, #20]
    3e0e:	0010      	movs	r0, r2
    3e10:	4798      	blx	r3
    3e12:	e00f      	b.n	3e34 <_spi_interrupt_handler+0x1e8>
						}
					} else if (module->dir == SPI_DIRECTION_READ) {
    3e14:	697b      	ldr	r3, [r7, #20]
    3e16:	7a1b      	ldrb	r3, [r3, #8]
    3e18:	b2db      	uxtb	r3, r3
    3e1a:	2b00      	cmp	r3, #0
    3e1c:	d10a      	bne.n	3e34 <_spi_interrupt_handler+0x1e8>
						if (callback_mask & (1 << SPI_CALLBACK_BUFFER_RECEIVED)) {
    3e1e:	230f      	movs	r3, #15
    3e20:	18fb      	adds	r3, r7, r3
    3e22:	781b      	ldrb	r3, [r3, #0]
    3e24:	2202      	movs	r2, #2
    3e26:	4013      	ands	r3, r2
    3e28:	d004      	beq.n	3e34 <_spi_interrupt_handler+0x1e8>
							(module->callback[SPI_CALLBACK_BUFFER_RECEIVED])(module);
    3e2a:	697b      	ldr	r3, [r7, #20]
    3e2c:	691b      	ldr	r3, [r3, #16]
    3e2e:	697a      	ldr	r2, [r7, #20]
    3e30:	0010      	movs	r0, r2
    3e32:	4798      	blx	r3
			}
		}
	}

	/* Transmit complete */
	if (interrupt_status & SPI_INTERRUPT_FLAG_TX_COMPLETE) {
    3e34:	230c      	movs	r3, #12
    3e36:	18fb      	adds	r3, r7, r3
    3e38:	881b      	ldrh	r3, [r3, #0]
    3e3a:	2202      	movs	r2, #2
    3e3c:	4013      	ands	r3, r2
    3e3e:	d024      	beq.n	3e8a <_spi_interrupt_handler+0x23e>
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    3e40:	697b      	ldr	r3, [r7, #20]
    3e42:	795b      	ldrb	r3, [r3, #5]
    3e44:	2b01      	cmp	r3, #1
    3e46:	d120      	bne.n	3e8a <_spi_interrupt_handler+0x23e>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    3e48:	697b      	ldr	r3, [r7, #20]
    3e4a:	7a1b      	ldrb	r3, [r3, #8]
    3e4c:	b2db      	uxtb	r3, r3
			}

		}
#  endif
#  if CONF_SPI_MASTER_ENABLE == true
		if ((module->mode == SPI_MODE_MASTER) &&
    3e4e:	2b01      	cmp	r3, #1
    3e50:	d11b      	bne.n	3e8a <_spi_interrupt_handler+0x23e>
			(module->dir == SPI_DIRECTION_WRITE) && !(module->receiver_enabled)) {
    3e52:	697b      	ldr	r3, [r7, #20]
    3e54:	79db      	ldrb	r3, [r3, #7]
    3e56:	2201      	movs	r2, #1
    3e58:	4053      	eors	r3, r2
    3e5a:	b2db      	uxtb	r3, r3
    3e5c:	2b00      	cmp	r3, #0
    3e5e:	d014      	beq.n	3e8a <_spi_interrupt_handler+0x23e>
		  	/* Clear interrupt flag */
		 	spi_hw->INTENCLR.reg
					= SPI_INTERRUPT_FLAG_TX_COMPLETE;
    3e60:	693b      	ldr	r3, [r7, #16]
    3e62:	2202      	movs	r2, #2
    3e64:	731a      	strb	r2, [r3, #12]
			/* Buffer sent with receiver disabled */
			module->dir = SPI_DIRECTION_IDLE;
    3e66:	697b      	ldr	r3, [r7, #20]
    3e68:	2203      	movs	r2, #3
    3e6a:	721a      	strb	r2, [r3, #8]
			module->status = STATUS_OK;
    3e6c:	697b      	ldr	r3, [r7, #20]
    3e6e:	2230      	movs	r2, #48	; 0x30
    3e70:	2100      	movs	r1, #0
    3e72:	5499      	strb	r1, [r3, r2]
			/* Run callback if registered and enabled */
			if (callback_mask & (1 << SPI_CALLBACK_BUFFER_TRANSMITTED)){
    3e74:	230f      	movs	r3, #15
    3e76:	18fb      	adds	r3, r7, r3
    3e78:	781b      	ldrb	r3, [r3, #0]
    3e7a:	2201      	movs	r2, #1
    3e7c:	4013      	ands	r3, r2
    3e7e:	d004      	beq.n	3e8a <_spi_interrupt_handler+0x23e>
				(module->callback[SPI_CALLBACK_BUFFER_TRANSMITTED])
    3e80:	697b      	ldr	r3, [r7, #20]
    3e82:	68db      	ldr	r3, [r3, #12]
    3e84:	697a      	ldr	r2, [r7, #20]
    3e86:	0010      	movs	r0, r2
    3e88:	4798      	blx	r3
		if (callback_mask & (1 << SPI_CALLBACK_COMBINED_ERROR)) {
			(module->callback[SPI_CALLBACK_COMBINED_ERROR])(module);
		}
	}
#  endif
}
    3e8a:	46c0      	nop			; (mov r8, r8)
    3e8c:	46bd      	mov	sp, r7
    3e8e:	b006      	add	sp, #24
    3e90:	bd80      	pop	{r7, pc}
    3e92:	46c0      	nop			; (mov r8, r8)
    3e94:	20002e54 	.word	0x20002e54
    3e98:	00003b75 	.word	0x00003b75
    3e9c:	00003af9 	.word	0x00003af9
    3ea0:	00003ba5 	.word	0x00003ba5
    3ea4:	00003bdd 	.word	0x00003bdd

00003ea8 <system_gclk_gen_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_gen_get_config_defaults(
		struct system_gclk_gen_config *const config)
{
    3ea8:	b580      	push	{r7, lr}
    3eaa:	b082      	sub	sp, #8
    3eac:	af00      	add	r7, sp, #0
    3eae:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->division_factor    = 1;
    3eb0:	687b      	ldr	r3, [r7, #4]
    3eb2:	2201      	movs	r2, #1
    3eb4:	605a      	str	r2, [r3, #4]
	config->high_when_disabled = false;
    3eb6:	687b      	ldr	r3, [r7, #4]
    3eb8:	2200      	movs	r2, #0
    3eba:	705a      	strb	r2, [r3, #1]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    3ebc:	687b      	ldr	r3, [r7, #4]
    3ebe:	2206      	movs	r2, #6
    3ec0:	701a      	strb	r2, [r3, #0]
#endif
	config->run_in_standby     = false;
    3ec2:	687b      	ldr	r3, [r7, #4]
    3ec4:	2200      	movs	r2, #0
    3ec6:	721a      	strb	r2, [r3, #8]
	config->output_enable      = false;
    3ec8:	687b      	ldr	r3, [r7, #4]
    3eca:	2200      	movs	r2, #0
    3ecc:	725a      	strb	r2, [r3, #9]
}
    3ece:	46c0      	nop			; (mov r8, r8)
    3ed0:	46bd      	mov	sp, r7
    3ed2:	b002      	add	sp, #8
    3ed4:	bd80      	pop	{r7, pc}
    3ed6:	46c0      	nop			; (mov r8, r8)

00003ed8 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    3ed8:	b580      	push	{r7, lr}
    3eda:	b082      	sub	sp, #8
    3edc:	af00      	add	r7, sp, #0
    3ede:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    3ee0:	687b      	ldr	r3, [r7, #4]
    3ee2:	2200      	movs	r2, #0
    3ee4:	701a      	strb	r2, [r3, #0]
}
    3ee6:	46c0      	nop			; (mov r8, r8)
    3ee8:	46bd      	mov	sp, r7
    3eea:	b002      	add	sp, #8
    3eec:	bd80      	pop	{r7, pc}
    3eee:	46c0      	nop			; (mov r8, r8)

00003ef0 <system_clock_source_osc32k_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_osc32k_get_config_defaults(
		struct system_clock_source_osc32k_config *const config)
{
    3ef0:	b580      	push	{r7, lr}
    3ef2:	b082      	sub	sp, #8
    3ef4:	af00      	add	r7, sp, #0
    3ef6:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->enable_1khz_output  = true;
    3ef8:	687b      	ldr	r3, [r7, #4]
    3efa:	2201      	movs	r2, #1
    3efc:	705a      	strb	r2, [r3, #1]
	config->enable_32khz_output = true;
    3efe:	687b      	ldr	r3, [r7, #4]
    3f00:	2201      	movs	r2, #1
    3f02:	709a      	strb	r2, [r3, #2]
	config->run_in_standby      = false;
    3f04:	687b      	ldr	r3, [r7, #4]
    3f06:	2200      	movs	r2, #0
    3f08:	70da      	strb	r2, [r3, #3]
	config->on_demand           = true;
    3f0a:	687b      	ldr	r3, [r7, #4]
    3f0c:	2201      	movs	r2, #1
    3f0e:	711a      	strb	r2, [r3, #4]
	config->startup_time        = SYSTEM_OSC32K_STARTUP_130;
    3f10:	687b      	ldr	r3, [r7, #4]
    3f12:	2207      	movs	r2, #7
    3f14:	701a      	strb	r2, [r3, #0]
	config->write_once          = false;
    3f16:	687b      	ldr	r3, [r7, #4]
    3f18:	2200      	movs	r2, #0
    3f1a:	715a      	strb	r2, [r3, #5]
}
    3f1c:	46c0      	nop			; (mov r8, r8)
    3f1e:	46bd      	mov	sp, r7
    3f20:	b002      	add	sp, #8
    3f22:	bd80      	pop	{r7, pc}

00003f24 <system_clock_source_osc8m_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_osc8m_get_config_defaults(
		struct system_clock_source_osc8m_config *const config)
{
    3f24:	b580      	push	{r7, lr}
    3f26:	b082      	sub	sp, #8
    3f28:	af00      	add	r7, sp, #0
    3f2a:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->prescaler       = SYSTEM_OSC8M_DIV_8;
    3f2c:	687b      	ldr	r3, [r7, #4]
    3f2e:	2203      	movs	r2, #3
    3f30:	701a      	strb	r2, [r3, #0]
	config->run_in_standby  = false;
    3f32:	687b      	ldr	r3, [r7, #4]
    3f34:	2200      	movs	r2, #0
    3f36:	705a      	strb	r2, [r3, #1]
	config->on_demand       = true;
    3f38:	687b      	ldr	r3, [r7, #4]
    3f3a:	2201      	movs	r2, #1
    3f3c:	709a      	strb	r2, [r3, #2]
}
    3f3e:	46c0      	nop			; (mov r8, r8)
    3f40:	46bd      	mov	sp, r7
    3f42:	b002      	add	sp, #8
    3f44:	bd80      	pop	{r7, pc}
    3f46:	46c0      	nop			; (mov r8, r8)

00003f48 <system_clock_source_dfll_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to fill with default values
 */
static inline void system_clock_source_dfll_get_config_defaults(
		struct system_clock_source_dfll_config *const config)
{
    3f48:	b580      	push	{r7, lr}
    3f4a:	b082      	sub	sp, #8
    3f4c:	af00      	add	r7, sp, #0
    3f4e:	6078      	str	r0, [r7, #4]
	Assert(config);

	config->loop_mode       = SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN;
    3f50:	687b      	ldr	r3, [r7, #4]
    3f52:	2200      	movs	r2, #0
    3f54:	701a      	strb	r2, [r3, #0]
	config->quick_lock      = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    3f56:	687b      	ldr	r3, [r7, #4]
    3f58:	2200      	movs	r2, #0
    3f5a:	805a      	strh	r2, [r3, #2]
	config->chill_cycle     = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    3f5c:	687b      	ldr	r3, [r7, #4]
    3f5e:	2200      	movs	r2, #0
    3f60:	809a      	strh	r2, [r3, #4]
	config->wakeup_lock     = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    3f62:	687b      	ldr	r3, [r7, #4]
    3f64:	2200      	movs	r2, #0
    3f66:	719a      	strb	r2, [r3, #6]
	config->stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    3f68:	687b      	ldr	r3, [r7, #4]
    3f6a:	2200      	movs	r2, #0
    3f6c:	71da      	strb	r2, [r3, #7]
	config->on_demand       = true;
    3f6e:	687b      	ldr	r3, [r7, #4]
    3f70:	2201      	movs	r2, #1
    3f72:	705a      	strb	r2, [r3, #1]

	/* Open loop mode calibration value */
	config->coarse_value    = 0x1f / 4; /* Midpoint */
    3f74:	687b      	ldr	r3, [r7, #4]
    3f76:	2207      	movs	r2, #7
    3f78:	721a      	strb	r2, [r3, #8]
	config->fine_value      = 0xff / 4; /* Midpoint */
    3f7a:	687b      	ldr	r3, [r7, #4]
    3f7c:	223f      	movs	r2, #63	; 0x3f
    3f7e:	815a      	strh	r2, [r3, #10]

	/* Closed loop mode */
	config->coarse_max_step = 1;
    3f80:	687b      	ldr	r3, [r7, #4]
    3f82:	2201      	movs	r2, #1
    3f84:	731a      	strb	r2, [r3, #12]
	config->fine_max_step   = 1;
    3f86:	687b      	ldr	r3, [r7, #4]
    3f88:	2201      	movs	r2, #1
    3f8a:	81da      	strh	r2, [r3, #14]
	config->multiply_factor = 6; /* Multiply 8MHz by 6 to get 48MHz */
    3f8c:	687b      	ldr	r3, [r7, #4]
    3f8e:	2206      	movs	r2, #6
    3f90:	821a      	strh	r2, [r3, #16]
}
    3f92:	46c0      	nop			; (mov r8, r8)
    3f94:	46bd      	mov	sp, r7
    3f96:	b002      	add	sp, #8
    3f98:	bd80      	pop	{r7, pc}
    3f9a:	46c0      	nop			; (mov r8, r8)

00003f9c <system_cpu_clock_set_divider>:
 *
 * \param[in] divider  CPU clock divider to set
 */
static inline void system_cpu_clock_set_divider(
		const enum system_main_clock_div divider)
{
    3f9c:	b580      	push	{r7, lr}
    3f9e:	b082      	sub	sp, #8
    3fa0:	af00      	add	r7, sp, #0
    3fa2:	0002      	movs	r2, r0
    3fa4:	1dfb      	adds	r3, r7, #7
    3fa6:	701a      	strb	r2, [r3, #0]
	Assert(((uint32_t)divider & PM_CPUSEL_CPUDIV_Msk) == divider);
	PM->CPUSEL.reg = (uint32_t)divider;
    3fa8:	4a03      	ldr	r2, [pc, #12]	; (3fb8 <system_cpu_clock_set_divider+0x1c>)
    3faa:	1dfb      	adds	r3, r7, #7
    3fac:	781b      	ldrb	r3, [r3, #0]
    3fae:	7213      	strb	r3, [r2, #8]
}
    3fb0:	46c0      	nop			; (mov r8, r8)
    3fb2:	46bd      	mov	sp, r7
    3fb4:	b002      	add	sp, #8
    3fb6:	bd80      	pop	{r7, pc}
    3fb8:	40000400 	.word	0x40000400

00003fbc <system_apb_clock_set_divider>:
 * \retval STATUS_OK               The APBx clock was set successfully
 */
static inline enum status_code system_apb_clock_set_divider(
		const enum system_clock_apb_bus bus,
		const enum system_main_clock_div divider)
{
    3fbc:	b580      	push	{r7, lr}
    3fbe:	b082      	sub	sp, #8
    3fc0:	af00      	add	r7, sp, #0
    3fc2:	0002      	movs	r2, r0
    3fc4:	1dfb      	adds	r3, r7, #7
    3fc6:	701a      	strb	r2, [r3, #0]
    3fc8:	1dbb      	adds	r3, r7, #6
    3fca:	1c0a      	adds	r2, r1, #0
    3fcc:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    3fce:	1dfb      	adds	r3, r7, #7
    3fd0:	781b      	ldrb	r3, [r3, #0]
    3fd2:	2b01      	cmp	r3, #1
    3fd4:	d008      	beq.n	3fe8 <system_apb_clock_set_divider+0x2c>
    3fd6:	2b02      	cmp	r3, #2
    3fd8:	d00b      	beq.n	3ff2 <system_apb_clock_set_divider+0x36>
    3fda:	2b00      	cmp	r3, #0
    3fdc:	d10e      	bne.n	3ffc <system_apb_clock_set_divider+0x40>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBASEL.reg = (uint32_t)divider;
    3fde:	4a0b      	ldr	r2, [pc, #44]	; (400c <system_apb_clock_set_divider+0x50>)
    3fe0:	1dbb      	adds	r3, r7, #6
    3fe2:	781b      	ldrb	r3, [r3, #0]
    3fe4:	7253      	strb	r3, [r2, #9]
			break;
    3fe6:	e00b      	b.n	4000 <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBSEL.reg = (uint32_t)divider;
    3fe8:	4a08      	ldr	r2, [pc, #32]	; (400c <system_apb_clock_set_divider+0x50>)
    3fea:	1dbb      	adds	r3, r7, #6
    3fec:	781b      	ldrb	r3, [r3, #0]
    3fee:	7293      	strb	r3, [r2, #10]
			break;
    3ff0:	e006      	b.n	4000 <system_apb_clock_set_divider+0x44>
		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCSEL.reg = (uint32_t)divider;
    3ff2:	4a06      	ldr	r2, [pc, #24]	; (400c <system_apb_clock_set_divider+0x50>)
    3ff4:	1dbb      	adds	r3, r7, #6
    3ff6:	781b      	ldrb	r3, [r3, #0]
    3ff8:	72d3      	strb	r3, [r2, #11]
			break;
    3ffa:	e001      	b.n	4000 <system_apb_clock_set_divider+0x44>
		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    3ffc:	2317      	movs	r3, #23
    3ffe:	e000      	b.n	4002 <system_apb_clock_set_divider+0x46>
	}

	return STATUS_OK;
    4000:	2300      	movs	r3, #0
}
    4002:	0018      	movs	r0, r3
    4004:	46bd      	mov	sp, r7
    4006:	b002      	add	sp, #8
    4008:	bd80      	pop	{r7, pc}
    400a:	46c0      	nop			; (mov r8, r8)
    400c:	40000400 	.word	0x40000400

00004010 <system_flash_set_waitstates>:
 * can be found in the electrical characteristics of the device.
 *
 * \param[in] wait_states Number of wait states to use for internal flash
 */
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
    4010:	b580      	push	{r7, lr}
    4012:	b082      	sub	sp, #8
    4014:	af00      	add	r7, sp, #0
    4016:	0002      	movs	r2, r0
    4018:	1dfb      	adds	r3, r7, #7
    401a:	701a      	strb	r2, [r3, #0]
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    401c:	4a08      	ldr	r2, [pc, #32]	; (4040 <system_flash_set_waitstates+0x30>)
    401e:	1dfb      	adds	r3, r7, #7
    4020:	781b      	ldrb	r3, [r3, #0]
    4022:	210f      	movs	r1, #15
    4024:	400b      	ands	r3, r1
    4026:	b2d9      	uxtb	r1, r3
    4028:	6853      	ldr	r3, [r2, #4]
    402a:	200f      	movs	r0, #15
    402c:	4001      	ands	r1, r0
    402e:	0049      	lsls	r1, r1, #1
    4030:	201e      	movs	r0, #30
    4032:	4383      	bics	r3, r0
    4034:	430b      	orrs	r3, r1
    4036:	6053      	str	r3, [r2, #4]
}
    4038:	46c0      	nop			; (mov r8, r8)
    403a:	46bd      	mov	sp, r7
    403c:	b002      	add	sp, #8
    403e:	bd80      	pop	{r7, pc}
    4040:	41004000 	.word	0x41004000

00004044 <system_get_device_id>:
 * Retrieves the signature of the current device.
 *
 * \return Device ID signature as a 32-bit integer.
 */
static inline uint32_t system_get_device_id(void)
{
    4044:	b580      	push	{r7, lr}
    4046:	af00      	add	r7, sp, #0
	return DSU->DID.reg;
    4048:	4b02      	ldr	r3, [pc, #8]	; (4054 <system_get_device_id+0x10>)
    404a:	699b      	ldr	r3, [r3, #24]
}
    404c:	0018      	movs	r0, r3
    404e:	46bd      	mov	sp, r7
    4050:	bd80      	pop	{r7, pc}
    4052:	46c0      	nop			; (mov r8, r8)
    4054:	41002000 	.word	0x41002000

00004058 <_system_dfll_wait_for_sync>:
/**
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
    4058:	b580      	push	{r7, lr}
    405a:	af00      	add	r7, sp, #0
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    405c:	46c0      	nop			; (mov r8, r8)
    405e:	4b04      	ldr	r3, [pc, #16]	; (4070 <_system_dfll_wait_for_sync+0x18>)
    4060:	68db      	ldr	r3, [r3, #12]
    4062:	2210      	movs	r2, #16
    4064:	4013      	ands	r3, r2
    4066:	d0fa      	beq.n	405e <_system_dfll_wait_for_sync+0x6>
		/* Wait for DFLL sync */
	}
}
    4068:	46c0      	nop			; (mov r8, r8)
    406a:	46bd      	mov	sp, r7
    406c:	bd80      	pop	{r7, pc}
    406e:	46c0      	nop			; (mov r8, r8)
    4070:	40000800 	.word	0x40000800

00004074 <_system_clock_source_dfll_set_config_errata_9905>:
		/* Wait for OSC32K sync */
	}
}

static inline void _system_clock_source_dfll_set_config_errata_9905(void)
{
    4074:	b580      	push	{r7, lr}
    4076:	af00      	add	r7, sp, #0

	/* Disable ONDEMAND mode while writing configurations */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control & ~SYSCTRL_DFLLCTRL_ONDEMAND;
    4078:	4a0c      	ldr	r2, [pc, #48]	; (40ac <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    407a:	4b0d      	ldr	r3, [pc, #52]	; (40b0 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    407c:	681b      	ldr	r3, [r3, #0]
    407e:	b29b      	uxth	r3, r3
    4080:	2180      	movs	r1, #128	; 0x80
    4082:	438b      	bics	r3, r1
    4084:	b29b      	uxth	r3, r3
    4086:	8493      	strh	r3, [r2, #36]	; 0x24
	_system_dfll_wait_for_sync();
    4088:	4b0a      	ldr	r3, [pc, #40]	; (40b4 <_system_clock_source_dfll_set_config_errata_9905+0x40>)
    408a:	4798      	blx	r3

	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    408c:	4a07      	ldr	r2, [pc, #28]	; (40ac <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    408e:	4b08      	ldr	r3, [pc, #32]	; (40b0 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    4090:	689b      	ldr	r3, [r3, #8]
    4092:	62d3      	str	r3, [r2, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    4094:	4a05      	ldr	r2, [pc, #20]	; (40ac <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    4096:	4b06      	ldr	r3, [pc, #24]	; (40b0 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    4098:	685b      	ldr	r3, [r3, #4]
    409a:	6293      	str	r3, [r2, #40]	; 0x28

	/* Write full configuration to DFLL control register */
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    409c:	4a03      	ldr	r2, [pc, #12]	; (40ac <_system_clock_source_dfll_set_config_errata_9905+0x38>)
    409e:	4b04      	ldr	r3, [pc, #16]	; (40b0 <_system_clock_source_dfll_set_config_errata_9905+0x3c>)
    40a0:	681b      	ldr	r3, [r3, #0]
    40a2:	b29b      	uxth	r3, r3
    40a4:	8493      	strh	r3, [r2, #36]	; 0x24
}
    40a6:	46c0      	nop			; (mov r8, r8)
    40a8:	46bd      	mov	sp, r7
    40aa:	bd80      	pop	{r7, pc}
    40ac:	40000800 	.word	0x40000800
    40b0:	20000af0 	.word	0x20000af0
    40b4:	00004059 	.word	0x00004059

000040b8 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    40b8:	b580      	push	{r7, lr}
    40ba:	b082      	sub	sp, #8
    40bc:	af00      	add	r7, sp, #0
    40be:	0002      	movs	r2, r0
    40c0:	1dfb      	adds	r3, r7, #7
    40c2:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
    40c4:	1dfb      	adds	r3, r7, #7
    40c6:	781b      	ldrb	r3, [r3, #0]
    40c8:	2b07      	cmp	r3, #7
    40ca:	d833      	bhi.n	4134 <system_clock_source_get_hz+0x7c>
    40cc:	009a      	lsls	r2, r3, #2
    40ce:	4b1c      	ldr	r3, [pc, #112]	; (4140 <system_clock_source_get_hz+0x88>)
    40d0:	18d3      	adds	r3, r2, r3
    40d2:	681b      	ldr	r3, [r3, #0]
    40d4:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_XOSC:
		return _system_clock_inst.xosc.frequency;
    40d6:	4b1b      	ldr	r3, [pc, #108]	; (4144 <system_clock_source_get_hz+0x8c>)
    40d8:	68db      	ldr	r3, [r3, #12]
    40da:	e02c      	b.n	4136 <system_clock_source_get_hz+0x7e>

	case SYSTEM_CLOCK_SOURCE_OSC8M:
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    40dc:	4b1a      	ldr	r3, [pc, #104]	; (4148 <system_clock_source_get_hz+0x90>)
    40de:	6a1b      	ldr	r3, [r3, #32]
    40e0:	059b      	lsls	r3, r3, #22
    40e2:	0f9b      	lsrs	r3, r3, #30
    40e4:	b2db      	uxtb	r3, r3
    40e6:	001a      	movs	r2, r3
    40e8:	4b18      	ldr	r3, [pc, #96]	; (414c <system_clock_source_get_hz+0x94>)
    40ea:	40d3      	lsrs	r3, r2
    40ec:	e023      	b.n	4136 <system_clock_source_get_hz+0x7e>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		return 32768UL;
    40ee:	2380      	movs	r3, #128	; 0x80
    40f0:	021b      	lsls	r3, r3, #8
    40f2:	e020      	b.n	4136 <system_clock_source_get_hz+0x7e>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		return 32768UL;
    40f4:	2380      	movs	r3, #128	; 0x80
    40f6:	021b      	lsls	r3, r3, #8
    40f8:	e01d      	b.n	4136 <system_clock_source_get_hz+0x7e>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		return _system_clock_inst.xosc32k.frequency;
    40fa:	4b12      	ldr	r3, [pc, #72]	; (4144 <system_clock_source_get_hz+0x8c>)
    40fc:	691b      	ldr	r3, [r3, #16]
    40fe:	e01a      	b.n	4136 <system_clock_source_get_hz+0x7e>

	case SYSTEM_CLOCK_SOURCE_DFLL:

		/* Check if the DFLL has been configured */
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    4100:	4b10      	ldr	r3, [pc, #64]	; (4144 <system_clock_source_get_hz+0x8c>)
    4102:	681b      	ldr	r3, [r3, #0]
    4104:	2202      	movs	r2, #2
    4106:	4013      	ands	r3, r2
    4108:	d101      	bne.n	410e <system_clock_source_get_hz+0x56>
			return 0;
    410a:	2300      	movs	r3, #0
    410c:	e013      	b.n	4136 <system_clock_source_get_hz+0x7e>

		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();
    410e:	4b10      	ldr	r3, [pc, #64]	; (4150 <system_clock_source_get_hz+0x98>)
    4110:	4798      	blx	r3

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    4112:	4b0c      	ldr	r3, [pc, #48]	; (4144 <system_clock_source_get_hz+0x8c>)
    4114:	681b      	ldr	r3, [r3, #0]
    4116:	2204      	movs	r2, #4
    4118:	4013      	ands	r3, r2
    411a:	d009      	beq.n	4130 <system_clock_source_get_hz+0x78>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    411c:	2000      	movs	r0, #0
    411e:	4b0d      	ldr	r3, [pc, #52]	; (4154 <system_clock_source_get_hz+0x9c>)
    4120:	4798      	blx	r3
    4122:	0002      	movs	r2, r0
					(_system_clock_inst.dfll.mul & 0xffff);
    4124:	4b07      	ldr	r3, [pc, #28]	; (4144 <system_clock_source_get_hz+0x8c>)
    4126:	689b      	ldr	r3, [r3, #8]
    4128:	041b      	lsls	r3, r3, #16
    412a:	0c1b      	lsrs	r3, r3, #16
		/* Make sure that the DFLL module is ready */
		_system_dfll_wait_for_sync();

		/* Check if operating in closed loop mode */
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    412c:	4353      	muls	r3, r2
    412e:	e002      	b.n	4136 <system_clock_source_get_hz+0x7e>
					(_system_clock_inst.dfll.mul & 0xffff);
		}

		return 48000000UL;
    4130:	4b09      	ldr	r3, [pc, #36]	; (4158 <system_clock_source_get_hz+0xa0>)
    4132:	e000      	b.n	4136 <system_clock_source_get_hz+0x7e>

	default:
		return 0;
    4134:	2300      	movs	r3, #0
	}
}
    4136:	0018      	movs	r0, r3
    4138:	46bd      	mov	sp, r7
    413a:	b002      	add	sp, #8
    413c:	bd80      	pop	{r7, pc}
    413e:	46c0      	nop			; (mov r8, r8)
    4140:	0000fcc4 	.word	0x0000fcc4
    4144:	20000af0 	.word	0x20000af0
    4148:	40000800 	.word	0x40000800
    414c:	007a1200 	.word	0x007a1200
    4150:	00004059 	.word	0x00004059
    4154:	00004bcd 	.word	0x00004bcd
    4158:	02dc6c00 	.word	0x02dc6c00

0000415c <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    415c:	b580      	push	{r7, lr}
    415e:	b084      	sub	sp, #16
    4160:	af00      	add	r7, sp, #0
    4162:	6078      	str	r0, [r7, #4]
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    4164:	4b1a      	ldr	r3, [pc, #104]	; (41d0 <system_clock_source_osc8m_set_config+0x74>)
    4166:	6a1b      	ldr	r3, [r3, #32]
    4168:	60fb      	str	r3, [r7, #12]

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    416a:	687b      	ldr	r3, [r7, #4]
    416c:	781b      	ldrb	r3, [r3, #0]
    416e:	1c1a      	adds	r2, r3, #0
    4170:	2303      	movs	r3, #3
    4172:	4013      	ands	r3, r2
    4174:	b2da      	uxtb	r2, r3
    4176:	230d      	movs	r3, #13
    4178:	18fb      	adds	r3, r7, r3
    417a:	2103      	movs	r1, #3
    417c:	400a      	ands	r2, r1
    417e:	0010      	movs	r0, r2
    4180:	781a      	ldrb	r2, [r3, #0]
    4182:	2103      	movs	r1, #3
    4184:	438a      	bics	r2, r1
    4186:	1c11      	adds	r1, r2, #0
    4188:	1c02      	adds	r2, r0, #0
    418a:	430a      	orrs	r2, r1
    418c:	701a      	strb	r2, [r3, #0]
	temp.bit.ONDEMAND = config->on_demand;
    418e:	687b      	ldr	r3, [r7, #4]
    4190:	789a      	ldrb	r2, [r3, #2]
    4192:	230c      	movs	r3, #12
    4194:	18fb      	adds	r3, r7, r3
    4196:	01d0      	lsls	r0, r2, #7
    4198:	781a      	ldrb	r2, [r3, #0]
    419a:	217f      	movs	r1, #127	; 0x7f
    419c:	400a      	ands	r2, r1
    419e:	1c11      	adds	r1, r2, #0
    41a0:	1c02      	adds	r2, r0, #0
    41a2:	430a      	orrs	r2, r1
    41a4:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
    41a6:	687b      	ldr	r3, [r7, #4]
    41a8:	785a      	ldrb	r2, [r3, #1]
    41aa:	230c      	movs	r3, #12
    41ac:	18fb      	adds	r3, r7, r3
    41ae:	2101      	movs	r1, #1
    41b0:	400a      	ands	r2, r1
    41b2:	0190      	lsls	r0, r2, #6
    41b4:	781a      	ldrb	r2, [r3, #0]
    41b6:	2140      	movs	r1, #64	; 0x40
    41b8:	438a      	bics	r2, r1
    41ba:	1c11      	adds	r1, r2, #0
    41bc:	1c02      	adds	r2, r0, #0
    41be:	430a      	orrs	r2, r1
    41c0:	701a      	strb	r2, [r3, #0]

	SYSCTRL->OSC8M = temp;
    41c2:	4b03      	ldr	r3, [pc, #12]	; (41d0 <system_clock_source_osc8m_set_config+0x74>)
    41c4:	68fa      	ldr	r2, [r7, #12]
    41c6:	621a      	str	r2, [r3, #32]
}
    41c8:	46c0      	nop			; (mov r8, r8)
    41ca:	46bd      	mov	sp, r7
    41cc:	b004      	add	sp, #16
    41ce:	bd80      	pop	{r7, pc}
    41d0:	40000800 	.word	0x40000800

000041d4 <system_clock_source_osc32k_set_config>:
 *
 * \param[in] config  OSC32K configuration structure containing the new config
 */
void system_clock_source_osc32k_set_config(
		struct system_clock_source_osc32k_config *const config)
{
    41d4:	b580      	push	{r7, lr}
    41d6:	b084      	sub	sp, #16
    41d8:	af00      	add	r7, sp, #0
    41da:	6078      	str	r0, [r7, #4]
	SYSCTRL_OSC32K_Type temp = SYSCTRL->OSC32K;
    41dc:	4b2f      	ldr	r3, [pc, #188]	; (429c <system_clock_source_osc32k_set_config+0xc8>)
    41de:	699b      	ldr	r3, [r3, #24]
    41e0:	60fb      	str	r3, [r7, #12]

	/* Update settings via a temporary struct to reduce register access */
	temp.bit.EN1K     = config->enable_1khz_output;
    41e2:	687b      	ldr	r3, [r7, #4]
    41e4:	785a      	ldrb	r2, [r3, #1]
    41e6:	230c      	movs	r3, #12
    41e8:	18fb      	adds	r3, r7, r3
    41ea:	2101      	movs	r1, #1
    41ec:	400a      	ands	r2, r1
    41ee:	00d0      	lsls	r0, r2, #3
    41f0:	781a      	ldrb	r2, [r3, #0]
    41f2:	2108      	movs	r1, #8
    41f4:	438a      	bics	r2, r1
    41f6:	1c11      	adds	r1, r2, #0
    41f8:	1c02      	adds	r2, r0, #0
    41fa:	430a      	orrs	r2, r1
    41fc:	701a      	strb	r2, [r3, #0]
	temp.bit.EN32K    = config->enable_32khz_output;
    41fe:	687b      	ldr	r3, [r7, #4]
    4200:	789a      	ldrb	r2, [r3, #2]
    4202:	230c      	movs	r3, #12
    4204:	18fb      	adds	r3, r7, r3
    4206:	2101      	movs	r1, #1
    4208:	400a      	ands	r2, r1
    420a:	0090      	lsls	r0, r2, #2
    420c:	781a      	ldrb	r2, [r3, #0]
    420e:	2104      	movs	r1, #4
    4210:	438a      	bics	r2, r1
    4212:	1c11      	adds	r1, r2, #0
    4214:	1c02      	adds	r2, r0, #0
    4216:	430a      	orrs	r2, r1
    4218:	701a      	strb	r2, [r3, #0]
	temp.bit.STARTUP  = config->startup_time;
    421a:	687b      	ldr	r3, [r7, #4]
    421c:	781b      	ldrb	r3, [r3, #0]
    421e:	1c1a      	adds	r2, r3, #0
    4220:	2307      	movs	r3, #7
    4222:	4013      	ands	r3, r2
    4224:	b2da      	uxtb	r2, r3
    4226:	230d      	movs	r3, #13
    4228:	18fb      	adds	r3, r7, r3
    422a:	2107      	movs	r1, #7
    422c:	400a      	ands	r2, r1
    422e:	0010      	movs	r0, r2
    4230:	781a      	ldrb	r2, [r3, #0]
    4232:	2107      	movs	r1, #7
    4234:	438a      	bics	r2, r1
    4236:	1c11      	adds	r1, r2, #0
    4238:	1c02      	adds	r2, r0, #0
    423a:	430a      	orrs	r2, r1
    423c:	701a      	strb	r2, [r3, #0]
	temp.bit.ONDEMAND = config->on_demand;
    423e:	687b      	ldr	r3, [r7, #4]
    4240:	791a      	ldrb	r2, [r3, #4]
    4242:	230c      	movs	r3, #12
    4244:	18fb      	adds	r3, r7, r3
    4246:	01d0      	lsls	r0, r2, #7
    4248:	781a      	ldrb	r2, [r3, #0]
    424a:	217f      	movs	r1, #127	; 0x7f
    424c:	400a      	ands	r2, r1
    424e:	1c11      	adds	r1, r2, #0
    4250:	1c02      	adds	r2, r0, #0
    4252:	430a      	orrs	r2, r1
    4254:	701a      	strb	r2, [r3, #0]
	temp.bit.RUNSTDBY = config->run_in_standby;
    4256:	687b      	ldr	r3, [r7, #4]
    4258:	78da      	ldrb	r2, [r3, #3]
    425a:	230c      	movs	r3, #12
    425c:	18fb      	adds	r3, r7, r3
    425e:	2101      	movs	r1, #1
    4260:	400a      	ands	r2, r1
    4262:	0190      	lsls	r0, r2, #6
    4264:	781a      	ldrb	r2, [r3, #0]
    4266:	2140      	movs	r1, #64	; 0x40
    4268:	438a      	bics	r2, r1
    426a:	1c11      	adds	r1, r2, #0
    426c:	1c02      	adds	r2, r0, #0
    426e:	430a      	orrs	r2, r1
    4270:	701a      	strb	r2, [r3, #0]
	temp.bit.WRTLOCK  = config->write_once;
    4272:	687b      	ldr	r3, [r7, #4]
    4274:	795a      	ldrb	r2, [r3, #5]
    4276:	230d      	movs	r3, #13
    4278:	18fb      	adds	r3, r7, r3
    427a:	2101      	movs	r1, #1
    427c:	400a      	ands	r2, r1
    427e:	0110      	lsls	r0, r2, #4
    4280:	781a      	ldrb	r2, [r3, #0]
    4282:	2110      	movs	r1, #16
    4284:	438a      	bics	r2, r1
    4286:	1c11      	adds	r1, r2, #0
    4288:	1c02      	adds	r2, r0, #0
    428a:	430a      	orrs	r2, r1
    428c:	701a      	strb	r2, [r3, #0]

	SYSCTRL->OSC32K  = temp;
    428e:	4b03      	ldr	r3, [pc, #12]	; (429c <system_clock_source_osc32k_set_config+0xc8>)
    4290:	68fa      	ldr	r2, [r7, #12]
    4292:	619a      	str	r2, [r3, #24]
}
    4294:	46c0      	nop			; (mov r8, r8)
    4296:	46bd      	mov	sp, r7
    4298:	b004      	add	sp, #16
    429a:	bd80      	pop	{r7, pc}
    429c:	40000800 	.word	0x40000800

000042a0 <system_clock_source_dfll_set_config>:
 *
 * \param[in] config  DFLL configuration structure containing the new config
 */
void system_clock_source_dfll_set_config(
		struct system_clock_source_dfll_config *const config)
{
    42a0:	b580      	push	{r7, lr}
    42a2:	b084      	sub	sp, #16
    42a4:	af00      	add	r7, sp, #0
    42a6:	6078      	str	r0, [r7, #4]

	/* Get MCU revision */
	uint32_t rev = system_get_device_id();
    42a8:	4b3a      	ldr	r3, [pc, #232]	; (4394 <system_clock_source_dfll_set_config+0xf4>)
    42aa:	4798      	blx	r3
    42ac:	0003      	movs	r3, r0
    42ae:	60fb      	str	r3, [r7, #12]

	rev &= DSU_DID_REVISION_Msk;
    42b0:	68fa      	ldr	r2, [r7, #12]
    42b2:	23f0      	movs	r3, #240	; 0xf0
    42b4:	011b      	lsls	r3, r3, #4
    42b6:	4013      	ands	r3, r2
    42b8:	60fb      	str	r3, [r7, #12]
	rev = rev >> DSU_DID_REVISION_Pos;
    42ba:	68fb      	ldr	r3, [r7, #12]
    42bc:	0a1b      	lsrs	r3, r3, #8
    42be:	60fb      	str	r3, [r7, #12]

	if (rev < _SYSTEM_MCU_REVISION_D) {
    42c0:	68fb      	ldr	r3, [r7, #12]
    42c2:	2b02      	cmp	r3, #2
    42c4:	d80f      	bhi.n	42e6 <system_clock_source_dfll_set_config+0x46>
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
    42c6:	687b      	ldr	r3, [r7, #4]
    42c8:	7a1b      	ldrb	r3, [r3, #8]
    42ca:	021b      	lsls	r3, r3, #8
    42cc:	001a      	movs	r2, r3
    42ce:	23f8      	movs	r3, #248	; 0xf8
    42d0:	015b      	lsls	r3, r3, #5
    42d2:	401a      	ands	r2, r3
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
    42d4:	687b      	ldr	r3, [r7, #4]
    42d6:	895b      	ldrh	r3, [r3, #10]
    42d8:	0019      	movs	r1, r3
    42da:	23ff      	movs	r3, #255	; 0xff
    42dc:	400b      	ands	r3, r1
	rev &= DSU_DID_REVISION_Msk;
	rev = rev >> DSU_DID_REVISION_Pos;

	if (rev < _SYSTEM_MCU_REVISION_D) {
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
    42de:	431a      	orrs	r2, r3

	rev &= DSU_DID_REVISION_Msk;
	rev = rev >> DSU_DID_REVISION_Pos;

	if (rev < _SYSTEM_MCU_REVISION_D) {
		_system_clock_inst.dfll.val =
    42e0:	4b2d      	ldr	r3, [pc, #180]	; (4398 <system_clock_source_dfll_set_config+0xf8>)
    42e2:	605a      	str	r2, [r3, #4]
    42e4:	e00b      	b.n	42fe <system_clock_source_dfll_set_config+0x5e>
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
	} else {
		_system_clock_inst.dfll.val =
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
    42e6:	687b      	ldr	r3, [r7, #4]
    42e8:	7a1b      	ldrb	r3, [r3, #8]
    42ea:	029b      	lsls	r3, r3, #10
    42ec:	041b      	lsls	r3, r3, #16
    42ee:	0c1a      	lsrs	r2, r3, #16
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
    42f0:	687b      	ldr	r3, [r7, #4]
    42f2:	895b      	ldrh	r3, [r3, #10]
    42f4:	059b      	lsls	r3, r3, #22
    42f6:	0d9b      	lsrs	r3, r3, #22
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
	} else {
		_system_clock_inst.dfll.val =
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
    42f8:	431a      	orrs	r2, r3
	if (rev < _SYSTEM_MCU_REVISION_D) {
		_system_clock_inst.dfll.val =
				_SYSTEM_OLD_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_OLD_DFLLVAL_FINE(config->fine_value);
	} else {
		_system_clock_inst.dfll.val =
    42fa:	4b27      	ldr	r3, [pc, #156]	; (4398 <system_clock_source_dfll_set_config+0xf8>)
    42fc:	605a      	str	r2, [r3, #4]
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
	}

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    42fe:	687b      	ldr	r3, [r7, #4]
    4300:	799a      	ldrb	r2, [r3, #6]
			(uint32_t)config->stable_tracking |
    4302:	687b      	ldr	r3, [r7, #4]
    4304:	79db      	ldrb	r3, [r3, #7]
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
	}

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
    4306:	4313      	orrs	r3, r2
    4308:	b2db      	uxtb	r3, r3
    430a:	001a      	movs	r2, r3
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    430c:	687b      	ldr	r3, [r7, #4]
    430e:	885b      	ldrh	r3, [r3, #2]
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
	}

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
    4310:	4313      	orrs	r3, r2
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    4312:	687a      	ldr	r2, [r7, #4]
    4314:	8892      	ldrh	r2, [r2, #4]
	}

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
    4316:	431a      	orrs	r2, r3
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);
    4318:	687b      	ldr	r3, [r7, #4]
    431a:	785b      	ldrb	r3, [r3, #1]
    431c:	01db      	lsls	r3, r3, #7

	_system_clock_inst.dfll.control =
			(uint32_t)config->wakeup_lock     |
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
    431e:	431a      	orrs	r2, r3
		_system_clock_inst.dfll.val =
				_SYSTEM_NEW_DFLLVAL_COARSE(config->coarse_value) |
				_SYSTEM_NEW_DFLLVAL_FINE(config->fine_value);
	}

	_system_clock_inst.dfll.control =
    4320:	4b1d      	ldr	r3, [pc, #116]	; (4398 <system_clock_source_dfll_set_config+0xf8>)
    4322:	601a      	str	r2, [r3, #0]
			(uint32_t)config->stable_tracking |
			(uint32_t)config->quick_lock      |
			(uint32_t)config->chill_cycle     |
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
    4324:	687b      	ldr	r3, [r7, #4]
    4326:	781b      	ldrb	r3, [r3, #0]
    4328:	2b04      	cmp	r3, #4
    432a:	d12e      	bne.n	438a <system_clock_source_dfll_set_config+0xea>

		if(rev < _SYSTEM_MCU_REVISION_D) {
    432c:	68fb      	ldr	r3, [r7, #12]
    432e:	2b02      	cmp	r3, #2
    4330:	d814      	bhi.n	435c <system_clock_source_dfll_set_config+0xbc>
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
    4332:	687b      	ldr	r3, [r7, #4]
    4334:	7b1b      	ldrb	r3, [r3, #12]
    4336:	061b      	lsls	r3, r3, #24
    4338:	001a      	movs	r2, r3
    433a:	23f8      	movs	r3, #248	; 0xf8
    433c:	055b      	lsls	r3, r3, #21
    433e:	401a      	ands	r2, r3
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
    4340:	687b      	ldr	r3, [r7, #4]
    4342:	89db      	ldrh	r3, [r3, #14]
    4344:	041b      	lsls	r3, r3, #16
    4346:	0019      	movs	r1, r3
    4348:	23ff      	movs	r3, #255	; 0xff
    434a:	041b      	lsls	r3, r3, #16
    434c:	400b      	ands	r3, r1

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		if(rev < _SYSTEM_MCU_REVISION_D) {
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
    434e:	4313      	orrs	r3, r2
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    4350:	687a      	ldr	r2, [r7, #4]
    4352:	8a12      	ldrh	r2, [r2, #16]
	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		if(rev < _SYSTEM_MCU_REVISION_D) {
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
    4354:	431a      	orrs	r2, r3
			((uint32_t)config->on_demand << SYSCTRL_DFLLCTRL_ONDEMAND_Pos);

	if (config->loop_mode == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {

		if(rev < _SYSTEM_MCU_REVISION_D) {
			_system_clock_inst.dfll.mul =
    4356:	4b10      	ldr	r3, [pc, #64]	; (4398 <system_clock_source_dfll_set_config+0xf8>)
    4358:	609a      	str	r2, [r3, #8]
    435a:	e00f      	b.n	437c <system_clock_source_dfll_set_config+0xdc>
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		} else {
			_system_clock_inst.dfll.mul =
					_SYSTEM_NEW_DFLLMUL_CSTEP(config->coarse_max_step) |
    435c:	687b      	ldr	r3, [r7, #4]
    435e:	7b1b      	ldrb	r3, [r3, #12]
    4360:	069b      	lsls	r3, r3, #26
    4362:	001a      	movs	r2, r3
					_SYSTEM_NEW_DFLLMUL_FSTEP(config->fine_max_step)   |
    4364:	687b      	ldr	r3, [r7, #4]
    4366:	89db      	ldrh	r3, [r3, #14]
    4368:	041b      	lsls	r3, r3, #16
    436a:	0019      	movs	r1, r3
    436c:	4b0b      	ldr	r3, [pc, #44]	; (439c <system_clock_source_dfll_set_config+0xfc>)
    436e:	400b      	ands	r3, r1
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		} else {
			_system_clock_inst.dfll.mul =
					_SYSTEM_NEW_DFLLMUL_CSTEP(config->coarse_max_step) |
    4370:	4313      	orrs	r3, r2
					_SYSTEM_NEW_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
    4372:	687a      	ldr	r2, [r7, #4]
    4374:	8a12      	ldrh	r2, [r2, #16]
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		} else {
			_system_clock_inst.dfll.mul =
					_SYSTEM_NEW_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_NEW_DFLLMUL_FSTEP(config->fine_max_step)   |
    4376:	431a      	orrs	r2, r3
			_system_clock_inst.dfll.mul =
					_SYSTEM_OLD_DFLLMUL_CSTEP(config->coarse_max_step) |
					_SYSTEM_OLD_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		} else {
			_system_clock_inst.dfll.mul =
    4378:	4b07      	ldr	r3, [pc, #28]	; (4398 <system_clock_source_dfll_set_config+0xf8>)
    437a:	609a      	str	r2, [r3, #8]
					_SYSTEM_NEW_DFLLMUL_FSTEP(config->fine_max_step)   |
					SYSCTRL_DFLLMUL_MUL(config->multiply_factor);
		}

		/* Enable the closed loop mode */
		_system_clock_inst.dfll.control |= config->loop_mode;
    437c:	4b06      	ldr	r3, [pc, #24]	; (4398 <system_clock_source_dfll_set_config+0xf8>)
    437e:	681b      	ldr	r3, [r3, #0]
    4380:	687a      	ldr	r2, [r7, #4]
    4382:	7812      	ldrb	r2, [r2, #0]
    4384:	431a      	orrs	r2, r3
    4386:	4b04      	ldr	r3, [pc, #16]	; (4398 <system_clock_source_dfll_set_config+0xf8>)
    4388:	601a      	str	r2, [r3, #0]
	}
}
    438a:	46c0      	nop			; (mov r8, r8)
    438c:	46bd      	mov	sp, r7
    438e:	b004      	add	sp, #16
    4390:	bd80      	pop	{r7, pc}
    4392:	46c0      	nop			; (mov r8, r8)
    4394:	00004045 	.word	0x00004045
    4398:	20000af0 	.word	0x20000af0
    439c:	03ff0000 	.word	0x03ff0000

000043a0 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
    43a0:	b580      	push	{r7, lr}
    43a2:	b082      	sub	sp, #8
    43a4:	af00      	add	r7, sp, #0
    43a6:	0002      	movs	r2, r0
    43a8:	1dfb      	adds	r3, r7, #7
    43aa:	701a      	strb	r2, [r3, #0]
	switch (clock_source) {
    43ac:	1dfb      	adds	r3, r7, #7
    43ae:	781b      	ldrb	r3, [r3, #0]
    43b0:	2b07      	cmp	r3, #7
    43b2:	d830      	bhi.n	4416 <system_clock_source_enable+0x76>
    43b4:	009a      	lsls	r2, r3, #2
    43b6:	4b1b      	ldr	r3, [pc, #108]	; (4424 <system_clock_source_enable+0x84>)
    43b8:	18d3      	adds	r3, r2, r3
    43ba:	681b      	ldr	r3, [r3, #0]
    43bc:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    43be:	4b1a      	ldr	r3, [pc, #104]	; (4428 <system_clock_source_enable+0x88>)
    43c0:	4a19      	ldr	r2, [pc, #100]	; (4428 <system_clock_source_enable+0x88>)
    43c2:	6a12      	ldr	r2, [r2, #32]
    43c4:	2102      	movs	r1, #2
    43c6:	430a      	orrs	r2, r1
    43c8:	621a      	str	r2, [r3, #32]
		return STATUS_OK;
    43ca:	2300      	movs	r3, #0
    43cc:	e026      	b.n	441c <system_clock_source_enable+0x7c>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    43ce:	4b16      	ldr	r3, [pc, #88]	; (4428 <system_clock_source_enable+0x88>)
    43d0:	4a15      	ldr	r2, [pc, #84]	; (4428 <system_clock_source_enable+0x88>)
    43d2:	6992      	ldr	r2, [r2, #24]
    43d4:	2102      	movs	r1, #2
    43d6:	430a      	orrs	r2, r1
    43d8:	619a      	str	r2, [r3, #24]
		break;
    43da:	e01e      	b.n	441a <system_clock_source_enable+0x7a>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    43dc:	4a12      	ldr	r2, [pc, #72]	; (4428 <system_clock_source_enable+0x88>)
    43de:	4b12      	ldr	r3, [pc, #72]	; (4428 <system_clock_source_enable+0x88>)
    43e0:	8a1b      	ldrh	r3, [r3, #16]
    43e2:	b29b      	uxth	r3, r3
    43e4:	2102      	movs	r1, #2
    43e6:	430b      	orrs	r3, r1
    43e8:	b29b      	uxth	r3, r3
    43ea:	8213      	strh	r3, [r2, #16]
		break;
    43ec:	e015      	b.n	441a <system_clock_source_enable+0x7a>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    43ee:	4a0e      	ldr	r2, [pc, #56]	; (4428 <system_clock_source_enable+0x88>)
    43f0:	4b0d      	ldr	r3, [pc, #52]	; (4428 <system_clock_source_enable+0x88>)
    43f2:	8a9b      	ldrh	r3, [r3, #20]
    43f4:	b29b      	uxth	r3, r3
    43f6:	2102      	movs	r1, #2
    43f8:	430b      	orrs	r3, r1
    43fa:	b29b      	uxth	r3, r3
    43fc:	8293      	strh	r3, [r2, #20]
		break;
    43fe:	e00c      	b.n	441a <system_clock_source_enable+0x7a>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    4400:	4b0a      	ldr	r3, [pc, #40]	; (442c <system_clock_source_enable+0x8c>)
    4402:	681b      	ldr	r3, [r3, #0]
    4404:	2202      	movs	r2, #2
    4406:	431a      	orrs	r2, r3
    4408:	4b08      	ldr	r3, [pc, #32]	; (442c <system_clock_source_enable+0x8c>)
    440a:	601a      	str	r2, [r3, #0]
		_system_clock_source_dfll_set_config_errata_9905();
    440c:	4b08      	ldr	r3, [pc, #32]	; (4430 <system_clock_source_enable+0x90>)
    440e:	4798      	blx	r3
		break;
    4410:	e003      	b.n	441a <system_clock_source_enable+0x7a>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Always enabled */
		return STATUS_OK;
    4412:	2300      	movs	r3, #0
    4414:	e002      	b.n	441c <system_clock_source_enable+0x7c>

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    4416:	2317      	movs	r3, #23
    4418:	e000      	b.n	441c <system_clock_source_enable+0x7c>
	}

	return STATUS_OK;
    441a:	2300      	movs	r3, #0
}
    441c:	0018      	movs	r0, r3
    441e:	46bd      	mov	sp, r7
    4420:	b002      	add	sp, #8
    4422:	bd80      	pop	{r7, pc}
    4424:	0000fce4 	.word	0x0000fce4
    4428:	40000800 	.word	0x40000800
    442c:	20000af0 	.word	0x20000af0
    4430:	00004075 	.word	0x00004075

00004434 <system_clock_source_is_ready>:
 * \retval true   Clock source is enabled and ready
 * \retval false  Clock source is disabled or not yet ready
 */
bool system_clock_source_is_ready(
		const enum system_clock_source clock_source)
{
    4434:	b580      	push	{r7, lr}
    4436:	b084      	sub	sp, #16
    4438:	af00      	add	r7, sp, #0
    443a:	0002      	movs	r2, r0
    443c:	1dfb      	adds	r3, r7, #7
    443e:	701a      	strb	r2, [r3, #0]
	uint32_t mask = 0;
    4440:	2300      	movs	r3, #0
    4442:	60fb      	str	r3, [r7, #12]

	switch (clock_source) {
    4444:	1dfb      	adds	r3, r7, #7
    4446:	781b      	ldrb	r3, [r3, #0]
    4448:	2b07      	cmp	r3, #7
    444a:	d815      	bhi.n	4478 <system_clock_source_is_ready+0x44>
    444c:	009a      	lsls	r2, r3, #2
    444e:	4b12      	ldr	r3, [pc, #72]	; (4498 <system_clock_source_is_ready+0x64>)
    4450:	18d3      	adds	r3, r2, r3
    4452:	681b      	ldr	r3, [r3, #0]
    4454:	469f      	mov	pc, r3
	case SYSTEM_CLOCK_SOURCE_OSC8M:
		mask = SYSCTRL_PCLKSR_OSC8MRDY;
    4456:	2308      	movs	r3, #8
    4458:	60fb      	str	r3, [r7, #12]
		break;
    445a:	e00f      	b.n	447c <system_clock_source_is_ready+0x48>

	case SYSTEM_CLOCK_SOURCE_OSC32K:
		mask = SYSCTRL_PCLKSR_OSC32KRDY;
    445c:	2304      	movs	r3, #4
    445e:	60fb      	str	r3, [r7, #12]
		break;
    4460:	e00c      	b.n	447c <system_clock_source_is_ready+0x48>

	case SYSTEM_CLOCK_SOURCE_XOSC:
		mask = SYSCTRL_PCLKSR_XOSCRDY;
    4462:	2301      	movs	r3, #1
    4464:	60fb      	str	r3, [r7, #12]
		break;
    4466:	e009      	b.n	447c <system_clock_source_is_ready+0x48>

	case SYSTEM_CLOCK_SOURCE_XOSC32K:
		mask = SYSCTRL_PCLKSR_XOSC32KRDY;
    4468:	2302      	movs	r3, #2
    446a:	60fb      	str	r3, [r7, #12]
		break;
    446c:	e006      	b.n	447c <system_clock_source_is_ready+0x48>

	case SYSTEM_CLOCK_SOURCE_DFLL:
		if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
			mask = (SYSCTRL_PCLKSR_DFLLRDY |
    446e:	23d0      	movs	r3, #208	; 0xd0
    4470:	60fb      	str	r3, [r7, #12]
			        SYSCTRL_PCLKSR_DFLLLCKF | SYSCTRL_PCLKSR_DFLLLCKC);
		} else {
			mask = SYSCTRL_PCLKSR_DFLLRDY;
		}
		break;
    4472:	e003      	b.n	447c <system_clock_source_is_ready+0x48>

	case SYSTEM_CLOCK_SOURCE_ULP32K:
		/* Not possible to disable */
		return true;
    4474:	2301      	movs	r3, #1
    4476:	e00a      	b.n	448e <system_clock_source_is_ready+0x5a>

	default:
		return false;
    4478:	2300      	movs	r3, #0
    447a:	e008      	b.n	448e <system_clock_source_is_ready+0x5a>
	}

	return ((SYSCTRL->PCLKSR.reg & mask) == mask);
    447c:	4b07      	ldr	r3, [pc, #28]	; (449c <system_clock_source_is_ready+0x68>)
    447e:	68db      	ldr	r3, [r3, #12]
    4480:	68fa      	ldr	r2, [r7, #12]
    4482:	401a      	ands	r2, r3
    4484:	68fb      	ldr	r3, [r7, #12]
    4486:	1ad3      	subs	r3, r2, r3
    4488:	425a      	negs	r2, r3
    448a:	4153      	adcs	r3, r2
    448c:	b2db      	uxtb	r3, r3
}
    448e:	0018      	movs	r0, r3
    4490:	46bd      	mov	sp, r7
    4492:	b004      	add	sp, #16
    4494:	bd80      	pop	{r7, pc}
    4496:	46c0      	nop			; (mov r8, r8)
    4498:	0000fd04 	.word	0x0000fd04
    449c:	40000800 	.word	0x40000800

000044a0 <_switch_peripheral_gclk>:
 *
 * Switch all peripheral clock to a not enabled general clock
 * to save power.
 */
static void _switch_peripheral_gclk(void)
{
    44a0:	b580      	push	{r7, lr}
    44a2:	b082      	sub	sp, #8
    44a4:	af00      	add	r7, sp, #0
	struct system_gclk_chan_config gclk_conf;

#if CONF_CLOCK_GCLK_1_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_1;
#elif CONF_CLOCK_GCLK_2_ENABLE == false
	gclk_conf.source_generator = GCLK_GENERATOR_2;
    44a6:	003b      	movs	r3, r7
    44a8:	2202      	movs	r2, #2
    44aa:	701a      	strb	r2, [r3, #0]
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    44ac:	2300      	movs	r3, #0
    44ae:	607b      	str	r3, [r7, #4]
    44b0:	e009      	b.n	44c6 <_switch_peripheral_gclk+0x26>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    44b2:	687b      	ldr	r3, [r7, #4]
    44b4:	b2db      	uxtb	r3, r3
    44b6:	003a      	movs	r2, r7
    44b8:	0011      	movs	r1, r2
    44ba:	0018      	movs	r0, r3
    44bc:	4b05      	ldr	r3, [pc, #20]	; (44d4 <_switch_peripheral_gclk+0x34>)
    44be:	4798      	blx	r3
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#else
	gclk_conf.source_generator = GCLK_GENERATOR_7;
#endif

	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    44c0:	687b      	ldr	r3, [r7, #4]
    44c2:	3301      	adds	r3, #1
    44c4:	607b      	str	r3, [r7, #4]
    44c6:	687b      	ldr	r3, [r7, #4]
    44c8:	2b1b      	cmp	r3, #27
    44ca:	d9f2      	bls.n	44b2 <_switch_peripheral_gclk+0x12>
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
	}
}
    44cc:	46c0      	nop			; (mov r8, r8)
    44ce:	46bd      	mov	sp, r7
    44d0:	b002      	add	sp, #8
    44d2:	bd80      	pop	{r7, pc}
    44d4:	00004aa9 	.word	0x00004aa9

000044d8 <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    44d8:	b580      	push	{r7, lr}
    44da:	b0a6      	sub	sp, #152	; 0x98
    44dc:	af00      	add	r7, sp, #0
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    44de:	4b90      	ldr	r3, [pc, #576]	; (4720 <system_clock_init+0x248>)
    44e0:	22c2      	movs	r2, #194	; 0xc2
    44e2:	00d2      	lsls	r2, r2, #3
    44e4:	609a      	str	r2, [r3, #8]
			SYSCTRL_INTFLAG_DFLLRDY;

	system_flash_set_waitstates(CONF_CLOCK_FLASH_WAIT_STATES);
    44e6:	2002      	movs	r0, #2
    44e8:	4b8e      	ldr	r3, [pc, #568]	; (4724 <system_clock_init+0x24c>)
    44ea:	4798      	blx	r3

	/* Switch all peripheral clock to a not enabled general clock to save power. */
	_switch_peripheral_gclk();
    44ec:	4b8e      	ldr	r3, [pc, #568]	; (4728 <system_clock_init+0x250>)
    44ee:	4798      	blx	r3
#endif


	/* OSCK32K */
#if CONF_CLOCK_OSC32K_ENABLE == true
	SYSCTRL->OSC32K.bit.CALIB =
    44f0:	4a8b      	ldr	r2, [pc, #556]	; (4720 <system_clock_init+0x248>)
			(*(uint32_t *)FUSES_OSC32KCAL_ADDR >> FUSES_OSC32KCAL_Pos);
    44f2:	4b8e      	ldr	r3, [pc, #568]	; (472c <system_clock_init+0x254>)
    44f4:	681b      	ldr	r3, [r3, #0]
    44f6:	099b      	lsrs	r3, r3, #6
#endif


	/* OSCK32K */
#if CONF_CLOCK_OSC32K_ENABLE == true
	SYSCTRL->OSC32K.bit.CALIB =
    44f8:	b2db      	uxtb	r3, r3
    44fa:	1c19      	adds	r1, r3, #0
    44fc:	237f      	movs	r3, #127	; 0x7f
    44fe:	400b      	ands	r3, r1
    4500:	b2d9      	uxtb	r1, r3
    4502:	6993      	ldr	r3, [r2, #24]
    4504:	207f      	movs	r0, #127	; 0x7f
    4506:	4001      	ands	r1, r0
    4508:	0409      	lsls	r1, r1, #16
    450a:	4889      	ldr	r0, [pc, #548]	; (4730 <system_clock_init+0x258>)
    450c:	4003      	ands	r3, r0
    450e:	430b      	orrs	r3, r1
    4510:	6193      	str	r3, [r2, #24]
			(*(uint32_t *)FUSES_OSC32KCAL_ADDR >> FUSES_OSC32KCAL_Pos);

	struct system_clock_source_osc32k_config osc32k_conf;
	system_clock_source_osc32k_get_config_defaults(&osc32k_conf);
    4512:	2388      	movs	r3, #136	; 0x88
    4514:	18fb      	adds	r3, r7, r3
    4516:	0018      	movs	r0, r3
    4518:	4b86      	ldr	r3, [pc, #536]	; (4734 <system_clock_init+0x25c>)
    451a:	4798      	blx	r3

	osc32k_conf.startup_time        = CONF_CLOCK_OSC32K_STARTUP_TIME;
    451c:	2388      	movs	r3, #136	; 0x88
    451e:	18fb      	adds	r3, r7, r3
    4520:	2207      	movs	r2, #7
    4522:	701a      	strb	r2, [r3, #0]
	osc32k_conf.enable_1khz_output  = CONF_CLOCK_OSC32K_ENABLE_1KHZ_OUTPUT;
    4524:	2388      	movs	r3, #136	; 0x88
    4526:	18fb      	adds	r3, r7, r3
    4528:	2200      	movs	r2, #0
    452a:	705a      	strb	r2, [r3, #1]
	osc32k_conf.enable_32khz_output = CONF_CLOCK_OSC32K_ENABLE_32KHZ_OUTPUT;
    452c:	2388      	movs	r3, #136	; 0x88
    452e:	18fb      	adds	r3, r7, r3
    4530:	2200      	movs	r2, #0
    4532:	709a      	strb	r2, [r3, #2]
	osc32k_conf.on_demand           = CONF_CLOCK_OSC32K_ON_DEMAND;
    4534:	2388      	movs	r3, #136	; 0x88
    4536:	18fb      	adds	r3, r7, r3
    4538:	2201      	movs	r2, #1
    453a:	711a      	strb	r2, [r3, #4]
	osc32k_conf.run_in_standby      = CONF_CLOCK_OSC32K_RUN_IN_STANDBY;
    453c:	2388      	movs	r3, #136	; 0x88
    453e:	18fb      	adds	r3, r7, r3
    4540:	2200      	movs	r2, #0
    4542:	70da      	strb	r2, [r3, #3]

	system_clock_source_osc32k_set_config(&osc32k_conf);
    4544:	2388      	movs	r3, #136	; 0x88
    4546:	18fb      	adds	r3, r7, r3
    4548:	0018      	movs	r0, r3
    454a:	4b7b      	ldr	r3, [pc, #492]	; (4738 <system_clock_init+0x260>)
    454c:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC32K);
    454e:	2004      	movs	r0, #4
    4550:	4b7a      	ldr	r3, [pc, #488]	; (473c <system_clock_init+0x264>)
    4552:	4798      	blx	r3


	/* DFLL Config (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	struct system_clock_source_dfll_config dfll_conf;
	system_clock_source_dfll_get_config_defaults(&dfll_conf);
    4554:	2374      	movs	r3, #116	; 0x74
    4556:	18fb      	adds	r3, r7, r3
    4558:	0018      	movs	r0, r3
    455a:	4b79      	ldr	r3, [pc, #484]	; (4740 <system_clock_init+0x268>)
    455c:	4798      	blx	r3

	dfll_conf.loop_mode      = CONF_CLOCK_DFLL_LOOP_MODE;
    455e:	2374      	movs	r3, #116	; 0x74
    4560:	18fb      	adds	r3, r7, r3
    4562:	2204      	movs	r2, #4
    4564:	701a      	strb	r2, [r3, #0]
	dfll_conf.on_demand      = false;
    4566:	2374      	movs	r3, #116	; 0x74
    4568:	18fb      	adds	r3, r7, r3
    456a:	2200      	movs	r2, #0
    456c:	705a      	strb	r2, [r3, #1]
	/* Using DFLL48M COARSE CAL value from NVM Software Calibration Area Mapping
     in DFLL.COARSE helps to output a frequency close to 48 MHz.
	   Not applicable for silicon rev C and previous*/

	/* Get MCU revision */
	uint32_t rev = system_get_device_id();
    456e:	4b75      	ldr	r3, [pc, #468]	; (4744 <system_clock_init+0x26c>)
    4570:	4798      	blx	r3
    4572:	0003      	movs	r3, r0
    4574:	2290      	movs	r2, #144	; 0x90
    4576:	18ba      	adds	r2, r7, r2
    4578:	6013      	str	r3, [r2, #0]

	rev &= DSU_DID_REVISION_Msk;
    457a:	2390      	movs	r3, #144	; 0x90
    457c:	18fb      	adds	r3, r7, r3
    457e:	681a      	ldr	r2, [r3, #0]
    4580:	23f0      	movs	r3, #240	; 0xf0
    4582:	011b      	lsls	r3, r3, #4
    4584:	4013      	ands	r3, r2
    4586:	2290      	movs	r2, #144	; 0x90
    4588:	18ba      	adds	r2, r7, r2
    458a:	6013      	str	r3, [r2, #0]
	rev = rev >> DSU_DID_REVISION_Pos;
    458c:	2390      	movs	r3, #144	; 0x90
    458e:	18fb      	adds	r3, r7, r3
    4590:	681b      	ldr	r3, [r3, #0]
    4592:	0a1b      	lsrs	r3, r3, #8
    4594:	2290      	movs	r2, #144	; 0x90
    4596:	18ba      	adds	r2, r7, r2
    4598:	6013      	str	r3, [r2, #0]

	if (rev >= _SYSTEM_MCU_REVISION_D) {
    459a:	2390      	movs	r3, #144	; 0x90
    459c:	18fb      	adds	r3, r7, r3
    459e:	681b      	ldr	r3, [r3, #0]
    45a0:	2b02      	cmp	r3, #2
    45a2:	d915      	bls.n	45d0 <system_clock_init+0xf8>
#define NVM_DFLL_COARSE_POS    58 /* DFLL48M Coarse calibration value bit position.*/
#define NVM_DFLL_COARSE_SIZE   6  /* DFLL48M Coarse calibration value bit size.*/

		uint32_t coarse =( *((uint32_t *)(NVMCTRL_OTP4)
    45a4:	4b61      	ldr	r3, [pc, #388]	; (472c <system_clock_init+0x254>)
    45a6:	681b      	ldr	r3, [r3, #0]
    45a8:	0e9b      	lsrs	r3, r3, #26
    45aa:	2294      	movs	r2, #148	; 0x94
    45ac:	18ba      	adds	r2, r7, r2
    45ae:	6013      	str	r3, [r2, #0]
				+ (NVM_DFLL_COARSE_POS / 32))
			>> (NVM_DFLL_COARSE_POS % 32))
			& ((1 << NVM_DFLL_COARSE_SIZE) - 1);
		/* In some revision chip, the coarse calibration value is not correct. */
		if (coarse == 0x3f) {
    45b0:	2394      	movs	r3, #148	; 0x94
    45b2:	18fb      	adds	r3, r7, r3
    45b4:	681b      	ldr	r3, [r3, #0]
    45b6:	2b3f      	cmp	r3, #63	; 0x3f
    45b8:	d103      	bne.n	45c2 <system_clock_init+0xea>
			coarse = 0x1f;
    45ba:	231f      	movs	r3, #31
    45bc:	2294      	movs	r2, #148	; 0x94
    45be:	18ba      	adds	r2, r7, r2
    45c0:	6013      	str	r3, [r2, #0]
		}
		dfll_conf.coarse_value = coarse;
    45c2:	2394      	movs	r3, #148	; 0x94
    45c4:	18fb      	adds	r3, r7, r3
    45c6:	681b      	ldr	r3, [r3, #0]
    45c8:	b2da      	uxtb	r2, r3
    45ca:	2374      	movs	r3, #116	; 0x74
    45cc:	18fb      	adds	r3, r7, r3
    45ce:	721a      	strb	r2, [r3, #8]
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_OPEN) {
		dfll_conf.fine_value   = CONF_CLOCK_DFLL_FINE_VALUE;
	}

#  if CONF_CLOCK_DFLL_QUICK_LOCK == true
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_ENABLE;
    45d0:	2374      	movs	r3, #116	; 0x74
    45d2:	18fb      	adds	r3, r7, r3
    45d4:	2200      	movs	r2, #0
    45d6:	805a      	strh	r2, [r3, #2]
#  else
	dfll_conf.quick_lock = SYSTEM_CLOCK_DFLL_QUICK_LOCK_DISABLE;
#  endif

#  if CONF_CLOCK_DFLL_TRACK_AFTER_FINE_LOCK == true
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_TRACK_AFTER_LOCK;
    45d8:	2374      	movs	r3, #116	; 0x74
    45da:	18fb      	adds	r3, r7, r3
    45dc:	2200      	movs	r2, #0
    45de:	71da      	strb	r2, [r3, #7]
#  else
	dfll_conf.stable_tracking = SYSTEM_CLOCK_DFLL_STABLE_TRACKING_FIX_AFTER_LOCK;
#  endif

#  if CONF_CLOCK_DFLL_KEEP_LOCK_ON_WAKEUP == true
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_KEEP;
    45e0:	2374      	movs	r3, #116	; 0x74
    45e2:	18fb      	adds	r3, r7, r3
    45e4:	2200      	movs	r2, #0
    45e6:	719a      	strb	r2, [r3, #6]
#  else
	dfll_conf.wakeup_lock = SYSTEM_CLOCK_DFLL_WAKEUP_LOCK_LOSE;
#  endif

#  if CONF_CLOCK_DFLL_ENABLE_CHILL_CYCLE == true
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_ENABLE;
    45e8:	2374      	movs	r3, #116	; 0x74
    45ea:	18fb      	adds	r3, r7, r3
    45ec:	2200      	movs	r2, #0
    45ee:	809a      	strh	r2, [r3, #4]
#  else
	dfll_conf.chill_cycle = SYSTEM_CLOCK_DFLL_CHILL_CYCLE_DISABLE;
#  endif

	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		dfll_conf.multiply_factor = CONF_CLOCK_DFLL_MULTIPLY_FACTOR;
    45f0:	2374      	movs	r3, #116	; 0x74
    45f2:	18fb      	adds	r3, r7, r3
    45f4:	22b7      	movs	r2, #183	; 0xb7
    45f6:	00d2      	lsls	r2, r2, #3
    45f8:	821a      	strh	r2, [r3, #16]
	}

	dfll_conf.coarse_max_step = CONF_CLOCK_DFLL_MAX_COARSE_STEP_SIZE;
    45fa:	2374      	movs	r3, #116	; 0x74
    45fc:	18fb      	adds	r3, r7, r3
    45fe:	2207      	movs	r2, #7
    4600:	731a      	strb	r2, [r3, #12]
	dfll_conf.fine_max_step   = CONF_CLOCK_DFLL_MAX_FINE_STEP_SIZE;
    4602:	2374      	movs	r3, #116	; 0x74
    4604:	18fb      	adds	r3, r7, r3
    4606:	223f      	movs	r2, #63	; 0x3f
    4608:	81da      	strh	r2, [r3, #14]

	system_clock_source_dfll_set_config(&dfll_conf);
    460a:	2374      	movs	r3, #116	; 0x74
    460c:	18fb      	adds	r3, r7, r3
    460e:	0018      	movs	r0, r3
    4610:	4b4d      	ldr	r3, [pc, #308]	; (4748 <system_clock_init+0x270>)
    4612:	4798      	blx	r3
#endif


	/* OSC8M */
	struct system_clock_source_osc8m_config osc8m_conf;
	system_clock_source_osc8m_get_config_defaults(&osc8m_conf);
    4614:	2370      	movs	r3, #112	; 0x70
    4616:	18fb      	adds	r3, r7, r3
    4618:	0018      	movs	r0, r3
    461a:	4b4c      	ldr	r3, [pc, #304]	; (474c <system_clock_init+0x274>)
    461c:	4798      	blx	r3

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    461e:	2370      	movs	r3, #112	; 0x70
    4620:	18fb      	adds	r3, r7, r3
    4622:	2200      	movs	r2, #0
    4624:	701a      	strb	r2, [r3, #0]
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
    4626:	2370      	movs	r3, #112	; 0x70
    4628:	18fb      	adds	r3, r7, r3
    462a:	2201      	movs	r2, #1
    462c:	709a      	strb	r2, [r3, #2]
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;
    462e:	2370      	movs	r3, #112	; 0x70
    4630:	18fb      	adds	r3, r7, r3
    4632:	2200      	movs	r2, #0
    4634:	705a      	strb	r2, [r3, #1]

	system_clock_source_osc8m_set_config(&osc8m_conf);
    4636:	2370      	movs	r3, #112	; 0x70
    4638:	18fb      	adds	r3, r7, r3
    463a:	0018      	movs	r0, r3
    463c:	4b44      	ldr	r3, [pc, #272]	; (4750 <system_clock_init+0x278>)
    463e:	4798      	blx	r3
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    4640:	2006      	movs	r0, #6
    4642:	4b3e      	ldr	r3, [pc, #248]	; (473c <system_clock_init+0x264>)
    4644:	4798      	blx	r3


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    4646:	4b43      	ldr	r3, [pc, #268]	; (4754 <system_clock_init+0x27c>)
    4648:	4798      	blx	r3

	/* Configure all GCLK generators except for the main generator, which
	 * is configured later after all other clock systems are set up */
	MREPEAT(GCLK_GEN_NUM, _CONF_CLOCK_GCLK_CONFIG_NONMAIN, ~);
    464a:	2358      	movs	r3, #88	; 0x58
    464c:	18fb      	adds	r3, r7, r3
    464e:	0018      	movs	r0, r3
    4650:	4b41      	ldr	r3, [pc, #260]	; (4758 <system_clock_init+0x280>)
    4652:	4798      	blx	r3
    4654:	2358      	movs	r3, #88	; 0x58
    4656:	18fb      	adds	r3, r7, r3
    4658:	2206      	movs	r2, #6
    465a:	701a      	strb	r2, [r3, #0]
    465c:	2358      	movs	r3, #88	; 0x58
    465e:	18fb      	adds	r3, r7, r3
    4660:	2280      	movs	r2, #128	; 0x80
    4662:	0052      	lsls	r2, r2, #1
    4664:	605a      	str	r2, [r3, #4]
    4666:	2358      	movs	r3, #88	; 0x58
    4668:	18fb      	adds	r3, r7, r3
    466a:	2200      	movs	r2, #0
    466c:	721a      	strb	r2, [r3, #8]
    466e:	2358      	movs	r3, #88	; 0x58
    4670:	18fb      	adds	r3, r7, r3
    4672:	2200      	movs	r2, #0
    4674:	725a      	strb	r2, [r3, #9]
    4676:	2358      	movs	r3, #88	; 0x58
    4678:	18fb      	adds	r3, r7, r3
    467a:	0019      	movs	r1, r3
    467c:	2001      	movs	r0, #1
    467e:	4b37      	ldr	r3, [pc, #220]	; (475c <system_clock_init+0x284>)
    4680:	4798      	blx	r3
    4682:	2001      	movs	r0, #1
    4684:	4b36      	ldr	r3, [pc, #216]	; (4760 <system_clock_init+0x288>)
    4686:	4798      	blx	r3
#  if CONF_CLOCK_DFLL_ENABLE == true
	/* Enable DFLL reference clock if in closed loop mode */
	if (CONF_CLOCK_DFLL_LOOP_MODE == SYSTEM_CLOCK_DFLL_LOOP_MODE_CLOSED) {
		struct system_gclk_chan_config dfll_gclk_chan_conf;

		system_gclk_chan_get_config_defaults(&dfll_gclk_chan_conf);
    4688:	230c      	movs	r3, #12
    468a:	18fb      	adds	r3, r7, r3
    468c:	0018      	movs	r0, r3
    468e:	4b35      	ldr	r3, [pc, #212]	; (4764 <system_clock_init+0x28c>)
    4690:	4798      	blx	r3
		dfll_gclk_chan_conf.source_generator = CONF_CLOCK_DFLL_SOURCE_GCLK_GENERATOR;
    4692:	230c      	movs	r3, #12
    4694:	18fb      	adds	r3, r7, r3
    4696:	2201      	movs	r2, #1
    4698:	701a      	strb	r2, [r3, #0]
		system_gclk_chan_set_config(SYSCTRL_GCLK_ID_DFLL48, &dfll_gclk_chan_conf);
    469a:	230c      	movs	r3, #12
    469c:	18fb      	adds	r3, r7, r3
    469e:	0019      	movs	r1, r3
    46a0:	2000      	movs	r0, #0
    46a2:	4b31      	ldr	r3, [pc, #196]	; (4768 <system_clock_init+0x290>)
    46a4:	4798      	blx	r3
		system_gclk_chan_enable(SYSCTRL_GCLK_ID_DFLL48);
    46a6:	2000      	movs	r0, #0
    46a8:	4b30      	ldr	r3, [pc, #192]	; (476c <system_clock_init+0x294>)
    46aa:	4798      	blx	r3
#endif


	/* DFLL Enable (Open and Closed Loop) */
#if CONF_CLOCK_DFLL_ENABLE == true
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_DFLL);
    46ac:	2007      	movs	r0, #7
    46ae:	4b23      	ldr	r3, [pc, #140]	; (473c <system_clock_init+0x264>)
    46b0:	4798      	blx	r3
	while(!system_clock_source_is_ready(SYSTEM_CLOCK_SOURCE_DFLL));
    46b2:	46c0      	nop			; (mov r8, r8)
    46b4:	2007      	movs	r0, #7
    46b6:	4b2e      	ldr	r3, [pc, #184]	; (4770 <system_clock_init+0x298>)
    46b8:	4798      	blx	r3
    46ba:	0003      	movs	r3, r0
    46bc:	001a      	movs	r2, r3
    46be:	2301      	movs	r3, #1
    46c0:	4053      	eors	r3, r2
    46c2:	b2db      	uxtb	r3, r3
    46c4:	2b00      	cmp	r3, #0
    46c6:	d1f5      	bne.n	46b4 <system_clock_init+0x1dc>
		SYSCTRL->DFLLCTRL.bit.ONDEMAND = 1;
	}
#endif

	/* CPU and BUS clocks */
	system_cpu_clock_set_divider(CONF_CLOCK_CPU_DIVIDER);
    46c8:	2000      	movs	r0, #0
    46ca:	4b2a      	ldr	r3, [pc, #168]	; (4774 <system_clock_init+0x29c>)
    46cc:	4798      	blx	r3

	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBA, CONF_CLOCK_APBA_DIVIDER);
    46ce:	2100      	movs	r1, #0
    46d0:	2000      	movs	r0, #0
    46d2:	4b29      	ldr	r3, [pc, #164]	; (4778 <system_clock_init+0x2a0>)
    46d4:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBB, CONF_CLOCK_APBB_DIVIDER);
    46d6:	2100      	movs	r1, #0
    46d8:	2001      	movs	r0, #1
    46da:	4b27      	ldr	r3, [pc, #156]	; (4778 <system_clock_init+0x2a0>)
    46dc:	4798      	blx	r3
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);
    46de:	2100      	movs	r1, #0
    46e0:	2002      	movs	r0, #2
    46e2:	4b25      	ldr	r3, [pc, #148]	; (4778 <system_clock_init+0x2a0>)
    46e4:	4798      	blx	r3

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    46e6:	003b      	movs	r3, r7
    46e8:	0018      	movs	r0, r3
    46ea:	4b1b      	ldr	r3, [pc, #108]	; (4758 <system_clock_init+0x280>)
    46ec:	4798      	blx	r3
    46ee:	003b      	movs	r3, r7
    46f0:	2207      	movs	r2, #7
    46f2:	701a      	strb	r2, [r3, #0]
    46f4:	003b      	movs	r3, r7
    46f6:	2201      	movs	r2, #1
    46f8:	605a      	str	r2, [r3, #4]
    46fa:	003b      	movs	r3, r7
    46fc:	2200      	movs	r2, #0
    46fe:	721a      	strb	r2, [r3, #8]
    4700:	003b      	movs	r3, r7
    4702:	2200      	movs	r2, #0
    4704:	725a      	strb	r2, [r3, #9]
    4706:	003b      	movs	r3, r7
    4708:	0019      	movs	r1, r3
    470a:	2000      	movs	r0, #0
    470c:	4b13      	ldr	r3, [pc, #76]	; (475c <system_clock_init+0x284>)
    470e:	4798      	blx	r3
    4710:	2000      	movs	r0, #0
    4712:	4b13      	ldr	r3, [pc, #76]	; (4760 <system_clock_init+0x288>)
    4714:	4798      	blx	r3
#endif
}
    4716:	46c0      	nop			; (mov r8, r8)
    4718:	46bd      	mov	sp, r7
    471a:	b026      	add	sp, #152	; 0x98
    471c:	bd80      	pop	{r7, pc}
    471e:	46c0      	nop			; (mov r8, r8)
    4720:	40000800 	.word	0x40000800
    4724:	00004011 	.word	0x00004011
    4728:	000044a1 	.word	0x000044a1
    472c:	00806024 	.word	0x00806024
    4730:	ff80ffff 	.word	0xff80ffff
    4734:	00003ef1 	.word	0x00003ef1
    4738:	000041d5 	.word	0x000041d5
    473c:	000043a1 	.word	0x000043a1
    4740:	00003f49 	.word	0x00003f49
    4744:	00004045 	.word	0x00004045
    4748:	000042a1 	.word	0x000042a1
    474c:	00003f25 	.word	0x00003f25
    4750:	0000415d 	.word	0x0000415d
    4754:	00004821 	.word	0x00004821
    4758:	00003ea9 	.word	0x00003ea9
    475c:	00004851 	.word	0x00004851
    4760:	00004975 	.word	0x00004975
    4764:	00003ed9 	.word	0x00003ed9
    4768:	00004aa9 	.word	0x00004aa9
    476c:	00004aed 	.word	0x00004aed
    4770:	00004435 	.word	0x00004435
    4774:	00003f9d 	.word	0x00003f9d
    4778:	00003fbd 	.word	0x00003fbd

0000477c <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    477c:	b580      	push	{r7, lr}
    477e:	b082      	sub	sp, #8
    4780:	af00      	add	r7, sp, #0
    4782:	0002      	movs	r2, r0
    4784:	6039      	str	r1, [r7, #0]
    4786:	1dfb      	adds	r3, r7, #7
    4788:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    478a:	1dfb      	adds	r3, r7, #7
    478c:	781b      	ldrb	r3, [r3, #0]
    478e:	2b01      	cmp	r3, #1
    4790:	d00a      	beq.n	47a8 <system_apb_clock_set_mask+0x2c>
    4792:	2b02      	cmp	r3, #2
    4794:	d00f      	beq.n	47b6 <system_apb_clock_set_mask+0x3a>
    4796:	2b00      	cmp	r3, #0
    4798:	d114      	bne.n	47c4 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    479a:	4b0e      	ldr	r3, [pc, #56]	; (47d4 <system_apb_clock_set_mask+0x58>)
    479c:	4a0d      	ldr	r2, [pc, #52]	; (47d4 <system_apb_clock_set_mask+0x58>)
    479e:	6991      	ldr	r1, [r2, #24]
    47a0:	683a      	ldr	r2, [r7, #0]
    47a2:	430a      	orrs	r2, r1
    47a4:	619a      	str	r2, [r3, #24]
			break;
    47a6:	e00f      	b.n	47c8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    47a8:	4b0a      	ldr	r3, [pc, #40]	; (47d4 <system_apb_clock_set_mask+0x58>)
    47aa:	4a0a      	ldr	r2, [pc, #40]	; (47d4 <system_apb_clock_set_mask+0x58>)
    47ac:	69d1      	ldr	r1, [r2, #28]
    47ae:	683a      	ldr	r2, [r7, #0]
    47b0:	430a      	orrs	r2, r1
    47b2:	61da      	str	r2, [r3, #28]
			break;
    47b4:	e008      	b.n	47c8 <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    47b6:	4b07      	ldr	r3, [pc, #28]	; (47d4 <system_apb_clock_set_mask+0x58>)
    47b8:	4a06      	ldr	r2, [pc, #24]	; (47d4 <system_apb_clock_set_mask+0x58>)
    47ba:	6a11      	ldr	r1, [r2, #32]
    47bc:	683a      	ldr	r2, [r7, #0]
    47be:	430a      	orrs	r2, r1
    47c0:	621a      	str	r2, [r3, #32]
			break;
    47c2:	e001      	b.n	47c8 <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    47c4:	2317      	movs	r3, #23
    47c6:	e000      	b.n	47ca <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    47c8:	2300      	movs	r3, #0
}
    47ca:	0018      	movs	r0, r3
    47cc:	46bd      	mov	sp, r7
    47ce:	b002      	add	sp, #8
    47d0:	bd80      	pop	{r7, pc}
    47d2:	46c0      	nop			; (mov r8, r8)
    47d4:	40000400 	.word	0x40000400

000047d8 <system_interrupt_enter_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
    47d8:	b580      	push	{r7, lr}
    47da:	af00      	add	r7, sp, #0
	cpu_irq_enter_critical();
    47dc:	4b02      	ldr	r3, [pc, #8]	; (47e8 <system_interrupt_enter_critical_section+0x10>)
    47de:	4798      	blx	r3
}
    47e0:	46c0      	nop			; (mov r8, r8)
    47e2:	46bd      	mov	sp, r7
    47e4:	bd80      	pop	{r7, pc}
    47e6:	46c0      	nop			; (mov r8, r8)
    47e8:	0000195d 	.word	0x0000195d

000047ec <system_interrupt_leave_critical_section>:
 * count of the critical section nesting will be kept, so that global interrupts
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
    47ec:	b580      	push	{r7, lr}
    47ee:	af00      	add	r7, sp, #0
	cpu_irq_leave_critical();
    47f0:	4b02      	ldr	r3, [pc, #8]	; (47fc <system_interrupt_leave_critical_section+0x10>)
    47f2:	4798      	blx	r3
}
    47f4:	46c0      	nop			; (mov r8, r8)
    47f6:	46bd      	mov	sp, r7
    47f8:	bd80      	pop	{r7, pc}
    47fa:	46c0      	nop			; (mov r8, r8)
    47fc:	000019b1 	.word	0x000019b1

00004800 <system_gclk_is_syncing>:
 *
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
    4800:	b580      	push	{r7, lr}
    4802:	af00      	add	r7, sp, #0
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    4804:	4b05      	ldr	r3, [pc, #20]	; (481c <system_gclk_is_syncing+0x1c>)
    4806:	785b      	ldrb	r3, [r3, #1]
    4808:	b2db      	uxtb	r3, r3
    480a:	b25b      	sxtb	r3, r3
    480c:	2b00      	cmp	r3, #0
    480e:	da01      	bge.n	4814 <system_gclk_is_syncing+0x14>
		return true;
    4810:	2301      	movs	r3, #1
    4812:	e000      	b.n	4816 <system_gclk_is_syncing+0x16>
	}

	return false;
    4814:	2300      	movs	r3, #0
}
    4816:	0018      	movs	r0, r3
    4818:	46bd      	mov	sp, r7
    481a:	bd80      	pop	{r7, pc}
    481c:	40000c00 	.word	0x40000c00

00004820 <system_gclk_init>:
 *
 * Initializes the Generic Clock module, disabling and resetting all active
 * Generic Clock Generators and Channels to their power-on default values.
 */
void system_gclk_init(void)
{
    4820:	b580      	push	{r7, lr}
    4822:	af00      	add	r7, sp, #0
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);
    4824:	2108      	movs	r1, #8
    4826:	2000      	movs	r0, #0
    4828:	4b07      	ldr	r3, [pc, #28]	; (4848 <system_gclk_init+0x28>)
    482a:	4798      	blx	r3

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    482c:	4b07      	ldr	r3, [pc, #28]	; (484c <system_gclk_init+0x2c>)
    482e:	2201      	movs	r2, #1
    4830:	701a      	strb	r2, [r3, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    4832:	46c0      	nop			; (mov r8, r8)
    4834:	4b05      	ldr	r3, [pc, #20]	; (484c <system_gclk_init+0x2c>)
    4836:	781b      	ldrb	r3, [r3, #0]
    4838:	b2db      	uxtb	r3, r3
    483a:	001a      	movs	r2, r3
    483c:	2301      	movs	r3, #1
    483e:	4013      	ands	r3, r2
    4840:	d1f8      	bne.n	4834 <system_gclk_init+0x14>
		/* Wait for reset to complete */
	}
}
    4842:	46c0      	nop			; (mov r8, r8)
    4844:	46bd      	mov	sp, r7
    4846:	bd80      	pop	{r7, pc}
    4848:	0000477d 	.word	0x0000477d
    484c:	40000c00 	.word	0x40000c00

00004850 <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    4850:	b580      	push	{r7, lr}
    4852:	b086      	sub	sp, #24
    4854:	af00      	add	r7, sp, #0
    4856:	0002      	movs	r2, r0
    4858:	6039      	str	r1, [r7, #0]
    485a:	1dfb      	adds	r3, r7, #7
    485c:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    485e:	1dfb      	adds	r3, r7, #7
    4860:	781b      	ldrb	r3, [r3, #0]
    4862:	617b      	str	r3, [r7, #20]
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);
    4864:	1dfb      	adds	r3, r7, #7
    4866:	781b      	ldrb	r3, [r3, #0]
    4868:	613b      	str	r3, [r7, #16]

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    486a:	683b      	ldr	r3, [r7, #0]
    486c:	781b      	ldrb	r3, [r3, #0]
    486e:	021b      	lsls	r3, r3, #8
    4870:	001a      	movs	r2, r3
    4872:	697b      	ldr	r3, [r7, #20]
    4874:	4313      	orrs	r3, r2
    4876:	617b      	str	r3, [r7, #20]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    4878:	683b      	ldr	r3, [r7, #0]
    487a:	785b      	ldrb	r3, [r3, #1]
    487c:	2b00      	cmp	r3, #0
    487e:	d004      	beq.n	488a <system_gclk_gen_set_config+0x3a>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    4880:	697b      	ldr	r3, [r7, #20]
    4882:	2280      	movs	r2, #128	; 0x80
    4884:	02d2      	lsls	r2, r2, #11
    4886:	4313      	orrs	r3, r2
    4888:	617b      	str	r3, [r7, #20]
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    488a:	683b      	ldr	r3, [r7, #0]
    488c:	7a5b      	ldrb	r3, [r3, #9]
    488e:	2b00      	cmp	r3, #0
    4890:	d004      	beq.n	489c <system_gclk_gen_set_config+0x4c>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    4892:	697b      	ldr	r3, [r7, #20]
    4894:	2280      	movs	r2, #128	; 0x80
    4896:	0312      	lsls	r2, r2, #12
    4898:	4313      	orrs	r3, r2
    489a:	617b      	str	r3, [r7, #20]
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    489c:	683b      	ldr	r3, [r7, #0]
    489e:	685b      	ldr	r3, [r3, #4]
    48a0:	2b01      	cmp	r3, #1
    48a2:	d92c      	bls.n	48fe <system_gclk_gen_set_config+0xae>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    48a4:	683b      	ldr	r3, [r7, #0]
    48a6:	685a      	ldr	r2, [r3, #4]
    48a8:	683b      	ldr	r3, [r7, #0]
    48aa:	685b      	ldr	r3, [r3, #4]
    48ac:	3b01      	subs	r3, #1
    48ae:	4013      	ands	r3, r2
    48b0:	d11a      	bne.n	48e8 <system_gclk_gen_set_config+0x98>
			/* Determine the index of the highest bit set to get the
			 * division factor that must be loaded into the division
			 * register */

			uint32_t div2_count = 0;
    48b2:	2300      	movs	r3, #0
    48b4:	60fb      	str	r3, [r7, #12]

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    48b6:	2302      	movs	r3, #2
    48b8:	60bb      	str	r3, [r7, #8]
    48ba:	e005      	b.n	48c8 <system_gclk_gen_set_config+0x78>
						mask <<= 1) {
				div2_count++;
    48bc:	68fb      	ldr	r3, [r7, #12]
    48be:	3301      	adds	r3, #1
    48c0:	60fb      	str	r3, [r7, #12]

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
						mask <<= 1) {
    48c2:	68bb      	ldr	r3, [r7, #8]
    48c4:	005b      	lsls	r3, r3, #1
    48c6:	60bb      	str	r3, [r7, #8]
			 * register */

			uint32_t div2_count = 0;

			uint32_t mask;
			for (mask = (1UL << 1); mask < config->division_factor;
    48c8:	683b      	ldr	r3, [r7, #0]
    48ca:	685a      	ldr	r2, [r3, #4]
    48cc:	68bb      	ldr	r3, [r7, #8]
    48ce:	429a      	cmp	r2, r3
    48d0:	d8f4      	bhi.n	48bc <system_gclk_gen_set_config+0x6c>
						mask <<= 1) {
				div2_count++;
			}

			/* Set binary divider power of 2 division factor */
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    48d2:	68fb      	ldr	r3, [r7, #12]
    48d4:	021b      	lsls	r3, r3, #8
    48d6:	693a      	ldr	r2, [r7, #16]
    48d8:	4313      	orrs	r3, r2
    48da:	613b      	str	r3, [r7, #16]
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    48dc:	697b      	ldr	r3, [r7, #20]
    48de:	2280      	movs	r2, #128	; 0x80
    48e0:	0352      	lsls	r2, r2, #13
    48e2:	4313      	orrs	r3, r2
    48e4:	617b      	str	r3, [r7, #20]
    48e6:	e00a      	b.n	48fe <system_gclk_gen_set_config+0xae>
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    48e8:	683b      	ldr	r3, [r7, #0]
    48ea:	685b      	ldr	r3, [r3, #4]
    48ec:	021b      	lsls	r3, r3, #8
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
    48ee:	693a      	ldr	r2, [r7, #16]
    48f0:	4313      	orrs	r3, r2
    48f2:	613b      	str	r3, [r7, #16]
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    48f4:	697b      	ldr	r3, [r7, #20]
    48f6:	2280      	movs	r2, #128	; 0x80
    48f8:	0292      	lsls	r2, r2, #10
    48fa:	4313      	orrs	r3, r2
    48fc:	617b      	str	r3, [r7, #20]
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    48fe:	683b      	ldr	r3, [r7, #0]
    4900:	7a1b      	ldrb	r3, [r3, #8]
    4902:	2b00      	cmp	r3, #0
    4904:	d004      	beq.n	4910 <system_gclk_gen_set_config+0xc0>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    4906:	697b      	ldr	r3, [r7, #20]
    4908:	2280      	movs	r2, #128	; 0x80
    490a:	0392      	lsls	r2, r2, #14
    490c:	4313      	orrs	r3, r2
    490e:	617b      	str	r3, [r7, #20]
	}

	while (system_gclk_is_syncing()) {
    4910:	46c0      	nop			; (mov r8, r8)
    4912:	4b13      	ldr	r3, [pc, #76]	; (4960 <system_gclk_gen_set_config+0x110>)
    4914:	4798      	blx	r3
    4916:	1e03      	subs	r3, r0, #0
    4918:	d1fb      	bne.n	4912 <system_gclk_gen_set_config+0xc2>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    491a:	4b12      	ldr	r3, [pc, #72]	; (4964 <system_gclk_gen_set_config+0x114>)
    491c:	4798      	blx	r3

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    491e:	4a12      	ldr	r2, [pc, #72]	; (4968 <system_gclk_gen_set_config+0x118>)
    4920:	1dfb      	adds	r3, r7, #7
    4922:	781b      	ldrb	r3, [r3, #0]
    4924:	7013      	strb	r3, [r2, #0]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    4926:	46c0      	nop			; (mov r8, r8)
    4928:	4b0d      	ldr	r3, [pc, #52]	; (4960 <system_gclk_gen_set_config+0x110>)
    492a:	4798      	blx	r3
    492c:	1e03      	subs	r3, r0, #0
    492e:	d1fb      	bne.n	4928 <system_gclk_gen_set_config+0xd8>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    4930:	4b0e      	ldr	r3, [pc, #56]	; (496c <system_gclk_gen_set_config+0x11c>)
    4932:	693a      	ldr	r2, [r7, #16]
    4934:	609a      	str	r2, [r3, #8]

	while (system_gclk_is_syncing()) {
    4936:	46c0      	nop			; (mov r8, r8)
    4938:	4b09      	ldr	r3, [pc, #36]	; (4960 <system_gclk_gen_set_config+0x110>)
    493a:	4798      	blx	r3
    493c:	1e03      	subs	r3, r0, #0
    493e:	d1fb      	bne.n	4938 <system_gclk_gen_set_config+0xe8>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    4940:	4b0a      	ldr	r3, [pc, #40]	; (496c <system_gclk_gen_set_config+0x11c>)
    4942:	4a0a      	ldr	r2, [pc, #40]	; (496c <system_gclk_gen_set_config+0x11c>)
    4944:	6851      	ldr	r1, [r2, #4]
    4946:	2280      	movs	r2, #128	; 0x80
    4948:	0252      	lsls	r2, r2, #9
    494a:	4011      	ands	r1, r2
    494c:	697a      	ldr	r2, [r7, #20]
    494e:	430a      	orrs	r2, r1
    4950:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
    4952:	4b07      	ldr	r3, [pc, #28]	; (4970 <system_gclk_gen_set_config+0x120>)
    4954:	4798      	blx	r3
}
    4956:	46c0      	nop			; (mov r8, r8)
    4958:	46bd      	mov	sp, r7
    495a:	b006      	add	sp, #24
    495c:	bd80      	pop	{r7, pc}
    495e:	46c0      	nop			; (mov r8, r8)
    4960:	00004801 	.word	0x00004801
    4964:	000047d9 	.word	0x000047d9
    4968:	40000c08 	.word	0x40000c08
    496c:	40000c00 	.word	0x40000c00
    4970:	000047ed 	.word	0x000047ed

00004974 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    4974:	b580      	push	{r7, lr}
    4976:	b082      	sub	sp, #8
    4978:	af00      	add	r7, sp, #0
    497a:	0002      	movs	r2, r0
    497c:	1dfb      	adds	r3, r7, #7
    497e:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
    4980:	46c0      	nop			; (mov r8, r8)
    4982:	4b0e      	ldr	r3, [pc, #56]	; (49bc <system_gclk_gen_enable+0x48>)
    4984:	4798      	blx	r3
    4986:	1e03      	subs	r3, r0, #0
    4988:	d1fb      	bne.n	4982 <system_gclk_gen_enable+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    498a:	4b0d      	ldr	r3, [pc, #52]	; (49c0 <system_gclk_gen_enable+0x4c>)
    498c:	4798      	blx	r3

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    498e:	4a0d      	ldr	r2, [pc, #52]	; (49c4 <system_gclk_gen_enable+0x50>)
    4990:	1dfb      	adds	r3, r7, #7
    4992:	781b      	ldrb	r3, [r3, #0]
    4994:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
    4996:	46c0      	nop			; (mov r8, r8)
    4998:	4b08      	ldr	r3, [pc, #32]	; (49bc <system_gclk_gen_enable+0x48>)
    499a:	4798      	blx	r3
    499c:	1e03      	subs	r3, r0, #0
    499e:	d1fb      	bne.n	4998 <system_gclk_gen_enable+0x24>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    49a0:	4b09      	ldr	r3, [pc, #36]	; (49c8 <system_gclk_gen_enable+0x54>)
    49a2:	4a09      	ldr	r2, [pc, #36]	; (49c8 <system_gclk_gen_enable+0x54>)
    49a4:	6852      	ldr	r2, [r2, #4]
    49a6:	2180      	movs	r1, #128	; 0x80
    49a8:	0249      	lsls	r1, r1, #9
    49aa:	430a      	orrs	r2, r1
    49ac:	605a      	str	r2, [r3, #4]

	system_interrupt_leave_critical_section();
    49ae:	4b07      	ldr	r3, [pc, #28]	; (49cc <system_gclk_gen_enable+0x58>)
    49b0:	4798      	blx	r3
}
    49b2:	46c0      	nop			; (mov r8, r8)
    49b4:	46bd      	mov	sp, r7
    49b6:	b002      	add	sp, #8
    49b8:	bd80      	pop	{r7, pc}
    49ba:	46c0      	nop			; (mov r8, r8)
    49bc:	00004801 	.word	0x00004801
    49c0:	000047d9 	.word	0x000047d9
    49c4:	40000c04 	.word	0x40000c04
    49c8:	40000c00 	.word	0x40000c00
    49cc:	000047ed 	.word	0x000047ed

000049d0 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    49d0:	b580      	push	{r7, lr}
    49d2:	b086      	sub	sp, #24
    49d4:	af00      	add	r7, sp, #0
    49d6:	0002      	movs	r2, r0
    49d8:	1dfb      	adds	r3, r7, #7
    49da:	701a      	strb	r2, [r3, #0]
	while (system_gclk_is_syncing()) {
    49dc:	46c0      	nop			; (mov r8, r8)
    49de:	4b2a      	ldr	r3, [pc, #168]	; (4a88 <system_gclk_gen_get_hz+0xb8>)
    49e0:	4798      	blx	r3
    49e2:	1e03      	subs	r3, r0, #0
    49e4:	d1fb      	bne.n	49de <system_gclk_gen_get_hz+0xe>
		/* Wait for synchronization */
	};

	system_interrupt_enter_critical_section();
    49e6:	4b29      	ldr	r3, [pc, #164]	; (4a8c <system_gclk_gen_get_hz+0xbc>)
    49e8:	4798      	blx	r3

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    49ea:	4a29      	ldr	r2, [pc, #164]	; (4a90 <system_gclk_gen_get_hz+0xc0>)
    49ec:	1dfb      	adds	r3, r7, #7
    49ee:	781b      	ldrb	r3, [r3, #0]
    49f0:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
    49f2:	46c0      	nop			; (mov r8, r8)
    49f4:	4b24      	ldr	r3, [pc, #144]	; (4a88 <system_gclk_gen_get_hz+0xb8>)
    49f6:	4798      	blx	r3
    49f8:	1e03      	subs	r3, r0, #0
    49fa:	d1fb      	bne.n	49f4 <system_gclk_gen_get_hz+0x24>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    49fc:	4b25      	ldr	r3, [pc, #148]	; (4a94 <system_gclk_gen_get_hz+0xc4>)
    49fe:	685b      	ldr	r3, [r3, #4]
    4a00:	04db      	lsls	r3, r3, #19
    4a02:	0edb      	lsrs	r3, r3, #27
    4a04:	b2db      	uxtb	r3, r3
	while (system_gclk_is_syncing()) {
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
    4a06:	0018      	movs	r0, r3
    4a08:	4b23      	ldr	r3, [pc, #140]	; (4a98 <system_gclk_gen_get_hz+0xc8>)
    4a0a:	4798      	blx	r3
    4a0c:	0003      	movs	r3, r0
    4a0e:	617b      	str	r3, [r7, #20]
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    4a10:	4a1f      	ldr	r2, [pc, #124]	; (4a90 <system_gclk_gen_get_hz+0xc0>)
    4a12:	1dfb      	adds	r3, r7, #7
    4a14:	781b      	ldrb	r3, [r3, #0]
    4a16:	7013      	strb	r3, [r2, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    4a18:	4b1e      	ldr	r3, [pc, #120]	; (4a94 <system_gclk_gen_get_hz+0xc4>)
    4a1a:	685b      	ldr	r3, [r3, #4]
    4a1c:	02db      	lsls	r3, r3, #11
    4a1e:	0fdb      	lsrs	r3, r3, #31
    4a20:	b2da      	uxtb	r2, r3
    4a22:	2313      	movs	r3, #19
    4a24:	18fb      	adds	r3, r7, r3
    4a26:	701a      	strb	r2, [r3, #0]

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    4a28:	4a1c      	ldr	r2, [pc, #112]	; (4a9c <system_gclk_gen_get_hz+0xcc>)
    4a2a:	1dfb      	adds	r3, r7, #7
    4a2c:	781b      	ldrb	r3, [r3, #0]
    4a2e:	7013      	strb	r3, [r2, #0]
	while (system_gclk_is_syncing()) {
    4a30:	46c0      	nop			; (mov r8, r8)
    4a32:	4b15      	ldr	r3, [pc, #84]	; (4a88 <system_gclk_gen_get_hz+0xb8>)
    4a34:	4798      	blx	r3
    4a36:	1e03      	subs	r3, r0, #0
    4a38:	d1fb      	bne.n	4a32 <system_gclk_gen_get_hz+0x62>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    4a3a:	4b16      	ldr	r3, [pc, #88]	; (4a94 <system_gclk_gen_get_hz+0xc4>)
    4a3c:	689b      	ldr	r3, [r3, #8]
    4a3e:	021b      	lsls	r3, r3, #8
    4a40:	0c1b      	lsrs	r3, r3, #16
    4a42:	b29b      	uxth	r3, r3
    4a44:	60fb      	str	r3, [r7, #12]

	system_interrupt_leave_critical_section();
    4a46:	4b16      	ldr	r3, [pc, #88]	; (4aa0 <system_gclk_gen_get_hz+0xd0>)
    4a48:	4798      	blx	r3

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    4a4a:	2313      	movs	r3, #19
    4a4c:	18fb      	adds	r3, r7, r3
    4a4e:	781b      	ldrb	r3, [r3, #0]
    4a50:	2b00      	cmp	r3, #0
    4a52:	d109      	bne.n	4a68 <system_gclk_gen_get_hz+0x98>
    4a54:	68fb      	ldr	r3, [r7, #12]
    4a56:	2b01      	cmp	r3, #1
    4a58:	d906      	bls.n	4a68 <system_gclk_gen_get_hz+0x98>
		gen_input_hz /= divider;
    4a5a:	4b12      	ldr	r3, [pc, #72]	; (4aa4 <system_gclk_gen_get_hz+0xd4>)
    4a5c:	68f9      	ldr	r1, [r7, #12]
    4a5e:	6978      	ldr	r0, [r7, #20]
    4a60:	4798      	blx	r3
    4a62:	0003      	movs	r3, r0
    4a64:	617b      	str	r3, [r7, #20]
    4a66:	e00a      	b.n	4a7e <system_gclk_gen_get_hz+0xae>
	} else if (divsel) {
    4a68:	2313      	movs	r3, #19
    4a6a:	18fb      	adds	r3, r7, r3
    4a6c:	781b      	ldrb	r3, [r3, #0]
    4a6e:	2b00      	cmp	r3, #0
    4a70:	d005      	beq.n	4a7e <system_gclk_gen_get_hz+0xae>
		gen_input_hz >>= (divider+1);
    4a72:	68fb      	ldr	r3, [r7, #12]
    4a74:	3301      	adds	r3, #1
    4a76:	697a      	ldr	r2, [r7, #20]
    4a78:	40da      	lsrs	r2, r3
    4a7a:	0013      	movs	r3, r2
    4a7c:	617b      	str	r3, [r7, #20]
	}

	return gen_input_hz;
    4a7e:	697b      	ldr	r3, [r7, #20]
}
    4a80:	0018      	movs	r0, r3
    4a82:	46bd      	mov	sp, r7
    4a84:	b006      	add	sp, #24
    4a86:	bd80      	pop	{r7, pc}
    4a88:	00004801 	.word	0x00004801
    4a8c:	000047d9 	.word	0x000047d9
    4a90:	40000c04 	.word	0x40000c04
    4a94:	40000c00 	.word	0x40000c00
    4a98:	000040b9 	.word	0x000040b9
    4a9c:	40000c08 	.word	0x40000c08
    4aa0:	000047ed 	.word	0x000047ed
    4aa4:	0000f8ed 	.word	0x0000f8ed

00004aa8 <system_gclk_chan_set_config>:
 *
 */
void system_gclk_chan_set_config(
		const uint8_t channel,
		struct system_gclk_chan_config *const config)
{
    4aa8:	b580      	push	{r7, lr}
    4aaa:	b084      	sub	sp, #16
    4aac:	af00      	add	r7, sp, #0
    4aae:	0002      	movs	r2, r0
    4ab0:	6039      	str	r1, [r7, #0]
    4ab2:	1dfb      	adds	r3, r7, #7
    4ab4:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(config);

	/* Cache the new config to reduce sync requirements */
	uint32_t new_clkctrl_config = (channel << GCLK_CLKCTRL_ID_Pos);
    4ab6:	1dfb      	adds	r3, r7, #7
    4ab8:	781b      	ldrb	r3, [r3, #0]
    4aba:	60fb      	str	r3, [r7, #12]

	/* Select the desired generic clock generator */
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    4abc:	683b      	ldr	r3, [r7, #0]
    4abe:	781b      	ldrb	r3, [r3, #0]
    4ac0:	021b      	lsls	r3, r3, #8
    4ac2:	001a      	movs	r2, r3
    4ac4:	68fb      	ldr	r3, [r7, #12]
    4ac6:	4313      	orrs	r3, r2
    4ac8:	60fb      	str	r3, [r7, #12]

	/* Disable generic clock channel */
	system_gclk_chan_disable(channel);
    4aca:	1dfb      	adds	r3, r7, #7
    4acc:	781b      	ldrb	r3, [r3, #0]
    4ace:	0018      	movs	r0, r3
    4ad0:	4b04      	ldr	r3, [pc, #16]	; (4ae4 <system_gclk_chan_set_config+0x3c>)
    4ad2:	4798      	blx	r3

	/* Write the new configuration */
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    4ad4:	4b04      	ldr	r3, [pc, #16]	; (4ae8 <system_gclk_chan_set_config+0x40>)
    4ad6:	68fa      	ldr	r2, [r7, #12]
    4ad8:	b292      	uxth	r2, r2
    4ada:	805a      	strh	r2, [r3, #2]
}
    4adc:	46c0      	nop			; (mov r8, r8)
    4ade:	46bd      	mov	sp, r7
    4ae0:	b004      	add	sp, #16
    4ae2:	bd80      	pop	{r7, pc}
    4ae4:	00004b35 	.word	0x00004b35
    4ae8:	40000c00 	.word	0x40000c00

00004aec <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    4aec:	b580      	push	{r7, lr}
    4aee:	b082      	sub	sp, #8
    4af0:	af00      	add	r7, sp, #0
    4af2:	0002      	movs	r2, r0
    4af4:	1dfb      	adds	r3, r7, #7
    4af6:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
    4af8:	4b0a      	ldr	r3, [pc, #40]	; (4b24 <system_gclk_chan_enable+0x38>)
    4afa:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    4afc:	4a0a      	ldr	r2, [pc, #40]	; (4b28 <system_gclk_chan_enable+0x3c>)
    4afe:	1dfb      	adds	r3, r7, #7
    4b00:	781b      	ldrb	r3, [r3, #0]
    4b02:	7013      	strb	r3, [r2, #0]

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    4b04:	4909      	ldr	r1, [pc, #36]	; (4b2c <system_gclk_chan_enable+0x40>)
    4b06:	4b09      	ldr	r3, [pc, #36]	; (4b2c <system_gclk_chan_enable+0x40>)
    4b08:	885b      	ldrh	r3, [r3, #2]
    4b0a:	b29b      	uxth	r3, r3
    4b0c:	2280      	movs	r2, #128	; 0x80
    4b0e:	01d2      	lsls	r2, r2, #7
    4b10:	4313      	orrs	r3, r2
    4b12:	b29b      	uxth	r3, r3
    4b14:	804b      	strh	r3, [r1, #2]

	system_interrupt_leave_critical_section();
    4b16:	4b06      	ldr	r3, [pc, #24]	; (4b30 <system_gclk_chan_enable+0x44>)
    4b18:	4798      	blx	r3
}
    4b1a:	46c0      	nop			; (mov r8, r8)
    4b1c:	46bd      	mov	sp, r7
    4b1e:	b002      	add	sp, #8
    4b20:	bd80      	pop	{r7, pc}
    4b22:	46c0      	nop			; (mov r8, r8)
    4b24:	000047d9 	.word	0x000047d9
    4b28:	40000c02 	.word	0x40000c02
    4b2c:	40000c00 	.word	0x40000c00
    4b30:	000047ed 	.word	0x000047ed

00004b34 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    4b34:	b580      	push	{r7, lr}
    4b36:	b084      	sub	sp, #16
    4b38:	af00      	add	r7, sp, #0
    4b3a:	0002      	movs	r2, r0
    4b3c:	1dfb      	adds	r3, r7, #7
    4b3e:	701a      	strb	r2, [r3, #0]
	system_interrupt_enter_critical_section();
    4b40:	4b1c      	ldr	r3, [pc, #112]	; (4bb4 <system_gclk_chan_disable+0x80>)
    4b42:	4798      	blx	r3

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    4b44:	4a1c      	ldr	r2, [pc, #112]	; (4bb8 <system_gclk_chan_disable+0x84>)
    4b46:	1dfb      	adds	r3, r7, #7
    4b48:	781b      	ldrb	r3, [r3, #0]
    4b4a:	7013      	strb	r3, [r2, #0]

	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    4b4c:	4b1b      	ldr	r3, [pc, #108]	; (4bbc <system_gclk_chan_disable+0x88>)
    4b4e:	885b      	ldrh	r3, [r3, #2]
    4b50:	051b      	lsls	r3, r3, #20
    4b52:	0f1b      	lsrs	r3, r3, #28
    4b54:	b2db      	uxtb	r3, r3
    4b56:	60fb      	str	r3, [r7, #12]
	GCLK->CLKCTRL.bit.GEN = 0;
    4b58:	4a18      	ldr	r2, [pc, #96]	; (4bbc <system_gclk_chan_disable+0x88>)
    4b5a:	8853      	ldrh	r3, [r2, #2]
    4b5c:	4918      	ldr	r1, [pc, #96]	; (4bc0 <system_gclk_chan_disable+0x8c>)
    4b5e:	400b      	ands	r3, r1
    4b60:	8053      	strh	r3, [r2, #2]

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    4b62:	4a16      	ldr	r2, [pc, #88]	; (4bbc <system_gclk_chan_disable+0x88>)
    4b64:	4b15      	ldr	r3, [pc, #84]	; (4bbc <system_gclk_chan_disable+0x88>)
    4b66:	885b      	ldrh	r3, [r3, #2]
    4b68:	b29b      	uxth	r3, r3
    4b6a:	4916      	ldr	r1, [pc, #88]	; (4bc4 <system_gclk_chan_disable+0x90>)
    4b6c:	400b      	ands	r3, r1
    4b6e:	b29b      	uxth	r3, r3
    4b70:	8053      	strh	r3, [r2, #2]
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    4b72:	46c0      	nop			; (mov r8, r8)
    4b74:	4b11      	ldr	r3, [pc, #68]	; (4bbc <system_gclk_chan_disable+0x88>)
    4b76:	885b      	ldrh	r3, [r3, #2]
    4b78:	b29b      	uxth	r3, r3
    4b7a:	001a      	movs	r2, r3
    4b7c:	2380      	movs	r3, #128	; 0x80
    4b7e:	01db      	lsls	r3, r3, #7
    4b80:	4013      	ands	r3, r2
    4b82:	d1f7      	bne.n	4b74 <system_gclk_chan_disable+0x40>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    4b84:	4a0d      	ldr	r2, [pc, #52]	; (4bbc <system_gclk_chan_disable+0x88>)
    4b86:	68fb      	ldr	r3, [r7, #12]
    4b88:	b2db      	uxtb	r3, r3
    4b8a:	1c19      	adds	r1, r3, #0
    4b8c:	230f      	movs	r3, #15
    4b8e:	400b      	ands	r3, r1
    4b90:	b2d9      	uxtb	r1, r3
    4b92:	8853      	ldrh	r3, [r2, #2]
    4b94:	1c08      	adds	r0, r1, #0
    4b96:	210f      	movs	r1, #15
    4b98:	4001      	ands	r1, r0
    4b9a:	0208      	lsls	r0, r1, #8
    4b9c:	4908      	ldr	r1, [pc, #32]	; (4bc0 <system_gclk_chan_disable+0x8c>)
    4b9e:	400b      	ands	r3, r1
    4ba0:	1c19      	adds	r1, r3, #0
    4ba2:	1c03      	adds	r3, r0, #0
    4ba4:	430b      	orrs	r3, r1
    4ba6:	8053      	strh	r3, [r2, #2]

	system_interrupt_leave_critical_section();
    4ba8:	4b07      	ldr	r3, [pc, #28]	; (4bc8 <system_gclk_chan_disable+0x94>)
    4baa:	4798      	blx	r3
}
    4bac:	46c0      	nop			; (mov r8, r8)
    4bae:	46bd      	mov	sp, r7
    4bb0:	b004      	add	sp, #16
    4bb2:	bd80      	pop	{r7, pc}
    4bb4:	000047d9 	.word	0x000047d9
    4bb8:	40000c02 	.word	0x40000c02
    4bbc:	40000c00 	.word	0x40000c00
    4bc0:	fffff0ff 	.word	0xfffff0ff
    4bc4:	ffffbfff 	.word	0xffffbfff
    4bc8:	000047ed 	.word	0x000047ed

00004bcc <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    4bcc:	b580      	push	{r7, lr}
    4bce:	b084      	sub	sp, #16
    4bd0:	af00      	add	r7, sp, #0
    4bd2:	0002      	movs	r2, r0
    4bd4:	1dfb      	adds	r3, r7, #7
    4bd6:	701a      	strb	r2, [r3, #0]
	uint8_t gen_id;

	system_interrupt_enter_critical_section();
    4bd8:	4b0d      	ldr	r3, [pc, #52]	; (4c10 <system_gclk_chan_get_hz+0x44>)
    4bda:	4798      	blx	r3

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    4bdc:	4a0d      	ldr	r2, [pc, #52]	; (4c14 <system_gclk_chan_get_hz+0x48>)
    4bde:	1dfb      	adds	r3, r7, #7
    4be0:	781b      	ldrb	r3, [r3, #0]
    4be2:	7013      	strb	r3, [r2, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    4be4:	4b0c      	ldr	r3, [pc, #48]	; (4c18 <system_gclk_chan_get_hz+0x4c>)
    4be6:	885b      	ldrh	r3, [r3, #2]
    4be8:	051b      	lsls	r3, r3, #20
    4bea:	0f1b      	lsrs	r3, r3, #28
    4bec:	b2da      	uxtb	r2, r3
    4bee:	230f      	movs	r3, #15
    4bf0:	18fb      	adds	r3, r7, r3
    4bf2:	701a      	strb	r2, [r3, #0]

	system_interrupt_leave_critical_section();
    4bf4:	4b09      	ldr	r3, [pc, #36]	; (4c1c <system_gclk_chan_get_hz+0x50>)
    4bf6:	4798      	blx	r3

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    4bf8:	230f      	movs	r3, #15
    4bfa:	18fb      	adds	r3, r7, r3
    4bfc:	781b      	ldrb	r3, [r3, #0]
    4bfe:	0018      	movs	r0, r3
    4c00:	4b07      	ldr	r3, [pc, #28]	; (4c20 <system_gclk_chan_get_hz+0x54>)
    4c02:	4798      	blx	r3
    4c04:	0003      	movs	r3, r0
}
    4c06:	0018      	movs	r0, r3
    4c08:	46bd      	mov	sp, r7
    4c0a:	b004      	add	sp, #16
    4c0c:	bd80      	pop	{r7, pc}
    4c0e:	46c0      	nop			; (mov r8, r8)
    4c10:	000047d9 	.word	0x000047d9
    4c14:	40000c02 	.word	0x40000c02
    4c18:	40000c00 	.word	0x40000c00
    4c1c:	000047ed 	.word	0x000047ed
    4c20:	000049d1 	.word	0x000049d1

00004c24 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    4c24:	b580      	push	{r7, lr}
    4c26:	b084      	sub	sp, #16
    4c28:	af00      	add	r7, sp, #0
    4c2a:	0002      	movs	r2, r0
    4c2c:	1dfb      	adds	r3, r7, #7
    4c2e:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    4c30:	230f      	movs	r3, #15
    4c32:	18fb      	adds	r3, r7, r3
    4c34:	1dfa      	adds	r2, r7, #7
    4c36:	7812      	ldrb	r2, [r2, #0]
    4c38:	09d2      	lsrs	r2, r2, #7
    4c3a:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    4c3c:	230e      	movs	r3, #14
    4c3e:	18fb      	adds	r3, r7, r3
    4c40:	1dfa      	adds	r2, r7, #7
    4c42:	7812      	ldrb	r2, [r2, #0]
    4c44:	0952      	lsrs	r2, r2, #5
    4c46:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    4c48:	4b0d      	ldr	r3, [pc, #52]	; (4c80 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    4c4a:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    4c4c:	230f      	movs	r3, #15
    4c4e:	18fb      	adds	r3, r7, r3
    4c50:	781b      	ldrb	r3, [r3, #0]
    4c52:	2b00      	cmp	r3, #0
    4c54:	d10f      	bne.n	4c76 <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    4c56:	230f      	movs	r3, #15
    4c58:	18fb      	adds	r3, r7, r3
    4c5a:	781b      	ldrb	r3, [r3, #0]
    4c5c:	009b      	lsls	r3, r3, #2
    4c5e:	2210      	movs	r2, #16
    4c60:	4694      	mov	ip, r2
    4c62:	44bc      	add	ip, r7
    4c64:	4463      	add	r3, ip
    4c66:	3b08      	subs	r3, #8
    4c68:	681a      	ldr	r2, [r3, #0]
    4c6a:	230e      	movs	r3, #14
    4c6c:	18fb      	adds	r3, r7, r3
    4c6e:	781b      	ldrb	r3, [r3, #0]
    4c70:	01db      	lsls	r3, r3, #7
    4c72:	18d3      	adds	r3, r2, r3
    4c74:	e000      	b.n	4c78 <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    4c76:	2300      	movs	r3, #0
	}
}
    4c78:	0018      	movs	r0, r3
    4c7a:	46bd      	mov	sp, r7
    4c7c:	b004      	add	sp, #16
    4c7e:	bd80      	pop	{r7, pc}
    4c80:	41004400 	.word	0x41004400

00004c84 <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    4c84:	b580      	push	{r7, lr}
    4c86:	b088      	sub	sp, #32
    4c88:	af00      	add	r7, sp, #0
    4c8a:	60f8      	str	r0, [r7, #12]
    4c8c:	60b9      	str	r1, [r7, #8]
    4c8e:	607a      	str	r2, [r7, #4]
	Assert(port);
	Assert(config);

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;
    4c90:	2300      	movs	r3, #0
    4c92:	61fb      	str	r3, [r7, #28]

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    4c94:	687b      	ldr	r3, [r7, #4]
    4c96:	78db      	ldrb	r3, [r3, #3]
    4c98:	2201      	movs	r2, #1
    4c9a:	4053      	eors	r3, r2
    4c9c:	b2db      	uxtb	r3, r3
    4c9e:	2b00      	cmp	r3, #0
    4ca0:	d035      	beq.n	4d0e <_system_pinmux_config+0x8a>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    4ca2:	687b      	ldr	r3, [r7, #4]
    4ca4:	781b      	ldrb	r3, [r3, #0]
    4ca6:	2b80      	cmp	r3, #128	; 0x80
    4ca8:	d00b      	beq.n	4cc2 <_system_pinmux_config+0x3e>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
    4caa:	69fb      	ldr	r3, [r7, #28]
    4cac:	2280      	movs	r2, #128	; 0x80
    4cae:	0252      	lsls	r2, r2, #9
    4cb0:	4313      	orrs	r3, r2
    4cb2:	61fb      	str	r3, [r7, #28]
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    4cb4:	687b      	ldr	r3, [r7, #4]
    4cb6:	781b      	ldrb	r3, [r3, #0]
    4cb8:	061b      	lsls	r3, r3, #24
    4cba:	001a      	movs	r2, r3
    4cbc:	69fb      	ldr	r3, [r7, #28]
    4cbe:	4313      	orrs	r3, r2
    4cc0:	61fb      	str	r3, [r7, #28]
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    4cc2:	687b      	ldr	r3, [r7, #4]
    4cc4:	785b      	ldrb	r3, [r3, #1]
    4cc6:	2b00      	cmp	r3, #0
    4cc8:	d003      	beq.n	4cd2 <_system_pinmux_config+0x4e>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    4cca:	687b      	ldr	r3, [r7, #4]
    4ccc:	785b      	ldrb	r3, [r3, #1]
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    4cce:	2b02      	cmp	r3, #2
    4cd0:	d110      	bne.n	4cf4 <_system_pinmux_config+0x70>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;
    4cd2:	69fb      	ldr	r3, [r7, #28]
    4cd4:	2280      	movs	r2, #128	; 0x80
    4cd6:	0292      	lsls	r2, r2, #10
    4cd8:	4313      	orrs	r3, r2
    4cda:	61fb      	str	r3, [r7, #28]

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    4cdc:	687b      	ldr	r3, [r7, #4]
    4cde:	789b      	ldrb	r3, [r3, #2]
    4ce0:	2b00      	cmp	r3, #0
    4ce2:	d004      	beq.n	4cee <_system_pinmux_config+0x6a>
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    4ce4:	69fb      	ldr	r3, [r7, #28]
    4ce6:	2280      	movs	r2, #128	; 0x80
    4ce8:	02d2      	lsls	r2, r2, #11
    4cea:	4313      	orrs	r3, r2
    4cec:	61fb      	str	r3, [r7, #28]
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    4cee:	68fb      	ldr	r3, [r7, #12]
    4cf0:	68ba      	ldr	r2, [r7, #8]
    4cf2:	605a      	str	r2, [r3, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    4cf4:	687b      	ldr	r3, [r7, #4]
    4cf6:	785b      	ldrb	r3, [r3, #1]
    4cf8:	2b01      	cmp	r3, #1
    4cfa:	d003      	beq.n	4d04 <_system_pinmux_config+0x80>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    4cfc:	687b      	ldr	r3, [r7, #4]
    4cfe:	785b      	ldrb	r3, [r3, #1]
			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    4d00:	2b02      	cmp	r3, #2
    4d02:	d107      	bne.n	4d14 <_system_pinmux_config+0x90>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    4d04:	69fb      	ldr	r3, [r7, #28]
    4d06:	4a22      	ldr	r2, [pc, #136]	; (4d90 <_system_pinmux_config+0x10c>)
    4d08:	4013      	ands	r3, r2
    4d0a:	61fb      	str	r3, [r7, #28]
    4d0c:	e002      	b.n	4d14 <_system_pinmux_config+0x90>
		}
	} else {
		port->DIRCLR.reg = pin_mask;
    4d0e:	68fb      	ldr	r3, [r7, #12]
    4d10:	68ba      	ldr	r2, [r7, #8]
    4d12:	605a      	str	r2, [r3, #4]
	}

	/* The Write Configuration register (WRCONFIG) requires the
	 * pins to to grouped into two 16-bit half-words - split them out here */
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    4d14:	68bb      	ldr	r3, [r7, #8]
    4d16:	041b      	lsls	r3, r3, #16
    4d18:	0c1b      	lsrs	r3, r3, #16
    4d1a:	61bb      	str	r3, [r7, #24]
	uint32_t upper_pin_mask = (pin_mask >> 16);
    4d1c:	68bb      	ldr	r3, [r7, #8]
    4d1e:	0c1b      	lsrs	r3, r3, #16
    4d20:	617b      	str	r3, [r7, #20]

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    4d22:	69ba      	ldr	r2, [r7, #24]
    4d24:	69fb      	ldr	r3, [r7, #28]
    4d26:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    4d28:	22a0      	movs	r2, #160	; 0xa0
    4d2a:	05d2      	lsls	r2, r2, #23
    4d2c:	431a      	orrs	r2, r3
	uint32_t upper_pin_mask = (pin_mask >> 16);

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    4d2e:	68fb      	ldr	r3, [r7, #12]
    4d30:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    4d32:	697a      	ldr	r2, [r7, #20]
    4d34:	69fb      	ldr	r3, [r7, #28]
    4d36:	4313      	orrs	r3, r2
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    4d38:	22d0      	movs	r2, #208	; 0xd0
    4d3a:	0612      	lsls	r2, r2, #24
    4d3c:	431a      	orrs	r2, r3
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    4d3e:	68fb      	ldr	r3, [r7, #12]
    4d40:	629a      	str	r2, [r3, #40]	; 0x28
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    4d42:	687b      	ldr	r3, [r7, #4]
    4d44:	78db      	ldrb	r3, [r3, #3]
    4d46:	2201      	movs	r2, #1
    4d48:	4053      	eors	r3, r2
    4d4a:	b2db      	uxtb	r3, r3
    4d4c:	2b00      	cmp	r3, #0
    4d4e:	d01a      	beq.n	4d86 <_system_pinmux_config+0x102>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    4d50:	69fa      	ldr	r2, [r7, #28]
    4d52:	2380      	movs	r3, #128	; 0x80
    4d54:	02db      	lsls	r3, r3, #11
    4d56:	4013      	ands	r3, r2
    4d58:	d00a      	beq.n	4d70 <_system_pinmux_config+0xec>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    4d5a:	687b      	ldr	r3, [r7, #4]
    4d5c:	789b      	ldrb	r3, [r3, #2]
    4d5e:	2b01      	cmp	r3, #1
    4d60:	d103      	bne.n	4d6a <_system_pinmux_config+0xe6>
				port->OUTSET.reg = pin_mask;
    4d62:	68fb      	ldr	r3, [r7, #12]
    4d64:	68ba      	ldr	r2, [r7, #8]
    4d66:	619a      	str	r2, [r3, #24]
    4d68:	e002      	b.n	4d70 <_system_pinmux_config+0xec>
			} else {
				port->OUTCLR.reg = pin_mask;
    4d6a:	68fb      	ldr	r3, [r7, #12]
    4d6c:	68ba      	ldr	r2, [r7, #8]
    4d6e:	615a      	str	r2, [r3, #20]
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    4d70:	687b      	ldr	r3, [r7, #4]
    4d72:	785b      	ldrb	r3, [r3, #1]
    4d74:	2b01      	cmp	r3, #1
    4d76:	d003      	beq.n	4d80 <_system_pinmux_config+0xfc>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
    4d78:	687b      	ldr	r3, [r7, #4]
    4d7a:	785b      	ldrb	r3, [r3, #1]
				port->OUTCLR.reg = pin_mask;
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    4d7c:	2b02      	cmp	r3, #2
    4d7e:	d102      	bne.n	4d86 <_system_pinmux_config+0x102>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    4d80:	68fb      	ldr	r3, [r7, #12]
    4d82:	68ba      	ldr	r2, [r7, #8]
    4d84:	609a      	str	r2, [r3, #8]
		}
	}
}
    4d86:	46c0      	nop			; (mov r8, r8)
    4d88:	46bd      	mov	sp, r7
    4d8a:	b008      	add	sp, #32
    4d8c:	bd80      	pop	{r7, pc}
    4d8e:	46c0      	nop			; (mov r8, r8)
    4d90:	fffbffff 	.word	0xfffbffff

00004d94 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    4d94:	b580      	push	{r7, lr}
    4d96:	b084      	sub	sp, #16
    4d98:	af00      	add	r7, sp, #0
    4d9a:	0002      	movs	r2, r0
    4d9c:	6039      	str	r1, [r7, #0]
    4d9e:	1dfb      	adds	r3, r7, #7
    4da0:	701a      	strb	r2, [r3, #0]
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
    4da2:	1dfb      	adds	r3, r7, #7
    4da4:	781b      	ldrb	r3, [r3, #0]
    4da6:	0018      	movs	r0, r3
    4da8:	4b0a      	ldr	r3, [pc, #40]	; (4dd4 <system_pinmux_pin_set_config+0x40>)
    4daa:	4798      	blx	r3
    4dac:	0003      	movs	r3, r0
    4dae:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    4db0:	1dfb      	adds	r3, r7, #7
    4db2:	781b      	ldrb	r3, [r3, #0]
    4db4:	221f      	movs	r2, #31
    4db6:	4013      	ands	r3, r2
    4db8:	2201      	movs	r2, #1
    4dba:	409a      	lsls	r2, r3
    4dbc:	0013      	movs	r3, r2
    4dbe:	60bb      	str	r3, [r7, #8]

	_system_pinmux_config(port, pin_mask, config);
    4dc0:	683a      	ldr	r2, [r7, #0]
    4dc2:	68b9      	ldr	r1, [r7, #8]
    4dc4:	68fb      	ldr	r3, [r7, #12]
    4dc6:	0018      	movs	r0, r3
    4dc8:	4b03      	ldr	r3, [pc, #12]	; (4dd8 <system_pinmux_pin_set_config+0x44>)
    4dca:	4798      	blx	r3
}
    4dcc:	46c0      	nop			; (mov r8, r8)
    4dce:	46bd      	mov	sp, r7
    4dd0:	b004      	add	sp, #16
    4dd2:	bd80      	pop	{r7, pc}
    4dd4:	00004c25 	.word	0x00004c25
    4dd8:	00004c85 	.word	0x00004c85

00004ddc <_system_dummy_init>:
 * Dummy initialization function, used as a weak alias target for the various
 * init functions called by \ref system_init().
 */
void _system_dummy_init(void);
void _system_dummy_init(void)
{
    4ddc:	b580      	push	{r7, lr}
    4dde:	af00      	add	r7, sp, #0
	return;
    4de0:	46c0      	nop			; (mov r8, r8)
}
    4de2:	46bd      	mov	sp, r7
    4de4:	bd80      	pop	{r7, pc}
    4de6:	46c0      	nop			; (mov r8, r8)

00004de8 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    4de8:	b580      	push	{r7, lr}
    4dea:	af00      	add	r7, sp, #0
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    4dec:	4b06      	ldr	r3, [pc, #24]	; (4e08 <system_init+0x20>)
    4dee:	4798      	blx	r3

	/* Initialize board hardware */
	system_board_init();
    4df0:	4b06      	ldr	r3, [pc, #24]	; (4e0c <system_init+0x24>)
    4df2:	4798      	blx	r3

	/* Initialize EVSYS hardware */
	_system_events_init();
    4df4:	4b06      	ldr	r3, [pc, #24]	; (4e10 <system_init+0x28>)
    4df6:	4798      	blx	r3

	/* Initialize External hardware */
	_system_extint_init();
    4df8:	4b06      	ldr	r3, [pc, #24]	; (4e14 <system_init+0x2c>)
    4dfa:	4798      	blx	r3
	
	/* Initialize DIVAS hardware */
	_system_divas_init();
    4dfc:	4b06      	ldr	r3, [pc, #24]	; (4e18 <system_init+0x30>)
    4dfe:	4798      	blx	r3
}
    4e00:	46c0      	nop			; (mov r8, r8)
    4e02:	46bd      	mov	sp, r7
    4e04:	bd80      	pop	{r7, pc}
    4e06:	46c0      	nop			; (mov r8, r8)
    4e08:	000044d9 	.word	0x000044d9
    4e0c:	00001aed 	.word	0x00001aed
    4e10:	00004ddd 	.word	0x00004ddd
    4e14:	000027f1 	.word	0x000027f1
    4e18:	00004ddd 	.word	0x00004ddd

00004e1c <tc_register_callback>:
 */
enum status_code tc_register_callback(
		struct tc_module *const module,
		tc_callback_t callback_func,
		const enum tc_callback callback_type)
{
    4e1c:	b580      	push	{r7, lr}
    4e1e:	b084      	sub	sp, #16
    4e20:	af00      	add	r7, sp, #0
    4e22:	60f8      	str	r0, [r7, #12]
    4e24:	60b9      	str	r1, [r7, #8]
    4e26:	1dfb      	adds	r3, r7, #7
    4e28:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    4e2a:	1dfb      	adds	r3, r7, #7
    4e2c:	781a      	ldrb	r2, [r3, #0]
    4e2e:	68fb      	ldr	r3, [r7, #12]
    4e30:	3202      	adds	r2, #2
    4e32:	0092      	lsls	r2, r2, #2
    4e34:	68b9      	ldr	r1, [r7, #8]
    4e36:	50d1      	str	r1, [r2, r3]

	/* Set the bit corresponding to the callback_type */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
    4e38:	1dfb      	adds	r3, r7, #7
    4e3a:	781b      	ldrb	r3, [r3, #0]
    4e3c:	2b02      	cmp	r3, #2
    4e3e:	d107      	bne.n	4e50 <tc_register_callback+0x34>
		module->register_callback_mask |= TC_INTFLAG_MC(1);
    4e40:	68fb      	ldr	r3, [r7, #12]
    4e42:	7e1b      	ldrb	r3, [r3, #24]
    4e44:	2210      	movs	r2, #16
    4e46:	4313      	orrs	r3, r2
    4e48:	b2da      	uxtb	r2, r3
    4e4a:	68fb      	ldr	r3, [r7, #12]
    4e4c:	761a      	strb	r2, [r3, #24]
    4e4e:	e019      	b.n	4e84 <tc_register_callback+0x68>
	}
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
    4e50:	1dfb      	adds	r3, r7, #7
    4e52:	781b      	ldrb	r3, [r3, #0]
    4e54:	2b03      	cmp	r3, #3
    4e56:	d107      	bne.n	4e68 <tc_register_callback+0x4c>
		module->register_callback_mask |= TC_INTFLAG_MC(2);
    4e58:	68fb      	ldr	r3, [r7, #12]
    4e5a:	7e1b      	ldrb	r3, [r3, #24]
    4e5c:	2220      	movs	r2, #32
    4e5e:	4313      	orrs	r3, r2
    4e60:	b2da      	uxtb	r2, r3
    4e62:	68fb      	ldr	r3, [r7, #12]
    4e64:	761a      	strb	r2, [r3, #24]
    4e66:	e00d      	b.n	4e84 <tc_register_callback+0x68>
	}
	else {
		module->register_callback_mask |= (1 << callback_type);
    4e68:	68fb      	ldr	r3, [r7, #12]
    4e6a:	7e1b      	ldrb	r3, [r3, #24]
    4e6c:	b25a      	sxtb	r2, r3
    4e6e:	1dfb      	adds	r3, r7, #7
    4e70:	781b      	ldrb	r3, [r3, #0]
    4e72:	2101      	movs	r1, #1
    4e74:	4099      	lsls	r1, r3
    4e76:	000b      	movs	r3, r1
    4e78:	b25b      	sxtb	r3, r3
    4e7a:	4313      	orrs	r3, r2
    4e7c:	b25b      	sxtb	r3, r3
    4e7e:	b2da      	uxtb	r2, r3
    4e80:	68fb      	ldr	r3, [r7, #12]
    4e82:	761a      	strb	r2, [r3, #24]
	}
	return STATUS_OK;
    4e84:	2300      	movs	r3, #0
}
    4e86:	0018      	movs	r0, r3
    4e88:	46bd      	mov	sp, r7
    4e8a:	b004      	add	sp, #16
    4e8c:	bd80      	pop	{r7, pc}
    4e8e:	46c0      	nop			; (mov r8, r8)

00004e90 <TC0_Handler>:
#if (SAML21E) || (SAML21G)
	_TC_INTERRUPT_HANDLER(0,0)
	_TC_INTERRUPT_HANDLER(1,1)
	_TC_INTERRUPT_HANDLER(4,2)
#else
	MRECURSION(TC_INST_NUM, _TC_INTERRUPT_HANDLER, TC_INST_MAX_ID)
    4e90:	b580      	push	{r7, lr}
    4e92:	af00      	add	r7, sp, #0
    4e94:	2000      	movs	r0, #0
    4e96:	4b02      	ldr	r3, [pc, #8]	; (4ea0 <TC0_Handler+0x10>)
    4e98:	4798      	blx	r3
    4e9a:	46c0      	nop			; (mov r8, r8)
    4e9c:	46bd      	mov	sp, r7
    4e9e:	bd80      	pop	{r7, pc}
    4ea0:	00004f31 	.word	0x00004f31

00004ea4 <TC1_Handler>:
    4ea4:	b580      	push	{r7, lr}
    4ea6:	af00      	add	r7, sp, #0
    4ea8:	2001      	movs	r0, #1
    4eaa:	4b02      	ldr	r3, [pc, #8]	; (4eb4 <TC1_Handler+0x10>)
    4eac:	4798      	blx	r3
    4eae:	46c0      	nop			; (mov r8, r8)
    4eb0:	46bd      	mov	sp, r7
    4eb2:	bd80      	pop	{r7, pc}
    4eb4:	00004f31 	.word	0x00004f31

00004eb8 <TC2_Handler>:
    4eb8:	b580      	push	{r7, lr}
    4eba:	af00      	add	r7, sp, #0
    4ebc:	2002      	movs	r0, #2
    4ebe:	4b02      	ldr	r3, [pc, #8]	; (4ec8 <TC2_Handler+0x10>)
    4ec0:	4798      	blx	r3
    4ec2:	46c0      	nop			; (mov r8, r8)
    4ec4:	46bd      	mov	sp, r7
    4ec6:	bd80      	pop	{r7, pc}
    4ec8:	00004f31 	.word	0x00004f31

00004ecc <TC3_Handler>:
    4ecc:	b580      	push	{r7, lr}
    4ece:	af00      	add	r7, sp, #0
    4ed0:	2003      	movs	r0, #3
    4ed2:	4b02      	ldr	r3, [pc, #8]	; (4edc <TC3_Handler+0x10>)
    4ed4:	4798      	blx	r3
    4ed6:	46c0      	nop			; (mov r8, r8)
    4ed8:	46bd      	mov	sp, r7
    4eda:	bd80      	pop	{r7, pc}
    4edc:	00004f31 	.word	0x00004f31

00004ee0 <TC4_Handler>:
    4ee0:	b580      	push	{r7, lr}
    4ee2:	af00      	add	r7, sp, #0
    4ee4:	2004      	movs	r0, #4
    4ee6:	4b02      	ldr	r3, [pc, #8]	; (4ef0 <TC4_Handler+0x10>)
    4ee8:	4798      	blx	r3
    4eea:	46c0      	nop			; (mov r8, r8)
    4eec:	46bd      	mov	sp, r7
    4eee:	bd80      	pop	{r7, pc}
    4ef0:	00004f31 	.word	0x00004f31

00004ef4 <TC5_Handler>:
    4ef4:	b580      	push	{r7, lr}
    4ef6:	af00      	add	r7, sp, #0
    4ef8:	2005      	movs	r0, #5
    4efa:	4b02      	ldr	r3, [pc, #8]	; (4f04 <TC5_Handler+0x10>)
    4efc:	4798      	blx	r3
    4efe:	46c0      	nop			; (mov r8, r8)
    4f00:	46bd      	mov	sp, r7
    4f02:	bd80      	pop	{r7, pc}
    4f04:	00004f31 	.word	0x00004f31

00004f08 <TC6_Handler>:
    4f08:	b580      	push	{r7, lr}
    4f0a:	af00      	add	r7, sp, #0
    4f0c:	2006      	movs	r0, #6
    4f0e:	4b02      	ldr	r3, [pc, #8]	; (4f18 <TC6_Handler+0x10>)
    4f10:	4798      	blx	r3
    4f12:	46c0      	nop			; (mov r8, r8)
    4f14:	46bd      	mov	sp, r7
    4f16:	bd80      	pop	{r7, pc}
    4f18:	00004f31 	.word	0x00004f31

00004f1c <TC7_Handler>:
    4f1c:	b580      	push	{r7, lr}
    4f1e:	af00      	add	r7, sp, #0
    4f20:	2007      	movs	r0, #7
    4f22:	4b02      	ldr	r3, [pc, #8]	; (4f2c <TC7_Handler+0x10>)
    4f24:	4798      	blx	r3
    4f26:	46c0      	nop			; (mov r8, r8)
    4f28:	46bd      	mov	sp, r7
    4f2a:	bd80      	pop	{r7, pc}
    4f2c:	00004f31 	.word	0x00004f31

00004f30 <_tc_interrupt_handler>:
 * \param[in]  instance  ID of the TC instance calling the interrupt
 *                       handler.
 */
void _tc_interrupt_handler(
		uint8_t instance)
{
    4f30:	b580      	push	{r7, lr}
    4f32:	b084      	sub	sp, #16
    4f34:	af00      	add	r7, sp, #0
    4f36:	0002      	movs	r2, r0
    4f38:	1dfb      	adds	r3, r7, #7
    4f3a:	701a      	strb	r2, [r3, #0]
	/* Temporary variable */
	uint8_t interrupt_and_callback_status_mask;

	/* Get device instance from the look-up table */
	struct tc_module *module
			= (struct tc_module *)_tc_instances[instance];
    4f3c:	1dfb      	adds	r3, r7, #7
    4f3e:	781a      	ldrb	r2, [r3, #0]
{
	/* Temporary variable */
	uint8_t interrupt_and_callback_status_mask;

	/* Get device instance from the look-up table */
	struct tc_module *module
    4f40:	4b28      	ldr	r3, [pc, #160]	; (4fe4 <_tc_interrupt_handler+0xb4>)
    4f42:	0092      	lsls	r2, r2, #2
    4f44:	58d3      	ldr	r3, [r2, r3]
    4f46:	60fb      	str	r3, [r7, #12]
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    4f48:	68fb      	ldr	r3, [r7, #12]
    4f4a:	681b      	ldr	r3, [r3, #0]
    4f4c:	7b9b      	ldrb	r3, [r3, #14]
    4f4e:	b2db      	uxtb	r3, r3
			module->register_callback_mask &
    4f50:	68fa      	ldr	r2, [r7, #12]
    4f52:	7e12      	ldrb	r2, [r2, #24]
	/* Get device instance from the look-up table */
	struct tc_module *module
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    4f54:	4013      	ands	r3, r2
    4f56:	b2da      	uxtb	r2, r3
			module->register_callback_mask &
			module->enable_callback_mask;
    4f58:	68fb      	ldr	r3, [r7, #12]
    4f5a:	7e59      	ldrb	r1, [r3, #25]
	/* Get device instance from the look-up table */
	struct tc_module *module
			= (struct tc_module *)_tc_instances[instance];

	/* Read and mask interrupt flag register */
	interrupt_and_callback_status_mask = module->hw->COUNT8.INTFLAG.reg &
    4f5c:	230b      	movs	r3, #11
    4f5e:	18fb      	adds	r3, r7, r3
    4f60:	400a      	ands	r2, r1
    4f62:	701a      	strb	r2, [r3, #0]
			module->register_callback_mask &
			module->enable_callback_mask;

	/* Check if an Overflow interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_OVF) {
    4f64:	230b      	movs	r3, #11
    4f66:	18fb      	adds	r3, r7, r3
    4f68:	781b      	ldrb	r3, [r3, #0]
    4f6a:	2201      	movs	r2, #1
    4f6c:	4013      	ands	r3, r2
    4f6e:	d008      	beq.n	4f82 <_tc_interrupt_handler+0x52>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_OVERFLOW])(module);
    4f70:	68fb      	ldr	r3, [r7, #12]
    4f72:	689b      	ldr	r3, [r3, #8]
    4f74:	68fa      	ldr	r2, [r7, #12]
    4f76:	0010      	movs	r0, r2
    4f78:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    4f7a:	68fb      	ldr	r3, [r7, #12]
    4f7c:	681b      	ldr	r3, [r3, #0]
    4f7e:	2201      	movs	r2, #1
    4f80:	739a      	strb	r2, [r3, #14]
	}

	/* Check if an Error interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_ERR) {
    4f82:	230b      	movs	r3, #11
    4f84:	18fb      	adds	r3, r7, r3
    4f86:	781b      	ldrb	r3, [r3, #0]
    4f88:	2202      	movs	r2, #2
    4f8a:	4013      	ands	r3, r2
    4f8c:	d008      	beq.n	4fa0 <_tc_interrupt_handler+0x70>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_ERROR])(module);
    4f8e:	68fb      	ldr	r3, [r7, #12]
    4f90:	68db      	ldr	r3, [r3, #12]
    4f92:	68fa      	ldr	r2, [r7, #12]
    4f94:	0010      	movs	r0, r2
    4f96:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_ERR;
    4f98:	68fb      	ldr	r3, [r7, #12]
    4f9a:	681b      	ldr	r3, [r3, #0]
    4f9c:	2202      	movs	r2, #2
    4f9e:	739a      	strb	r2, [r3, #14]
	}

	/* Check if an Match/Capture Channel 0 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(1)) {
    4fa0:	230b      	movs	r3, #11
    4fa2:	18fb      	adds	r3, r7, r3
    4fa4:	781b      	ldrb	r3, [r3, #0]
    4fa6:	2210      	movs	r2, #16
    4fa8:	4013      	ands	r3, r2
    4faa:	d008      	beq.n	4fbe <_tc_interrupt_handler+0x8e>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL0])(module);
    4fac:	68fb      	ldr	r3, [r7, #12]
    4fae:	691b      	ldr	r3, [r3, #16]
    4fb0:	68fa      	ldr	r2, [r7, #12]
    4fb2:	0010      	movs	r0, r2
    4fb4:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(1);
    4fb6:	68fb      	ldr	r3, [r7, #12]
    4fb8:	681b      	ldr	r3, [r3, #0]
    4fba:	2210      	movs	r2, #16
    4fbc:	739a      	strb	r2, [r3, #14]
	}

	/* Check if an Match/Capture Channel 1 interrupt has occurred */
	if (interrupt_and_callback_status_mask & TC_INTFLAG_MC(2)) {
    4fbe:	230b      	movs	r3, #11
    4fc0:	18fb      	adds	r3, r7, r3
    4fc2:	781b      	ldrb	r3, [r3, #0]
    4fc4:	2220      	movs	r2, #32
    4fc6:	4013      	ands	r3, r2
    4fc8:	d008      	beq.n	4fdc <_tc_interrupt_handler+0xac>
		/* Invoke registered and enabled callback function */
		(module->callback[TC_CALLBACK_CC_CHANNEL1])(module);
    4fca:	68fb      	ldr	r3, [r7, #12]
    4fcc:	695b      	ldr	r3, [r3, #20]
    4fce:	68fa      	ldr	r2, [r7, #12]
    4fd0:	0010      	movs	r0, r2
    4fd2:	4798      	blx	r3
		/* Clear interrupt flag */
		module->hw->COUNT8.INTFLAG.reg = TC_INTFLAG_MC(2);
    4fd4:	68fb      	ldr	r3, [r7, #12]
    4fd6:	681b      	ldr	r3, [r3, #0]
    4fd8:	2220      	movs	r2, #32
    4fda:	739a      	strb	r2, [r3, #14]
	}
}
    4fdc:	46c0      	nop			; (mov r8, r8)
    4fde:	46bd      	mov	sp, r7
    4fe0:	b004      	add	sp, #16
    4fe2:	bd80      	pop	{r7, pc}
    4fe4:	20002e70 	.word	0x20002e70

00004fe8 <system_gclk_chan_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_gclk_chan_get_config_defaults(
		struct system_gclk_chan_config *const config)
{
    4fe8:	b580      	push	{r7, lr}
    4fea:	b082      	sub	sp, #8
    4fec:	af00      	add	r7, sp, #0
    4fee:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    4ff0:	687b      	ldr	r3, [r7, #4]
    4ff2:	2200      	movs	r2, #0
    4ff4:	701a      	strb	r2, [r3, #0]
}
    4ff6:	46c0      	nop			; (mov r8, r8)
    4ff8:	46bd      	mov	sp, r7
    4ffa:	b002      	add	sp, #8
    4ffc:	bd80      	pop	{r7, pc}
    4ffe:	46c0      	nop			; (mov r8, r8)

00005000 <system_apb_clock_set_mask>:
 * \retval STATUS_OK               The clock mask was set successfully
 */
static inline enum status_code system_apb_clock_set_mask(
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
    5000:	b580      	push	{r7, lr}
    5002:	b082      	sub	sp, #8
    5004:	af00      	add	r7, sp, #0
    5006:	0002      	movs	r2, r0
    5008:	6039      	str	r1, [r7, #0]
    500a:	1dfb      	adds	r3, r7, #7
    500c:	701a      	strb	r2, [r3, #0]
	switch (bus) {
    500e:	1dfb      	adds	r3, r7, #7
    5010:	781b      	ldrb	r3, [r3, #0]
    5012:	2b01      	cmp	r3, #1
    5014:	d00a      	beq.n	502c <system_apb_clock_set_mask+0x2c>
    5016:	2b02      	cmp	r3, #2
    5018:	d00f      	beq.n	503a <system_apb_clock_set_mask+0x3a>
    501a:	2b00      	cmp	r3, #0
    501c:	d114      	bne.n	5048 <system_apb_clock_set_mask+0x48>
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    501e:	4b0e      	ldr	r3, [pc, #56]	; (5058 <system_apb_clock_set_mask+0x58>)
    5020:	4a0d      	ldr	r2, [pc, #52]	; (5058 <system_apb_clock_set_mask+0x58>)
    5022:	6991      	ldr	r1, [r2, #24]
    5024:	683a      	ldr	r2, [r7, #0]
    5026:	430a      	orrs	r2, r1
    5028:	619a      	str	r2, [r3, #24]
			break;
    502a:	e00f      	b.n	504c <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBB:
			PM->APBBMASK.reg |= mask;
    502c:	4b0a      	ldr	r3, [pc, #40]	; (5058 <system_apb_clock_set_mask+0x58>)
    502e:	4a0a      	ldr	r2, [pc, #40]	; (5058 <system_apb_clock_set_mask+0x58>)
    5030:	69d1      	ldr	r1, [r2, #28]
    5032:	683a      	ldr	r2, [r7, #0]
    5034:	430a      	orrs	r2, r1
    5036:	61da      	str	r2, [r3, #28]
			break;
    5038:	e008      	b.n	504c <system_apb_clock_set_mask+0x4c>

		case SYSTEM_CLOCK_APB_APBC:
			PM->APBCMASK.reg |= mask;
    503a:	4b07      	ldr	r3, [pc, #28]	; (5058 <system_apb_clock_set_mask+0x58>)
    503c:	4a06      	ldr	r2, [pc, #24]	; (5058 <system_apb_clock_set_mask+0x58>)
    503e:	6a11      	ldr	r1, [r2, #32]
    5040:	683a      	ldr	r2, [r7, #0]
    5042:	430a      	orrs	r2, r1
    5044:	621a      	str	r2, [r3, #32]
			break;
    5046:	e001      	b.n	504c <system_apb_clock_set_mask+0x4c>

		default:
			Assert(false);
			return STATUS_ERR_INVALID_ARG;
    5048:	2317      	movs	r3, #23
    504a:	e000      	b.n	504e <system_apb_clock_set_mask+0x4e>

	}

	return STATUS_OK;
    504c:	2300      	movs	r3, #0
}
    504e:	0018      	movs	r0, r3
    5050:	46bd      	mov	sp, r7
    5052:	b002      	add	sp, #8
    5054:	bd80      	pop	{r7, pc}
    5056:	46c0      	nop			; (mov r8, r8)
    5058:	40000400 	.word	0x40000400

0000505c <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    505c:	b580      	push	{r7, lr}
    505e:	b082      	sub	sp, #8
    5060:	af00      	add	r7, sp, #0
    5062:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    5064:	687b      	ldr	r3, [r7, #4]
    5066:	2280      	movs	r2, #128	; 0x80
    5068:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    506a:	687b      	ldr	r3, [r7, #4]
    506c:	2200      	movs	r2, #0
    506e:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    5070:	687b      	ldr	r3, [r7, #4]
    5072:	2201      	movs	r2, #1
    5074:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    5076:	687b      	ldr	r3, [r7, #4]
    5078:	2200      	movs	r2, #0
    507a:	70da      	strb	r2, [r3, #3]
}
    507c:	46c0      	nop			; (mov r8, r8)
    507e:	46bd      	mov	sp, r7
    5080:	b002      	add	sp, #8
    5082:	bd80      	pop	{r7, pc}

00005084 <tc_is_syncing>:
 * \retval false If the module has completed synchronization
 * \retval true  If the module synchronization is ongoing
 */
static inline bool tc_is_syncing(
		const struct tc_module *const module_inst)
{
    5084:	b580      	push	{r7, lr}
    5086:	b084      	sub	sp, #16
    5088:	af00      	add	r7, sp, #0
    508a:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    508c:	687b      	ldr	r3, [r7, #4]
    508e:	681b      	ldr	r3, [r3, #0]
    5090:	60fb      	str	r3, [r7, #12]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    5092:	68fb      	ldr	r3, [r7, #12]
    5094:	7bdb      	ldrb	r3, [r3, #15]
    5096:	b2db      	uxtb	r3, r3
    5098:	001a      	movs	r2, r3
    509a:	2380      	movs	r3, #128	; 0x80
    509c:	4013      	ands	r3, r2
    509e:	1e5a      	subs	r2, r3, #1
    50a0:	4193      	sbcs	r3, r2
    50a2:	b2db      	uxtb	r3, r3
#endif
}
    50a4:	0018      	movs	r0, r3
    50a6:	46bd      	mov	sp, r7
    50a8:	b004      	add	sp, #16
    50aa:	bd80      	pop	{r7, pc}

000050ac <_tc_get_inst_index>:
 *
 * \return Index of the given TC module instance.
 */
uint8_t _tc_get_inst_index(
		Tc *const hw)
{
    50ac:	b590      	push	{r4, r7, lr}
    50ae:	b08d      	sub	sp, #52	; 0x34
    50b0:	af00      	add	r7, sp, #0
    50b2:	6078      	str	r0, [r7, #4]
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
    50b4:	230c      	movs	r3, #12
    50b6:	18fb      	adds	r3, r7, r3
    50b8:	4a0f      	ldr	r2, [pc, #60]	; (50f8 <_tc_get_inst_index+0x4c>)
    50ba:	ca13      	ldmia	r2!, {r0, r1, r4}
    50bc:	c313      	stmia	r3!, {r0, r1, r4}
    50be:	ca13      	ldmia	r2!, {r0, r1, r4}
    50c0:	c313      	stmia	r3!, {r0, r1, r4}
    50c2:	ca03      	ldmia	r2!, {r0, r1}
    50c4:	c303      	stmia	r3!, {r0, r1}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    50c6:	2300      	movs	r3, #0
    50c8:	62fb      	str	r3, [r7, #44]	; 0x2c
    50ca:	e00d      	b.n	50e8 <_tc_get_inst_index+0x3c>
		if (hw == tc_modules[i]) {
    50cc:	230c      	movs	r3, #12
    50ce:	18fb      	adds	r3, r7, r3
    50d0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    50d2:	0092      	lsls	r2, r2, #2
    50d4:	58d2      	ldr	r2, [r2, r3]
    50d6:	687b      	ldr	r3, [r7, #4]
    50d8:	429a      	cmp	r2, r3
    50da:	d102      	bne.n	50e2 <_tc_get_inst_index+0x36>
			return i;
    50dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    50de:	b2db      	uxtb	r3, r3
    50e0:	e006      	b.n	50f0 <_tc_get_inst_index+0x44>
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    50e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    50e4:	3301      	adds	r3, #1
    50e6:	62fb      	str	r3, [r7, #44]	; 0x2c
    50e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    50ea:	2b07      	cmp	r3, #7
    50ec:	d9ee      	bls.n	50cc <_tc_get_inst_index+0x20>
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    50ee:	2300      	movs	r3, #0
}
    50f0:	0018      	movs	r0, r3
    50f2:	46bd      	mov	sp, r7
    50f4:	b00d      	add	sp, #52	; 0x34
    50f6:	bd90      	pop	{r4, r7, pc}
    50f8:	0000fd24 	.word	0x0000fd24

000050fc <tc_init>:
 */
enum status_code tc_init(
		struct tc_module *const module_inst,
		Tc *const hw,
		const struct tc_config *const config)
{
    50fc:	b590      	push	{r4, r7, lr}
    50fe:	b08f      	sub	sp, #60	; 0x3c
    5100:	af00      	add	r7, sp, #0
    5102:	60f8      	str	r0, [r7, #12]
    5104:	60b9      	str	r1, [r7, #8]
    5106:	607a      	str	r2, [r7, #4]
	Assert(module_inst);
	Assert(config);

	/* Temporary variable to hold all updates to the CTRLA
	 * register before they are written to it */
	uint16_t ctrla_tmp = 0;
    5108:	2336      	movs	r3, #54	; 0x36
    510a:	18fb      	adds	r3, r7, r3
    510c:	2200      	movs	r2, #0
    510e:	801a      	strh	r2, [r3, #0]
	/* Temporary variable to hold all updates to the CTRLBSET
	 * register before they are written to it */
	uint8_t ctrlbset_tmp = 0;
    5110:	2335      	movs	r3, #53	; 0x35
    5112:	18fb      	adds	r3, r7, r3
    5114:	2200      	movs	r2, #0
    5116:	701a      	strb	r2, [r3, #0]
	/* Temporary variable to hold all updates to the CTRLC
	 * register before they are written to it */
	uint8_t ctrlc_tmp = 0;
    5118:	2334      	movs	r3, #52	; 0x34
    511a:	18fb      	adds	r3, r7, r3
    511c:	2200      	movs	r2, #0
    511e:	701a      	strb	r2, [r3, #0]
	/* Temporary variable to hold TC instance number */
	uint8_t instance = _tc_get_inst_index(hw);
    5120:	2331      	movs	r3, #49	; 0x31
    5122:	18fc      	adds	r4, r7, r3
    5124:	68bb      	ldr	r3, [r7, #8]
    5126:	0018      	movs	r0, r3
    5128:	4bbe      	ldr	r3, [pc, #760]	; (5424 <tc_init+0x328>)
    512a:	4798      	blx	r3
    512c:	0003      	movs	r3, r0
    512e:	7023      	strb	r3, [r4, #0]

	/* Array of GLCK ID for different TC instances */
	uint8_t inst_gclk_id[] = TC_INST_GCLK_ID;
    5130:	2328      	movs	r3, #40	; 0x28
    5132:	18fa      	adds	r2, r7, r3
    5134:	4bbc      	ldr	r3, [pc, #752]	; (5428 <tc_init+0x32c>)
    5136:	0010      	movs	r0, r2
    5138:	0019      	movs	r1, r3
    513a:	2308      	movs	r3, #8
    513c:	001a      	movs	r2, r3
    513e:	4bbb      	ldr	r3, [pc, #748]	; (542c <tc_init+0x330>)
    5140:	4798      	blx	r3
	/* Array of PM APBC mask bit position for different TC instances */
	uint16_t inst_pm_apbmask[] = TC_INST_PM_APBCMASK;
    5142:	2318      	movs	r3, #24
    5144:	18fa      	adds	r2, r7, r3
    5146:	4bba      	ldr	r3, [pc, #744]	; (5430 <tc_init+0x334>)
    5148:	0010      	movs	r0, r2
    514a:	0019      	movs	r1, r3
    514c:	2310      	movs	r3, #16
    514e:	001a      	movs	r2, r3
    5150:	4bb6      	ldr	r3, [pc, #728]	; (542c <tc_init+0x330>)
    5152:	4798      	blx	r3
	struct system_pinmux_config pin_config;
	struct system_gclk_chan_config gclk_chan_config;

#if TC_ASYNC == true
	/* Initialize parameters */
	for (uint8_t i = 0; i < TC_CALLBACK_N; i++) {
    5154:	2333      	movs	r3, #51	; 0x33
    5156:	18fb      	adds	r3, r7, r3
    5158:	2200      	movs	r2, #0
    515a:	701a      	strb	r2, [r3, #0]
    515c:	e00e      	b.n	517c <tc_init+0x80>
		module_inst->callback[i]        = NULL;
    515e:	2333      	movs	r3, #51	; 0x33
    5160:	18fb      	adds	r3, r7, r3
    5162:	781a      	ldrb	r2, [r3, #0]
    5164:	68fb      	ldr	r3, [r7, #12]
    5166:	3202      	adds	r2, #2
    5168:	0092      	lsls	r2, r2, #2
    516a:	2100      	movs	r1, #0
    516c:	50d1      	str	r1, [r2, r3]
	struct system_pinmux_config pin_config;
	struct system_gclk_chan_config gclk_chan_config;

#if TC_ASYNC == true
	/* Initialize parameters */
	for (uint8_t i = 0; i < TC_CALLBACK_N; i++) {
    516e:	2333      	movs	r3, #51	; 0x33
    5170:	18fb      	adds	r3, r7, r3
    5172:	781a      	ldrb	r2, [r3, #0]
    5174:	2333      	movs	r3, #51	; 0x33
    5176:	18fb      	adds	r3, r7, r3
    5178:	3201      	adds	r2, #1
    517a:	701a      	strb	r2, [r3, #0]
    517c:	2333      	movs	r3, #51	; 0x33
    517e:	18fb      	adds	r3, r7, r3
    5180:	781b      	ldrb	r3, [r3, #0]
    5182:	2b03      	cmp	r3, #3
    5184:	d9eb      	bls.n	515e <tc_init+0x62>
		module_inst->callback[i]        = NULL;
	}
	module_inst->register_callback_mask     = 0x00;
    5186:	68fb      	ldr	r3, [r7, #12]
    5188:	2200      	movs	r2, #0
    518a:	761a      	strb	r2, [r3, #24]
	module_inst->enable_callback_mask       = 0x00;
    518c:	68fb      	ldr	r3, [r7, #12]
    518e:	2200      	movs	r2, #0
    5190:	765a      	strb	r2, [r3, #25]

	/* Register this instance for callbacks*/
	_tc_instances[instance] = module_inst;
    5192:	2331      	movs	r3, #49	; 0x31
    5194:	18fb      	adds	r3, r7, r3
    5196:	781a      	ldrb	r2, [r3, #0]
    5198:	4ba6      	ldr	r3, [pc, #664]	; (5434 <tc_init+0x338>)
    519a:	0092      	lsls	r2, r2, #2
    519c:	68f9      	ldr	r1, [r7, #12]
    519e:	50d1      	str	r1, [r2, r3]
#endif

	/* Associate the given device instance with the hardware module */
	module_inst->hw = hw;
    51a0:	68fb      	ldr	r3, [r7, #12]
    51a2:	68ba      	ldr	r2, [r7, #8]
    51a4:	601a      	str	r2, [r3, #0]
#else
	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    51a6:	687b      	ldr	r3, [r7, #4]
    51a8:	789b      	ldrb	r3, [r3, #2]
    51aa:	2b08      	cmp	r3, #8
    51ac:	d107      	bne.n	51be <tc_init+0xc2>
			((instance + TC_INSTANCE_OFFSET) & 0x01)) {
    51ae:	2331      	movs	r3, #49	; 0x31
    51b0:	18fb      	adds	r3, r7, r3
    51b2:	781b      	ldrb	r3, [r3, #0]
    51b4:	2201      	movs	r2, #1
    51b6:	4013      	ands	r3, r2
#else
	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    51b8:	d001      	beq.n	51be <tc_init+0xc2>
			((instance + TC_INSTANCE_OFFSET) & 0x01)) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    51ba:	2317      	movs	r3, #23
    51bc:	e1c3      	b.n	5546 <tc_init+0x44a>
#endif

	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;
    51be:	687b      	ldr	r3, [r7, #4]
    51c0:	789a      	ldrb	r2, [r3, #2]
    51c2:	68fb      	ldr	r3, [r7, #12]
    51c4:	711a      	strb	r2, [r3, #4]

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    51c6:	68bb      	ldr	r3, [r7, #8]
    51c8:	881b      	ldrh	r3, [r3, #0]
    51ca:	b29b      	uxth	r3, r3
    51cc:	001a      	movs	r2, r3
    51ce:	2301      	movs	r3, #1
    51d0:	4013      	ands	r3, r2
    51d2:	d001      	beq.n	51d8 <tc_init+0xdc>
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    51d4:	2305      	movs	r3, #5
    51d6:	e1b6      	b.n	5546 <tc_init+0x44a>
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    51d8:	68bb      	ldr	r3, [r7, #8]
    51da:	7bdb      	ldrb	r3, [r3, #15]
    51dc:	b2db      	uxtb	r3, r3
    51de:	001a      	movs	r2, r3
    51e0:	2310      	movs	r3, #16
    51e2:	4013      	ands	r3, r2
    51e4:	d001      	beq.n	51ea <tc_init+0xee>
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
    51e6:	231c      	movs	r3, #28
    51e8:	e1ad      	b.n	5546 <tc_init+0x44a>
	}

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_ENABLE) {
    51ea:	68bb      	ldr	r3, [r7, #8]
    51ec:	881b      	ldrh	r3, [r3, #0]
    51ee:	b29b      	uxth	r3, r3
    51f0:	001a      	movs	r2, r3
    51f2:	2302      	movs	r3, #2
    51f4:	4013      	ands	r3, r2
    51f6:	d001      	beq.n	51fc <tc_init+0x100>
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
    51f8:	231c      	movs	r3, #28
    51fa:	e1a4      	b.n	5546 <tc_init+0x44a>
	}

	/* Set up the TC PWM out pin for channel 0 */
	if (config->pwm_channel[0].enabled) {
    51fc:	687b      	ldr	r3, [r7, #4]
    51fe:	7c1b      	ldrb	r3, [r3, #16]
    5200:	2b00      	cmp	r3, #0
    5202:	d017      	beq.n	5234 <tc_init+0x138>
		system_pinmux_get_config_defaults(&pin_config);
    5204:	2314      	movs	r3, #20
    5206:	18fb      	adds	r3, r7, r3
    5208:	0018      	movs	r0, r3
    520a:	4b8b      	ldr	r3, [pc, #556]	; (5438 <tc_init+0x33c>)
    520c:	4798      	blx	r3
		pin_config.mux_position = config->pwm_channel[0].pin_mux;
    520e:	687b      	ldr	r3, [r7, #4]
    5210:	699b      	ldr	r3, [r3, #24]
    5212:	b2da      	uxtb	r2, r3
    5214:	2314      	movs	r3, #20
    5216:	18fb      	adds	r3, r7, r3
    5218:	701a      	strb	r2, [r3, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    521a:	2314      	movs	r3, #20
    521c:	18fb      	adds	r3, r7, r3
    521e:	2201      	movs	r2, #1
    5220:	705a      	strb	r2, [r3, #1]
		system_pinmux_pin_set_config(
				config->pwm_channel[0].pin_out, &pin_config);
    5222:	687b      	ldr	r3, [r7, #4]
    5224:	695b      	ldr	r3, [r3, #20]
	/* Set up the TC PWM out pin for channel 0 */
	if (config->pwm_channel[0].enabled) {
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[0].pin_mux;
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
		system_pinmux_pin_set_config(
    5226:	b2db      	uxtb	r3, r3
    5228:	2214      	movs	r2, #20
    522a:	18ba      	adds	r2, r7, r2
    522c:	0011      	movs	r1, r2
    522e:	0018      	movs	r0, r3
    5230:	4b82      	ldr	r3, [pc, #520]	; (543c <tc_init+0x340>)
    5232:	4798      	blx	r3
				config->pwm_channel[0].pin_out, &pin_config);
	}

	/* Set up the TC PWM out pin for channel 1 */
	if (config->pwm_channel[1].enabled) {
    5234:	687b      	ldr	r3, [r7, #4]
    5236:	7f1b      	ldrb	r3, [r3, #28]
    5238:	2b00      	cmp	r3, #0
    523a:	d017      	beq.n	526c <tc_init+0x170>
		system_pinmux_get_config_defaults(&pin_config);
    523c:	2314      	movs	r3, #20
    523e:	18fb      	adds	r3, r7, r3
    5240:	0018      	movs	r0, r3
    5242:	4b7d      	ldr	r3, [pc, #500]	; (5438 <tc_init+0x33c>)
    5244:	4798      	blx	r3
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
    5246:	687b      	ldr	r3, [r7, #4]
    5248:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    524a:	b2da      	uxtb	r2, r3
    524c:	2314      	movs	r3, #20
    524e:	18fb      	adds	r3, r7, r3
    5250:	701a      	strb	r2, [r3, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    5252:	2314      	movs	r3, #20
    5254:	18fb      	adds	r3, r7, r3
    5256:	2201      	movs	r2, #1
    5258:	705a      	strb	r2, [r3, #1]
		system_pinmux_pin_set_config(
				config->pwm_channel[1].pin_out, &pin_config);
    525a:	687b      	ldr	r3, [r7, #4]
    525c:	6a1b      	ldr	r3, [r3, #32]
	/* Set up the TC PWM out pin for channel 1 */
	if (config->pwm_channel[1].enabled) {
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
		system_pinmux_pin_set_config(
    525e:	b2db      	uxtb	r3, r3
    5260:	2214      	movs	r2, #20
    5262:	18ba      	adds	r2, r7, r2
    5264:	0011      	movs	r1, r2
    5266:	0018      	movs	r0, r3
    5268:	4b74      	ldr	r3, [pc, #464]	; (543c <tc_init+0x340>)
    526a:	4798      	blx	r3
				config->pwm_channel[1].pin_out, &pin_config);
	}

	/* Enable the user interface clock in the PM */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
			inst_pm_apbmask[instance]);
    526c:	2331      	movs	r3, #49	; 0x31
    526e:	18fb      	adds	r3, r7, r3
    5270:	781a      	ldrb	r2, [r3, #0]
    5272:	2318      	movs	r3, #24
    5274:	18fb      	adds	r3, r7, r3
    5276:	0052      	lsls	r2, r2, #1
    5278:	5ad3      	ldrh	r3, [r2, r3]
		system_pinmux_pin_set_config(
				config->pwm_channel[1].pin_out, &pin_config);
	}

	/* Enable the user interface clock in the PM */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    527a:	0019      	movs	r1, r3
    527c:	2002      	movs	r0, #2
    527e:	4b70      	ldr	r3, [pc, #448]	; (5440 <tc_init+0x344>)
    5280:	4798      	blx	r3
			inst_pm_apbmask[instance]);

	/* Enable the slave counter if counter_size is 32-bit */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT))
    5282:	687b      	ldr	r3, [r7, #4]
    5284:	789b      	ldrb	r3, [r3, #2]
    5286:	2b08      	cmp	r3, #8
    5288:	d10b      	bne.n	52a2 <tc_init+0x1a6>
	{
		/* Enable the user interface clock in the PM */
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
				inst_pm_apbmask[instance + 1]);
    528a:	2331      	movs	r3, #49	; 0x31
    528c:	18fb      	adds	r3, r7, r3
    528e:	781b      	ldrb	r3, [r3, #0]
    5290:	1c5a      	adds	r2, r3, #1
    5292:	2318      	movs	r3, #24
    5294:	18fb      	adds	r3, r7, r3
    5296:	0052      	lsls	r2, r2, #1
    5298:	5ad3      	ldrh	r3, [r2, r3]

	/* Enable the slave counter if counter_size is 32-bit */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT))
	{
		/* Enable the user interface clock in the PM */
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    529a:	0019      	movs	r1, r3
    529c:	2002      	movs	r0, #2
    529e:	4b68      	ldr	r3, [pc, #416]	; (5440 <tc_init+0x344>)
    52a0:	4798      	blx	r3
				inst_pm_apbmask[instance + 1]);
	}

	/* Setup clock for module */
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
    52a2:	2310      	movs	r3, #16
    52a4:	18fb      	adds	r3, r7, r3
    52a6:	0018      	movs	r0, r3
    52a8:	4b66      	ldr	r3, [pc, #408]	; (5444 <tc_init+0x348>)
    52aa:	4798      	blx	r3
	gclk_chan_config.source_generator = config->clock_source;
    52ac:	687b      	ldr	r3, [r7, #4]
    52ae:	781a      	ldrb	r2, [r3, #0]
    52b0:	2310      	movs	r3, #16
    52b2:	18fb      	adds	r3, r7, r3
    52b4:	701a      	strb	r2, [r3, #0]
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
    52b6:	2331      	movs	r3, #49	; 0x31
    52b8:	18fb      	adds	r3, r7, r3
    52ba:	781b      	ldrb	r3, [r3, #0]
    52bc:	2228      	movs	r2, #40	; 0x28
    52be:	18ba      	adds	r2, r7, r2
    52c0:	5cd3      	ldrb	r3, [r2, r3]
    52c2:	2210      	movs	r2, #16
    52c4:	18ba      	adds	r2, r7, r2
    52c6:	0011      	movs	r1, r2
    52c8:	0018      	movs	r0, r3
    52ca:	4b5f      	ldr	r3, [pc, #380]	; (5448 <tc_init+0x34c>)
    52cc:	4798      	blx	r3
	system_gclk_chan_enable(inst_gclk_id[instance]);
    52ce:	2331      	movs	r3, #49	; 0x31
    52d0:	18fb      	adds	r3, r7, r3
    52d2:	781b      	ldrb	r3, [r3, #0]
    52d4:	2228      	movs	r2, #40	; 0x28
    52d6:	18ba      	adds	r2, r7, r2
    52d8:	5cd3      	ldrb	r3, [r2, r3]
    52da:	0018      	movs	r0, r3
    52dc:	4b5b      	ldr	r3, [pc, #364]	; (544c <tc_init+0x350>)
    52de:	4798      	blx	r3

	/* Set ctrla register */
	ctrla_tmp =
			(uint32_t)config->counter_size |
    52e0:	687b      	ldr	r3, [r7, #4]
    52e2:	789a      	ldrb	r2, [r3, #2]
			(uint32_t)config->wave_generation |
    52e4:	687b      	ldr	r3, [r7, #4]
    52e6:	799b      	ldrb	r3, [r3, #6]
	gclk_chan_config.source_generator = config->clock_source;
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
	system_gclk_chan_enable(inst_gclk_id[instance]);

	/* Set ctrla register */
	ctrla_tmp =
    52e8:	4313      	orrs	r3, r2
    52ea:	b2db      	uxtb	r3, r3
    52ec:	b29a      	uxth	r2, r3
			(uint32_t)config->counter_size |
			(uint32_t)config->wave_generation |
			(uint32_t)config->reload_action |
    52ee:	687b      	ldr	r3, [r7, #4]
    52f0:	891b      	ldrh	r3, [r3, #8]
	gclk_chan_config.source_generator = config->clock_source;
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
	system_gclk_chan_enable(inst_gclk_id[instance]);

	/* Set ctrla register */
	ctrla_tmp =
    52f2:	4313      	orrs	r3, r2
    52f4:	b299      	uxth	r1, r3
			(uint32_t)config->counter_size |
			(uint32_t)config->wave_generation |
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;
    52f6:	687b      	ldr	r3, [r7, #4]
    52f8:	889a      	ldrh	r2, [r3, #4]
	gclk_chan_config.source_generator = config->clock_source;
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
	system_gclk_chan_enable(inst_gclk_id[instance]);

	/* Set ctrla register */
	ctrla_tmp =
    52fa:	2336      	movs	r3, #54	; 0x36
    52fc:	18fb      	adds	r3, r7, r3
    52fe:	430a      	orrs	r2, r1
    5300:	801a      	strh	r2, [r3, #0]
			(uint32_t)config->counter_size |
			(uint32_t)config->wave_generation |
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;

	if (config->run_in_standby) {
    5302:	687b      	ldr	r3, [r7, #4]
    5304:	785b      	ldrb	r3, [r3, #1]
    5306:	2b00      	cmp	r3, #0
    5308:	d008      	beq.n	531c <tc_init+0x220>
		ctrla_tmp |= TC_CTRLA_RUNSTDBY;
    530a:	2336      	movs	r3, #54	; 0x36
    530c:	18fb      	adds	r3, r7, r3
    530e:	2236      	movs	r2, #54	; 0x36
    5310:	18ba      	adds	r2, r7, r2
    5312:	8812      	ldrh	r2, [r2, #0]
    5314:	2180      	movs	r1, #128	; 0x80
    5316:	0109      	lsls	r1, r1, #4
    5318:	430a      	orrs	r2, r1
    531a:	801a      	strh	r2, [r3, #0]
	}

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    531c:	46c0      	nop			; (mov r8, r8)
    531e:	68fb      	ldr	r3, [r7, #12]
    5320:	0018      	movs	r0, r3
    5322:	4b4b      	ldr	r3, [pc, #300]	; (5450 <tc_init+0x354>)
    5324:	4798      	blx	r3
    5326:	1e03      	subs	r3, r0, #0
    5328:	d1f9      	bne.n	531e <tc_init+0x222>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLA.reg = ctrla_tmp;
    532a:	68bb      	ldr	r3, [r7, #8]
    532c:	2236      	movs	r2, #54	; 0x36
    532e:	18ba      	adds	r2, r7, r2
    5330:	8812      	ldrh	r2, [r2, #0]
    5332:	801a      	strh	r2, [r3, #0]

	/* Set ctrlb register */
	if (config->oneshot) {
    5334:	687b      	ldr	r3, [r7, #4]
    5336:	7b5b      	ldrb	r3, [r3, #13]
    5338:	2b00      	cmp	r3, #0
    533a:	d003      	beq.n	5344 <tc_init+0x248>
		ctrlbset_tmp = TC_CTRLBSET_ONESHOT;
    533c:	2335      	movs	r3, #53	; 0x35
    533e:	18fb      	adds	r3, r7, r3
    5340:	2204      	movs	r2, #4
    5342:	701a      	strb	r2, [r3, #0]
	}

	if (config->count_direction) {
    5344:	687b      	ldr	r3, [r7, #4]
    5346:	7b9b      	ldrb	r3, [r3, #14]
    5348:	2b00      	cmp	r3, #0
    534a:	d007      	beq.n	535c <tc_init+0x260>
		ctrlbset_tmp |= TC_CTRLBSET_DIR;
    534c:	2335      	movs	r3, #53	; 0x35
    534e:	18fb      	adds	r3, r7, r3
    5350:	2235      	movs	r2, #53	; 0x35
    5352:	18ba      	adds	r2, r7, r2
    5354:	7812      	ldrb	r2, [r2, #0]
    5356:	2101      	movs	r1, #1
    5358:	430a      	orrs	r2, r1
    535a:	701a      	strb	r2, [r3, #0]
	}

	/* Clear old ctrlb configuration */
	while (tc_is_syncing(module_inst)) {
    535c:	46c0      	nop			; (mov r8, r8)
    535e:	68fb      	ldr	r3, [r7, #12]
    5360:	0018      	movs	r0, r3
    5362:	4b3b      	ldr	r3, [pc, #236]	; (5450 <tc_init+0x354>)
    5364:	4798      	blx	r3
    5366:	1e03      	subs	r3, r0, #0
    5368:	d1f9      	bne.n	535e <tc_init+0x262>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLBCLR.reg = 0xFF;
    536a:	68bb      	ldr	r3, [r7, #8]
    536c:	22ff      	movs	r2, #255	; 0xff
    536e:	711a      	strb	r2, [r3, #4]

	/* Check if we actually need to go into a wait state. */
	if (ctrlbset_tmp) {
    5370:	2335      	movs	r3, #53	; 0x35
    5372:	18fb      	adds	r3, r7, r3
    5374:	781b      	ldrb	r3, [r3, #0]
    5376:	2b00      	cmp	r3, #0
    5378:	d00b      	beq.n	5392 <tc_init+0x296>
		while (tc_is_syncing(module_inst)) {
    537a:	46c0      	nop			; (mov r8, r8)
    537c:	68fb      	ldr	r3, [r7, #12]
    537e:	0018      	movs	r0, r3
    5380:	4b33      	ldr	r3, [pc, #204]	; (5450 <tc_init+0x354>)
    5382:	4798      	blx	r3
    5384:	1e03      	subs	r3, r0, #0
    5386:	d1f9      	bne.n	537c <tc_init+0x280>
			/* Wait for sync */
		}
		/* Write configuration to register */
		hw->COUNT8.CTRLBSET.reg = ctrlbset_tmp;
    5388:	68bb      	ldr	r3, [r7, #8]
    538a:	2235      	movs	r2, #53	; 0x35
    538c:	18ba      	adds	r2, r7, r2
    538e:	7812      	ldrb	r2, [r2, #0]
    5390:	715a      	strb	r2, [r3, #5]
	}

	/* Set ctrlc register*/
	ctrlc_tmp = config->waveform_invert_output;
    5392:	2334      	movs	r3, #52	; 0x34
    5394:	18fb      	adds	r3, r7, r3
    5396:	687a      	ldr	r2, [r7, #4]
    5398:	7a92      	ldrb	r2, [r2, #10]
    539a:	701a      	strb	r2, [r3, #0]
	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
    539c:	2332      	movs	r3, #50	; 0x32
    539e:	18fb      	adds	r3, r7, r3
    53a0:	2200      	movs	r2, #0
    53a2:	701a      	strb	r2, [r3, #0]
    53a4:	e01c      	b.n	53e0 <tc_init+0x2e4>
		if (config->enable_capture_on_channel[i] == true) {
    53a6:	2332      	movs	r3, #50	; 0x32
    53a8:	18fb      	adds	r3, r7, r3
    53aa:	781b      	ldrb	r3, [r3, #0]
    53ac:	687a      	ldr	r2, [r7, #4]
    53ae:	18d3      	adds	r3, r2, r3
    53b0:	7adb      	ldrb	r3, [r3, #11]
    53b2:	2b00      	cmp	r3, #0
    53b4:	d00d      	beq.n	53d2 <tc_init+0x2d6>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
    53b6:	2332      	movs	r3, #50	; 0x32
    53b8:	18fb      	adds	r3, r7, r3
    53ba:	781b      	ldrb	r3, [r3, #0]
    53bc:	2210      	movs	r2, #16
    53be:	409a      	lsls	r2, r3
    53c0:	0013      	movs	r3, r2
    53c2:	b2d9      	uxtb	r1, r3
    53c4:	2334      	movs	r3, #52	; 0x34
    53c6:	18fb      	adds	r3, r7, r3
    53c8:	2234      	movs	r2, #52	; 0x34
    53ca:	18ba      	adds	r2, r7, r2
    53cc:	7812      	ldrb	r2, [r2, #0]
    53ce:	430a      	orrs	r2, r1
    53d0:	701a      	strb	r2, [r3, #0]
		hw->COUNT8.CTRLBSET.reg = ctrlbset_tmp;
	}

	/* Set ctrlc register*/
	ctrlc_tmp = config->waveform_invert_output;
	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
    53d2:	2332      	movs	r3, #50	; 0x32
    53d4:	18fb      	adds	r3, r7, r3
    53d6:	781a      	ldrb	r2, [r3, #0]
    53d8:	2332      	movs	r3, #50	; 0x32
    53da:	18fb      	adds	r3, r7, r3
    53dc:	3201      	adds	r2, #1
    53de:	701a      	strb	r2, [r3, #0]
    53e0:	2332      	movs	r3, #50	; 0x32
    53e2:	18fb      	adds	r3, r7, r3
    53e4:	781b      	ldrb	r3, [r3, #0]
    53e6:	2b01      	cmp	r3, #1
    53e8:	d9dd      	bls.n	53a6 <tc_init+0x2aa>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
		}
	}

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    53ea:	46c0      	nop			; (mov r8, r8)
    53ec:	68fb      	ldr	r3, [r7, #12]
    53ee:	0018      	movs	r0, r3
    53f0:	4b17      	ldr	r3, [pc, #92]	; (5450 <tc_init+0x354>)
    53f2:	4798      	blx	r3
    53f4:	1e03      	subs	r3, r0, #0
    53f6:	d1f9      	bne.n	53ec <tc_init+0x2f0>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLC.reg = ctrlc_tmp;
    53f8:	68bb      	ldr	r3, [r7, #8]
    53fa:	2234      	movs	r2, #52	; 0x34
    53fc:	18ba      	adds	r2, r7, r2
    53fe:	7812      	ldrb	r2, [r2, #0]
    5400:	719a      	strb	r2, [r3, #6]

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    5402:	46c0      	nop			; (mov r8, r8)
    5404:	68fb      	ldr	r3, [r7, #12]
    5406:	0018      	movs	r0, r3
    5408:	4b11      	ldr	r3, [pc, #68]	; (5450 <tc_init+0x354>)
    540a:	4798      	blx	r3
    540c:	1e03      	subs	r3, r0, #0
    540e:	d1f9      	bne.n	5404 <tc_init+0x308>
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
    5410:	68fb      	ldr	r3, [r7, #12]
    5412:	791b      	ldrb	r3, [r3, #4]
    5414:	2b04      	cmp	r3, #4
    5416:	d01d      	beq.n	5454 <tc_init+0x358>
    5418:	2b08      	cmp	r3, #8
    541a:	d100      	bne.n	541e <tc_init+0x322>
    541c:	e06f      	b.n	54fe <tc_init+0x402>
    541e:	2b00      	cmp	r3, #0
    5420:	d04a      	beq.n	54b8 <tc_init+0x3bc>
    5422:	e08f      	b.n	5544 <tc_init+0x448>
    5424:	000050ad 	.word	0x000050ad
    5428:	0000fd44 	.word	0x0000fd44
    542c:	0000fc43 	.word	0x0000fc43
    5430:	0000fd4c 	.word	0x0000fd4c
    5434:	20002e70 	.word	0x20002e70
    5438:	0000505d 	.word	0x0000505d
    543c:	00004d95 	.word	0x00004d95
    5440:	00005001 	.word	0x00005001
    5444:	00004fe9 	.word	0x00004fe9
    5448:	00004aa9 	.word	0x00004aa9
    544c:	00004aed 	.word	0x00004aed
    5450:	00005085 	.word	0x00005085
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
    5454:	46c0      	nop			; (mov r8, r8)
    5456:	68fb      	ldr	r3, [r7, #12]
    5458:	0018      	movs	r0, r3
    545a:	4b3d      	ldr	r3, [pc, #244]	; (5550 <tc_init+0x454>)
    545c:	4798      	blx	r3
    545e:	1e03      	subs	r3, r0, #0
    5460:	d1f9      	bne.n	5456 <tc_init+0x35a>
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
					config->counter_8_bit.value;
    5462:	687b      	ldr	r3, [r7, #4]
    5464:	2228      	movs	r2, #40	; 0x28
    5466:	5c9a      	ldrb	r2, [r3, r2]
		case TC_COUNTER_SIZE_8BIT:
			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.COUNT.reg =
    5468:	68bb      	ldr	r3, [r7, #8]
    546a:	741a      	strb	r2, [r3, #16]
					config->counter_8_bit.value;


			while (tc_is_syncing(module_inst)) {
    546c:	46c0      	nop			; (mov r8, r8)
    546e:	68fb      	ldr	r3, [r7, #12]
    5470:	0018      	movs	r0, r3
    5472:	4b37      	ldr	r3, [pc, #220]	; (5550 <tc_init+0x454>)
    5474:	4798      	blx	r3
    5476:	1e03      	subs	r3, r0, #0
    5478:	d1f9      	bne.n	546e <tc_init+0x372>
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
					config->counter_8_bit.period;
    547a:	687b      	ldr	r3, [r7, #4]
    547c:	2229      	movs	r2, #41	; 0x29
    547e:	5c9a      	ldrb	r2, [r3, r2]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.PER.reg =
    5480:	68bb      	ldr	r3, [r7, #8]
    5482:	751a      	strb	r2, [r3, #20]
					config->counter_8_bit.period;

			while (tc_is_syncing(module_inst)) {
    5484:	46c0      	nop			; (mov r8, r8)
    5486:	68fb      	ldr	r3, [r7, #12]
    5488:	0018      	movs	r0, r3
    548a:	4b31      	ldr	r3, [pc, #196]	; (5550 <tc_init+0x454>)
    548c:	4798      	blx	r3
    548e:	1e03      	subs	r3, r0, #0
    5490:	d1f9      	bne.n	5486 <tc_init+0x38a>
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
					config->counter_8_bit.compare_capture_channel[0];
    5492:	687b      	ldr	r3, [r7, #4]
    5494:	222a      	movs	r2, #42	; 0x2a
    5496:	5c9a      	ldrb	r2, [r3, r2]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[0].reg =
    5498:	68bb      	ldr	r3, [r7, #8]
    549a:	761a      	strb	r2, [r3, #24]
					config->counter_8_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    549c:	46c0      	nop			; (mov r8, r8)
    549e:	68fb      	ldr	r3, [r7, #12]
    54a0:	0018      	movs	r0, r3
    54a2:	4b2b      	ldr	r3, [pc, #172]	; (5550 <tc_init+0x454>)
    54a4:	4798      	blx	r3
    54a6:	1e03      	subs	r3, r0, #0
    54a8:	d1f9      	bne.n	549e <tc_init+0x3a2>
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
					config->counter_8_bit.compare_capture_channel[1];
    54aa:	687b      	ldr	r3, [r7, #4]
    54ac:	222b      	movs	r2, #43	; 0x2b
    54ae:	5c9a      	ldrb	r2, [r3, r2]

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT8.CC[1].reg =
    54b0:	68bb      	ldr	r3, [r7, #8]
    54b2:	765a      	strb	r2, [r3, #25]
					config->counter_8_bit.compare_capture_channel[1];

			return STATUS_OK;
    54b4:	2300      	movs	r3, #0
    54b6:	e046      	b.n	5546 <tc_init+0x44a>

		case TC_COUNTER_SIZE_16BIT:
			while (tc_is_syncing(module_inst)) {
    54b8:	46c0      	nop			; (mov r8, r8)
    54ba:	68fb      	ldr	r3, [r7, #12]
    54bc:	0018      	movs	r0, r3
    54be:	4b24      	ldr	r3, [pc, #144]	; (5550 <tc_init+0x454>)
    54c0:	4798      	blx	r3
    54c2:	1e03      	subs	r3, r0, #0
    54c4:	d1f9      	bne.n	54ba <tc_init+0x3be>
				/* Wait for sync */
			}

			hw->COUNT16.COUNT.reg
				= config->counter_16_bit.value;
    54c6:	687b      	ldr	r3, [r7, #4]
    54c8:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
    54ca:	68bb      	ldr	r3, [r7, #8]
    54cc:	821a      	strh	r2, [r3, #16]

			while (tc_is_syncing(module_inst)) {
    54ce:	46c0      	nop			; (mov r8, r8)
    54d0:	68fb      	ldr	r3, [r7, #12]
    54d2:	0018      	movs	r0, r3
    54d4:	4b1e      	ldr	r3, [pc, #120]	; (5550 <tc_init+0x454>)
    54d6:	4798      	blx	r3
    54d8:	1e03      	subs	r3, r0, #0
    54da:	d1f9      	bne.n	54d0 <tc_init+0x3d4>
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
					config->counter_16_bit.compare_capture_channel[0];
    54dc:	687b      	ldr	r3, [r7, #4]
    54de:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[0].reg =
    54e0:	68bb      	ldr	r3, [r7, #8]
    54e2:	831a      	strh	r2, [r3, #24]
					config->counter_16_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    54e4:	46c0      	nop			; (mov r8, r8)
    54e6:	68fb      	ldr	r3, [r7, #12]
    54e8:	0018      	movs	r0, r3
    54ea:	4b19      	ldr	r3, [pc, #100]	; (5550 <tc_init+0x454>)
    54ec:	4798      	blx	r3
    54ee:	1e03      	subs	r3, r0, #0
    54f0:	d1f9      	bne.n	54e6 <tc_init+0x3ea>
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
					config->counter_16_bit.compare_capture_channel[1];
    54f2:	687b      	ldr	r3, [r7, #4]
    54f4:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT16.CC[1].reg =
    54f6:	68bb      	ldr	r3, [r7, #8]
    54f8:	835a      	strh	r2, [r3, #26]
					config->counter_16_bit.compare_capture_channel[1];

			return STATUS_OK;
    54fa:	2300      	movs	r3, #0
    54fc:	e023      	b.n	5546 <tc_init+0x44a>

		case TC_COUNTER_SIZE_32BIT:
			while (tc_is_syncing(module_inst)) {
    54fe:	46c0      	nop			; (mov r8, r8)
    5500:	68fb      	ldr	r3, [r7, #12]
    5502:	0018      	movs	r0, r3
    5504:	4b12      	ldr	r3, [pc, #72]	; (5550 <tc_init+0x454>)
    5506:	4798      	blx	r3
    5508:	1e03      	subs	r3, r0, #0
    550a:	d1f9      	bne.n	5500 <tc_init+0x404>
				/* Wait for sync */
			}

			hw->COUNT32.COUNT.reg
				= config->counter_32_bit.value;
    550c:	687b      	ldr	r3, [r7, #4]
    550e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    5510:	68bb      	ldr	r3, [r7, #8]
    5512:	611a      	str	r2, [r3, #16]

			while (tc_is_syncing(module_inst)) {
    5514:	46c0      	nop			; (mov r8, r8)
    5516:	68fb      	ldr	r3, [r7, #12]
    5518:	0018      	movs	r0, r3
    551a:	4b0d      	ldr	r3, [pc, #52]	; (5550 <tc_init+0x454>)
    551c:	4798      	blx	r3
    551e:	1e03      	subs	r3, r0, #0
    5520:	d1f9      	bne.n	5516 <tc_init+0x41a>
				/* Wait for sync */
			}

			hw->COUNT32.CC[0].reg =
					config->counter_32_bit.compare_capture_channel[0];
    5522:	687b      	ldr	r3, [r7, #4]
    5524:	6ada      	ldr	r2, [r3, #44]	; 0x2c

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT32.CC[0].reg =
    5526:	68bb      	ldr	r3, [r7, #8]
    5528:	619a      	str	r2, [r3, #24]
					config->counter_32_bit.compare_capture_channel[0];

			while (tc_is_syncing(module_inst)) {
    552a:	46c0      	nop			; (mov r8, r8)
    552c:	68fb      	ldr	r3, [r7, #12]
    552e:	0018      	movs	r0, r3
    5530:	4b07      	ldr	r3, [pc, #28]	; (5550 <tc_init+0x454>)
    5532:	4798      	blx	r3
    5534:	1e03      	subs	r3, r0, #0
    5536:	d1f9      	bne.n	552c <tc_init+0x430>
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
					config->counter_32_bit.compare_capture_channel[1];
    5538:	687b      	ldr	r3, [r7, #4]
    553a:	6b1a      	ldr	r2, [r3, #48]	; 0x30

			while (tc_is_syncing(module_inst)) {
				/* Wait for sync */
			}

			hw->COUNT32.CC[1].reg =
    553c:	68bb      	ldr	r3, [r7, #8]
    553e:	61da      	str	r2, [r3, #28]
					config->counter_32_bit.compare_capture_channel[1];

			return STATUS_OK;
    5540:	2300      	movs	r3, #0
    5542:	e000      	b.n	5546 <tc_init+0x44a>
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
    5544:	2317      	movs	r3, #23
}
    5546:	0018      	movs	r0, r3
    5548:	46bd      	mov	sp, r7
    554a:	b00f      	add	sp, #60	; 0x3c
    554c:	bd90      	pop	{r4, r7, pc}
    554e:	46c0      	nop			; (mov r8, r8)
    5550:	00005085 	.word	0x00005085

00005554 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
    5554:	b580      	push	{r7, lr}
    5556:	b082      	sub	sp, #8
    5558:	af00      	add	r7, sp, #0
        uint32_t *pSrc, *pDest;

        /* Initialize the relocate segment */
        pSrc = &_etext;
    555a:	4b19      	ldr	r3, [pc, #100]	; (55c0 <Reset_Handler+0x6c>)
    555c:	607b      	str	r3, [r7, #4]
        pDest = &_srelocate;
    555e:	4b19      	ldr	r3, [pc, #100]	; (55c4 <Reset_Handler+0x70>)
    5560:	603b      	str	r3, [r7, #0]

        if (pSrc != pDest) {
    5562:	687a      	ldr	r2, [r7, #4]
    5564:	683b      	ldr	r3, [r7, #0]
    5566:	429a      	cmp	r2, r3
    5568:	d00c      	beq.n	5584 <Reset_Handler+0x30>
                for (; pDest < &_erelocate;) {
    556a:	e007      	b.n	557c <Reset_Handler+0x28>
                        *pDest++ = *pSrc++;
    556c:	683b      	ldr	r3, [r7, #0]
    556e:	1d1a      	adds	r2, r3, #4
    5570:	603a      	str	r2, [r7, #0]
    5572:	687a      	ldr	r2, [r7, #4]
    5574:	1d11      	adds	r1, r2, #4
    5576:	6079      	str	r1, [r7, #4]
    5578:	6812      	ldr	r2, [r2, #0]
    557a:	601a      	str	r2, [r3, #0]
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
    557c:	683a      	ldr	r2, [r7, #0]
    557e:	4b12      	ldr	r3, [pc, #72]	; (55c8 <Reset_Handler+0x74>)
    5580:	429a      	cmp	r2, r3
    5582:	d3f3      	bcc.n	556c <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    5584:	4b11      	ldr	r3, [pc, #68]	; (55cc <Reset_Handler+0x78>)
    5586:	603b      	str	r3, [r7, #0]
    5588:	e004      	b.n	5594 <Reset_Handler+0x40>
                *pDest++ = 0;
    558a:	683b      	ldr	r3, [r7, #0]
    558c:	1d1a      	adds	r2, r3, #4
    558e:	603a      	str	r2, [r7, #0]
    5590:	2200      	movs	r2, #0
    5592:	601a      	str	r2, [r3, #0]
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
    5594:	683a      	ldr	r2, [r7, #0]
    5596:	4b0e      	ldr	r3, [pc, #56]	; (55d0 <Reset_Handler+0x7c>)
    5598:	429a      	cmp	r2, r3
    559a:	d3f6      	bcc.n	558a <Reset_Handler+0x36>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
    559c:	4b0d      	ldr	r3, [pc, #52]	; (55d4 <Reset_Handler+0x80>)
    559e:	607b      	str	r3, [r7, #4]
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
    55a0:	4b0d      	ldr	r3, [pc, #52]	; (55d8 <Reset_Handler+0x84>)
    55a2:	687a      	ldr	r2, [r7, #4]
    55a4:	21ff      	movs	r1, #255	; 0xff
    55a6:	438a      	bics	r2, r1
    55a8:	609a      	str	r2, [r3, #8]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
    55aa:	4a0c      	ldr	r2, [pc, #48]	; (55dc <Reset_Handler+0x88>)
    55ac:	6853      	ldr	r3, [r2, #4]
    55ae:	2180      	movs	r1, #128	; 0x80
    55b0:	430b      	orrs	r3, r1
    55b2:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
    55b4:	4b0a      	ldr	r3, [pc, #40]	; (55e0 <Reset_Handler+0x8c>)
    55b6:	4798      	blx	r3

        /* Branch to main function */
        main();
    55b8:	4b0a      	ldr	r3, [pc, #40]	; (55e4 <Reset_Handler+0x90>)
    55ba:	4798      	blx	r3

        /* Infinite loop */
        while (1);
    55bc:	e7fe      	b.n	55bc <Reset_Handler+0x68>
    55be:	46c0      	nop			; (mov r8, r8)
    55c0:	0000fe18 	.word	0x0000fe18
    55c4:	20000000 	.word	0x20000000
    55c8:	20000048 	.word	0x20000048
    55cc:	20000048 	.word	0x20000048
    55d0:	20003f44 	.word	0x20003f44
    55d4:	00000000 	.word	0x00000000
    55d8:	e000ed00 	.word	0xe000ed00
    55dc:	41004000 	.word	0x41004000
    55e0:	0000fbd9 	.word	0x0000fbd9
    55e4:	0000f845 	.word	0x0000f845

000055e8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    55e8:	b580      	push	{r7, lr}
    55ea:	af00      	add	r7, sp, #0
        while (1) {
        }
    55ec:	e7fe      	b.n	55ec <Dummy_Handler+0x4>
    55ee:	46c0      	nop			; (mov r8, r8)

000055f0 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
    55f0:	b580      	push	{r7, lr}
    55f2:	b082      	sub	sp, #8
    55f4:	af00      	add	r7, sp, #0
    55f6:	0002      	movs	r2, r0
    55f8:	1dbb      	adds	r3, r7, #6
    55fa:	801a      	strh	r2, [r3, #0]
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
    55fc:	1dbb      	adds	r3, r7, #6
    55fe:	881b      	ldrh	r3, [r3, #0]
    5600:	021b      	lsls	r3, r3, #8
    5602:	b21a      	sxth	r2, r3
    5604:	1dbb      	adds	r3, r7, #6
    5606:	881b      	ldrh	r3, [r3, #0]
    5608:	0a1b      	lsrs	r3, r3, #8
    560a:	b29b      	uxth	r3, r3
    560c:	b21b      	sxth	r3, r3
    560e:	4313      	orrs	r3, r2
    5610:	b21b      	sxth	r3, r3
    5612:	b29b      	uxth	r3, r3
}
    5614:	0018      	movs	r0, r3
    5616:	46bd      	mov	sp, r7
    5618:	b002      	add	sp, #8
    561a:	bd80      	pop	{r7, pc}

0000561c <lwip_ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
lwip_ntohs(u16_t n)
{
    561c:	b580      	push	{r7, lr}
    561e:	b082      	sub	sp, #8
    5620:	af00      	add	r7, sp, #0
    5622:	0002      	movs	r2, r0
    5624:	1dbb      	adds	r3, r7, #6
    5626:	801a      	strh	r2, [r3, #0]
  return lwip_htons(n);
    5628:	1dbb      	adds	r3, r7, #6
    562a:	881b      	ldrh	r3, [r3, #0]
    562c:	0018      	movs	r0, r3
    562e:	4b03      	ldr	r3, [pc, #12]	; (563c <lwip_ntohs+0x20>)
    5630:	4798      	blx	r3
    5632:	0003      	movs	r3, r0
}
    5634:	0018      	movs	r0, r3
    5636:	46bd      	mov	sp, r7
    5638:	b002      	add	sp, #8
    563a:	bd80      	pop	{r7, pc}
    563c:	000055f1 	.word	0x000055f1

00005640 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
    5640:	b580      	push	{r7, lr}
    5642:	b082      	sub	sp, #8
    5644:	af00      	add	r7, sp, #0
    5646:	6078      	str	r0, [r7, #4]
  return ((n & 0xff) << 24) |
    5648:	687b      	ldr	r3, [r7, #4]
    564a:	061a      	lsls	r2, r3, #24
    ((n & 0xff00) << 8) |
    564c:	687b      	ldr	r3, [r7, #4]
    564e:	0219      	lsls	r1, r3, #8
    5650:	23ff      	movs	r3, #255	; 0xff
    5652:	041b      	lsls	r3, r3, #16
    5654:	400b      	ands	r3, r1
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    5656:	431a      	orrs	r2, r3
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    5658:	687b      	ldr	r3, [r7, #4]
    565a:	0a19      	lsrs	r1, r3, #8
    565c:	23ff      	movs	r3, #255	; 0xff
    565e:	021b      	lsls	r3, r3, #8
    5660:	400b      	ands	r3, r1
 */
u32_t
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    5662:	431a      	orrs	r2, r3
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
    5664:	687b      	ldr	r3, [r7, #4]
    5666:	0e1b      	lsrs	r3, r3, #24
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    5668:	4313      	orrs	r3, r2
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
    566a:	0018      	movs	r0, r3
    566c:	46bd      	mov	sp, r7
    566e:	b002      	add	sp, #8
    5670:	bd80      	pop	{r7, pc}
    5672:	46c0      	nop			; (mov r8, r8)

00005674 <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
lwip_ntohl(u32_t n)
{
    5674:	b580      	push	{r7, lr}
    5676:	b082      	sub	sp, #8
    5678:	af00      	add	r7, sp, #0
    567a:	6078      	str	r0, [r7, #4]
  return lwip_htonl(n);
    567c:	687b      	ldr	r3, [r7, #4]
    567e:	0018      	movs	r0, r3
    5680:	4b03      	ldr	r3, [pc, #12]	; (5690 <lwip_ntohl+0x1c>)
    5682:	4798      	blx	r3
    5684:	0003      	movs	r3, r0
}
    5686:	0018      	movs	r0, r3
    5688:	46bd      	mov	sp, r7
    568a:	b002      	add	sp, #8
    568c:	bd80      	pop	{r7, pc}
    568e:	46c0      	nop			; (mov r8, r8)
    5690:	00005641 	.word	0x00005641

00005694 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
    5694:	b5b0      	push	{r4, r5, r7, lr}
    5696:	b08c      	sub	sp, #48	; 0x30
    5698:	af04      	add	r7, sp, #16
    569a:	6078      	str	r0, [r7, #4]
    569c:	6039      	str	r1, [r7, #0]

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
    569e:	687b      	ldr	r3, [r7, #4]
    56a0:	685b      	ldr	r3, [r3, #4]
    56a2:	61fb      	str	r3, [r7, #28]
  hlen = IPH_HL(iphdr) * 4;
    56a4:	69fb      	ldr	r3, [r7, #28]
    56a6:	781b      	ldrb	r3, [r3, #0]
    56a8:	b29b      	uxth	r3, r3
    56aa:	220f      	movs	r2, #15
    56ac:	4013      	ands	r3, r2
    56ae:	b29b      	uxth	r3, r3
    56b0:	009b      	lsls	r3, r3, #2
    56b2:	b29a      	uxth	r2, r3
    56b4:	2316      	movs	r3, #22
    56b6:	18fb      	adds	r3, r7, r3
    56b8:	801a      	strh	r2, [r3, #0]
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    56ba:	2316      	movs	r3, #22
    56bc:	18fb      	adds	r3, r7, r3
    56be:	881b      	ldrh	r3, [r3, #0]
    56c0:	425b      	negs	r3, r3
    56c2:	b29b      	uxth	r3, r3
    56c4:	b21a      	sxth	r2, r3
    56c6:	687b      	ldr	r3, [r7, #4]
    56c8:	0011      	movs	r1, r2
    56ca:	0018      	movs	r0, r3
    56cc:	4b9e      	ldr	r3, [pc, #632]	; (5948 <icmp_input+0x2b4>)
    56ce:	4798      	blx	r3
    56d0:	1e03      	subs	r3, r0, #0
    56d2:	d000      	beq.n	56d6 <icmp_input+0x42>
    56d4:	e121      	b.n	591a <icmp_input+0x286>
    56d6:	687b      	ldr	r3, [r7, #4]
    56d8:	891b      	ldrh	r3, [r3, #8]
    56da:	2b03      	cmp	r3, #3
    56dc:	d800      	bhi.n	56e0 <icmp_input+0x4c>
    56de:	e11c      	b.n	591a <icmp_input+0x286>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
    56e0:	687b      	ldr	r3, [r7, #4]
    56e2:	685a      	ldr	r2, [r3, #4]
    56e4:	2315      	movs	r3, #21
    56e6:	18fb      	adds	r3, r7, r3
    56e8:	7812      	ldrb	r2, [r2, #0]
    56ea:	701a      	strb	r2, [r3, #0]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
    56ec:	2315      	movs	r3, #21
    56ee:	18fb      	adds	r3, r7, r3
    56f0:	781b      	ldrb	r3, [r3, #0]
    56f2:	2b00      	cmp	r3, #0
    56f4:	d100      	bne.n	56f8 <icmp_input+0x64>
    56f6:	e107      	b.n	5908 <icmp_input+0x274>
    56f8:	2b08      	cmp	r3, #8
    56fa:	d000      	beq.n	56fe <icmp_input+0x6a>
    56fc:	e107      	b.n	590e <icmp_input+0x27a>
       (as obviously, an echo request has been sent, too). */
    break; 
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
    56fe:	2301      	movs	r3, #1
    5700:	61bb      	str	r3, [r7, #24]
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
    5702:	4b92      	ldr	r3, [pc, #584]	; (594c <icmp_input+0x2b8>)
    5704:	681b      	ldr	r3, [r3, #0]
    5706:	22f0      	movs	r2, #240	; 0xf0
    5708:	4013      	ands	r3, r2
    570a:	2be0      	cmp	r3, #224	; 0xe0
    570c:	d101      	bne.n	5712 <icmp_input+0x7e>
        accepted = 0;
    570e:	2300      	movs	r3, #0
    5710:	61bb      	str	r3, [r7, #24]
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
    5712:	4b8e      	ldr	r3, [pc, #568]	; (594c <icmp_input+0x2b8>)
    5714:	681b      	ldr	r3, [r3, #0]
    5716:	683a      	ldr	r2, [r7, #0]
    5718:	0011      	movs	r1, r2
    571a:	0018      	movs	r0, r3
    571c:	4b8c      	ldr	r3, [pc, #560]	; (5950 <icmp_input+0x2bc>)
    571e:	4798      	blx	r3
    5720:	1e03      	subs	r3, r0, #0
    5722:	d001      	beq.n	5728 <icmp_input+0x94>
        accepted = 0;
    5724:	2300      	movs	r3, #0
    5726:	61bb      	str	r3, [r7, #24]
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
    5728:	69bb      	ldr	r3, [r7, #24]
    572a:	2b00      	cmp	r3, #0
    572c:	d104      	bne.n	5738 <icmp_input+0xa4>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
        pbuf_free(p);
    572e:	687b      	ldr	r3, [r7, #4]
    5730:	0018      	movs	r0, r3
    5732:	4b88      	ldr	r3, [pc, #544]	; (5954 <icmp_input+0x2c0>)
    5734:	4798      	blx	r3
        return;
    5736:	e103      	b.n	5940 <icmp_input+0x2ac>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
    5738:	687b      	ldr	r3, [r7, #4]
    573a:	891b      	ldrh	r3, [r3, #8]
    573c:	2b07      	cmp	r3, #7
    573e:	d800      	bhi.n	5742 <icmp_input+0xae>
    5740:	e0ea      	b.n	5918 <icmp_input+0x284>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
    5742:	687b      	ldr	r3, [r7, #4]
    5744:	0018      	movs	r0, r3
    5746:	4b84      	ldr	r3, [pc, #528]	; (5958 <icmp_input+0x2c4>)
    5748:	4798      	blx	r3
    574a:	1e03      	subs	r3, r0, #0
    574c:	d004      	beq.n	5758 <icmp_input+0xc4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
    574e:	687b      	ldr	r3, [r7, #4]
    5750:	0018      	movs	r0, r3
    5752:	4b80      	ldr	r3, [pc, #512]	; (5954 <icmp_input+0x2c0>)
    5754:	4798      	blx	r3
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    5756:	e0f3      	b.n	5940 <icmp_input+0x2ac>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    5758:	687b      	ldr	r3, [r7, #4]
    575a:	2122      	movs	r1, #34	; 0x22
    575c:	0018      	movs	r0, r3
    575e:	4b7a      	ldr	r3, [pc, #488]	; (5948 <icmp_input+0x2b4>)
    5760:	4798      	blx	r3
    5762:	1e03      	subs	r3, r0, #0
    5764:	d039      	beq.n	57da <icmp_input+0x146>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
    5766:	2316      	movs	r3, #22
    5768:	18fb      	adds	r3, r7, r3
    576a:	2200      	movs	r2, #0
    576c:	5e9a      	ldrsh	r2, [r3, r2]
    576e:	687b      	ldr	r3, [r7, #4]
    5770:	0011      	movs	r1, r2
    5772:	0018      	movs	r0, r3
    5774:	4b74      	ldr	r3, [pc, #464]	; (5948 <icmp_input+0x2b4>)
    5776:	4798      	blx	r3
    5778:	1e03      	subs	r3, r0, #0
    577a:	d000      	beq.n	577e <icmp_input+0xea>
    577c:	e0d2      	b.n	5924 <icmp_input+0x290>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
    577e:	687b      	ldr	r3, [r7, #4]
    5780:	891b      	ldrh	r3, [r3, #8]
    5782:	2200      	movs	r2, #0
    5784:	0019      	movs	r1, r3
    5786:	2002      	movs	r0, #2
    5788:	4b74      	ldr	r3, [pc, #464]	; (595c <icmp_input+0x2c8>)
    578a:	4798      	blx	r3
    578c:	0003      	movs	r3, r0
    578e:	613b      	str	r3, [r7, #16]
      if (r == NULL) {
    5790:	693b      	ldr	r3, [r7, #16]
    5792:	2b00      	cmp	r3, #0
    5794:	d100      	bne.n	5798 <icmp_input+0x104>
    5796:	e0c7      	b.n	5928 <icmp_input+0x294>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
    5798:	687a      	ldr	r2, [r7, #4]
    579a:	693b      	ldr	r3, [r7, #16]
    579c:	0011      	movs	r1, r2
    579e:	0018      	movs	r0, r3
    57a0:	4b6f      	ldr	r3, [pc, #444]	; (5960 <icmp_input+0x2cc>)
    57a2:	4798      	blx	r3
    57a4:	1e03      	subs	r3, r0, #0
    57a6:	d000      	beq.n	57aa <icmp_input+0x116>
    57a8:	e0c0      	b.n	592c <icmp_input+0x298>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
    57aa:	693b      	ldr	r3, [r7, #16]
    57ac:	685b      	ldr	r3, [r3, #4]
    57ae:	61fb      	str	r3, [r7, #28]
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
    57b0:	2316      	movs	r3, #22
    57b2:	18fb      	adds	r3, r7, r3
    57b4:	881b      	ldrh	r3, [r3, #0]
    57b6:	425b      	negs	r3, r3
    57b8:	b29b      	uxth	r3, r3
    57ba:	b21a      	sxth	r2, r3
    57bc:	693b      	ldr	r3, [r7, #16]
    57be:	0011      	movs	r1, r2
    57c0:	0018      	movs	r0, r3
    57c2:	4b61      	ldr	r3, [pc, #388]	; (5948 <icmp_input+0x2b4>)
    57c4:	4798      	blx	r3
    57c6:	1e03      	subs	r3, r0, #0
    57c8:	d000      	beq.n	57cc <icmp_input+0x138>
    57ca:	e0b1      	b.n	5930 <icmp_input+0x29c>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
    57cc:	687b      	ldr	r3, [r7, #4]
    57ce:	0018      	movs	r0, r3
    57d0:	4b60      	ldr	r3, [pc, #384]	; (5954 <icmp_input+0x2c0>)
    57d2:	4798      	blx	r3
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    57d4:	693b      	ldr	r3, [r7, #16]
    57d6:	607b      	str	r3, [r7, #4]
    57d8:	e009      	b.n	57ee <icmp_input+0x15a>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
    57da:	2322      	movs	r3, #34	; 0x22
    57dc:	425a      	negs	r2, r3
    57de:	687b      	ldr	r3, [r7, #4]
    57e0:	0011      	movs	r1, r2
    57e2:	0018      	movs	r0, r3
    57e4:	4b58      	ldr	r3, [pc, #352]	; (5948 <icmp_input+0x2b4>)
    57e6:	4798      	blx	r3
    57e8:	1e03      	subs	r3, r0, #0
    57ea:	d000      	beq.n	57ee <icmp_input+0x15a>
    57ec:	e0a2      	b.n	5934 <icmp_input+0x2a0>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    57ee:	687b      	ldr	r3, [r7, #4]
    57f0:	685b      	ldr	r3, [r3, #4]
    57f2:	60fb      	str	r3, [r7, #12]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    57f4:	4b55      	ldr	r3, [pc, #340]	; (594c <icmp_input+0x2b8>)
    57f6:	681a      	ldr	r2, [r3, #0]
    57f8:	69fb      	ldr	r3, [r7, #28]
    57fa:	21ff      	movs	r1, #255	; 0xff
    57fc:	4011      	ands	r1, r2
    57fe:	000c      	movs	r4, r1
    5800:	7b19      	ldrb	r1, [r3, #12]
    5802:	2000      	movs	r0, #0
    5804:	4001      	ands	r1, r0
    5806:	1c08      	adds	r0, r1, #0
    5808:	1c21      	adds	r1, r4, #0
    580a:	4301      	orrs	r1, r0
    580c:	7319      	strb	r1, [r3, #12]
    580e:	0a11      	lsrs	r1, r2, #8
    5810:	20ff      	movs	r0, #255	; 0xff
    5812:	4001      	ands	r1, r0
    5814:	000c      	movs	r4, r1
    5816:	7b59      	ldrb	r1, [r3, #13]
    5818:	2000      	movs	r0, #0
    581a:	4001      	ands	r1, r0
    581c:	1c08      	adds	r0, r1, #0
    581e:	1c21      	adds	r1, r4, #0
    5820:	4301      	orrs	r1, r0
    5822:	7359      	strb	r1, [r3, #13]
    5824:	0c11      	lsrs	r1, r2, #16
    5826:	20ff      	movs	r0, #255	; 0xff
    5828:	4001      	ands	r1, r0
    582a:	000c      	movs	r4, r1
    582c:	7b99      	ldrb	r1, [r3, #14]
    582e:	2000      	movs	r0, #0
    5830:	4001      	ands	r1, r0
    5832:	1c08      	adds	r0, r1, #0
    5834:	1c21      	adds	r1, r4, #0
    5836:	4301      	orrs	r1, r0
    5838:	7399      	strb	r1, [r3, #14]
    583a:	0e10      	lsrs	r0, r2, #24
    583c:	7bda      	ldrb	r2, [r3, #15]
    583e:	2100      	movs	r1, #0
    5840:	400a      	ands	r2, r1
    5842:	1c11      	adds	r1, r2, #0
    5844:	1c02      	adds	r2, r0, #0
    5846:	430a      	orrs	r2, r1
    5848:	73da      	strb	r2, [r3, #15]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    584a:	4b46      	ldr	r3, [pc, #280]	; (5964 <icmp_input+0x2d0>)
    584c:	681a      	ldr	r2, [r3, #0]
    584e:	69fb      	ldr	r3, [r7, #28]
    5850:	21ff      	movs	r1, #255	; 0xff
    5852:	4011      	ands	r1, r2
    5854:	000c      	movs	r4, r1
    5856:	7c19      	ldrb	r1, [r3, #16]
    5858:	2000      	movs	r0, #0
    585a:	4001      	ands	r1, r0
    585c:	1c08      	adds	r0, r1, #0
    585e:	1c21      	adds	r1, r4, #0
    5860:	4301      	orrs	r1, r0
    5862:	7419      	strb	r1, [r3, #16]
    5864:	0a11      	lsrs	r1, r2, #8
    5866:	20ff      	movs	r0, #255	; 0xff
    5868:	4001      	ands	r1, r0
    586a:	000c      	movs	r4, r1
    586c:	7c59      	ldrb	r1, [r3, #17]
    586e:	2000      	movs	r0, #0
    5870:	4001      	ands	r1, r0
    5872:	1c08      	adds	r0, r1, #0
    5874:	1c21      	adds	r1, r4, #0
    5876:	4301      	orrs	r1, r0
    5878:	7459      	strb	r1, [r3, #17]
    587a:	0c11      	lsrs	r1, r2, #16
    587c:	20ff      	movs	r0, #255	; 0xff
    587e:	4001      	ands	r1, r0
    5880:	000c      	movs	r4, r1
    5882:	7c99      	ldrb	r1, [r3, #18]
    5884:	2000      	movs	r0, #0
    5886:	4001      	ands	r1, r0
    5888:	1c08      	adds	r0, r1, #0
    588a:	1c21      	adds	r1, r4, #0
    588c:	4301      	orrs	r1, r0
    588e:	7499      	strb	r1, [r3, #18]
    5890:	0e10      	lsrs	r0, r2, #24
    5892:	7cda      	ldrb	r2, [r3, #19]
    5894:	2100      	movs	r1, #0
    5896:	400a      	ands	r2, r1
    5898:	1c11      	adds	r1, r2, #0
    589a:	1c02      	adds	r2, r0, #0
    589c:	430a      	orrs	r2, r1
    589e:	74da      	strb	r2, [r3, #19]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
    58a0:	68fb      	ldr	r3, [r7, #12]
    58a2:	2200      	movs	r2, #0
    58a4:	701a      	strb	r2, [r3, #0]
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
    }
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
    58a6:	68fb      	ldr	r3, [r7, #12]
    58a8:	789a      	ldrb	r2, [r3, #2]
    58aa:	2100      	movs	r1, #0
    58ac:	400a      	ands	r2, r1
    58ae:	709a      	strb	r2, [r3, #2]
    58b0:	78da      	ldrb	r2, [r3, #3]
    58b2:	2100      	movs	r1, #0
    58b4:	400a      	ands	r2, r1
    58b6:	70da      	strb	r2, [r3, #3]
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    58b8:	69fb      	ldr	r3, [r7, #28]
    58ba:	22ff      	movs	r2, #255	; 0xff
    58bc:	721a      	strb	r2, [r3, #8]
    IPH_CHKSUM_SET(iphdr, 0);
    58be:	69fb      	ldr	r3, [r7, #28]
    58c0:	7a9a      	ldrb	r2, [r3, #10]
    58c2:	2100      	movs	r1, #0
    58c4:	400a      	ands	r2, r1
    58c6:	729a      	strb	r2, [r3, #10]
    58c8:	7ada      	ldrb	r2, [r3, #11]
    58ca:	2100      	movs	r1, #0
    58cc:	400a      	ands	r2, r1
    58ce:	72da      	strb	r2, [r3, #11]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
    58d0:	2316      	movs	r3, #22
    58d2:	18fb      	adds	r3, r7, r3
    58d4:	2200      	movs	r2, #0
    58d6:	5e9a      	ldrsh	r2, [r3, r2]
    58d8:	687b      	ldr	r3, [r7, #4]
    58da:	0011      	movs	r1, r2
    58dc:	0018      	movs	r0, r3
    58de:	4b1a      	ldr	r3, [pc, #104]	; (5948 <icmp_input+0x2b4>)
    58e0:	4798      	blx	r3
    58e2:	1e03      	subs	r3, r0, #0
    58e4:	d112      	bne.n	590c <icmp_input+0x278>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
    58e6:	230b      	movs	r3, #11
    58e8:	18fc      	adds	r4, r7, r3
    58ea:	4918      	ldr	r1, [pc, #96]	; (594c <icmp_input+0x2b8>)
    58ec:	6878      	ldr	r0, [r7, #4]
    58ee:	683b      	ldr	r3, [r7, #0]
    58f0:	9302      	str	r3, [sp, #8]
    58f2:	2301      	movs	r3, #1
    58f4:	9301      	str	r3, [sp, #4]
    58f6:	2300      	movs	r3, #0
    58f8:	9300      	str	r3, [sp, #0]
    58fa:	23ff      	movs	r3, #255	; 0xff
    58fc:	2200      	movs	r2, #0
    58fe:	4d1a      	ldr	r5, [pc, #104]	; (5968 <icmp_input+0x2d4>)
    5900:	47a8      	blx	r5
    5902:	0003      	movs	r3, r0
    5904:	7023      	strb	r3, [r4, #0]
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    5906:	e001      	b.n	590c <icmp_input+0x278>
#endif /* LWIP_DEBUG */
  switch (type) {
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    break; 
    5908:	46c0      	nop			; (mov r8, r8)
    590a:	e000      	b.n	590e <icmp_input+0x27a>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
    590c:	46c0      	nop			; (mov r8, r8)
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
    590e:	687b      	ldr	r3, [r7, #4]
    5910:	0018      	movs	r0, r3
    5912:	4b10      	ldr	r3, [pc, #64]	; (5954 <icmp_input+0x2c0>)
    5914:	4798      	blx	r3
  return;
    5916:	e013      	b.n	5940 <icmp_input+0x2ac>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    5918:	46c0      	nop			; (mov r8, r8)
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
    591a:	687b      	ldr	r3, [r7, #4]
    591c:	0018      	movs	r0, r3
    591e:	4b0d      	ldr	r3, [pc, #52]	; (5954 <icmp_input+0x2c0>)
    5920:	4798      	blx	r3
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
    5922:	e00d      	b.n	5940 <icmp_input+0x2ac>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
    5924:	46c0      	nop			; (mov r8, r8)
    5926:	e006      	b.n	5936 <icmp_input+0x2a2>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
    5928:	46c0      	nop			; (mov r8, r8)
    592a:	e004      	b.n	5936 <icmp_input+0x2a2>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
    592c:	46c0      	nop			; (mov r8, r8)
    592e:	e002      	b.n	5936 <icmp_input+0x2a2>
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
    5930:	46c0      	nop			; (mov r8, r8)
    5932:	e000      	b.n	5936 <icmp_input+0x2a2>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
    5934:	46c0      	nop			; (mov r8, r8)
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
    5936:	687b      	ldr	r3, [r7, #4]
    5938:	0018      	movs	r0, r3
    593a:	4b06      	ldr	r3, [pc, #24]	; (5954 <icmp_input+0x2c0>)
    593c:	4798      	blx	r3
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
    593e:	46c0      	nop			; (mov r8, r8)
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
    5940:	46bd      	mov	sp, r7
    5942:	b008      	add	sp, #32
    5944:	bdb0      	pop	{r4, r5, r7, pc}
    5946:	46c0      	nop			; (mov r8, r8)
    5948:	00008235 	.word	0x00008235
    594c:	20002e98 	.word	0x20002e98
    5950:	0000626d 	.word	0x0000626d
    5954:	00008349 	.word	0x00008349
    5958:	00005bd5 	.word	0x00005bd5
    595c:	00007e19 	.word	0x00007e19
    5960:	0000851d 	.word	0x0000851d
    5964:	20002e90 	.word	0x20002e90
    5968:	00005f81 	.word	0x00005f81

0000596c <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
    596c:	b580      	push	{r7, lr}
    596e:	b082      	sub	sp, #8
    5970:	af00      	add	r7, sp, #0
    5972:	6078      	str	r0, [r7, #4]
    5974:	000a      	movs	r2, r1
    5976:	1cfb      	adds	r3, r7, #3
    5978:	701a      	strb	r2, [r3, #0]
  icmp_send_response(p, ICMP_DUR, t);
    597a:	1cfb      	adds	r3, r7, #3
    597c:	781a      	ldrb	r2, [r3, #0]
    597e:	687b      	ldr	r3, [r7, #4]
    5980:	2103      	movs	r1, #3
    5982:	0018      	movs	r0, r3
    5984:	4b02      	ldr	r3, [pc, #8]	; (5990 <icmp_dest_unreach+0x24>)
    5986:	4798      	blx	r3
}
    5988:	46c0      	nop			; (mov r8, r8)
    598a:	46bd      	mov	sp, r7
    598c:	b002      	add	sp, #8
    598e:	bd80      	pop	{r7, pc}
    5990:	000059bd 	.word	0x000059bd

00005994 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
    5994:	b580      	push	{r7, lr}
    5996:	b082      	sub	sp, #8
    5998:	af00      	add	r7, sp, #0
    599a:	6078      	str	r0, [r7, #4]
    599c:	000a      	movs	r2, r1
    599e:	1cfb      	adds	r3, r7, #3
    59a0:	701a      	strb	r2, [r3, #0]
  icmp_send_response(p, ICMP_TE, t);
    59a2:	1cfb      	adds	r3, r7, #3
    59a4:	781a      	ldrb	r2, [r3, #0]
    59a6:	687b      	ldr	r3, [r7, #4]
    59a8:	210b      	movs	r1, #11
    59aa:	0018      	movs	r0, r3
    59ac:	4b02      	ldr	r3, [pc, #8]	; (59b8 <icmp_time_exceeded+0x24>)
    59ae:	4798      	blx	r3
}
    59b0:	46c0      	nop			; (mov r8, r8)
    59b2:	46bd      	mov	sp, r7
    59b4:	b002      	add	sp, #8
    59b6:	bd80      	pop	{r7, pc}
    59b8:	000059bd 	.word	0x000059bd

000059bc <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
    59bc:	b590      	push	{r4, r7, lr}
    59be:	b089      	sub	sp, #36	; 0x24
    59c0:	af02      	add	r7, sp, #8
    59c2:	6078      	str	r0, [r7, #4]
    59c4:	0008      	movs	r0, r1
    59c6:	0011      	movs	r1, r2
    59c8:	1cfb      	adds	r3, r7, #3
    59ca:	1c02      	adds	r2, r0, #0
    59cc:	701a      	strb	r2, [r3, #0]
    59ce:	1cbb      	adds	r3, r7, #2
    59d0:	1c0a      	adds	r2, r1, #0
    59d2:	701a      	strb	r2, [r3, #0]
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
    59d4:	2200      	movs	r2, #0
    59d6:	2124      	movs	r1, #36	; 0x24
    59d8:	2001      	movs	r0, #1
    59da:	4b3b      	ldr	r3, [pc, #236]	; (5ac8 <icmp_send_response+0x10c>)
    59dc:	4798      	blx	r3
    59de:	0003      	movs	r3, r0
    59e0:	617b      	str	r3, [r7, #20]
                 PBUF_RAM);
  if (q == NULL) {
    59e2:	697b      	ldr	r3, [r7, #20]
    59e4:	2b00      	cmp	r3, #0
    59e6:	d06b      	beq.n	5ac0 <icmp_send_response+0x104>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
    59e8:	687b      	ldr	r3, [r7, #4]
    59ea:	685b      	ldr	r3, [r3, #4]
    59ec:	613b      	str	r3, [r7, #16]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
    59ee:	697b      	ldr	r3, [r7, #20]
    59f0:	685b      	ldr	r3, [r3, #4]
    59f2:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
    59f4:	68fb      	ldr	r3, [r7, #12]
    59f6:	1cfa      	adds	r2, r7, #3
    59f8:	7812      	ldrb	r2, [r2, #0]
    59fa:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
    59fc:	68fb      	ldr	r3, [r7, #12]
    59fe:	1cba      	adds	r2, r7, #2
    5a00:	7812      	ldrb	r2, [r2, #0]
    5a02:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
    5a04:	68fb      	ldr	r3, [r7, #12]
    5a06:	791a      	ldrb	r2, [r3, #4]
    5a08:	2100      	movs	r1, #0
    5a0a:	400a      	ands	r2, r1
    5a0c:	711a      	strb	r2, [r3, #4]
    5a0e:	795a      	ldrb	r2, [r3, #5]
    5a10:	2100      	movs	r1, #0
    5a12:	400a      	ands	r2, r1
    5a14:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
    5a16:	68fb      	ldr	r3, [r7, #12]
    5a18:	799a      	ldrb	r2, [r3, #6]
    5a1a:	2100      	movs	r1, #0
    5a1c:	400a      	ands	r2, r1
    5a1e:	719a      	strb	r2, [r3, #6]
    5a20:	79da      	ldrb	r2, [r3, #7]
    5a22:	2100      	movs	r1, #0
    5a24:	400a      	ands	r2, r1
    5a26:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
    5a28:	697b      	ldr	r3, [r7, #20]
    5a2a:	685b      	ldr	r3, [r3, #4]
    5a2c:	3308      	adds	r3, #8
    5a2e:	0018      	movs	r0, r3
    5a30:	687b      	ldr	r3, [r7, #4]
    5a32:	685b      	ldr	r3, [r3, #4]
    5a34:	221c      	movs	r2, #28
    5a36:	0019      	movs	r1, r3
    5a38:	4b24      	ldr	r3, [pc, #144]	; (5acc <icmp_send_response+0x110>)
    5a3a:	4798      	blx	r3
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
    5a3c:	68fb      	ldr	r3, [r7, #12]
    5a3e:	789a      	ldrb	r2, [r3, #2]
    5a40:	2100      	movs	r1, #0
    5a42:	400a      	ands	r2, r1
    5a44:	709a      	strb	r2, [r3, #2]
    5a46:	78da      	ldrb	r2, [r3, #3]
    5a48:	2100      	movs	r1, #0
    5a4a:	400a      	ands	r2, r1
    5a4c:	70da      	strb	r2, [r3, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
    5a4e:	697b      	ldr	r3, [r7, #20]
    5a50:	895a      	ldrh	r2, [r3, #10]
    5a52:	68fb      	ldr	r3, [r7, #12]
    5a54:	0011      	movs	r1, r2
    5a56:	0018      	movs	r0, r3
    5a58:	4b1d      	ldr	r3, [pc, #116]	; (5ad0 <icmp_send_response+0x114>)
    5a5a:	4798      	blx	r3
    5a5c:	0003      	movs	r3, r0
    5a5e:	001a      	movs	r2, r3
    5a60:	68fb      	ldr	r3, [r7, #12]
    5a62:	21ff      	movs	r1, #255	; 0xff
    5a64:	4011      	ands	r1, r2
    5a66:	000c      	movs	r4, r1
    5a68:	7899      	ldrb	r1, [r3, #2]
    5a6a:	2000      	movs	r0, #0
    5a6c:	4001      	ands	r1, r0
    5a6e:	1c08      	adds	r0, r1, #0
    5a70:	1c21      	adds	r1, r4, #0
    5a72:	4301      	orrs	r1, r0
    5a74:	7099      	strb	r1, [r3, #2]
    5a76:	0a12      	lsrs	r2, r2, #8
    5a78:	b290      	uxth	r0, r2
    5a7a:	78da      	ldrb	r2, [r3, #3]
    5a7c:	2100      	movs	r1, #0
    5a7e:	400a      	ands	r2, r1
    5a80:	1c11      	adds	r1, r2, #0
    5a82:	1c02      	adds	r2, r0, #0
    5a84:	430a      	orrs	r2, r1
    5a86:	70da      	strb	r2, [r3, #3]
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
    5a88:	693b      	ldr	r3, [r7, #16]
    5a8a:	7b1a      	ldrb	r2, [r3, #12]
    5a8c:	7b59      	ldrb	r1, [r3, #13]
    5a8e:	0209      	lsls	r1, r1, #8
    5a90:	430a      	orrs	r2, r1
    5a92:	7b99      	ldrb	r1, [r3, #14]
    5a94:	0409      	lsls	r1, r1, #16
    5a96:	430a      	orrs	r2, r1
    5a98:	7bdb      	ldrb	r3, [r3, #15]
    5a9a:	061b      	lsls	r3, r3, #24
    5a9c:	4313      	orrs	r3, r2
    5a9e:	60bb      	str	r3, [r7, #8]
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
    5aa0:	2308      	movs	r3, #8
    5aa2:	18fa      	adds	r2, r7, r3
    5aa4:	6978      	ldr	r0, [r7, #20]
    5aa6:	2301      	movs	r3, #1
    5aa8:	9301      	str	r3, [sp, #4]
    5aaa:	2300      	movs	r3, #0
    5aac:	9300      	str	r3, [sp, #0]
    5aae:	23ff      	movs	r3, #255	; 0xff
    5ab0:	2100      	movs	r1, #0
    5ab2:	4c08      	ldr	r4, [pc, #32]	; (5ad4 <icmp_send_response+0x118>)
    5ab4:	47a0      	blx	r4
  pbuf_free(q);
    5ab6:	697b      	ldr	r3, [r7, #20]
    5ab8:	0018      	movs	r0, r3
    5aba:	4b07      	ldr	r3, [pc, #28]	; (5ad8 <icmp_send_response+0x11c>)
    5abc:	4798      	blx	r3
    5abe:	e000      	b.n	5ac2 <icmp_send_response+0x106>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
    5ac0:	46c0      	nop			; (mov r8, r8)
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
    5ac2:	46bd      	mov	sp, r7
    5ac4:	b007      	add	sp, #28
    5ac6:	bd90      	pop	{r4, r7, pc}
    5ac8:	00007e19 	.word	0x00007e19
    5acc:	0000fc43 	.word	0x0000fc43
    5ad0:	00005ba5 	.word	0x00005ba5
    5ad4:	0000620d 	.word	0x0000620d
    5ad8:	00008349 	.word	0x00008349

00005adc <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
    5adc:	b580      	push	{r7, lr}
    5ade:	b088      	sub	sp, #32
    5ae0:	af00      	add	r7, sp, #0
    5ae2:	6078      	str	r0, [r7, #4]
    5ae4:	6039      	str	r1, [r7, #0]
  u8_t *pb = (u8_t *)dataptr;
    5ae6:	687b      	ldr	r3, [r7, #4]
    5ae8:	61fb      	str	r3, [r7, #28]
  u16_t *ps, t = 0;
    5aea:	230e      	movs	r3, #14
    5aec:	18fb      	adds	r3, r7, r3
    5aee:	2200      	movs	r2, #0
    5af0:	801a      	strh	r2, [r3, #0]
  u32_t sum = 0;
    5af2:	2300      	movs	r3, #0
    5af4:	617b      	str	r3, [r7, #20]
  int odd = ((mem_ptr_t)pb & 1);
    5af6:	69fb      	ldr	r3, [r7, #28]
    5af8:	2201      	movs	r2, #1
    5afa:	4013      	ands	r3, r2
    5afc:	613b      	str	r3, [r7, #16]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    5afe:	693b      	ldr	r3, [r7, #16]
    5b00:	2b00      	cmp	r3, #0
    5b02:	d00d      	beq.n	5b20 <lwip_standard_chksum+0x44>
    5b04:	683b      	ldr	r3, [r7, #0]
    5b06:	2b00      	cmp	r3, #0
    5b08:	dd0a      	ble.n	5b20 <lwip_standard_chksum+0x44>
    ((u8_t *)&t)[1] = *pb++;
    5b0a:	230e      	movs	r3, #14
    5b0c:	18fb      	adds	r3, r7, r3
    5b0e:	3301      	adds	r3, #1
    5b10:	69fa      	ldr	r2, [r7, #28]
    5b12:	1c51      	adds	r1, r2, #1
    5b14:	61f9      	str	r1, [r7, #28]
    5b16:	7812      	ldrb	r2, [r2, #0]
    5b18:	701a      	strb	r2, [r3, #0]
    len--;
    5b1a:	683b      	ldr	r3, [r7, #0]
    5b1c:	3b01      	subs	r3, #1
    5b1e:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
    5b20:	69fb      	ldr	r3, [r7, #28]
    5b22:	61bb      	str	r3, [r7, #24]
  while (len > 1) {
    5b24:	e00a      	b.n	5b3c <lwip_standard_chksum+0x60>
    sum += *ps++;
    5b26:	69bb      	ldr	r3, [r7, #24]
    5b28:	1c9a      	adds	r2, r3, #2
    5b2a:	61ba      	str	r2, [r7, #24]
    5b2c:	881b      	ldrh	r3, [r3, #0]
    5b2e:	001a      	movs	r2, r3
    5b30:	697b      	ldr	r3, [r7, #20]
    5b32:	189b      	adds	r3, r3, r2
    5b34:	617b      	str	r3, [r7, #20]
    len -= 2;
    5b36:	683b      	ldr	r3, [r7, #0]
    5b38:	3b02      	subs	r3, #2
    5b3a:	603b      	str	r3, [r7, #0]
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
    5b3c:	683b      	ldr	r3, [r7, #0]
    5b3e:	2b01      	cmp	r3, #1
    5b40:	dcf1      	bgt.n	5b26 <lwip_standard_chksum+0x4a>
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
    5b42:	683b      	ldr	r3, [r7, #0]
    5b44:	2b00      	cmp	r3, #0
    5b46:	dd04      	ble.n	5b52 <lwip_standard_chksum+0x76>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
    5b48:	230e      	movs	r3, #14
    5b4a:	18fb      	adds	r3, r7, r3
    5b4c:	69ba      	ldr	r2, [r7, #24]
    5b4e:	7812      	ldrb	r2, [r2, #0]
    5b50:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
    5b52:	230e      	movs	r3, #14
    5b54:	18fb      	adds	r3, r7, r3
    5b56:	881b      	ldrh	r3, [r3, #0]
    5b58:	001a      	movs	r2, r3
    5b5a:	697b      	ldr	r3, [r7, #20]
    5b5c:	189b      	adds	r3, r3, r2
    5b5e:	617b      	str	r3, [r7, #20]

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
    5b60:	697b      	ldr	r3, [r7, #20]
    5b62:	0c1a      	lsrs	r2, r3, #16
    5b64:	697b      	ldr	r3, [r7, #20]
    5b66:	041b      	lsls	r3, r3, #16
    5b68:	0c1b      	lsrs	r3, r3, #16
    5b6a:	18d3      	adds	r3, r2, r3
    5b6c:	617b      	str	r3, [r7, #20]
  sum = FOLD_U32T(sum);
    5b6e:	697b      	ldr	r3, [r7, #20]
    5b70:	0c1a      	lsrs	r2, r3, #16
    5b72:	697b      	ldr	r3, [r7, #20]
    5b74:	041b      	lsls	r3, r3, #16
    5b76:	0c1b      	lsrs	r3, r3, #16
    5b78:	18d3      	adds	r3, r2, r3
    5b7a:	617b      	str	r3, [r7, #20]

  /* Swap if alignment was odd */
  if (odd) {
    5b7c:	693b      	ldr	r3, [r7, #16]
    5b7e:	2b00      	cmp	r3, #0
    5b80:	d009      	beq.n	5b96 <lwip_standard_chksum+0xba>
    sum = SWAP_BYTES_IN_WORD(sum);
    5b82:	697b      	ldr	r3, [r7, #20]
    5b84:	021b      	lsls	r3, r3, #8
    5b86:	041b      	lsls	r3, r3, #16
    5b88:	0c1a      	lsrs	r2, r3, #16
    5b8a:	697b      	ldr	r3, [r7, #20]
    5b8c:	0a1b      	lsrs	r3, r3, #8
    5b8e:	21ff      	movs	r1, #255	; 0xff
    5b90:	400b      	ands	r3, r1
    5b92:	4313      	orrs	r3, r2
    5b94:	617b      	str	r3, [r7, #20]
  }

  return (u16_t)sum;
    5b96:	697b      	ldr	r3, [r7, #20]
    5b98:	b29b      	uxth	r3, r3
}
    5b9a:	0018      	movs	r0, r3
    5b9c:	46bd      	mov	sp, r7
    5b9e:	b008      	add	sp, #32
    5ba0:	bd80      	pop	{r7, pc}
    5ba2:	46c0      	nop			; (mov r8, r8)

00005ba4 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
    5ba4:	b580      	push	{r7, lr}
    5ba6:	b082      	sub	sp, #8
    5ba8:	af00      	add	r7, sp, #0
    5baa:	6078      	str	r0, [r7, #4]
    5bac:	000a      	movs	r2, r1
    5bae:	1cbb      	adds	r3, r7, #2
    5bb0:	801a      	strh	r2, [r3, #0]
  return ~LWIP_CHKSUM(dataptr, len);
    5bb2:	1cbb      	adds	r3, r7, #2
    5bb4:	881a      	ldrh	r2, [r3, #0]
    5bb6:	687b      	ldr	r3, [r7, #4]
    5bb8:	0011      	movs	r1, r2
    5bba:	0018      	movs	r0, r3
    5bbc:	4b04      	ldr	r3, [pc, #16]	; (5bd0 <inet_chksum+0x2c>)
    5bbe:	4798      	blx	r3
    5bc0:	0003      	movs	r3, r0
    5bc2:	43db      	mvns	r3, r3
    5bc4:	b29b      	uxth	r3, r3
}
    5bc6:	0018      	movs	r0, r3
    5bc8:	46bd      	mov	sp, r7
    5bca:	b002      	add	sp, #8
    5bcc:	bd80      	pop	{r7, pc}
    5bce:	46c0      	nop			; (mov r8, r8)
    5bd0:	00005add 	.word	0x00005add

00005bd4 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
    5bd4:	b580      	push	{r7, lr}
    5bd6:	b086      	sub	sp, #24
    5bd8:	af00      	add	r7, sp, #0
    5bda:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
    5bdc:	2300      	movs	r3, #0
    5bde:	617b      	str	r3, [r7, #20]
  swapped = 0;
    5be0:	230f      	movs	r3, #15
    5be2:	18fb      	adds	r3, r7, r3
    5be4:	2200      	movs	r2, #0
    5be6:	701a      	strb	r2, [r3, #0]
  for(q = p; q != NULL; q = q->next) {
    5be8:	687b      	ldr	r3, [r7, #4]
    5bea:	613b      	str	r3, [r7, #16]
    5bec:	e02f      	b.n	5c4e <inet_chksum_pbuf+0x7a>
    acc += LWIP_CHKSUM(q->payload, q->len);
    5bee:	693b      	ldr	r3, [r7, #16]
    5bf0:	685a      	ldr	r2, [r3, #4]
    5bf2:	693b      	ldr	r3, [r7, #16]
    5bf4:	895b      	ldrh	r3, [r3, #10]
    5bf6:	0019      	movs	r1, r3
    5bf8:	0010      	movs	r0, r2
    5bfa:	4b22      	ldr	r3, [pc, #136]	; (5c84 <inet_chksum_pbuf+0xb0>)
    5bfc:	4798      	blx	r3
    5bfe:	0003      	movs	r3, r0
    5c00:	001a      	movs	r2, r3
    5c02:	697b      	ldr	r3, [r7, #20]
    5c04:	189b      	adds	r3, r3, r2
    5c06:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
    5c08:	697b      	ldr	r3, [r7, #20]
    5c0a:	0c1a      	lsrs	r2, r3, #16
    5c0c:	697b      	ldr	r3, [r7, #20]
    5c0e:	041b      	lsls	r3, r3, #16
    5c10:	0c1b      	lsrs	r3, r3, #16
    5c12:	18d3      	adds	r3, r2, r3
    5c14:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
    5c16:	693b      	ldr	r3, [r7, #16]
    5c18:	895b      	ldrh	r3, [r3, #10]
    5c1a:	2201      	movs	r2, #1
    5c1c:	4013      	ands	r3, r2
    5c1e:	b29b      	uxth	r3, r3
    5c20:	2b00      	cmp	r3, #0
    5c22:	d011      	beq.n	5c48 <inet_chksum_pbuf+0x74>
      swapped = 1 - swapped;
    5c24:	230f      	movs	r3, #15
    5c26:	18fb      	adds	r3, r7, r3
    5c28:	220f      	movs	r2, #15
    5c2a:	18ba      	adds	r2, r7, r2
    5c2c:	7812      	ldrb	r2, [r2, #0]
    5c2e:	2101      	movs	r1, #1
    5c30:	1a8a      	subs	r2, r1, r2
    5c32:	701a      	strb	r2, [r3, #0]
      acc = SWAP_BYTES_IN_WORD(acc);
    5c34:	697b      	ldr	r3, [r7, #20]
    5c36:	021b      	lsls	r3, r3, #8
    5c38:	041b      	lsls	r3, r3, #16
    5c3a:	0c1a      	lsrs	r2, r3, #16
    5c3c:	697b      	ldr	r3, [r7, #20]
    5c3e:	0a1b      	lsrs	r3, r3, #8
    5c40:	21ff      	movs	r1, #255	; 0xff
    5c42:	400b      	ands	r3, r1
    5c44:	4313      	orrs	r3, r2
    5c46:	617b      	str	r3, [r7, #20]
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    5c48:	693b      	ldr	r3, [r7, #16]
    5c4a:	681b      	ldr	r3, [r3, #0]
    5c4c:	613b      	str	r3, [r7, #16]
    5c4e:	693b      	ldr	r3, [r7, #16]
    5c50:	2b00      	cmp	r3, #0
    5c52:	d1cc      	bne.n	5bee <inet_chksum_pbuf+0x1a>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
    5c54:	230f      	movs	r3, #15
    5c56:	18fb      	adds	r3, r7, r3
    5c58:	781b      	ldrb	r3, [r3, #0]
    5c5a:	2b00      	cmp	r3, #0
    5c5c:	d009      	beq.n	5c72 <inet_chksum_pbuf+0x9e>
    acc = SWAP_BYTES_IN_WORD(acc);
    5c5e:	697b      	ldr	r3, [r7, #20]
    5c60:	021b      	lsls	r3, r3, #8
    5c62:	041b      	lsls	r3, r3, #16
    5c64:	0c1a      	lsrs	r2, r3, #16
    5c66:	697b      	ldr	r3, [r7, #20]
    5c68:	0a1b      	lsrs	r3, r3, #8
    5c6a:	21ff      	movs	r1, #255	; 0xff
    5c6c:	400b      	ands	r3, r1
    5c6e:	4313      	orrs	r3, r2
    5c70:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
    5c72:	697b      	ldr	r3, [r7, #20]
    5c74:	b29b      	uxth	r3, r3
    5c76:	43db      	mvns	r3, r3
    5c78:	b29b      	uxth	r3, r3
}
    5c7a:	0018      	movs	r0, r3
    5c7c:	46bd      	mov	sp, r7
    5c7e:	b006      	add	sp, #24
    5c80:	bd80      	pop	{r7, pc}
    5c82:	46c0      	nop			; (mov r8, r8)
    5c84:	00005add 	.word	0x00005add

00005c88 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *dest)
{
    5c88:	b580      	push	{r7, lr}
    5c8a:	b084      	sub	sp, #16
    5c8c:	af00      	add	r7, sp, #0
    5c8e:	6078      	str	r0, [r7, #4]
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
    5c90:	4b17      	ldr	r3, [pc, #92]	; (5cf0 <ip_route+0x68>)
    5c92:	681b      	ldr	r3, [r3, #0]
    5c94:	60fb      	str	r3, [r7, #12]
    5c96:	e014      	b.n	5cc2 <ip_route+0x3a>
    /* network mask matches? */
    if (netif_is_up(netif)) {
    5c98:	68fb      	ldr	r3, [r7, #12]
    5c9a:	222d      	movs	r2, #45	; 0x2d
    5c9c:	5c9b      	ldrb	r3, [r3, r2]
    5c9e:	001a      	movs	r2, r3
    5ca0:	2301      	movs	r3, #1
    5ca2:	4013      	ands	r3, r2
    5ca4:	d00a      	beq.n	5cbc <ip_route+0x34>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
    5ca6:	687b      	ldr	r3, [r7, #4]
    5ca8:	681a      	ldr	r2, [r3, #0]
    5caa:	68fb      	ldr	r3, [r7, #12]
    5cac:	685b      	ldr	r3, [r3, #4]
    5cae:	405a      	eors	r2, r3
    5cb0:	68fb      	ldr	r3, [r7, #12]
    5cb2:	689b      	ldr	r3, [r3, #8]
    5cb4:	4013      	ands	r3, r2
    5cb6:	d101      	bne.n	5cbc <ip_route+0x34>
        /* return netif on which to forward IP packet */
        return netif;
    5cb8:	68fb      	ldr	r3, [r7, #12]
    5cba:	e015      	b.n	5ce8 <ip_route+0x60>
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
    5cbc:	68fb      	ldr	r3, [r7, #12]
    5cbe:	681b      	ldr	r3, [r3, #0]
    5cc0:	60fb      	str	r3, [r7, #12]
    5cc2:	68fb      	ldr	r3, [r7, #12]
    5cc4:	2b00      	cmp	r3, #0
    5cc6:	d1e7      	bne.n	5c98 <ip_route+0x10>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    5cc8:	4b0a      	ldr	r3, [pc, #40]	; (5cf4 <ip_route+0x6c>)
    5cca:	681b      	ldr	r3, [r3, #0]
    5ccc:	2b00      	cmp	r3, #0
    5cce:	d007      	beq.n	5ce0 <ip_route+0x58>
    5cd0:	4b08      	ldr	r3, [pc, #32]	; (5cf4 <ip_route+0x6c>)
    5cd2:	681b      	ldr	r3, [r3, #0]
    5cd4:	222d      	movs	r2, #45	; 0x2d
    5cd6:	5c9b      	ldrb	r3, [r3, r2]
    5cd8:	001a      	movs	r2, r3
    5cda:	2301      	movs	r3, #1
    5cdc:	4013      	ands	r3, r2
    5cde:	d101      	bne.n	5ce4 <ip_route+0x5c>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
    5ce0:	2300      	movs	r3, #0
    5ce2:	e001      	b.n	5ce8 <ip_route+0x60>
  }
  /* no matching netif found, use default netif */
  return netif_default;
    5ce4:	4b03      	ldr	r3, [pc, #12]	; (5cf4 <ip_route+0x6c>)
    5ce6:	681b      	ldr	r3, [r3, #0]
}
    5ce8:	0018      	movs	r0, r3
    5cea:	46bd      	mov	sp, r7
    5cec:	b004      	add	sp, #16
    5cee:	bd80      	pop	{r7, pc}
    5cf0:	20003eb4 	.word	0x20003eb4
    5cf4:	20003eb8 	.word	0x20003eb8

00005cf8 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
    5cf8:	b590      	push	{r4, r7, lr}
    5cfa:	b087      	sub	sp, #28
    5cfc:	af00      	add	r7, sp, #0
    5cfe:	6078      	str	r0, [r7, #4]
    5d00:	6039      	str	r1, [r7, #0]

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
    5d02:	687b      	ldr	r3, [r7, #4]
    5d04:	685b      	ldr	r3, [r3, #4]
    5d06:	617b      	str	r3, [r7, #20]
  if (IPH_V(iphdr) != 4) {
    5d08:	697b      	ldr	r3, [r7, #20]
    5d0a:	781b      	ldrb	r3, [r3, #0]
    5d0c:	091b      	lsrs	r3, r3, #4
    5d0e:	b2db      	uxtb	r3, r3
    5d10:	2b04      	cmp	r3, #4
    5d12:	d005      	beq.n	5d20 <ip_input+0x28>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
    5d14:	687b      	ldr	r3, [r7, #4]
    5d16:	0018      	movs	r0, r3
    5d18:	4b8a      	ldr	r3, [pc, #552]	; (5f44 <ip_input+0x24c>)
    5d1a:	4798      	blx	r3
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
    5d1c:	2300      	movs	r3, #0
    5d1e:	e10d      	b.n	5f3c <ip_input+0x244>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
    5d20:	697b      	ldr	r3, [r7, #20]
    5d22:	781b      	ldrb	r3, [r3, #0]
    5d24:	b29a      	uxth	r2, r3
    5d26:	230a      	movs	r3, #10
    5d28:	18fb      	adds	r3, r7, r3
    5d2a:	210f      	movs	r1, #15
    5d2c:	400a      	ands	r2, r1
    5d2e:	801a      	strh	r2, [r3, #0]
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
    5d30:	230a      	movs	r3, #10
    5d32:	18fb      	adds	r3, r7, r3
    5d34:	220a      	movs	r2, #10
    5d36:	18ba      	adds	r2, r7, r2
    5d38:	8812      	ldrh	r2, [r2, #0]
    5d3a:	0092      	lsls	r2, r2, #2
    5d3c:	801a      	strh	r2, [r3, #0]
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
    5d3e:	697b      	ldr	r3, [r7, #20]
    5d40:	789a      	ldrb	r2, [r3, #2]
    5d42:	78db      	ldrb	r3, [r3, #3]
    5d44:	021b      	lsls	r3, r3, #8
    5d46:	4313      	orrs	r3, r2
    5d48:	b29b      	uxth	r3, r3
    5d4a:	2208      	movs	r2, #8
    5d4c:	18bc      	adds	r4, r7, r2
    5d4e:	0018      	movs	r0, r3
    5d50:	4b7d      	ldr	r3, [pc, #500]	; (5f48 <ip_input+0x250>)
    5d52:	4798      	blx	r3
    5d54:	0003      	movs	r3, r0
    5d56:	8023      	strh	r3, [r4, #0]

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
    5d58:	687b      	ldr	r3, [r7, #4]
    5d5a:	895b      	ldrh	r3, [r3, #10]
    5d5c:	220a      	movs	r2, #10
    5d5e:	18ba      	adds	r2, r7, r2
    5d60:	8812      	ldrh	r2, [r2, #0]
    5d62:	429a      	cmp	r2, r3
    5d64:	d806      	bhi.n	5d74 <ip_input+0x7c>
    5d66:	687b      	ldr	r3, [r7, #4]
    5d68:	891b      	ldrh	r3, [r3, #8]
    5d6a:	2208      	movs	r2, #8
    5d6c:	18ba      	adds	r2, r7, r2
    5d6e:	8812      	ldrh	r2, [r2, #0]
    5d70:	429a      	cmp	r2, r3
    5d72:	d905      	bls.n	5d80 <ip_input+0x88>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
    5d74:	687b      	ldr	r3, [r7, #4]
    5d76:	0018      	movs	r0, r3
    5d78:	4b72      	ldr	r3, [pc, #456]	; (5f44 <ip_input+0x24c>)
    5d7a:	4798      	blx	r3
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
    5d7c:	2300      	movs	r3, #0
    5d7e:	e0dd      	b.n	5f3c <ip_input+0x244>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
    5d80:	2308      	movs	r3, #8
    5d82:	18fb      	adds	r3, r7, r3
    5d84:	881a      	ldrh	r2, [r3, #0]
    5d86:	687b      	ldr	r3, [r7, #4]
    5d88:	0011      	movs	r1, r2
    5d8a:	0018      	movs	r0, r3
    5d8c:	4b6f      	ldr	r3, [pc, #444]	; (5f4c <ip_input+0x254>)
    5d8e:	4798      	blx	r3

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
    5d90:	697b      	ldr	r3, [r7, #20]
    5d92:	7c1a      	ldrb	r2, [r3, #16]
    5d94:	7c59      	ldrb	r1, [r3, #17]
    5d96:	0209      	lsls	r1, r1, #8
    5d98:	430a      	orrs	r2, r1
    5d9a:	7c99      	ldrb	r1, [r3, #18]
    5d9c:	0409      	lsls	r1, r1, #16
    5d9e:	430a      	orrs	r2, r1
    5da0:	7cdb      	ldrb	r3, [r3, #19]
    5da2:	061b      	lsls	r3, r3, #24
    5da4:	4313      	orrs	r3, r2
    5da6:	001a      	movs	r2, r3
    5da8:	4b69      	ldr	r3, [pc, #420]	; (5f50 <ip_input+0x258>)
    5daa:	601a      	str	r2, [r3, #0]
  ip_addr_copy(current_iphdr_src, iphdr->src);
    5dac:	697b      	ldr	r3, [r7, #20]
    5dae:	7b1a      	ldrb	r2, [r3, #12]
    5db0:	7b59      	ldrb	r1, [r3, #13]
    5db2:	0209      	lsls	r1, r1, #8
    5db4:	430a      	orrs	r2, r1
    5db6:	7b99      	ldrb	r1, [r3, #14]
    5db8:	0409      	lsls	r1, r1, #16
    5dba:	430a      	orrs	r2, r1
    5dbc:	7bdb      	ldrb	r3, [r3, #15]
    5dbe:	061b      	lsls	r3, r3, #24
    5dc0:	4313      	orrs	r3, r2
    5dc2:	001a      	movs	r2, r3
    5dc4:	4b63      	ldr	r3, [pc, #396]	; (5f54 <ip_input+0x25c>)
    5dc6:	601a      	str	r2, [r3, #0]
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    5dc8:	2301      	movs	r3, #1
    5dca:	60fb      	str	r3, [r7, #12]
    netif = inp;
    5dcc:	683b      	ldr	r3, [r7, #0]
    5dce:	613b      	str	r3, [r7, #16]
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
    5dd0:	693b      	ldr	r3, [r7, #16]
    5dd2:	222d      	movs	r2, #45	; 0x2d
    5dd4:	5c9b      	ldrb	r3, [r3, r2]
    5dd6:	001a      	movs	r2, r3
    5dd8:	2301      	movs	r3, #1
    5dda:	4013      	ands	r3, r2
    5ddc:	d016      	beq.n	5e0c <ip_input+0x114>
    5dde:	693b      	ldr	r3, [r7, #16]
    5de0:	3304      	adds	r3, #4
    5de2:	2b00      	cmp	r3, #0
    5de4:	d012      	beq.n	5e0c <ip_input+0x114>
    5de6:	693b      	ldr	r3, [r7, #16]
    5de8:	685b      	ldr	r3, [r3, #4]
    5dea:	2b00      	cmp	r3, #0
    5dec:	d00e      	beq.n	5e0c <ip_input+0x114>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    5dee:	4b58      	ldr	r3, [pc, #352]	; (5f50 <ip_input+0x258>)
    5df0:	681a      	ldr	r2, [r3, #0]
    5df2:	693b      	ldr	r3, [r7, #16]
    5df4:	685b      	ldr	r3, [r3, #4]
    5df6:	429a      	cmp	r2, r3
    5df8:	d01e      	beq.n	5e38 <ip_input+0x140>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
    5dfa:	4b55      	ldr	r3, [pc, #340]	; (5f50 <ip_input+0x258>)
    5dfc:	681b      	ldr	r3, [r3, #0]
    5dfe:	693a      	ldr	r2, [r7, #16]
    5e00:	0011      	movs	r1, r2
    5e02:	0018      	movs	r0, r3
    5e04:	4b54      	ldr	r3, [pc, #336]	; (5f58 <ip_input+0x260>)
    5e06:	4798      	blx	r3
    5e08:	1e03      	subs	r3, r0, #0
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
    5e0a:	d115      	bne.n	5e38 <ip_input+0x140>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
    5e0c:	68fb      	ldr	r3, [r7, #12]
    5e0e:	2b00      	cmp	r3, #0
    5e10:	d005      	beq.n	5e1e <ip_input+0x126>
        first = 0;
    5e12:	2300      	movs	r3, #0
    5e14:	60fb      	str	r3, [r7, #12]
        netif = netif_list;
    5e16:	4b51      	ldr	r3, [pc, #324]	; (5f5c <ip_input+0x264>)
    5e18:	681b      	ldr	r3, [r3, #0]
    5e1a:	613b      	str	r3, [r7, #16]
    5e1c:	e002      	b.n	5e24 <ip_input+0x12c>
      } else {
        netif = netif->next;
    5e1e:	693b      	ldr	r3, [r7, #16]
    5e20:	681b      	ldr	r3, [r3, #0]
    5e22:	613b      	str	r3, [r7, #16]
      }
      if (netif == inp) {
    5e24:	693a      	ldr	r2, [r7, #16]
    5e26:	683b      	ldr	r3, [r7, #0]
    5e28:	429a      	cmp	r2, r3
    5e2a:	d102      	bne.n	5e32 <ip_input+0x13a>
        netif = netif->next;
    5e2c:	693b      	ldr	r3, [r7, #16]
    5e2e:	681b      	ldr	r3, [r3, #0]
    5e30:	613b      	str	r3, [r7, #16]
      }
    } while(netif != NULL);
    5e32:	693b      	ldr	r3, [r7, #16]
    5e34:	2b00      	cmp	r3, #0
    5e36:	d1cb      	bne.n	5dd0 <ip_input+0xd8>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    5e38:	4b46      	ldr	r3, [pc, #280]	; (5f54 <ip_input+0x25c>)
    5e3a:	681b      	ldr	r3, [r3, #0]
    5e3c:	683a      	ldr	r2, [r7, #0]
    5e3e:	0011      	movs	r1, r2
    5e40:	0018      	movs	r0, r3
    5e42:	4b45      	ldr	r3, [pc, #276]	; (5f58 <ip_input+0x260>)
    5e44:	4798      	blx	r3
    5e46:	1e03      	subs	r3, r0, #0
    5e48:	d105      	bne.n	5e56 <ip_input+0x15e>
         (ip_addr_ismulticast(&current_iphdr_src))) {
    5e4a:	4b42      	ldr	r3, [pc, #264]	; (5f54 <ip_input+0x25c>)
    5e4c:	681b      	ldr	r3, [r3, #0]
    5e4e:	22f0      	movs	r2, #240	; 0xf0
    5e50:	4013      	ands	r3, r2
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
    5e52:	2be0      	cmp	r3, #224	; 0xe0
    5e54:	d105      	bne.n	5e62 <ip_input+0x16a>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
    5e56:	687b      	ldr	r3, [r7, #4]
    5e58:	0018      	movs	r0, r3
    5e5a:	4b3a      	ldr	r3, [pc, #232]	; (5f44 <ip_input+0x24c>)
    5e5c:	4798      	blx	r3
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
    5e5e:	2300      	movs	r3, #0
    5e60:	e06c      	b.n	5f3c <ip_input+0x244>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
    5e62:	693b      	ldr	r3, [r7, #16]
    5e64:	2b00      	cmp	r3, #0
    5e66:	d105      	bne.n	5e74 <ip_input+0x17c>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
    5e68:	687b      	ldr	r3, [r7, #4]
    5e6a:	0018      	movs	r0, r3
    5e6c:	4b35      	ldr	r3, [pc, #212]	; (5f44 <ip_input+0x24c>)
    5e6e:	4798      	blx	r3
    return ERR_OK;
    5e70:	2300      	movs	r3, #0
    5e72:	e063      	b.n	5f3c <ip_input+0x244>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
    5e74:	697b      	ldr	r3, [r7, #20]
    5e76:	799a      	ldrb	r2, [r3, #6]
    5e78:	79db      	ldrb	r3, [r3, #7]
    5e7a:	021b      	lsls	r3, r3, #8
    5e7c:	4313      	orrs	r3, r2
    5e7e:	b29b      	uxth	r3, r3
    5e80:	001a      	movs	r2, r3
    5e82:	4b37      	ldr	r3, [pc, #220]	; (5f60 <ip_input+0x268>)
    5e84:	4013      	ands	r3, r2
    5e86:	d00d      	beq.n	5ea4 <ip_input+0x1ac>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
    5e88:	687b      	ldr	r3, [r7, #4]
    5e8a:	0018      	movs	r0, r3
    5e8c:	4b35      	ldr	r3, [pc, #212]	; (5f64 <ip_input+0x26c>)
    5e8e:	4798      	blx	r3
    5e90:	0003      	movs	r3, r0
    5e92:	607b      	str	r3, [r7, #4]
    /* packet not fully reassembled yet? */
    if (p == NULL) {
    5e94:	687b      	ldr	r3, [r7, #4]
    5e96:	2b00      	cmp	r3, #0
    5e98:	d101      	bne.n	5e9e <ip_input+0x1a6>
      return ERR_OK;
    5e9a:	2300      	movs	r3, #0
    5e9c:	e04e      	b.n	5f3c <ip_input+0x244>
    }
    iphdr = (struct ip_hdr *)p->payload;
    5e9e:	687b      	ldr	r3, [r7, #4]
    5ea0:	685b      	ldr	r3, [r3, #4]
    5ea2:	617b      	str	r3, [r7, #20]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
    5ea4:	4b30      	ldr	r3, [pc, #192]	; (5f68 <ip_input+0x270>)
    5ea6:	683a      	ldr	r2, [r7, #0]
    5ea8:	601a      	str	r2, [r3, #0]
  current_header = iphdr;
    5eaa:	4b30      	ldr	r3, [pc, #192]	; (5f6c <ip_input+0x274>)
    5eac:	697a      	ldr	r2, [r7, #20]
    5eae:	601a      	str	r2, [r3, #0]
#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
    5eb0:	697b      	ldr	r3, [r7, #20]
    5eb2:	7a5b      	ldrb	r3, [r3, #9]
    5eb4:	2b06      	cmp	r3, #6
    5eb6:	d00b      	beq.n	5ed0 <ip_input+0x1d8>
    5eb8:	2b11      	cmp	r3, #17
    5eba:	d002      	beq.n	5ec2 <ip_input+0x1ca>
    5ebc:	2b01      	cmp	r3, #1
    5ebe:	d00e      	beq.n	5ede <ip_input+0x1e6>
    5ec0:	e014      	b.n	5eec <ip_input+0x1f4>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
    5ec2:	683a      	ldr	r2, [r7, #0]
    5ec4:	687b      	ldr	r3, [r7, #4]
    5ec6:	0011      	movs	r1, r2
    5ec8:	0018      	movs	r0, r3
    5eca:	4b29      	ldr	r3, [pc, #164]	; (5f70 <ip_input+0x278>)
    5ecc:	4798      	blx	r3
      break;
    5ece:	e028      	b.n	5f22 <ip_input+0x22a>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
    5ed0:	683a      	ldr	r2, [r7, #0]
    5ed2:	687b      	ldr	r3, [r7, #4]
    5ed4:	0011      	movs	r1, r2
    5ed6:	0018      	movs	r0, r3
    5ed8:	4b26      	ldr	r3, [pc, #152]	; (5f74 <ip_input+0x27c>)
    5eda:	4798      	blx	r3
      break;
    5edc:	e021      	b.n	5f22 <ip_input+0x22a>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
    5ede:	683a      	ldr	r2, [r7, #0]
    5ee0:	687b      	ldr	r3, [r7, #4]
    5ee2:	0011      	movs	r1, r2
    5ee4:	0018      	movs	r0, r3
    5ee6:	4b24      	ldr	r3, [pc, #144]	; (5f78 <ip_input+0x280>)
    5ee8:	4798      	blx	r3
      break;
    5eea:	e01a      	b.n	5f22 <ip_input+0x22a>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    5eec:	4b18      	ldr	r3, [pc, #96]	; (5f50 <ip_input+0x258>)
    5eee:	681b      	ldr	r3, [r3, #0]
    5ef0:	683a      	ldr	r2, [r7, #0]
    5ef2:	0011      	movs	r1, r2
    5ef4:	0018      	movs	r0, r3
    5ef6:	4b18      	ldr	r3, [pc, #96]	; (5f58 <ip_input+0x260>)
    5ef8:	4798      	blx	r3
    5efa:	1e03      	subs	r3, r0, #0
    5efc:	d10d      	bne.n	5f1a <ip_input+0x222>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    5efe:	4b14      	ldr	r3, [pc, #80]	; (5f50 <ip_input+0x258>)
    5f00:	681b      	ldr	r3, [r3, #0]
    5f02:	22f0      	movs	r2, #240	; 0xf0
    5f04:	4013      	ands	r3, r2
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
    5f06:	2be0      	cmp	r3, #224	; 0xe0
    5f08:	d007      	beq.n	5f1a <ip_input+0x222>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
    5f0a:	687b      	ldr	r3, [r7, #4]
    5f0c:	697a      	ldr	r2, [r7, #20]
    5f0e:	605a      	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
    5f10:	687b      	ldr	r3, [r7, #4]
    5f12:	2102      	movs	r1, #2
    5f14:	0018      	movs	r0, r3
    5f16:	4b19      	ldr	r3, [pc, #100]	; (5f7c <ip_input+0x284>)
    5f18:	4798      	blx	r3
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
    5f1a:	687b      	ldr	r3, [r7, #4]
    5f1c:	0018      	movs	r0, r3
    5f1e:	4b09      	ldr	r3, [pc, #36]	; (5f44 <ip_input+0x24c>)
    5f20:	4798      	blx	r3
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
    5f22:	4b11      	ldr	r3, [pc, #68]	; (5f68 <ip_input+0x270>)
    5f24:	2200      	movs	r2, #0
    5f26:	601a      	str	r2, [r3, #0]
  current_header = NULL;
    5f28:	4b10      	ldr	r3, [pc, #64]	; (5f6c <ip_input+0x274>)
    5f2a:	2200      	movs	r2, #0
    5f2c:	601a      	str	r2, [r3, #0]
  ip_addr_set_any(&current_iphdr_src);
    5f2e:	4b09      	ldr	r3, [pc, #36]	; (5f54 <ip_input+0x25c>)
    5f30:	2200      	movs	r2, #0
    5f32:	601a      	str	r2, [r3, #0]
  ip_addr_set_any(&current_iphdr_dest);
    5f34:	4b06      	ldr	r3, [pc, #24]	; (5f50 <ip_input+0x258>)
    5f36:	2200      	movs	r2, #0
    5f38:	601a      	str	r2, [r3, #0]

  return ERR_OK;
    5f3a:	2300      	movs	r3, #0
}
    5f3c:	0018      	movs	r0, r3
    5f3e:	46bd      	mov	sp, r7
    5f40:	b007      	add	sp, #28
    5f42:	bd90      	pop	{r4, r7, pc}
    5f44:	00008349 	.word	0x00008349
    5f48:	0000561d 	.word	0x0000561d
    5f4c:	00008151 	.word	0x00008151
    5f50:	20002e98 	.word	0x20002e98
    5f54:	20002e90 	.word	0x20002e90
    5f58:	0000626d 	.word	0x0000626d
    5f5c:	20003eb4 	.word	0x20003eb4
    5f60:	0000ff3f 	.word	0x0000ff3f
    5f64:	00006b4d 	.word	0x00006b4d
    5f68:	20002e94 	.word	0x20002e94
    5f6c:	20002e9c 	.word	0x20002e9c
    5f70:	0000d26d 	.word	0x0000d26d
    5f74:	0000987d 	.word	0x0000987d
    5f78:	00005695 	.word	0x00005695
    5f7c:	0000596d 	.word	0x0000596d

00005f80 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
    5f80:	b590      	push	{r4, r7, lr}
    5f82:	b089      	sub	sp, #36	; 0x24
    5f84:	af00      	add	r7, sp, #0
    5f86:	60f8      	str	r0, [r7, #12]
    5f88:	60b9      	str	r1, [r7, #8]
    5f8a:	607a      	str	r2, [r7, #4]
    5f8c:	001a      	movs	r2, r3
    5f8e:	1cfb      	adds	r3, r7, #3
    5f90:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
    5f92:	687b      	ldr	r3, [r7, #4]
    5f94:	2b00      	cmp	r3, #0
    5f96:	d100      	bne.n	5f9a <ip_output_if+0x1a>
    5f98:	e101      	b.n	619e <ip_output_if+0x21e>
    u16_t ip_hlen = IP_HLEN;
    5f9a:	231e      	movs	r3, #30
    5f9c:	18fb      	adds	r3, r7, r3
    5f9e:	2214      	movs	r2, #20
    5fa0:	801a      	strh	r2, [r3, #0]
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
    5fa2:	68fb      	ldr	r3, [r7, #12]
    5fa4:	2114      	movs	r1, #20
    5fa6:	0018      	movs	r0, r3
    5fa8:	4b94      	ldr	r3, [pc, #592]	; (61fc <ip_output_if+0x27c>)
    5faa:	4798      	blx	r3
    5fac:	1e03      	subs	r3, r0, #0
    5fae:	d002      	beq.n	5fb6 <ip_output_if+0x36>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    5fb0:	2302      	movs	r3, #2
    5fb2:	425b      	negs	r3, r3
    5fb4:	e11e      	b.n	61f4 <ip_output_if+0x274>
    }

    iphdr = (struct ip_hdr *)p->payload;
    5fb6:	68fb      	ldr	r3, [r7, #12]
    5fb8:	685b      	ldr	r3, [r3, #4]
    5fba:	61bb      	str	r3, [r7, #24]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    5fbc:	69bb      	ldr	r3, [r7, #24]
    5fbe:	1cfa      	adds	r2, r7, #3
    5fc0:	7812      	ldrb	r2, [r2, #0]
    5fc2:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
    5fc4:	69bb      	ldr	r3, [r7, #24]
    5fc6:	2234      	movs	r2, #52	; 0x34
    5fc8:	18ba      	adds	r2, r7, r2
    5fca:	7812      	ldrb	r2, [r2, #0]
    5fcc:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
    5fce:	687b      	ldr	r3, [r7, #4]
    5fd0:	681a      	ldr	r2, [r3, #0]
    5fd2:	69bb      	ldr	r3, [r7, #24]
    5fd4:	21ff      	movs	r1, #255	; 0xff
    5fd6:	4011      	ands	r1, r2
    5fd8:	000c      	movs	r4, r1
    5fda:	7c19      	ldrb	r1, [r3, #16]
    5fdc:	2000      	movs	r0, #0
    5fde:	4001      	ands	r1, r0
    5fe0:	1c08      	adds	r0, r1, #0
    5fe2:	1c21      	adds	r1, r4, #0
    5fe4:	4301      	orrs	r1, r0
    5fe6:	7419      	strb	r1, [r3, #16]
    5fe8:	0a11      	lsrs	r1, r2, #8
    5fea:	20ff      	movs	r0, #255	; 0xff
    5fec:	4001      	ands	r1, r0
    5fee:	000c      	movs	r4, r1
    5ff0:	7c59      	ldrb	r1, [r3, #17]
    5ff2:	2000      	movs	r0, #0
    5ff4:	4001      	ands	r1, r0
    5ff6:	1c08      	adds	r0, r1, #0
    5ff8:	1c21      	adds	r1, r4, #0
    5ffa:	4301      	orrs	r1, r0
    5ffc:	7459      	strb	r1, [r3, #17]
    5ffe:	0c11      	lsrs	r1, r2, #16
    6000:	20ff      	movs	r0, #255	; 0xff
    6002:	4001      	ands	r1, r0
    6004:	000c      	movs	r4, r1
    6006:	7c99      	ldrb	r1, [r3, #18]
    6008:	2000      	movs	r0, #0
    600a:	4001      	ands	r1, r0
    600c:	1c08      	adds	r0, r1, #0
    600e:	1c21      	adds	r1, r4, #0
    6010:	4301      	orrs	r1, r0
    6012:	7499      	strb	r1, [r3, #18]
    6014:	0e10      	lsrs	r0, r2, #24
    6016:	7cda      	ldrb	r2, [r3, #19]
    6018:	2100      	movs	r1, #0
    601a:	400a      	ands	r2, r1
    601c:	1c11      	adds	r1, r2, #0
    601e:	1c02      	adds	r2, r0, #0
    6020:	430a      	orrs	r2, r1
    6022:	74da      	strb	r2, [r3, #19]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    6024:	231e      	movs	r3, #30
    6026:	18fb      	adds	r3, r7, r3
    6028:	881b      	ldrh	r3, [r3, #0]
    602a:	089b      	lsrs	r3, r3, #2
    602c:	b29b      	uxth	r3, r3
    602e:	b2db      	uxtb	r3, r3
    6030:	2240      	movs	r2, #64	; 0x40
    6032:	4313      	orrs	r3, r2
    6034:	b2da      	uxtb	r2, r3
    6036:	69bb      	ldr	r3, [r7, #24]
    6038:	701a      	strb	r2, [r3, #0]
    IPH_TOS_SET(iphdr, tos);
    603a:	69bb      	ldr	r3, [r7, #24]
    603c:	2230      	movs	r2, #48	; 0x30
    603e:	18ba      	adds	r2, r7, r2
    6040:	7812      	ldrb	r2, [r2, #0]
    6042:	705a      	strb	r2, [r3, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    6044:	68fb      	ldr	r3, [r7, #12]
    6046:	891b      	ldrh	r3, [r3, #8]
    6048:	0018      	movs	r0, r3
    604a:	4b6d      	ldr	r3, [pc, #436]	; (6200 <ip_output_if+0x280>)
    604c:	4798      	blx	r3
    604e:	0003      	movs	r3, r0
    6050:	001a      	movs	r2, r3
    6052:	69bb      	ldr	r3, [r7, #24]
    6054:	21ff      	movs	r1, #255	; 0xff
    6056:	4011      	ands	r1, r2
    6058:	000c      	movs	r4, r1
    605a:	7899      	ldrb	r1, [r3, #2]
    605c:	2000      	movs	r0, #0
    605e:	4001      	ands	r1, r0
    6060:	1c08      	adds	r0, r1, #0
    6062:	1c21      	adds	r1, r4, #0
    6064:	4301      	orrs	r1, r0
    6066:	7099      	strb	r1, [r3, #2]
    6068:	0a12      	lsrs	r2, r2, #8
    606a:	b290      	uxth	r0, r2
    606c:	78da      	ldrb	r2, [r3, #3]
    606e:	2100      	movs	r1, #0
    6070:	400a      	ands	r2, r1
    6072:	1c11      	adds	r1, r2, #0
    6074:	1c02      	adds	r2, r0, #0
    6076:	430a      	orrs	r2, r1
    6078:	70da      	strb	r2, [r3, #3]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    607a:	69bb      	ldr	r3, [r7, #24]
    607c:	799a      	ldrb	r2, [r3, #6]
    607e:	2100      	movs	r1, #0
    6080:	400a      	ands	r2, r1
    6082:	719a      	strb	r2, [r3, #6]
    6084:	79da      	ldrb	r2, [r3, #7]
    6086:	2100      	movs	r1, #0
    6088:	400a      	ands	r2, r1
    608a:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
    608c:	4b5d      	ldr	r3, [pc, #372]	; (6204 <ip_output_if+0x284>)
    608e:	881b      	ldrh	r3, [r3, #0]
    6090:	0018      	movs	r0, r3
    6092:	4b5b      	ldr	r3, [pc, #364]	; (6200 <ip_output_if+0x280>)
    6094:	4798      	blx	r3
    6096:	0003      	movs	r3, r0
    6098:	001a      	movs	r2, r3
    609a:	69bb      	ldr	r3, [r7, #24]
    609c:	21ff      	movs	r1, #255	; 0xff
    609e:	4011      	ands	r1, r2
    60a0:	000c      	movs	r4, r1
    60a2:	7919      	ldrb	r1, [r3, #4]
    60a4:	2000      	movs	r0, #0
    60a6:	4001      	ands	r1, r0
    60a8:	1c08      	adds	r0, r1, #0
    60aa:	1c21      	adds	r1, r4, #0
    60ac:	4301      	orrs	r1, r0
    60ae:	7119      	strb	r1, [r3, #4]
    60b0:	0a12      	lsrs	r2, r2, #8
    60b2:	b290      	uxth	r0, r2
    60b4:	795a      	ldrb	r2, [r3, #5]
    60b6:	2100      	movs	r1, #0
    60b8:	400a      	ands	r2, r1
    60ba:	1c11      	adds	r1, r2, #0
    60bc:	1c02      	adds	r2, r0, #0
    60be:	430a      	orrs	r2, r1
    60c0:	715a      	strb	r2, [r3, #5]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
    60c2:	4b50      	ldr	r3, [pc, #320]	; (6204 <ip_output_if+0x284>)
    60c4:	881b      	ldrh	r3, [r3, #0]
    60c6:	3301      	adds	r3, #1
    60c8:	b29a      	uxth	r2, r3
    60ca:	4b4e      	ldr	r3, [pc, #312]	; (6204 <ip_output_if+0x284>)
    60cc:	801a      	strh	r2, [r3, #0]

    if (ip_addr_isany(src)) {
    60ce:	68bb      	ldr	r3, [r7, #8]
    60d0:	2b00      	cmp	r3, #0
    60d2:	d003      	beq.n	60dc <ip_output_if+0x15c>
    60d4:	68bb      	ldr	r3, [r7, #8]
    60d6:	681b      	ldr	r3, [r3, #0]
    60d8:	2b00      	cmp	r3, #0
    60da:	d12b      	bne.n	6134 <ip_output_if+0x1b4>
      ip_addr_copy(iphdr->src, netif->ip_addr);
    60dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    60de:	685a      	ldr	r2, [r3, #4]
    60e0:	69bb      	ldr	r3, [r7, #24]
    60e2:	21ff      	movs	r1, #255	; 0xff
    60e4:	4011      	ands	r1, r2
    60e6:	000c      	movs	r4, r1
    60e8:	7b19      	ldrb	r1, [r3, #12]
    60ea:	2000      	movs	r0, #0
    60ec:	4001      	ands	r1, r0
    60ee:	1c08      	adds	r0, r1, #0
    60f0:	1c21      	adds	r1, r4, #0
    60f2:	4301      	orrs	r1, r0
    60f4:	7319      	strb	r1, [r3, #12]
    60f6:	0a11      	lsrs	r1, r2, #8
    60f8:	20ff      	movs	r0, #255	; 0xff
    60fa:	4001      	ands	r1, r0
    60fc:	000c      	movs	r4, r1
    60fe:	7b59      	ldrb	r1, [r3, #13]
    6100:	2000      	movs	r0, #0
    6102:	4001      	ands	r1, r0
    6104:	1c08      	adds	r0, r1, #0
    6106:	1c21      	adds	r1, r4, #0
    6108:	4301      	orrs	r1, r0
    610a:	7359      	strb	r1, [r3, #13]
    610c:	0c11      	lsrs	r1, r2, #16
    610e:	20ff      	movs	r0, #255	; 0xff
    6110:	4001      	ands	r1, r0
    6112:	000c      	movs	r4, r1
    6114:	7b99      	ldrb	r1, [r3, #14]
    6116:	2000      	movs	r0, #0
    6118:	4001      	ands	r1, r0
    611a:	1c08      	adds	r0, r1, #0
    611c:	1c21      	adds	r1, r4, #0
    611e:	4301      	orrs	r1, r0
    6120:	7399      	strb	r1, [r3, #14]
    6122:	0e10      	lsrs	r0, r2, #24
    6124:	7bda      	ldrb	r2, [r3, #15]
    6126:	2100      	movs	r1, #0
    6128:	400a      	ands	r2, r1
    612a:	1c11      	adds	r1, r2, #0
    612c:	1c02      	adds	r2, r0, #0
    612e:	430a      	orrs	r2, r1
    6130:	73da      	strb	r2, [r3, #15]
    6132:	e02a      	b.n	618a <ip_output_if+0x20a>
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
    6134:	68bb      	ldr	r3, [r7, #8]
    6136:	681a      	ldr	r2, [r3, #0]
    6138:	69bb      	ldr	r3, [r7, #24]
    613a:	21ff      	movs	r1, #255	; 0xff
    613c:	4011      	ands	r1, r2
    613e:	000c      	movs	r4, r1
    6140:	7b19      	ldrb	r1, [r3, #12]
    6142:	2000      	movs	r0, #0
    6144:	4001      	ands	r1, r0
    6146:	1c08      	adds	r0, r1, #0
    6148:	1c21      	adds	r1, r4, #0
    614a:	4301      	orrs	r1, r0
    614c:	7319      	strb	r1, [r3, #12]
    614e:	0a11      	lsrs	r1, r2, #8
    6150:	20ff      	movs	r0, #255	; 0xff
    6152:	4001      	ands	r1, r0
    6154:	000c      	movs	r4, r1
    6156:	7b59      	ldrb	r1, [r3, #13]
    6158:	2000      	movs	r0, #0
    615a:	4001      	ands	r1, r0
    615c:	1c08      	adds	r0, r1, #0
    615e:	1c21      	adds	r1, r4, #0
    6160:	4301      	orrs	r1, r0
    6162:	7359      	strb	r1, [r3, #13]
    6164:	0c11      	lsrs	r1, r2, #16
    6166:	20ff      	movs	r0, #255	; 0xff
    6168:	4001      	ands	r1, r0
    616a:	000c      	movs	r4, r1
    616c:	7b99      	ldrb	r1, [r3, #14]
    616e:	2000      	movs	r0, #0
    6170:	4001      	ands	r1, r0
    6172:	1c08      	adds	r0, r1, #0
    6174:	1c21      	adds	r1, r4, #0
    6176:	4301      	orrs	r1, r0
    6178:	7399      	strb	r1, [r3, #14]
    617a:	0e10      	lsrs	r0, r2, #24
    617c:	7bda      	ldrb	r2, [r3, #15]
    617e:	2100      	movs	r1, #0
    6180:	400a      	ands	r2, r1
    6182:	1c11      	adds	r1, r2, #0
    6184:	1c02      	adds	r2, r0, #0
    6186:	430a      	orrs	r2, r1
    6188:	73da      	strb	r2, [r3, #15]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    chk_sum = (chk_sum >> 16) + chk_sum;
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
    618a:	69bb      	ldr	r3, [r7, #24]
    618c:	7a9a      	ldrb	r2, [r3, #10]
    618e:	2100      	movs	r1, #0
    6190:	400a      	ands	r2, r1
    6192:	729a      	strb	r2, [r3, #10]
    6194:	7ada      	ldrb	r2, [r3, #11]
    6196:	2100      	movs	r1, #0
    6198:	400a      	ands	r2, r1
    619a:	72da      	strb	r2, [r3, #11]
    619c:	e011      	b.n	61c2 <ip_output_if+0x242>
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    619e:	68fb      	ldr	r3, [r7, #12]
    61a0:	685b      	ldr	r3, [r3, #4]
    61a2:	61bb      	str	r3, [r7, #24]
    ip_addr_copy(dest_addr, iphdr->dest);
    61a4:	69bb      	ldr	r3, [r7, #24]
    61a6:	7c1a      	ldrb	r2, [r3, #16]
    61a8:	7c59      	ldrb	r1, [r3, #17]
    61aa:	0209      	lsls	r1, r1, #8
    61ac:	430a      	orrs	r2, r1
    61ae:	7c99      	ldrb	r1, [r3, #18]
    61b0:	0409      	lsls	r1, r1, #16
    61b2:	430a      	orrs	r2, r1
    61b4:	7cdb      	ldrb	r3, [r3, #19]
    61b6:	061b      	lsls	r3, r3, #24
    61b8:	4313      	orrs	r3, r2
    61ba:	617b      	str	r3, [r7, #20]
    dest = &dest_addr;
    61bc:	2314      	movs	r3, #20
    61be:	18fb      	adds	r3, r7, r3
    61c0:	607b      	str	r3, [r7, #4]
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    61c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    61c4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    61c6:	2b00      	cmp	r3, #0
    61c8:	d00d      	beq.n	61e6 <ip_output_if+0x266>
    61ca:	68fb      	ldr	r3, [r7, #12]
    61cc:	891a      	ldrh	r2, [r3, #8]
    61ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    61d0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    61d2:	429a      	cmp	r2, r3
    61d4:	d907      	bls.n	61e6 <ip_output_if+0x266>
    return ip_frag(p, netif, dest);
    61d6:	687a      	ldr	r2, [r7, #4]
    61d8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    61da:	68fb      	ldr	r3, [r7, #12]
    61dc:	0018      	movs	r0, r3
    61de:	4b0a      	ldr	r3, [pc, #40]	; (6208 <ip_output_if+0x288>)
    61e0:	4798      	blx	r3
    61e2:	0003      	movs	r3, r0
    61e4:	e006      	b.n	61f4 <ip_output_if+0x274>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
    61e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    61e8:	695b      	ldr	r3, [r3, #20]
    61ea:	687a      	ldr	r2, [r7, #4]
    61ec:	68f9      	ldr	r1, [r7, #12]
    61ee:	6bb8      	ldr	r0, [r7, #56]	; 0x38
    61f0:	4798      	blx	r3
    61f2:	0003      	movs	r3, r0
}
    61f4:	0018      	movs	r0, r3
    61f6:	46bd      	mov	sp, r7
    61f8:	b009      	add	sp, #36	; 0x24
    61fa:	bd90      	pop	{r4, r7, pc}
    61fc:	00008235 	.word	0x00008235
    6200:	000055f1 	.word	0x000055f1
    6204:	20000b04 	.word	0x20000b04
    6208:	00006f31 	.word	0x00006f31

0000620c <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
    620c:	b590      	push	{r4, r7, lr}
    620e:	b08b      	sub	sp, #44	; 0x2c
    6210:	af04      	add	r7, sp, #16
    6212:	60f8      	str	r0, [r7, #12]
    6214:	60b9      	str	r1, [r7, #8]
    6216:	607a      	str	r2, [r7, #4]
    6218:	001a      	movs	r2, r3
    621a:	1cfb      	adds	r3, r7, #3
    621c:	701a      	strb	r2, [r3, #0]

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
    621e:	687b      	ldr	r3, [r7, #4]
    6220:	0018      	movs	r0, r3
    6222:	4b10      	ldr	r3, [pc, #64]	; (6264 <ip_output+0x58>)
    6224:	4798      	blx	r3
    6226:	0003      	movs	r3, r0
    6228:	617b      	str	r3, [r7, #20]
    622a:	697b      	ldr	r3, [r7, #20]
    622c:	2b00      	cmp	r3, #0
    622e:	d102      	bne.n	6236 <ip_output+0x2a>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
    6230:	2304      	movs	r3, #4
    6232:	425b      	negs	r3, r3
    6234:	e012      	b.n	625c <ip_output+0x50>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
    6236:	1cfb      	adds	r3, r7, #3
    6238:	781c      	ldrb	r4, [r3, #0]
    623a:	687a      	ldr	r2, [r7, #4]
    623c:	68b9      	ldr	r1, [r7, #8]
    623e:	68f8      	ldr	r0, [r7, #12]
    6240:	697b      	ldr	r3, [r7, #20]
    6242:	9302      	str	r3, [sp, #8]
    6244:	232c      	movs	r3, #44	; 0x2c
    6246:	18fb      	adds	r3, r7, r3
    6248:	781b      	ldrb	r3, [r3, #0]
    624a:	9301      	str	r3, [sp, #4]
    624c:	2328      	movs	r3, #40	; 0x28
    624e:	18fb      	adds	r3, r7, r3
    6250:	781b      	ldrb	r3, [r3, #0]
    6252:	9300      	str	r3, [sp, #0]
    6254:	0023      	movs	r3, r4
    6256:	4c04      	ldr	r4, [pc, #16]	; (6268 <ip_output+0x5c>)
    6258:	47a0      	blx	r4
    625a:	0003      	movs	r3, r0
}
    625c:	0018      	movs	r0, r3
    625e:	46bd      	mov	sp, r7
    6260:	b007      	add	sp, #28
    6262:	bd90      	pop	{r4, r7, pc}
    6264:	00005c89 	.word	0x00005c89
    6268:	00005f81 	.word	0x00005f81

0000626c <ip4_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
    626c:	b580      	push	{r7, lr}
    626e:	b084      	sub	sp, #16
    6270:	af00      	add	r7, sp, #0
    6272:	6078      	str	r0, [r7, #4]
    6274:	6039      	str	r1, [r7, #0]
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
    6276:	687b      	ldr	r3, [r7, #4]
    6278:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
    627a:	687b      	ldr	r3, [r7, #4]
    627c:	3301      	adds	r3, #1
    627e:	d002      	beq.n	6286 <ip4_addr_isbroadcast+0x1a>
    6280:	687b      	ldr	r3, [r7, #4]
    6282:	2b00      	cmp	r3, #0
    6284:	d101      	bne.n	628a <ip4_addr_isbroadcast+0x1e>
      (addr == IPADDR_ANY)) {
    return 1;
    6286:	2301      	movs	r3, #1
    6288:	e024      	b.n	62d4 <ip4_addr_isbroadcast+0x68>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
    628a:	683b      	ldr	r3, [r7, #0]
    628c:	222d      	movs	r2, #45	; 0x2d
    628e:	5c9b      	ldrb	r3, [r3, r2]
    6290:	001a      	movs	r2, r3
    6292:	2302      	movs	r3, #2
    6294:	4013      	ands	r3, r2
    6296:	d101      	bne.n	629c <ip4_addr_isbroadcast+0x30>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
    6298:	2300      	movs	r3, #0
    629a:	e01b      	b.n	62d4 <ip4_addr_isbroadcast+0x68>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    629c:	683b      	ldr	r3, [r7, #0]
    629e:	685a      	ldr	r2, [r3, #4]
    62a0:	687b      	ldr	r3, [r7, #4]
    62a2:	429a      	cmp	r2, r3
    62a4:	d101      	bne.n	62aa <ip4_addr_isbroadcast+0x3e>
    return 0;
    62a6:	2300      	movs	r3, #0
    62a8:	e014      	b.n	62d4 <ip4_addr_isbroadcast+0x68>
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
    62aa:	68fa      	ldr	r2, [r7, #12]
    62ac:	683b      	ldr	r3, [r7, #0]
    62ae:	685b      	ldr	r3, [r3, #4]
    62b0:	405a      	eors	r2, r3
    62b2:	683b      	ldr	r3, [r7, #0]
    62b4:	689b      	ldr	r3, [r3, #8]
    62b6:	4013      	ands	r3, r2
    62b8:	d10b      	bne.n	62d2 <ip4_addr_isbroadcast+0x66>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
    62ba:	683b      	ldr	r3, [r7, #0]
    62bc:	689b      	ldr	r3, [r3, #8]
    62be:	43db      	mvns	r3, r3
    62c0:	687a      	ldr	r2, [r7, #4]
    62c2:	401a      	ands	r2, r3
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    62c4:	683b      	ldr	r3, [r7, #0]
    62c6:	689b      	ldr	r3, [r3, #8]
    62c8:	43db      	mvns	r3, r3
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
    62ca:	429a      	cmp	r2, r3
    62cc:	d101      	bne.n	62d2 <ip4_addr_isbroadcast+0x66>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
    62ce:	2301      	movs	r3, #1
    62d0:	e000      	b.n	62d4 <ip4_addr_isbroadcast+0x68>
  } else {
    return 0;
    62d2:	2300      	movs	r3, #0
  }
}
    62d4:	0018      	movs	r0, r3
    62d6:	46bd      	mov	sp, r7
    62d8:	b004      	add	sp, #16
    62da:	bd80      	pop	{r7, pc}

000062dc <ipaddr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
    62dc:	b580      	push	{r7, lr}
    62de:	b082      	sub	sp, #8
    62e0:	af00      	add	r7, sp, #0
    62e2:	6078      	str	r0, [r7, #4]
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
    62e4:	4905      	ldr	r1, [pc, #20]	; (62fc <ipaddr_ntoa+0x20>)
    62e6:	687b      	ldr	r3, [r7, #4]
    62e8:	2210      	movs	r2, #16
    62ea:	0018      	movs	r0, r3
    62ec:	4b04      	ldr	r3, [pc, #16]	; (6300 <ipaddr_ntoa+0x24>)
    62ee:	4798      	blx	r3
    62f0:	0003      	movs	r3, r0
}
    62f2:	0018      	movs	r0, r3
    62f4:	46bd      	mov	sp, r7
    62f6:	b002      	add	sp, #8
    62f8:	bd80      	pop	{r7, pc}
    62fa:	46c0      	nop			; (mov r8, r8)
    62fc:	20000b08 	.word	0x20000b08
    6300:	00006305 	.word	0x00006305

00006304 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
    6304:	b590      	push	{r4, r7, lr}
    6306:	b08d      	sub	sp, #52	; 0x34
    6308:	af00      	add	r7, sp, #0
    630a:	60f8      	str	r0, [r7, #12]
    630c:	60b9      	str	r1, [r7, #8]
    630e:	607a      	str	r2, [r7, #4]
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
    6310:	2300      	movs	r3, #0
    6312:	623b      	str	r3, [r7, #32]

  s_addr = ip4_addr_get_u32(addr);
    6314:	68fb      	ldr	r3, [r7, #12]
    6316:	681b      	ldr	r3, [r3, #0]
    6318:	61bb      	str	r3, [r7, #24]

  rp = buf;
    631a:	68bb      	ldr	r3, [r7, #8]
    631c:	62fb      	str	r3, [r7, #44]	; 0x2c
  ap = (u8_t *)&s_addr;
    631e:	2318      	movs	r3, #24
    6320:	18fb      	adds	r3, r7, r3
    6322:	62bb      	str	r3, [r7, #40]	; 0x28
  for(n = 0; n < 4; n++) {
    6324:	2327      	movs	r3, #39	; 0x27
    6326:	18fb      	adds	r3, r7, r3
    6328:	2200      	movs	r2, #0
    632a:	701a      	strb	r2, [r3, #0]
    632c:	e05e      	b.n	63ec <ipaddr_ntoa_r+0xe8>
    i = 0;
    632e:	2326      	movs	r3, #38	; 0x26
    6330:	18fb      	adds	r3, r7, r3
    6332:	2200      	movs	r2, #0
    6334:	701a      	strb	r2, [r3, #0]
    do {
      rem = *ap % (u8_t)10;
    6336:	6abb      	ldr	r3, [r7, #40]	; 0x28
    6338:	781a      	ldrb	r2, [r3, #0]
    633a:	231f      	movs	r3, #31
    633c:	18fc      	adds	r4, r7, r3
    633e:	4b33      	ldr	r3, [pc, #204]	; (640c <ipaddr_ntoa_r+0x108>)
    6340:	210a      	movs	r1, #10
    6342:	0010      	movs	r0, r2
    6344:	4798      	blx	r3
    6346:	000b      	movs	r3, r1
    6348:	7023      	strb	r3, [r4, #0]
      *ap /= (u8_t)10;
    634a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    634c:	781a      	ldrb	r2, [r3, #0]
    634e:	4b30      	ldr	r3, [pc, #192]	; (6410 <ipaddr_ntoa_r+0x10c>)
    6350:	210a      	movs	r1, #10
    6352:	0010      	movs	r0, r2
    6354:	4798      	blx	r3
    6356:	0003      	movs	r3, r0
    6358:	b2da      	uxtb	r2, r3
    635a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    635c:	701a      	strb	r2, [r3, #0]
      inv[i++] = '0' + rem;
    635e:	2326      	movs	r3, #38	; 0x26
    6360:	18fb      	adds	r3, r7, r3
    6362:	781b      	ldrb	r3, [r3, #0]
    6364:	2226      	movs	r2, #38	; 0x26
    6366:	18ba      	adds	r2, r7, r2
    6368:	1c59      	adds	r1, r3, #1
    636a:	7011      	strb	r1, [r2, #0]
    636c:	001a      	movs	r2, r3
    636e:	231f      	movs	r3, #31
    6370:	18fb      	adds	r3, r7, r3
    6372:	781b      	ldrb	r3, [r3, #0]
    6374:	3330      	adds	r3, #48	; 0x30
    6376:	b2d9      	uxtb	r1, r3
    6378:	2314      	movs	r3, #20
    637a:	18fb      	adds	r3, r7, r3
    637c:	5499      	strb	r1, [r3, r2]
    } while(*ap);
    637e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    6380:	781b      	ldrb	r3, [r3, #0]
    6382:	2b00      	cmp	r3, #0
    6384:	d1d7      	bne.n	6336 <ipaddr_ntoa_r+0x32>
    while(i--) {
    6386:	e011      	b.n	63ac <ipaddr_ntoa_r+0xa8>
      if (len++ >= buflen) {
    6388:	6a3b      	ldr	r3, [r7, #32]
    638a:	1c5a      	adds	r2, r3, #1
    638c:	623a      	str	r2, [r7, #32]
    638e:	687a      	ldr	r2, [r7, #4]
    6390:	4293      	cmp	r3, r2
    6392:	db01      	blt.n	6398 <ipaddr_ntoa_r+0x94>
        return NULL;
    6394:	2300      	movs	r3, #0
    6396:	e035      	b.n	6404 <ipaddr_ntoa_r+0x100>
      }
      *rp++ = inv[i];
    6398:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    639a:	1c5a      	adds	r2, r3, #1
    639c:	62fa      	str	r2, [r7, #44]	; 0x2c
    639e:	2226      	movs	r2, #38	; 0x26
    63a0:	18ba      	adds	r2, r7, r2
    63a2:	7812      	ldrb	r2, [r2, #0]
    63a4:	2114      	movs	r1, #20
    63a6:	1879      	adds	r1, r7, r1
    63a8:	5c8a      	ldrb	r2, [r1, r2]
    63aa:	701a      	strb	r2, [r3, #0]
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
    63ac:	2326      	movs	r3, #38	; 0x26
    63ae:	18fb      	adds	r3, r7, r3
    63b0:	781b      	ldrb	r3, [r3, #0]
    63b2:	2226      	movs	r2, #38	; 0x26
    63b4:	18ba      	adds	r2, r7, r2
    63b6:	1e59      	subs	r1, r3, #1
    63b8:	7011      	strb	r1, [r2, #0]
    63ba:	2b00      	cmp	r3, #0
    63bc:	d1e4      	bne.n	6388 <ipaddr_ntoa_r+0x84>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
    63be:	6a3b      	ldr	r3, [r7, #32]
    63c0:	1c5a      	adds	r2, r3, #1
    63c2:	623a      	str	r2, [r7, #32]
    63c4:	687a      	ldr	r2, [r7, #4]
    63c6:	4293      	cmp	r3, r2
    63c8:	db01      	blt.n	63ce <ipaddr_ntoa_r+0xca>
      return NULL;
    63ca:	2300      	movs	r3, #0
    63cc:	e01a      	b.n	6404 <ipaddr_ntoa_r+0x100>
    }
    *rp++ = '.';
    63ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    63d0:	1c5a      	adds	r2, r3, #1
    63d2:	62fa      	str	r2, [r7, #44]	; 0x2c
    63d4:	222e      	movs	r2, #46	; 0x2e
    63d6:	701a      	strb	r2, [r3, #0]
    ap++;
    63d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    63da:	3301      	adds	r3, #1
    63dc:	62bb      	str	r3, [r7, #40]	; 0x28

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    63de:	2327      	movs	r3, #39	; 0x27
    63e0:	18fb      	adds	r3, r7, r3
    63e2:	781a      	ldrb	r2, [r3, #0]
    63e4:	2327      	movs	r3, #39	; 0x27
    63e6:	18fb      	adds	r3, r7, r3
    63e8:	3201      	adds	r2, #1
    63ea:	701a      	strb	r2, [r3, #0]
    63ec:	2327      	movs	r3, #39	; 0x27
    63ee:	18fb      	adds	r3, r7, r3
    63f0:	781b      	ldrb	r3, [r3, #0]
    63f2:	2b03      	cmp	r3, #3
    63f4:	d99b      	bls.n	632e <ipaddr_ntoa_r+0x2a>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
    63f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    63f8:	3b01      	subs	r3, #1
    63fa:	62fb      	str	r3, [r7, #44]	; 0x2c
    63fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    63fe:	2200      	movs	r2, #0
    6400:	701a      	strb	r2, [r3, #0]
  return buf;
    6402:	68bb      	ldr	r3, [r7, #8]
}
    6404:	0018      	movs	r0, r3
    6406:	46bd      	mov	sp, r7
    6408:	b00d      	add	sp, #52	; 0x34
    640a:	bd90      	pop	{r4, r7, pc}
    640c:	0000f9f9 	.word	0x0000f9f9
    6410:	0000f8ed 	.word	0x0000f8ed

00006414 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
    6414:	b580      	push	{r7, lr}
    6416:	b084      	sub	sp, #16
    6418:	af00      	add	r7, sp, #0
  struct ip_reassdata *r, *prev = NULL;
    641a:	2300      	movs	r3, #0
    641c:	60bb      	str	r3, [r7, #8]

  r = reassdatagrams;
    641e:	4b13      	ldr	r3, [pc, #76]	; (646c <ip_reass_tmr+0x58>)
    6420:	681b      	ldr	r3, [r3, #0]
    6422:	60fb      	str	r3, [r7, #12]
  while (r != NULL) {
    6424:	e01a      	b.n	645c <ip_reass_tmr+0x48>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
    6426:	68fb      	ldr	r3, [r7, #12]
    6428:	7fdb      	ldrb	r3, [r3, #31]
    642a:	2b00      	cmp	r3, #0
    642c:	d00b      	beq.n	6446 <ip_reass_tmr+0x32>
      r->timer--;
    642e:	68fb      	ldr	r3, [r7, #12]
    6430:	7fdb      	ldrb	r3, [r3, #31]
    6432:	3b01      	subs	r3, #1
    6434:	b2da      	uxtb	r2, r3
    6436:	68fb      	ldr	r3, [r7, #12]
    6438:	77da      	strb	r2, [r3, #31]
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
    643a:	68fb      	ldr	r3, [r7, #12]
    643c:	60bb      	str	r3, [r7, #8]
      r = r->next;
    643e:	68fb      	ldr	r3, [r7, #12]
    6440:	681b      	ldr	r3, [r3, #0]
    6442:	60fb      	str	r3, [r7, #12]
    6444:	e00a      	b.n	645c <ip_reass_tmr+0x48>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
    6446:	68fb      	ldr	r3, [r7, #12]
    6448:	607b      	str	r3, [r7, #4]
      /* get the next pointer before freeing */
      r = r->next;
    644a:	68fb      	ldr	r3, [r7, #12]
    644c:	681b      	ldr	r3, [r3, #0]
    644e:	60fb      	str	r3, [r7, #12]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
    6450:	68ba      	ldr	r2, [r7, #8]
    6452:	687b      	ldr	r3, [r7, #4]
    6454:	0011      	movs	r1, r2
    6456:	0018      	movs	r0, r3
    6458:	4b05      	ldr	r3, [pc, #20]	; (6470 <ip_reass_tmr+0x5c>)
    645a:	4798      	blx	r3
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
    645c:	68fb      	ldr	r3, [r7, #12]
    645e:	2b00      	cmp	r3, #0
    6460:	d1e1      	bne.n	6426 <ip_reass_tmr+0x12>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
    6462:	46c0      	nop			; (mov r8, r8)
    6464:	46bd      	mov	sp, r7
    6466:	b004      	add	sp, #16
    6468:	bd80      	pop	{r7, pc}
    646a:	46c0      	nop			; (mov r8, r8)
    646c:	20000b18 	.word	0x20000b18
    6470:	00006475 	.word	0x00006475

00006474 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    6474:	b590      	push	{r4, r7, lr}
    6476:	b089      	sub	sp, #36	; 0x24
    6478:	af00      	add	r7, sp, #0
    647a:	6078      	str	r0, [r7, #4]
    647c:	6039      	str	r1, [r7, #0]
  u16_t pbufs_freed = 0;
    647e:	231e      	movs	r3, #30
    6480:	18fb      	adds	r3, r7, r3
    6482:	2200      	movs	r2, #0
    6484:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
    6486:	687b      	ldr	r3, [r7, #4]
    6488:	685b      	ldr	r3, [r3, #4]
    648a:	685b      	ldr	r3, [r3, #4]
    648c:	617b      	str	r3, [r7, #20]
  if (iprh->start == 0) {
    648e:	697b      	ldr	r3, [r7, #20]
    6490:	791a      	ldrb	r2, [r3, #4]
    6492:	795b      	ldrb	r3, [r3, #5]
    6494:	021b      	lsls	r3, r3, #8
    6496:	4313      	orrs	r3, r2
    6498:	b29b      	uxth	r3, r3
    649a:	2b00      	cmp	r3, #0
    649c:	d134      	bne.n	6508 <ip_reass_free_complete_datagram+0x94>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    649e:	687b      	ldr	r3, [r7, #4]
    64a0:	685b      	ldr	r3, [r3, #4]
    64a2:	61bb      	str	r3, [r7, #24]
    ipr->p = iprh->next_pbuf;
    64a4:	697b      	ldr	r3, [r7, #20]
    64a6:	781a      	ldrb	r2, [r3, #0]
    64a8:	7859      	ldrb	r1, [r3, #1]
    64aa:	0209      	lsls	r1, r1, #8
    64ac:	430a      	orrs	r2, r1
    64ae:	7899      	ldrb	r1, [r3, #2]
    64b0:	0409      	lsls	r1, r1, #16
    64b2:	430a      	orrs	r2, r1
    64b4:	78db      	ldrb	r3, [r3, #3]
    64b6:	061b      	lsls	r3, r3, #24
    64b8:	4313      	orrs	r3, r2
    64ba:	001a      	movs	r2, r3
    64bc:	687b      	ldr	r3, [r7, #4]
    64be:	605a      	str	r2, [r3, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
    64c0:	69bb      	ldr	r3, [r7, #24]
    64c2:	6858      	ldr	r0, [r3, #4]
    64c4:	687b      	ldr	r3, [r7, #4]
    64c6:	3308      	adds	r3, #8
    64c8:	2214      	movs	r2, #20
    64ca:	0019      	movs	r1, r3
    64cc:	4b31      	ldr	r3, [pc, #196]	; (6594 <ip_reass_free_complete_datagram+0x120>)
    64ce:	4798      	blx	r3
    icmp_time_exceeded(p, ICMP_TE_FRAG);
    64d0:	69bb      	ldr	r3, [r7, #24]
    64d2:	2101      	movs	r1, #1
    64d4:	0018      	movs	r0, r3
    64d6:	4b30      	ldr	r3, [pc, #192]	; (6598 <ip_reass_free_complete_datagram+0x124>)
    64d8:	4798      	blx	r3
    clen = pbuf_clen(p);
    64da:	2313      	movs	r3, #19
    64dc:	18fc      	adds	r4, r7, r3
    64de:	69bb      	ldr	r3, [r7, #24]
    64e0:	0018      	movs	r0, r3
    64e2:	4b2e      	ldr	r3, [pc, #184]	; (659c <ip_reass_free_complete_datagram+0x128>)
    64e4:	4798      	blx	r3
    64e6:	0003      	movs	r3, r0
    64e8:	7023      	strb	r3, [r4, #0]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    64ea:	2313      	movs	r3, #19
    64ec:	18fb      	adds	r3, r7, r3
    64ee:	781b      	ldrb	r3, [r3, #0]
    64f0:	b299      	uxth	r1, r3
    64f2:	231e      	movs	r3, #30
    64f4:	18fb      	adds	r3, r7, r3
    64f6:	221e      	movs	r2, #30
    64f8:	18ba      	adds	r2, r7, r2
    64fa:	8812      	ldrh	r2, [r2, #0]
    64fc:	188a      	adds	r2, r1, r2
    64fe:	801a      	strh	r2, [r3, #0]
    pbuf_free(p);
    6500:	69bb      	ldr	r3, [r7, #24]
    6502:	0018      	movs	r0, r3
    6504:	4b26      	ldr	r3, [pc, #152]	; (65a0 <ip_reass_free_complete_datagram+0x12c>)
    6506:	4798      	blx	r3
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
    6508:	687b      	ldr	r3, [r7, #4]
    650a:	685b      	ldr	r3, [r3, #4]
    650c:	61bb      	str	r3, [r7, #24]
  while (p != NULL) {
    650e:	e027      	b.n	6560 <ip_reass_free_complete_datagram+0xec>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    6510:	69bb      	ldr	r3, [r7, #24]
    6512:	685b      	ldr	r3, [r3, #4]
    6514:	617b      	str	r3, [r7, #20]
    pcur = p;
    6516:	69bb      	ldr	r3, [r7, #24]
    6518:	60fb      	str	r3, [r7, #12]
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    651a:	697b      	ldr	r3, [r7, #20]
    651c:	781a      	ldrb	r2, [r3, #0]
    651e:	7859      	ldrb	r1, [r3, #1]
    6520:	0209      	lsls	r1, r1, #8
    6522:	430a      	orrs	r2, r1
    6524:	7899      	ldrb	r1, [r3, #2]
    6526:	0409      	lsls	r1, r1, #16
    6528:	430a      	orrs	r2, r1
    652a:	78db      	ldrb	r3, [r3, #3]
    652c:	061b      	lsls	r3, r3, #24
    652e:	4313      	orrs	r3, r2
    6530:	61bb      	str	r3, [r7, #24]
    clen = pbuf_clen(pcur);
    6532:	2313      	movs	r3, #19
    6534:	18fc      	adds	r4, r7, r3
    6536:	68fb      	ldr	r3, [r7, #12]
    6538:	0018      	movs	r0, r3
    653a:	4b18      	ldr	r3, [pc, #96]	; (659c <ip_reass_free_complete_datagram+0x128>)
    653c:	4798      	blx	r3
    653e:	0003      	movs	r3, r0
    6540:	7023      	strb	r3, [r4, #0]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    6542:	2313      	movs	r3, #19
    6544:	18fb      	adds	r3, r7, r3
    6546:	781b      	ldrb	r3, [r3, #0]
    6548:	b299      	uxth	r1, r3
    654a:	231e      	movs	r3, #30
    654c:	18fb      	adds	r3, r7, r3
    654e:	221e      	movs	r2, #30
    6550:	18ba      	adds	r2, r7, r2
    6552:	8812      	ldrh	r2, [r2, #0]
    6554:	188a      	adds	r2, r1, r2
    6556:	801a      	strh	r2, [r3, #0]
    pbuf_free(pcur);
    6558:	68fb      	ldr	r3, [r7, #12]
    655a:	0018      	movs	r0, r3
    655c:	4b10      	ldr	r3, [pc, #64]	; (65a0 <ip_reass_free_complete_datagram+0x12c>)
    655e:	4798      	blx	r3
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    6560:	69bb      	ldr	r3, [r7, #24]
    6562:	2b00      	cmp	r3, #0
    6564:	d1d4      	bne.n	6510 <ip_reass_free_complete_datagram+0x9c>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
    6566:	683a      	ldr	r2, [r7, #0]
    6568:	687b      	ldr	r3, [r7, #4]
    656a:	0011      	movs	r1, r2
    656c:	0018      	movs	r0, r3
    656e:	4b0d      	ldr	r3, [pc, #52]	; (65a4 <ip_reass_free_complete_datagram+0x130>)
    6570:	4798      	blx	r3
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
    6572:	4b0d      	ldr	r3, [pc, #52]	; (65a8 <ip_reass_free_complete_datagram+0x134>)
    6574:	881a      	ldrh	r2, [r3, #0]
    6576:	231e      	movs	r3, #30
    6578:	18fb      	adds	r3, r7, r3
    657a:	881b      	ldrh	r3, [r3, #0]
    657c:	1ad3      	subs	r3, r2, r3
    657e:	b29a      	uxth	r2, r3
    6580:	4b09      	ldr	r3, [pc, #36]	; (65a8 <ip_reass_free_complete_datagram+0x134>)
    6582:	801a      	strh	r2, [r3, #0]

  return pbufs_freed;
    6584:	231e      	movs	r3, #30
    6586:	18fb      	adds	r3, r7, r3
    6588:	881b      	ldrh	r3, [r3, #0]
}
    658a:	0018      	movs	r0, r3
    658c:	46bd      	mov	sp, r7
    658e:	b009      	add	sp, #36	; 0x24
    6590:	bd90      	pop	{r4, r7, pc}
    6592:	46c0      	nop			; (mov r8, r8)
    6594:	0000fc43 	.word	0x0000fc43
    6598:	00005995 	.word	0x00005995
    659c:	00008431 	.word	0x00008431
    65a0:	00008349 	.word	0x00008349
    65a4:	00006729 	.word	0x00006729
    65a8:	20000b1c 	.word	0x20000b1c

000065ac <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
    65ac:	b580      	push	{r7, lr}
    65ae:	b088      	sub	sp, #32
    65b0:	af00      	add	r7, sp, #0
    65b2:	6078      	str	r0, [r7, #4]
    65b4:	6039      	str	r1, [r7, #0]
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
    65b6:	2300      	movs	r3, #0
    65b8:	613b      	str	r3, [r7, #16]
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    65ba:	2300      	movs	r3, #0
    65bc:	61bb      	str	r3, [r7, #24]
    prev = NULL;
    65be:	2300      	movs	r3, #0
    65c0:	617b      	str	r3, [r7, #20]
    other_datagrams = 0;
    65c2:	2300      	movs	r3, #0
    65c4:	60fb      	str	r3, [r7, #12]
    r = reassdatagrams;
    65c6:	4b32      	ldr	r3, [pc, #200]	; (6690 <ip_reass_remove_oldest_datagram+0xe4>)
    65c8:	681b      	ldr	r3, [r3, #0]
    65ca:	61fb      	str	r3, [r7, #28]
    while (r != NULL) {
    65cc:	e041      	b.n	6652 <ip_reass_remove_oldest_datagram+0xa6>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
    65ce:	69fb      	ldr	r3, [r7, #28]
    65d0:	695a      	ldr	r2, [r3, #20]
    65d2:	687b      	ldr	r3, [r7, #4]
    65d4:	7b19      	ldrb	r1, [r3, #12]
    65d6:	7b58      	ldrb	r0, [r3, #13]
    65d8:	0200      	lsls	r0, r0, #8
    65da:	4301      	orrs	r1, r0
    65dc:	7b98      	ldrb	r0, [r3, #14]
    65de:	0400      	lsls	r0, r0, #16
    65e0:	4301      	orrs	r1, r0
    65e2:	7bdb      	ldrb	r3, [r3, #15]
    65e4:	061b      	lsls	r3, r3, #24
    65e6:	430b      	orrs	r3, r1
    65e8:	429a      	cmp	r2, r3
    65ea:	d118      	bne.n	661e <ip_reass_remove_oldest_datagram+0x72>
    65ec:	69fb      	ldr	r3, [r7, #28]
    65ee:	699a      	ldr	r2, [r3, #24]
    65f0:	687b      	ldr	r3, [r7, #4]
    65f2:	7c19      	ldrb	r1, [r3, #16]
    65f4:	7c58      	ldrb	r0, [r3, #17]
    65f6:	0200      	lsls	r0, r0, #8
    65f8:	4301      	orrs	r1, r0
    65fa:	7c98      	ldrb	r0, [r3, #18]
    65fc:	0400      	lsls	r0, r0, #16
    65fe:	4301      	orrs	r1, r0
    6600:	7cdb      	ldrb	r3, [r3, #19]
    6602:	061b      	lsls	r3, r3, #24
    6604:	430b      	orrs	r3, r1
    6606:	429a      	cmp	r2, r3
    6608:	d109      	bne.n	661e <ip_reass_remove_oldest_datagram+0x72>
    660a:	69fb      	ldr	r3, [r7, #28]
    660c:	899a      	ldrh	r2, [r3, #12]
    660e:	687b      	ldr	r3, [r7, #4]
    6610:	7919      	ldrb	r1, [r3, #4]
    6612:	795b      	ldrb	r3, [r3, #5]
    6614:	021b      	lsls	r3, r3, #8
    6616:	430b      	orrs	r3, r1
    6618:	b29b      	uxth	r3, r3
    661a:	429a      	cmp	r2, r3
    661c:	d010      	beq.n	6640 <ip_reass_remove_oldest_datagram+0x94>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
    661e:	68fb      	ldr	r3, [r7, #12]
    6620:	3301      	adds	r3, #1
    6622:	60fb      	str	r3, [r7, #12]
        if (oldest == NULL) {
    6624:	69bb      	ldr	r3, [r7, #24]
    6626:	2b00      	cmp	r3, #0
    6628:	d102      	bne.n	6630 <ip_reass_remove_oldest_datagram+0x84>
          oldest = r;
    662a:	69fb      	ldr	r3, [r7, #28]
    662c:	61bb      	str	r3, [r7, #24]
    662e:	e007      	b.n	6640 <ip_reass_remove_oldest_datagram+0x94>
        } else if (r->timer <= oldest->timer) {
    6630:	69fb      	ldr	r3, [r7, #28]
    6632:	7fda      	ldrb	r2, [r3, #31]
    6634:	69bb      	ldr	r3, [r7, #24]
    6636:	7fdb      	ldrb	r3, [r3, #31]
    6638:	429a      	cmp	r2, r3
    663a:	d801      	bhi.n	6640 <ip_reass_remove_oldest_datagram+0x94>
          /* older than the previous oldest */
          oldest = r;
    663c:	69fb      	ldr	r3, [r7, #28]
    663e:	61bb      	str	r3, [r7, #24]
        }
      }
      if (r->next != NULL) {
    6640:	69fb      	ldr	r3, [r7, #28]
    6642:	681b      	ldr	r3, [r3, #0]
    6644:	2b00      	cmp	r3, #0
    6646:	d001      	beq.n	664c <ip_reass_remove_oldest_datagram+0xa0>
        prev = r;
    6648:	69fb      	ldr	r3, [r7, #28]
    664a:	617b      	str	r3, [r7, #20]
      }
      r = r->next;
    664c:	69fb      	ldr	r3, [r7, #28]
    664e:	681b      	ldr	r3, [r3, #0]
    6650:	61fb      	str	r3, [r7, #28]
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
    6652:	69fb      	ldr	r3, [r7, #28]
    6654:	2b00      	cmp	r3, #0
    6656:	d1ba      	bne.n	65ce <ip_reass_remove_oldest_datagram+0x22>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
    6658:	69bb      	ldr	r3, [r7, #24]
    665a:	2b00      	cmp	r3, #0
    665c:	d00b      	beq.n	6676 <ip_reass_remove_oldest_datagram+0xca>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
    665e:	697a      	ldr	r2, [r7, #20]
    6660:	69bb      	ldr	r3, [r7, #24]
    6662:	0011      	movs	r1, r2
    6664:	0018      	movs	r0, r3
    6666:	4b0b      	ldr	r3, [pc, #44]	; (6694 <ip_reass_remove_oldest_datagram+0xe8>)
    6668:	4798      	blx	r3
    666a:	0003      	movs	r3, r0
    666c:	60bb      	str	r3, [r7, #8]
      pbufs_freed += pbufs_freed_current;
    666e:	693a      	ldr	r2, [r7, #16]
    6670:	68bb      	ldr	r3, [r7, #8]
    6672:	18d3      	adds	r3, r2, r3
    6674:	613b      	str	r3, [r7, #16]
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
    6676:	693a      	ldr	r2, [r7, #16]
    6678:	683b      	ldr	r3, [r7, #0]
    667a:	429a      	cmp	r2, r3
    667c:	da02      	bge.n	6684 <ip_reass_remove_oldest_datagram+0xd8>
    667e:	68fb      	ldr	r3, [r7, #12]
    6680:	2b01      	cmp	r3, #1
    6682:	dc9a      	bgt.n	65ba <ip_reass_remove_oldest_datagram+0xe>
  return pbufs_freed;
    6684:	693b      	ldr	r3, [r7, #16]
}
    6686:	0018      	movs	r0, r3
    6688:	46bd      	mov	sp, r7
    668a:	b008      	add	sp, #32
    668c:	bd80      	pop	{r7, pc}
    668e:	46c0      	nop			; (mov r8, r8)
    6690:	20000b18 	.word	0x20000b18
    6694:	00006475 	.word	0x00006475

00006698 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
    6698:	b580      	push	{r7, lr}
    669a:	b084      	sub	sp, #16
    669c:	af00      	add	r7, sp, #0
    669e:	6078      	str	r0, [r7, #4]
    66a0:	6039      	str	r1, [r7, #0]
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    66a2:	2004      	movs	r0, #4
    66a4:	4b1b      	ldr	r3, [pc, #108]	; (6714 <ip_reass_enqueue_new_datagram+0x7c>)
    66a6:	4798      	blx	r3
    66a8:	0003      	movs	r3, r0
    66aa:	60fb      	str	r3, [r7, #12]
  if (ipr == NULL) {
    66ac:	68fb      	ldr	r3, [r7, #12]
    66ae:	2b00      	cmp	r3, #0
    66b0:	d113      	bne.n	66da <ip_reass_enqueue_new_datagram+0x42>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
    66b2:	683a      	ldr	r2, [r7, #0]
    66b4:	687b      	ldr	r3, [r7, #4]
    66b6:	0011      	movs	r1, r2
    66b8:	0018      	movs	r0, r3
    66ba:	4b17      	ldr	r3, [pc, #92]	; (6718 <ip_reass_enqueue_new_datagram+0x80>)
    66bc:	4798      	blx	r3
    66be:	1e02      	subs	r2, r0, #0
    66c0:	683b      	ldr	r3, [r7, #0]
    66c2:	429a      	cmp	r2, r3
    66c4:	db04      	blt.n	66d0 <ip_reass_enqueue_new_datagram+0x38>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
    66c6:	2004      	movs	r0, #4
    66c8:	4b12      	ldr	r3, [pc, #72]	; (6714 <ip_reass_enqueue_new_datagram+0x7c>)
    66ca:	4798      	blx	r3
    66cc:	0003      	movs	r3, r0
    66ce:	60fb      	str	r3, [r7, #12]
    }
    if (ipr == NULL)
    66d0:	68fb      	ldr	r3, [r7, #12]
    66d2:	2b00      	cmp	r3, #0
    66d4:	d101      	bne.n	66da <ip_reass_enqueue_new_datagram+0x42>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    66d6:	2300      	movs	r3, #0
    66d8:	e017      	b.n	670a <ip_reass_enqueue_new_datagram+0x72>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
    66da:	68fb      	ldr	r3, [r7, #12]
    66dc:	2220      	movs	r2, #32
    66de:	2100      	movs	r1, #0
    66e0:	0018      	movs	r0, r3
    66e2:	4b0e      	ldr	r3, [pc, #56]	; (671c <ip_reass_enqueue_new_datagram+0x84>)
    66e4:	4798      	blx	r3
  ipr->timer = IP_REASS_MAXAGE;
    66e6:	68fb      	ldr	r3, [r7, #12]
    66e8:	2203      	movs	r2, #3
    66ea:	77da      	strb	r2, [r3, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
    66ec:	4b0c      	ldr	r3, [pc, #48]	; (6720 <ip_reass_enqueue_new_datagram+0x88>)
    66ee:	681a      	ldr	r2, [r3, #0]
    66f0:	68fb      	ldr	r3, [r7, #12]
    66f2:	601a      	str	r2, [r3, #0]
  reassdatagrams = ipr;
    66f4:	4b0a      	ldr	r3, [pc, #40]	; (6720 <ip_reass_enqueue_new_datagram+0x88>)
    66f6:	68fa      	ldr	r2, [r7, #12]
    66f8:	601a      	str	r2, [r3, #0]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
    66fa:	68fb      	ldr	r3, [r7, #12]
    66fc:	3308      	adds	r3, #8
    66fe:	6879      	ldr	r1, [r7, #4]
    6700:	2214      	movs	r2, #20
    6702:	0018      	movs	r0, r3
    6704:	4b07      	ldr	r3, [pc, #28]	; (6724 <ip_reass_enqueue_new_datagram+0x8c>)
    6706:	4798      	blx	r3
  return ipr;
    6708:	68fb      	ldr	r3, [r7, #12]
}
    670a:	0018      	movs	r0, r3
    670c:	46bd      	mov	sp, r7
    670e:	b004      	add	sp, #16
    6710:	bd80      	pop	{r7, pc}
    6712:	46c0      	nop			; (mov r8, r8)
    6714:	00007af1 	.word	0x00007af1
    6718:	000065ad 	.word	0x000065ad
    671c:	0000fc55 	.word	0x0000fc55
    6720:	20000b18 	.word	0x20000b18
    6724:	0000fc43 	.word	0x0000fc43

00006728 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
    6728:	b580      	push	{r7, lr}
    672a:	b082      	sub	sp, #8
    672c:	af00      	add	r7, sp, #0
    672e:	6078      	str	r0, [r7, #4]
    6730:	6039      	str	r1, [r7, #0]
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    6732:	4b0b      	ldr	r3, [pc, #44]	; (6760 <ip_reass_dequeue_datagram+0x38>)
    6734:	681a      	ldr	r2, [r3, #0]
    6736:	687b      	ldr	r3, [r7, #4]
    6738:	429a      	cmp	r2, r3
    673a:	d104      	bne.n	6746 <ip_reass_dequeue_datagram+0x1e>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
    673c:	687b      	ldr	r3, [r7, #4]
    673e:	681a      	ldr	r2, [r3, #0]
    6740:	4b07      	ldr	r3, [pc, #28]	; (6760 <ip_reass_dequeue_datagram+0x38>)
    6742:	601a      	str	r2, [r3, #0]
    6744:	e003      	b.n	674e <ip_reass_dequeue_datagram+0x26>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
    6746:	687b      	ldr	r3, [r7, #4]
    6748:	681a      	ldr	r2, [r3, #0]
    674a:	683b      	ldr	r3, [r7, #0]
    674c:	601a      	str	r2, [r3, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
    674e:	687b      	ldr	r3, [r7, #4]
    6750:	0019      	movs	r1, r3
    6752:	2004      	movs	r0, #4
    6754:	4b03      	ldr	r3, [pc, #12]	; (6764 <ip_reass_dequeue_datagram+0x3c>)
    6756:	4798      	blx	r3
}
    6758:	46c0      	nop			; (mov r8, r8)
    675a:	46bd      	mov	sp, r7
    675c:	b002      	add	sp, #8
    675e:	bd80      	pop	{r7, pc}
    6760:	20000b18 	.word	0x20000b18
    6764:	00007b39 	.word	0x00007b39

00006768 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
    6768:	b590      	push	{r4, r7, lr}
    676a:	b08b      	sub	sp, #44	; 0x2c
    676c:	af00      	add	r7, sp, #0
    676e:	6078      	str	r0, [r7, #4]
    6770:	6039      	str	r1, [r7, #0]
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
    6772:	2300      	movs	r3, #0
    6774:	627b      	str	r3, [r7, #36]	; 0x24
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
    6776:	2301      	movs	r3, #1
    6778:	61fb      	str	r3, [r7, #28]

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
    677a:	683b      	ldr	r3, [r7, #0]
    677c:	685b      	ldr	r3, [r3, #4]
    677e:	61bb      	str	r3, [r7, #24]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    6780:	69bb      	ldr	r3, [r7, #24]
    6782:	789a      	ldrb	r2, [r3, #2]
    6784:	78db      	ldrb	r3, [r3, #3]
    6786:	021b      	lsls	r3, r3, #8
    6788:	4313      	orrs	r3, r2
    678a:	b29b      	uxth	r3, r3
    678c:	0018      	movs	r0, r3
    678e:	4bdf      	ldr	r3, [pc, #892]	; (6b0c <ip_reass_chain_frag_into_datagram_and_validate+0x3a4>)
    6790:	4798      	blx	r3
    6792:	0003      	movs	r3, r0
    6794:	0019      	movs	r1, r3
    6796:	69bb      	ldr	r3, [r7, #24]
    6798:	781b      	ldrb	r3, [r3, #0]
    679a:	b29b      	uxth	r3, r3
    679c:	220f      	movs	r2, #15
    679e:	4013      	ands	r3, r2
    67a0:	b29b      	uxth	r3, r3
    67a2:	009b      	lsls	r3, r3, #2
    67a4:	b29a      	uxth	r2, r3
    67a6:	2316      	movs	r3, #22
    67a8:	18fb      	adds	r3, r7, r3
    67aa:	1a8a      	subs	r2, r1, r2
    67ac:	801a      	strh	r2, [r3, #0]
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    67ae:	69bb      	ldr	r3, [r7, #24]
    67b0:	799a      	ldrb	r2, [r3, #6]
    67b2:	79db      	ldrb	r3, [r3, #7]
    67b4:	021b      	lsls	r3, r3, #8
    67b6:	4313      	orrs	r3, r2
    67b8:	b29b      	uxth	r3, r3
    67ba:	0018      	movs	r0, r3
    67bc:	4bd3      	ldr	r3, [pc, #844]	; (6b0c <ip_reass_chain_frag_into_datagram_and_validate+0x3a4>)
    67be:	4798      	blx	r3
    67c0:	0003      	movs	r3, r0
    67c2:	04db      	lsls	r3, r3, #19
    67c4:	0cdb      	lsrs	r3, r3, #19
    67c6:	b29a      	uxth	r2, r3
    67c8:	2314      	movs	r3, #20
    67ca:	18fb      	adds	r3, r7, r3
    67cc:	00d2      	lsls	r2, r2, #3
    67ce:	801a      	strh	r2, [r3, #0]
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
    67d0:	683b      	ldr	r3, [r7, #0]
    67d2:	685b      	ldr	r3, [r3, #4]
    67d4:	613b      	str	r3, [r7, #16]
  iprh->next_pbuf = NULL;
    67d6:	693b      	ldr	r3, [r7, #16]
    67d8:	781a      	ldrb	r2, [r3, #0]
    67da:	2100      	movs	r1, #0
    67dc:	400a      	ands	r2, r1
    67de:	701a      	strb	r2, [r3, #0]
    67e0:	785a      	ldrb	r2, [r3, #1]
    67e2:	2100      	movs	r1, #0
    67e4:	400a      	ands	r2, r1
    67e6:	705a      	strb	r2, [r3, #1]
    67e8:	789a      	ldrb	r2, [r3, #2]
    67ea:	2100      	movs	r1, #0
    67ec:	400a      	ands	r2, r1
    67ee:	709a      	strb	r2, [r3, #2]
    67f0:	78da      	ldrb	r2, [r3, #3]
    67f2:	2100      	movs	r1, #0
    67f4:	400a      	ands	r2, r1
    67f6:	70da      	strb	r2, [r3, #3]
  iprh->start = offset;
    67f8:	693b      	ldr	r3, [r7, #16]
    67fa:	2214      	movs	r2, #20
    67fc:	18ba      	adds	r2, r7, r2
    67fe:	7814      	ldrb	r4, [r2, #0]
    6800:	7919      	ldrb	r1, [r3, #4]
    6802:	2000      	movs	r0, #0
    6804:	4001      	ands	r1, r0
    6806:	1c08      	adds	r0, r1, #0
    6808:	1c21      	adds	r1, r4, #0
    680a:	4301      	orrs	r1, r0
    680c:	7119      	strb	r1, [r3, #4]
    680e:	7850      	ldrb	r0, [r2, #1]
    6810:	795a      	ldrb	r2, [r3, #5]
    6812:	2100      	movs	r1, #0
    6814:	400a      	ands	r2, r1
    6816:	1c11      	adds	r1, r2, #0
    6818:	1c02      	adds	r2, r0, #0
    681a:	430a      	orrs	r2, r1
    681c:	715a      	strb	r2, [r3, #5]
  iprh->end = offset + len;
    681e:	2314      	movs	r3, #20
    6820:	18fa      	adds	r2, r7, r3
    6822:	2316      	movs	r3, #22
    6824:	18fb      	adds	r3, r7, r3
    6826:	8812      	ldrh	r2, [r2, #0]
    6828:	881b      	ldrh	r3, [r3, #0]
    682a:	18d3      	adds	r3, r2, r3
    682c:	b29a      	uxth	r2, r3
    682e:	693b      	ldr	r3, [r7, #16]
    6830:	21ff      	movs	r1, #255	; 0xff
    6832:	4011      	ands	r1, r2
    6834:	000c      	movs	r4, r1
    6836:	7999      	ldrb	r1, [r3, #6]
    6838:	2000      	movs	r0, #0
    683a:	4001      	ands	r1, r0
    683c:	1c08      	adds	r0, r1, #0
    683e:	1c21      	adds	r1, r4, #0
    6840:	4301      	orrs	r1, r0
    6842:	7199      	strb	r1, [r3, #6]
    6844:	0a12      	lsrs	r2, r2, #8
    6846:	b290      	uxth	r0, r2
    6848:	79da      	ldrb	r2, [r3, #7]
    684a:	2100      	movs	r1, #0
    684c:	400a      	ands	r2, r1
    684e:	1c11      	adds	r1, r2, #0
    6850:	1c02      	adds	r2, r0, #0
    6852:	430a      	orrs	r2, r1
    6854:	71da      	strb	r2, [r3, #7]

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    6856:	687b      	ldr	r3, [r7, #4]
    6858:	685b      	ldr	r3, [r3, #4]
    685a:	623b      	str	r3, [r7, #32]
    685c:	e0c3      	b.n	69e6 <ip_reass_chain_frag_into_datagram_and_validate+0x27e>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    685e:	6a3b      	ldr	r3, [r7, #32]
    6860:	685b      	ldr	r3, [r3, #4]
    6862:	60fb      	str	r3, [r7, #12]
    if (iprh->start < iprh_tmp->start) {
    6864:	693b      	ldr	r3, [r7, #16]
    6866:	791a      	ldrb	r2, [r3, #4]
    6868:	795b      	ldrb	r3, [r3, #5]
    686a:	021b      	lsls	r3, r3, #8
    686c:	4313      	orrs	r3, r2
    686e:	b29a      	uxth	r2, r3
    6870:	68fb      	ldr	r3, [r7, #12]
    6872:	7919      	ldrb	r1, [r3, #4]
    6874:	795b      	ldrb	r3, [r3, #5]
    6876:	021b      	lsls	r3, r3, #8
    6878:	430b      	orrs	r3, r1
    687a:	b29b      	uxth	r3, r3
    687c:	429a      	cmp	r2, r3
    687e:	d273      	bcs.n	6968 <ip_reass_chain_frag_into_datagram_and_validate+0x200>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
    6880:	693b      	ldr	r3, [r7, #16]
    6882:	2220      	movs	r2, #32
    6884:	18ba      	adds	r2, r7, r2
    6886:	7810      	ldrb	r0, [r2, #0]
    6888:	781a      	ldrb	r2, [r3, #0]
    688a:	2100      	movs	r1, #0
    688c:	400a      	ands	r2, r1
    688e:	1c11      	adds	r1, r2, #0
    6890:	1c02      	adds	r2, r0, #0
    6892:	430a      	orrs	r2, r1
    6894:	701a      	strb	r2, [r3, #0]
    6896:	2221      	movs	r2, #33	; 0x21
    6898:	18ba      	adds	r2, r7, r2
    689a:	7810      	ldrb	r0, [r2, #0]
    689c:	785a      	ldrb	r2, [r3, #1]
    689e:	2100      	movs	r1, #0
    68a0:	400a      	ands	r2, r1
    68a2:	1c11      	adds	r1, r2, #0
    68a4:	1c02      	adds	r2, r0, #0
    68a6:	430a      	orrs	r2, r1
    68a8:	705a      	strb	r2, [r3, #1]
    68aa:	2222      	movs	r2, #34	; 0x22
    68ac:	18ba      	adds	r2, r7, r2
    68ae:	7810      	ldrb	r0, [r2, #0]
    68b0:	789a      	ldrb	r2, [r3, #2]
    68b2:	2100      	movs	r1, #0
    68b4:	400a      	ands	r2, r1
    68b6:	1c11      	adds	r1, r2, #0
    68b8:	1c02      	adds	r2, r0, #0
    68ba:	430a      	orrs	r2, r1
    68bc:	709a      	strb	r2, [r3, #2]
    68be:	2223      	movs	r2, #35	; 0x23
    68c0:	18ba      	adds	r2, r7, r2
    68c2:	7810      	ldrb	r0, [r2, #0]
    68c4:	78da      	ldrb	r2, [r3, #3]
    68c6:	2100      	movs	r1, #0
    68c8:	400a      	ands	r2, r1
    68ca:	1c11      	adds	r1, r2, #0
    68cc:	1c02      	adds	r2, r0, #0
    68ce:	430a      	orrs	r2, r1
    68d0:	70da      	strb	r2, [r3, #3]
      if (iprh_prev != NULL) {
    68d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    68d4:	2b00      	cmp	r3, #0
    68d6:	d043      	beq.n	6960 <ip_reass_chain_frag_into_datagram_and_validate+0x1f8>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
    68d8:	693b      	ldr	r3, [r7, #16]
    68da:	791a      	ldrb	r2, [r3, #4]
    68dc:	795b      	ldrb	r3, [r3, #5]
    68de:	021b      	lsls	r3, r3, #8
    68e0:	4313      	orrs	r3, r2
    68e2:	b29a      	uxth	r2, r3
    68e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    68e6:	7999      	ldrb	r1, [r3, #6]
    68e8:	79db      	ldrb	r3, [r3, #7]
    68ea:	021b      	lsls	r3, r3, #8
    68ec:	430b      	orrs	r3, r1
    68ee:	b29b      	uxth	r3, r3
    68f0:	429a      	cmp	r2, r3
    68f2:	d200      	bcs.n	68f6 <ip_reass_chain_frag_into_datagram_and_validate+0x18e>
    68f4:	e10d      	b.n	6b12 <ip_reass_chain_frag_into_datagram_and_validate+0x3aa>
    68f6:	693b      	ldr	r3, [r7, #16]
    68f8:	799a      	ldrb	r2, [r3, #6]
    68fa:	79db      	ldrb	r3, [r3, #7]
    68fc:	021b      	lsls	r3, r3, #8
    68fe:	4313      	orrs	r3, r2
    6900:	b29a      	uxth	r2, r3
    6902:	68fb      	ldr	r3, [r7, #12]
    6904:	7919      	ldrb	r1, [r3, #4]
    6906:	795b      	ldrb	r3, [r3, #5]
    6908:	021b      	lsls	r3, r3, #8
    690a:	430b      	orrs	r3, r1
    690c:	b29b      	uxth	r3, r3
    690e:	429a      	cmp	r2, r3
    6910:	d900      	bls.n	6914 <ip_reass_chain_frag_into_datagram_and_validate+0x1ac>
    6912:	e0fe      	b.n	6b12 <ip_reass_chain_frag_into_datagram_and_validate+0x3aa>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
    6914:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    6916:	003a      	movs	r2, r7
    6918:	7810      	ldrb	r0, [r2, #0]
    691a:	781a      	ldrb	r2, [r3, #0]
    691c:	2100      	movs	r1, #0
    691e:	400a      	ands	r2, r1
    6920:	1c11      	adds	r1, r2, #0
    6922:	1c02      	adds	r2, r0, #0
    6924:	430a      	orrs	r2, r1
    6926:	701a      	strb	r2, [r3, #0]
    6928:	1c7a      	adds	r2, r7, #1
    692a:	7810      	ldrb	r0, [r2, #0]
    692c:	785a      	ldrb	r2, [r3, #1]
    692e:	2100      	movs	r1, #0
    6930:	400a      	ands	r2, r1
    6932:	1c11      	adds	r1, r2, #0
    6934:	1c02      	adds	r2, r0, #0
    6936:	430a      	orrs	r2, r1
    6938:	705a      	strb	r2, [r3, #1]
    693a:	1cba      	adds	r2, r7, #2
    693c:	7810      	ldrb	r0, [r2, #0]
    693e:	789a      	ldrb	r2, [r3, #2]
    6940:	2100      	movs	r1, #0
    6942:	400a      	ands	r2, r1
    6944:	1c11      	adds	r1, r2, #0
    6946:	1c02      	adds	r2, r0, #0
    6948:	430a      	orrs	r2, r1
    694a:	709a      	strb	r2, [r3, #2]
    694c:	1cfa      	adds	r2, r7, #3
    694e:	7810      	ldrb	r0, [r2, #0]
    6950:	78da      	ldrb	r2, [r3, #3]
    6952:	2100      	movs	r1, #0
    6954:	400a      	ands	r2, r1
    6956:	1c11      	adds	r1, r2, #0
    6958:	1c02      	adds	r2, r0, #0
    695a:	430a      	orrs	r2, r1
    695c:	70da      	strb	r2, [r3, #3]
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    695e:	e046      	b.n	69ee <ip_reass_chain_frag_into_datagram_and_validate+0x286>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
    6960:	687b      	ldr	r3, [r7, #4]
    6962:	683a      	ldr	r2, [r7, #0]
    6964:	605a      	str	r2, [r3, #4]
      }
      break;
    6966:	e042      	b.n	69ee <ip_reass_chain_frag_into_datagram_and_validate+0x286>
    } else if(iprh->start == iprh_tmp->start) {
    6968:	693b      	ldr	r3, [r7, #16]
    696a:	791a      	ldrb	r2, [r3, #4]
    696c:	795b      	ldrb	r3, [r3, #5]
    696e:	021b      	lsls	r3, r3, #8
    6970:	4313      	orrs	r3, r2
    6972:	b29a      	uxth	r2, r3
    6974:	68fb      	ldr	r3, [r7, #12]
    6976:	7919      	ldrb	r1, [r3, #4]
    6978:	795b      	ldrb	r3, [r3, #5]
    697a:	021b      	lsls	r3, r3, #8
    697c:	430b      	orrs	r3, r1
    697e:	b29b      	uxth	r3, r3
    6980:	429a      	cmp	r2, r3
    6982:	d100      	bne.n	6986 <ip_reass_chain_frag_into_datagram_and_validate+0x21e>
    6984:	e0c0      	b.n	6b08 <ip_reass_chain_frag_into_datagram_and_validate+0x3a0>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
    6986:	693b      	ldr	r3, [r7, #16]
    6988:	791a      	ldrb	r2, [r3, #4]
    698a:	795b      	ldrb	r3, [r3, #5]
    698c:	021b      	lsls	r3, r3, #8
    698e:	4313      	orrs	r3, r2
    6990:	b29a      	uxth	r2, r3
    6992:	68fb      	ldr	r3, [r7, #12]
    6994:	7999      	ldrb	r1, [r3, #6]
    6996:	79db      	ldrb	r3, [r3, #7]
    6998:	021b      	lsls	r3, r3, #8
    699a:	430b      	orrs	r3, r1
    699c:	b29b      	uxth	r3, r3
    699e:	429a      	cmp	r2, r3
    69a0:	d200      	bcs.n	69a4 <ip_reass_chain_frag_into_datagram_and_validate+0x23c>
    69a2:	e0b5      	b.n	6b10 <ip_reass_chain_frag_into_datagram_and_validate+0x3a8>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
    69a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    69a6:	2b00      	cmp	r3, #0
    69a8:	d00f      	beq.n	69ca <ip_reass_chain_frag_into_datagram_and_validate+0x262>
        if (iprh_prev->end != iprh_tmp->start) {
    69aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    69ac:	799a      	ldrb	r2, [r3, #6]
    69ae:	79db      	ldrb	r3, [r3, #7]
    69b0:	021b      	lsls	r3, r3, #8
    69b2:	4313      	orrs	r3, r2
    69b4:	b29a      	uxth	r2, r3
    69b6:	68fb      	ldr	r3, [r7, #12]
    69b8:	7919      	ldrb	r1, [r3, #4]
    69ba:	795b      	ldrb	r3, [r3, #5]
    69bc:	021b      	lsls	r3, r3, #8
    69be:	430b      	orrs	r3, r1
    69c0:	b29b      	uxth	r3, r3
    69c2:	429a      	cmp	r2, r3
    69c4:	d001      	beq.n	69ca <ip_reass_chain_frag_into_datagram_and_validate+0x262>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
    69c6:	2300      	movs	r3, #0
    69c8:	61fb      	str	r3, [r7, #28]
        }
      }
    }
    q = iprh_tmp->next_pbuf;
    69ca:	68fb      	ldr	r3, [r7, #12]
    69cc:	781a      	ldrb	r2, [r3, #0]
    69ce:	7859      	ldrb	r1, [r3, #1]
    69d0:	0209      	lsls	r1, r1, #8
    69d2:	430a      	orrs	r2, r1
    69d4:	7899      	ldrb	r1, [r3, #2]
    69d6:	0409      	lsls	r1, r1, #16
    69d8:	430a      	orrs	r2, r1
    69da:	78db      	ldrb	r3, [r3, #3]
    69dc:	061b      	lsls	r3, r3, #24
    69de:	4313      	orrs	r3, r2
    69e0:	623b      	str	r3, [r7, #32]
    iprh_prev = iprh_tmp;
    69e2:	68fb      	ldr	r3, [r7, #12]
    69e4:	627b      	str	r3, [r7, #36]	; 0x24
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    69e6:	6a3b      	ldr	r3, [r7, #32]
    69e8:	2b00      	cmp	r3, #0
    69ea:	d000      	beq.n	69ee <ip_reass_chain_frag_into_datagram_and_validate+0x286>
    69ec:	e737      	b.n	685e <ip_reass_chain_frag_into_datagram_and_validate+0xf6>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    69ee:	6a3b      	ldr	r3, [r7, #32]
    69f0:	2b00      	cmp	r3, #0
    69f2:	d13b      	bne.n	6a6c <ip_reass_chain_frag_into_datagram_and_validate+0x304>
    if (iprh_prev != NULL) {
    69f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    69f6:	2b00      	cmp	r3, #0
    69f8:	d035      	beq.n	6a66 <ip_reass_chain_frag_into_datagram_and_validate+0x2fe>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
    69fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    69fc:	003a      	movs	r2, r7
    69fe:	7810      	ldrb	r0, [r2, #0]
    6a00:	781a      	ldrb	r2, [r3, #0]
    6a02:	2100      	movs	r1, #0
    6a04:	400a      	ands	r2, r1
    6a06:	1c11      	adds	r1, r2, #0
    6a08:	1c02      	adds	r2, r0, #0
    6a0a:	430a      	orrs	r2, r1
    6a0c:	701a      	strb	r2, [r3, #0]
    6a0e:	1c7a      	adds	r2, r7, #1
    6a10:	7810      	ldrb	r0, [r2, #0]
    6a12:	785a      	ldrb	r2, [r3, #1]
    6a14:	2100      	movs	r1, #0
    6a16:	400a      	ands	r2, r1
    6a18:	1c11      	adds	r1, r2, #0
    6a1a:	1c02      	adds	r2, r0, #0
    6a1c:	430a      	orrs	r2, r1
    6a1e:	705a      	strb	r2, [r3, #1]
    6a20:	1cba      	adds	r2, r7, #2
    6a22:	7810      	ldrb	r0, [r2, #0]
    6a24:	789a      	ldrb	r2, [r3, #2]
    6a26:	2100      	movs	r1, #0
    6a28:	400a      	ands	r2, r1
    6a2a:	1c11      	adds	r1, r2, #0
    6a2c:	1c02      	adds	r2, r0, #0
    6a2e:	430a      	orrs	r2, r1
    6a30:	709a      	strb	r2, [r3, #2]
    6a32:	1cfa      	adds	r2, r7, #3
    6a34:	7810      	ldrb	r0, [r2, #0]
    6a36:	78da      	ldrb	r2, [r3, #3]
    6a38:	2100      	movs	r1, #0
    6a3a:	400a      	ands	r2, r1
    6a3c:	1c11      	adds	r1, r2, #0
    6a3e:	1c02      	adds	r2, r0, #0
    6a40:	430a      	orrs	r2, r1
    6a42:	70da      	strb	r2, [r3, #3]
      if (iprh_prev->end != iprh->start) {
    6a44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    6a46:	799a      	ldrb	r2, [r3, #6]
    6a48:	79db      	ldrb	r3, [r3, #7]
    6a4a:	021b      	lsls	r3, r3, #8
    6a4c:	4313      	orrs	r3, r2
    6a4e:	b29a      	uxth	r2, r3
    6a50:	693b      	ldr	r3, [r7, #16]
    6a52:	7919      	ldrb	r1, [r3, #4]
    6a54:	795b      	ldrb	r3, [r3, #5]
    6a56:	021b      	lsls	r3, r3, #8
    6a58:	430b      	orrs	r3, r1
    6a5a:	b29b      	uxth	r3, r3
    6a5c:	429a      	cmp	r2, r3
    6a5e:	d005      	beq.n	6a6c <ip_reass_chain_frag_into_datagram_and_validate+0x304>
        valid = 0;
    6a60:	2300      	movs	r3, #0
    6a62:	61fb      	str	r3, [r7, #28]
    6a64:	e002      	b.n	6a6c <ip_reass_chain_frag_into_datagram_and_validate+0x304>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
    6a66:	687b      	ldr	r3, [r7, #4]
    6a68:	683a      	ldr	r2, [r7, #0]
    6a6a:	605a      	str	r2, [r3, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
    6a6c:	687b      	ldr	r3, [r7, #4]
    6a6e:	7f9b      	ldrb	r3, [r3, #30]
    6a70:	001a      	movs	r2, r3
    6a72:	2301      	movs	r3, #1
    6a74:	4013      	ands	r3, r2
    6a76:	d045      	beq.n	6b04 <ip_reass_chain_frag_into_datagram_and_validate+0x39c>
    /* and had no wholes so far */
    if (valid) {
    6a78:	69fb      	ldr	r3, [r7, #28]
    6a7a:	2b00      	cmp	r3, #0
    6a7c:	d040      	beq.n	6b00 <ip_reass_chain_frag_into_datagram_and_validate+0x398>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
    6a7e:	687b      	ldr	r3, [r7, #4]
    6a80:	685b      	ldr	r3, [r3, #4]
    6a82:	685b      	ldr	r3, [r3, #4]
    6a84:	791a      	ldrb	r2, [r3, #4]
    6a86:	795b      	ldrb	r3, [r3, #5]
    6a88:	021b      	lsls	r3, r3, #8
    6a8a:	4313      	orrs	r3, r2
    6a8c:	b29b      	uxth	r3, r3
    6a8e:	2b00      	cmp	r3, #0
    6a90:	d002      	beq.n	6a98 <ip_reass_chain_frag_into_datagram_and_validate+0x330>
        valid = 0;
    6a92:	2300      	movs	r3, #0
    6a94:	61fb      	str	r3, [r7, #28]
    6a96:	e033      	b.n	6b00 <ip_reass_chain_frag_into_datagram_and_validate+0x398>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
    6a98:	693b      	ldr	r3, [r7, #16]
    6a9a:	627b      	str	r3, [r7, #36]	; 0x24
        q = iprh->next_pbuf;
    6a9c:	693b      	ldr	r3, [r7, #16]
    6a9e:	781a      	ldrb	r2, [r3, #0]
    6aa0:	7859      	ldrb	r1, [r3, #1]
    6aa2:	0209      	lsls	r1, r1, #8
    6aa4:	430a      	orrs	r2, r1
    6aa6:	7899      	ldrb	r1, [r3, #2]
    6aa8:	0409      	lsls	r1, r1, #16
    6aaa:	430a      	orrs	r2, r1
    6aac:	78db      	ldrb	r3, [r3, #3]
    6aae:	061b      	lsls	r3, r3, #24
    6ab0:	4313      	orrs	r3, r2
    6ab2:	623b      	str	r3, [r7, #32]
        while (q != NULL) {
    6ab4:	e021      	b.n	6afa <ip_reass_chain_frag_into_datagram_and_validate+0x392>
          iprh = (struct ip_reass_helper*)q->payload;
    6ab6:	6a3b      	ldr	r3, [r7, #32]
    6ab8:	685b      	ldr	r3, [r3, #4]
    6aba:	613b      	str	r3, [r7, #16]
          if (iprh_prev->end != iprh->start) {
    6abc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    6abe:	799a      	ldrb	r2, [r3, #6]
    6ac0:	79db      	ldrb	r3, [r3, #7]
    6ac2:	021b      	lsls	r3, r3, #8
    6ac4:	4313      	orrs	r3, r2
    6ac6:	b29a      	uxth	r2, r3
    6ac8:	693b      	ldr	r3, [r7, #16]
    6aca:	7919      	ldrb	r1, [r3, #4]
    6acc:	795b      	ldrb	r3, [r3, #5]
    6ace:	021b      	lsls	r3, r3, #8
    6ad0:	430b      	orrs	r3, r1
    6ad2:	b29b      	uxth	r3, r3
    6ad4:	429a      	cmp	r2, r3
    6ad6:	d002      	beq.n	6ade <ip_reass_chain_frag_into_datagram_and_validate+0x376>
            valid = 0;
    6ad8:	2300      	movs	r3, #0
    6ada:	61fb      	str	r3, [r7, #28]
            break;
    6adc:	e010      	b.n	6b00 <ip_reass_chain_frag_into_datagram_and_validate+0x398>
          }
          iprh_prev = iprh;
    6ade:	693b      	ldr	r3, [r7, #16]
    6ae0:	627b      	str	r3, [r7, #36]	; 0x24
          q = iprh->next_pbuf;
    6ae2:	693b      	ldr	r3, [r7, #16]
    6ae4:	781a      	ldrb	r2, [r3, #0]
    6ae6:	7859      	ldrb	r1, [r3, #1]
    6ae8:	0209      	lsls	r1, r1, #8
    6aea:	430a      	orrs	r2, r1
    6aec:	7899      	ldrb	r1, [r3, #2]
    6aee:	0409      	lsls	r1, r1, #16
    6af0:	430a      	orrs	r2, r1
    6af2:	78db      	ldrb	r3, [r3, #3]
    6af4:	061b      	lsls	r3, r3, #24
    6af6:	4313      	orrs	r3, r2
    6af8:	623b      	str	r3, [r7, #32]
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
    6afa:	6a3b      	ldr	r3, [r7, #32]
    6afc:	2b00      	cmp	r3, #0
    6afe:	d1da      	bne.n	6ab6 <ip_reass_chain_frag_into_datagram_and_validate+0x34e>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
    6b00:	69fb      	ldr	r3, [r7, #28]
    6b02:	e018      	b.n	6b36 <ip_reass_chain_frag_into_datagram_and_validate+0x3ce>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
    6b04:	2300      	movs	r3, #0
    6b06:	e016      	b.n	6b36 <ip_reass_chain_frag_into_datagram_and_validate+0x3ce>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
    6b08:	46c0      	nop			; (mov r8, r8)
    6b0a:	e002      	b.n	6b12 <ip_reass_chain_frag_into_datagram_and_validate+0x3aa>
    6b0c:	0000561d 	.word	0x0000561d
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
    6b10:	46c0      	nop			; (mov r8, r8)
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
    6b12:	683b      	ldr	r3, [r7, #0]
    6b14:	0018      	movs	r0, r3
    6b16:	4b0a      	ldr	r3, [pc, #40]	; (6b40 <ip_reass_chain_frag_into_datagram_and_validate+0x3d8>)
    6b18:	4798      	blx	r3
    6b1a:	0003      	movs	r3, r0
    6b1c:	0019      	movs	r1, r3
    6b1e:	4b09      	ldr	r3, [pc, #36]	; (6b44 <ip_reass_chain_frag_into_datagram_and_validate+0x3dc>)
    6b20:	881a      	ldrh	r2, [r3, #0]
    6b22:	b28b      	uxth	r3, r1
    6b24:	1ad3      	subs	r3, r2, r3
    6b26:	b29a      	uxth	r2, r3
    6b28:	4b06      	ldr	r3, [pc, #24]	; (6b44 <ip_reass_chain_frag_into_datagram_and_validate+0x3dc>)
    6b2a:	801a      	strh	r2, [r3, #0]
  pbuf_free(new_p);
    6b2c:	683b      	ldr	r3, [r7, #0]
    6b2e:	0018      	movs	r0, r3
    6b30:	4b05      	ldr	r3, [pc, #20]	; (6b48 <ip_reass_chain_frag_into_datagram_and_validate+0x3e0>)
    6b32:	4798      	blx	r3
  return 0;
    6b34:	2300      	movs	r3, #0
#endif /* IP_REASS_CHECK_OVERLAP */
}
    6b36:	0018      	movs	r0, r3
    6b38:	46bd      	mov	sp, r7
    6b3a:	b00b      	add	sp, #44	; 0x2c
    6b3c:	bd90      	pop	{r4, r7, pc}
    6b3e:	46c0      	nop			; (mov r8, r8)
    6b40:	00008431 	.word	0x00008431
    6b44:	20000b1c 	.word	0x20000b1c
    6b48:	00008349 	.word	0x00008349

00006b4c <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
    6b4c:	b590      	push	{r4, r7, lr}
    6b4e:	b08b      	sub	sp, #44	; 0x2c
    6b50:	af00      	add	r7, sp, #0
    6b52:	6078      	str	r0, [r7, #4]
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
    6b54:	2300      	movs	r3, #0
    6b56:	61fb      	str	r3, [r7, #28]

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
    6b58:	687b      	ldr	r3, [r7, #4]
    6b5a:	685b      	ldr	r3, [r3, #4]
    6b5c:	61bb      	str	r3, [r7, #24]

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    6b5e:	69bb      	ldr	r3, [r7, #24]
    6b60:	781b      	ldrb	r3, [r3, #0]
    6b62:	001a      	movs	r2, r3
    6b64:	230f      	movs	r3, #15
    6b66:	4013      	ands	r3, r2
    6b68:	009b      	lsls	r3, r3, #2
    6b6a:	2b14      	cmp	r3, #20
    6b6c:	d000      	beq.n	6b70 <ip_reass+0x24>
    6b6e:	e181      	b.n	6e74 <ip_reass+0x328>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
    6b70:	69bb      	ldr	r3, [r7, #24]
    6b72:	799a      	ldrb	r2, [r3, #6]
    6b74:	79db      	ldrb	r3, [r3, #7]
    6b76:	021b      	lsls	r3, r3, #8
    6b78:	4313      	orrs	r3, r2
    6b7a:	b29b      	uxth	r3, r3
    6b7c:	0018      	movs	r0, r3
    6b7e:	4bc2      	ldr	r3, [pc, #776]	; (6e88 <ip_reass+0x33c>)
    6b80:	4798      	blx	r3
    6b82:	0003      	movs	r3, r0
    6b84:	04db      	lsls	r3, r3, #19
    6b86:	0cdb      	lsrs	r3, r3, #19
    6b88:	b29a      	uxth	r2, r3
    6b8a:	2316      	movs	r3, #22
    6b8c:	18fb      	adds	r3, r7, r3
    6b8e:	00d2      	lsls	r2, r2, #3
    6b90:	801a      	strh	r2, [r3, #0]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
    6b92:	69bb      	ldr	r3, [r7, #24]
    6b94:	789a      	ldrb	r2, [r3, #2]
    6b96:	78db      	ldrb	r3, [r3, #3]
    6b98:	021b      	lsls	r3, r3, #8
    6b9a:	4313      	orrs	r3, r2
    6b9c:	b29b      	uxth	r3, r3
    6b9e:	0018      	movs	r0, r3
    6ba0:	4bb9      	ldr	r3, [pc, #740]	; (6e88 <ip_reass+0x33c>)
    6ba2:	4798      	blx	r3
    6ba4:	0003      	movs	r3, r0
    6ba6:	0019      	movs	r1, r3
    6ba8:	69bb      	ldr	r3, [r7, #24]
    6baa:	781b      	ldrb	r3, [r3, #0]
    6bac:	b29b      	uxth	r3, r3
    6bae:	220f      	movs	r2, #15
    6bb0:	4013      	ands	r3, r2
    6bb2:	b29b      	uxth	r3, r3
    6bb4:	009b      	lsls	r3, r3, #2
    6bb6:	b29a      	uxth	r2, r3
    6bb8:	2314      	movs	r3, #20
    6bba:	18fb      	adds	r3, r7, r3
    6bbc:	1a8a      	subs	r2, r1, r2
    6bbe:	801a      	strh	r2, [r3, #0]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
    6bc0:	2313      	movs	r3, #19
    6bc2:	18fc      	adds	r4, r7, r3
    6bc4:	687b      	ldr	r3, [r7, #4]
    6bc6:	0018      	movs	r0, r3
    6bc8:	4bb0      	ldr	r3, [pc, #704]	; (6e8c <ip_reass+0x340>)
    6bca:	4798      	blx	r3
    6bcc:	0003      	movs	r3, r0
    6bce:	7023      	strb	r3, [r4, #0]
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
    6bd0:	4baf      	ldr	r3, [pc, #700]	; (6e90 <ip_reass+0x344>)
    6bd2:	881b      	ldrh	r3, [r3, #0]
    6bd4:	001a      	movs	r2, r3
    6bd6:	2313      	movs	r3, #19
    6bd8:	18fb      	adds	r3, r7, r3
    6bda:	781b      	ldrb	r3, [r3, #0]
    6bdc:	18d3      	adds	r3, r2, r3
    6bde:	2b0a      	cmp	r3, #10
    6be0:	dd14      	ble.n	6c0c <ip_reass+0xc0>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    6be2:	2313      	movs	r3, #19
    6be4:	18fb      	adds	r3, r7, r3
    6be6:	781a      	ldrb	r2, [r3, #0]
    6be8:	69bb      	ldr	r3, [r7, #24]
    6bea:	0011      	movs	r1, r2
    6bec:	0018      	movs	r0, r3
    6bee:	4ba9      	ldr	r3, [pc, #676]	; (6e94 <ip_reass+0x348>)
    6bf0:	4798      	blx	r3
    6bf2:	1e03      	subs	r3, r0, #0
    6bf4:	d100      	bne.n	6bf8 <ip_reass+0xac>
    6bf6:	e13e      	b.n	6e76 <ip_reass+0x32a>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
    6bf8:	4ba5      	ldr	r3, [pc, #660]	; (6e90 <ip_reass+0x344>)
    6bfa:	881b      	ldrh	r3, [r3, #0]
    6bfc:	001a      	movs	r2, r3
    6bfe:	2313      	movs	r3, #19
    6c00:	18fb      	adds	r3, r7, r3
    6c02:	781b      	ldrb	r3, [r3, #0]
    6c04:	18d3      	adds	r3, r2, r3

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
    6c06:	2b0a      	cmp	r3, #10
    6c08:	dd00      	ble.n	6c0c <ip_reass+0xc0>
    6c0a:	e134      	b.n	6e76 <ip_reass+0x32a>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    6c0c:	4ba2      	ldr	r3, [pc, #648]	; (6e98 <ip_reass+0x34c>)
    6c0e:	681b      	ldr	r3, [r3, #0]
    6c10:	623b      	str	r3, [r7, #32]
    6c12:	e02c      	b.n	6c6e <ip_reass+0x122>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
    6c14:	6a3b      	ldr	r3, [r7, #32]
    6c16:	695a      	ldr	r2, [r3, #20]
    6c18:	69bb      	ldr	r3, [r7, #24]
    6c1a:	7b19      	ldrb	r1, [r3, #12]
    6c1c:	7b58      	ldrb	r0, [r3, #13]
    6c1e:	0200      	lsls	r0, r0, #8
    6c20:	4301      	orrs	r1, r0
    6c22:	7b98      	ldrb	r0, [r3, #14]
    6c24:	0400      	lsls	r0, r0, #16
    6c26:	4301      	orrs	r1, r0
    6c28:	7bdb      	ldrb	r3, [r3, #15]
    6c2a:	061b      	lsls	r3, r3, #24
    6c2c:	430b      	orrs	r3, r1
    6c2e:	429a      	cmp	r2, r3
    6c30:	d118      	bne.n	6c64 <ip_reass+0x118>
    6c32:	6a3b      	ldr	r3, [r7, #32]
    6c34:	699a      	ldr	r2, [r3, #24]
    6c36:	69bb      	ldr	r3, [r7, #24]
    6c38:	7c19      	ldrb	r1, [r3, #16]
    6c3a:	7c58      	ldrb	r0, [r3, #17]
    6c3c:	0200      	lsls	r0, r0, #8
    6c3e:	4301      	orrs	r1, r0
    6c40:	7c98      	ldrb	r0, [r3, #18]
    6c42:	0400      	lsls	r0, r0, #16
    6c44:	4301      	orrs	r1, r0
    6c46:	7cdb      	ldrb	r3, [r3, #19]
    6c48:	061b      	lsls	r3, r3, #24
    6c4a:	430b      	orrs	r3, r1
    6c4c:	429a      	cmp	r2, r3
    6c4e:	d109      	bne.n	6c64 <ip_reass+0x118>
    6c50:	6a3b      	ldr	r3, [r7, #32]
    6c52:	899a      	ldrh	r2, [r3, #12]
    6c54:	69bb      	ldr	r3, [r7, #24]
    6c56:	7919      	ldrb	r1, [r3, #4]
    6c58:	795b      	ldrb	r3, [r3, #5]
    6c5a:	021b      	lsls	r3, r3, #8
    6c5c:	430b      	orrs	r3, r1
    6c5e:	b29b      	uxth	r3, r3
    6c60:	429a      	cmp	r2, r3
    6c62:	d008      	beq.n	6c76 <ip_reass+0x12a>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
    6c64:	6a3b      	ldr	r3, [r7, #32]
    6c66:	61fb      	str	r3, [r7, #28]
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
    6c68:	6a3b      	ldr	r3, [r7, #32]
    6c6a:	681b      	ldr	r3, [r3, #0]
    6c6c:	623b      	str	r3, [r7, #32]
    6c6e:	6a3b      	ldr	r3, [r7, #32]
    6c70:	2b00      	cmp	r3, #0
    6c72:	d1cf      	bne.n	6c14 <ip_reass+0xc8>
    6c74:	e000      	b.n	6c78 <ip_reass+0x12c>
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    6c76:	46c0      	nop			; (mov r8, r8)
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
    6c78:	6a3b      	ldr	r3, [r7, #32]
    6c7a:	2b00      	cmp	r3, #0
    6c7c:	d10d      	bne.n	6c9a <ip_reass+0x14e>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
    6c7e:	2313      	movs	r3, #19
    6c80:	18fb      	adds	r3, r7, r3
    6c82:	781a      	ldrb	r2, [r3, #0]
    6c84:	69bb      	ldr	r3, [r7, #24]
    6c86:	0011      	movs	r1, r2
    6c88:	0018      	movs	r0, r3
    6c8a:	4b84      	ldr	r3, [pc, #528]	; (6e9c <ip_reass+0x350>)
    6c8c:	4798      	blx	r3
    6c8e:	0003      	movs	r3, r0
    6c90:	623b      	str	r3, [r7, #32]
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
    6c92:	6a3b      	ldr	r3, [r7, #32]
    6c94:	2b00      	cmp	r3, #0
    6c96:	d11d      	bne.n	6cd4 <ip_reass+0x188>
      goto nullreturn;
    6c98:	e0ed      	b.n	6e76 <ip_reass+0x32a>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    6c9a:	69bb      	ldr	r3, [r7, #24]
    6c9c:	799a      	ldrb	r2, [r3, #6]
    6c9e:	79db      	ldrb	r3, [r3, #7]
    6ca0:	021b      	lsls	r3, r3, #8
    6ca2:	4313      	orrs	r3, r2
    6ca4:	b29b      	uxth	r3, r3
    6ca6:	0018      	movs	r0, r3
    6ca8:	4b77      	ldr	r3, [pc, #476]	; (6e88 <ip_reass+0x33c>)
    6caa:	4798      	blx	r3
    6cac:	0003      	movs	r3, r0
    6cae:	04db      	lsls	r3, r3, #19
    6cb0:	0cdb      	lsrs	r3, r3, #19
    6cb2:	d10f      	bne.n	6cd4 <ip_reass+0x188>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
    6cb4:	6a3b      	ldr	r3, [r7, #32]
    6cb6:	89db      	ldrh	r3, [r3, #14]
    6cb8:	0018      	movs	r0, r3
    6cba:	4b73      	ldr	r3, [pc, #460]	; (6e88 <ip_reass+0x33c>)
    6cbc:	4798      	blx	r3
    6cbe:	0003      	movs	r3, r0
    6cc0:	04db      	lsls	r3, r3, #19
    6cc2:	0cdb      	lsrs	r3, r3, #19
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
    6cc4:	d006      	beq.n	6cd4 <ip_reass+0x188>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    6cc6:	6a3b      	ldr	r3, [r7, #32]
    6cc8:	3308      	adds	r3, #8
    6cca:	69b9      	ldr	r1, [r7, #24]
    6ccc:	2214      	movs	r2, #20
    6cce:	0018      	movs	r0, r3
    6cd0:	4b73      	ldr	r3, [pc, #460]	; (6ea0 <ip_reass+0x354>)
    6cd2:	4798      	blx	r3
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
    6cd4:	2313      	movs	r3, #19
    6cd6:	18fb      	adds	r3, r7, r3
    6cd8:	781b      	ldrb	r3, [r3, #0]
    6cda:	b29a      	uxth	r2, r3
    6cdc:	4b6c      	ldr	r3, [pc, #432]	; (6e90 <ip_reass+0x344>)
    6cde:	881b      	ldrh	r3, [r3, #0]
    6ce0:	18d3      	adds	r3, r2, r3
    6ce2:	b29a      	uxth	r2, r3
    6ce4:	4b6a      	ldr	r3, [pc, #424]	; (6e90 <ip_reass+0x344>)
    6ce6:	801a      	strh	r2, [r3, #0]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    6ce8:	69bb      	ldr	r3, [r7, #24]
    6cea:	799a      	ldrb	r2, [r3, #6]
    6cec:	79db      	ldrb	r3, [r3, #7]
    6cee:	021b      	lsls	r3, r3, #8
    6cf0:	4313      	orrs	r3, r2
    6cf2:	b29b      	uxth	r3, r3
    6cf4:	001a      	movs	r2, r3
    6cf6:	2320      	movs	r3, #32
    6cf8:	4013      	ands	r3, r2
    6cfa:	d110      	bne.n	6d1e <ip_reass+0x1d2>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    6cfc:	6a3b      	ldr	r3, [r7, #32]
    6cfe:	7f9b      	ldrb	r3, [r3, #30]
    6d00:	2201      	movs	r2, #1
    6d02:	4313      	orrs	r3, r2
    6d04:	b2da      	uxtb	r2, r3
    6d06:	6a3b      	ldr	r3, [r7, #32]
    6d08:	779a      	strb	r2, [r3, #30]
    ipr->datagram_len = offset + len;
    6d0a:	2316      	movs	r3, #22
    6d0c:	18fa      	adds	r2, r7, r3
    6d0e:	2314      	movs	r3, #20
    6d10:	18fb      	adds	r3, r7, r3
    6d12:	8812      	ldrh	r2, [r2, #0]
    6d14:	881b      	ldrh	r3, [r3, #0]
    6d16:	18d3      	adds	r3, r2, r3
    6d18:	b29a      	uxth	r2, r3
    6d1a:	6a3b      	ldr	r3, [r7, #32]
    6d1c:	839a      	strh	r2, [r3, #28]
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    6d1e:	687a      	ldr	r2, [r7, #4]
    6d20:	6a3b      	ldr	r3, [r7, #32]
    6d22:	0011      	movs	r1, r2
    6d24:	0018      	movs	r0, r3
    6d26:	4b5f      	ldr	r3, [pc, #380]	; (6ea4 <ip_reass+0x358>)
    6d28:	4798      	blx	r3
    6d2a:	1e03      	subs	r3, r0, #0
    6d2c:	d100      	bne.n	6d30 <ip_reass+0x1e4>
    6d2e:	e09f      	b.n	6e70 <ip_reass+0x324>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
    6d30:	6a3b      	ldr	r3, [r7, #32]
    6d32:	8b9b      	ldrh	r3, [r3, #28]
    6d34:	3314      	adds	r3, #20
    6d36:	b29a      	uxth	r2, r3
    6d38:	6a3b      	ldr	r3, [r7, #32]
    6d3a:	839a      	strh	r2, [r3, #28]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
    6d3c:	6a3b      	ldr	r3, [r7, #32]
    6d3e:	685b      	ldr	r3, [r3, #4]
    6d40:	685b      	ldr	r3, [r3, #4]
    6d42:	781a      	ldrb	r2, [r3, #0]
    6d44:	7859      	ldrb	r1, [r3, #1]
    6d46:	0209      	lsls	r1, r1, #8
    6d48:	430a      	orrs	r2, r1
    6d4a:	7899      	ldrb	r1, [r3, #2]
    6d4c:	0409      	lsls	r1, r1, #16
    6d4e:	430a      	orrs	r2, r1
    6d50:	78db      	ldrb	r3, [r3, #3]
    6d52:	061b      	lsls	r3, r3, #24
    6d54:	4313      	orrs	r3, r2
    6d56:	627b      	str	r3, [r7, #36]	; 0x24

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    6d58:	6a3b      	ldr	r3, [r7, #32]
    6d5a:	685b      	ldr	r3, [r3, #4]
    6d5c:	685b      	ldr	r3, [r3, #4]
    6d5e:	61bb      	str	r3, [r7, #24]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    6d60:	6a3b      	ldr	r3, [r7, #32]
    6d62:	3308      	adds	r3, #8
    6d64:	0019      	movs	r1, r3
    6d66:	69bb      	ldr	r3, [r7, #24]
    6d68:	2214      	movs	r2, #20
    6d6a:	0018      	movs	r0, r3
    6d6c:	4b4c      	ldr	r3, [pc, #304]	; (6ea0 <ip_reass+0x354>)
    6d6e:	4798      	blx	r3
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    6d70:	6a3b      	ldr	r3, [r7, #32]
    6d72:	8b9b      	ldrh	r3, [r3, #28]
    6d74:	0018      	movs	r0, r3
    6d76:	4b4c      	ldr	r3, [pc, #304]	; (6ea8 <ip_reass+0x35c>)
    6d78:	4798      	blx	r3
    6d7a:	0003      	movs	r3, r0
    6d7c:	001a      	movs	r2, r3
    6d7e:	69bb      	ldr	r3, [r7, #24]
    6d80:	21ff      	movs	r1, #255	; 0xff
    6d82:	4011      	ands	r1, r2
    6d84:	000c      	movs	r4, r1
    6d86:	7899      	ldrb	r1, [r3, #2]
    6d88:	2000      	movs	r0, #0
    6d8a:	4001      	ands	r1, r0
    6d8c:	1c08      	adds	r0, r1, #0
    6d8e:	1c21      	adds	r1, r4, #0
    6d90:	4301      	orrs	r1, r0
    6d92:	7099      	strb	r1, [r3, #2]
    6d94:	0a12      	lsrs	r2, r2, #8
    6d96:	b290      	uxth	r0, r2
    6d98:	78da      	ldrb	r2, [r3, #3]
    6d9a:	2100      	movs	r1, #0
    6d9c:	400a      	ands	r2, r1
    6d9e:	1c11      	adds	r1, r2, #0
    6da0:	1c02      	adds	r2, r0, #0
    6da2:	430a      	orrs	r2, r1
    6da4:	70da      	strb	r2, [r3, #3]
    IPH_OFFSET_SET(fraghdr, 0);
    6da6:	69bb      	ldr	r3, [r7, #24]
    6da8:	799a      	ldrb	r2, [r3, #6]
    6daa:	2100      	movs	r1, #0
    6dac:	400a      	ands	r2, r1
    6dae:	719a      	strb	r2, [r3, #6]
    6db0:	79da      	ldrb	r2, [r3, #7]
    6db2:	2100      	movs	r1, #0
    6db4:	400a      	ands	r2, r1
    6db6:	71da      	strb	r2, [r3, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
    6db8:	69bb      	ldr	r3, [r7, #24]
    6dba:	7a9a      	ldrb	r2, [r3, #10]
    6dbc:	2100      	movs	r1, #0
    6dbe:	400a      	ands	r2, r1
    6dc0:	729a      	strb	r2, [r3, #10]
    6dc2:	7ada      	ldrb	r2, [r3, #11]
    6dc4:	2100      	movs	r1, #0
    6dc6:	400a      	ands	r2, r1
    6dc8:	72da      	strb	r2, [r3, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
    6dca:	69bb      	ldr	r3, [r7, #24]
    6dcc:	2114      	movs	r1, #20
    6dce:	0018      	movs	r0, r3
    6dd0:	4b36      	ldr	r3, [pc, #216]	; (6eac <ip_reass+0x360>)
    6dd2:	4798      	blx	r3
    6dd4:	0003      	movs	r3, r0
    6dd6:	001a      	movs	r2, r3
    6dd8:	69bb      	ldr	r3, [r7, #24]
    6dda:	21ff      	movs	r1, #255	; 0xff
    6ddc:	4011      	ands	r1, r2
    6dde:	000c      	movs	r4, r1
    6de0:	7a99      	ldrb	r1, [r3, #10]
    6de2:	2000      	movs	r0, #0
    6de4:	4001      	ands	r1, r0
    6de6:	1c08      	adds	r0, r1, #0
    6de8:	1c21      	adds	r1, r4, #0
    6dea:	4301      	orrs	r1, r0
    6dec:	7299      	strb	r1, [r3, #10]
    6dee:	0a12      	lsrs	r2, r2, #8
    6df0:	b290      	uxth	r0, r2
    6df2:	7ada      	ldrb	r2, [r3, #11]
    6df4:	2100      	movs	r1, #0
    6df6:	400a      	ands	r2, r1
    6df8:	1c11      	adds	r1, r2, #0
    6dfa:	1c02      	adds	r2, r0, #0
    6dfc:	430a      	orrs	r2, r1
    6dfe:	72da      	strb	r2, [r3, #11]

    p = ipr->p;
    6e00:	6a3b      	ldr	r3, [r7, #32]
    6e02:	685b      	ldr	r3, [r3, #4]
    6e04:	607b      	str	r3, [r7, #4]

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    6e06:	e01b      	b.n	6e40 <ip_reass+0x2f4>
      iprh = (struct ip_reass_helper*)r->payload;
    6e08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    6e0a:	685b      	ldr	r3, [r3, #4]
    6e0c:	60fb      	str	r3, [r7, #12]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
    6e0e:	2314      	movs	r3, #20
    6e10:	425a      	negs	r2, r3
    6e12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    6e14:	0011      	movs	r1, r2
    6e16:	0018      	movs	r0, r3
    6e18:	4b25      	ldr	r3, [pc, #148]	; (6eb0 <ip_reass+0x364>)
    6e1a:	4798      	blx	r3
      pbuf_cat(p, r);
    6e1c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    6e1e:	687b      	ldr	r3, [r7, #4]
    6e20:	0011      	movs	r1, r2
    6e22:	0018      	movs	r0, r3
    6e24:	4b23      	ldr	r3, [pc, #140]	; (6eb4 <ip_reass+0x368>)
    6e26:	4798      	blx	r3
      r = iprh->next_pbuf;
    6e28:	68fb      	ldr	r3, [r7, #12]
    6e2a:	781a      	ldrb	r2, [r3, #0]
    6e2c:	7859      	ldrb	r1, [r3, #1]
    6e2e:	0209      	lsls	r1, r1, #8
    6e30:	430a      	orrs	r2, r1
    6e32:	7899      	ldrb	r1, [r3, #2]
    6e34:	0409      	lsls	r1, r1, #16
    6e36:	430a      	orrs	r2, r1
    6e38:	78db      	ldrb	r3, [r3, #3]
    6e3a:	061b      	lsls	r3, r3, #24
    6e3c:	4313      	orrs	r3, r2
    6e3e:	627b      	str	r3, [r7, #36]	; 0x24
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
    6e40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    6e42:	2b00      	cmp	r3, #0
    6e44:	d1e0      	bne.n	6e08 <ip_reass+0x2bc>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
    6e46:	69fa      	ldr	r2, [r7, #28]
    6e48:	6a3b      	ldr	r3, [r7, #32]
    6e4a:	0011      	movs	r1, r2
    6e4c:	0018      	movs	r0, r3
    6e4e:	4b1a      	ldr	r3, [pc, #104]	; (6eb8 <ip_reass+0x36c>)
    6e50:	4798      	blx	r3

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
    6e52:	687b      	ldr	r3, [r7, #4]
    6e54:	0018      	movs	r0, r3
    6e56:	4b0d      	ldr	r3, [pc, #52]	; (6e8c <ip_reass+0x340>)
    6e58:	4798      	blx	r3
    6e5a:	0003      	movs	r3, r0
    6e5c:	0019      	movs	r1, r3
    6e5e:	4b0c      	ldr	r3, [pc, #48]	; (6e90 <ip_reass+0x344>)
    6e60:	881a      	ldrh	r2, [r3, #0]
    6e62:	b28b      	uxth	r3, r1
    6e64:	1ad3      	subs	r3, r2, r3
    6e66:	b29a      	uxth	r2, r3
    6e68:	4b09      	ldr	r3, [pc, #36]	; (6e90 <ip_reass+0x344>)
    6e6a:	801a      	strh	r2, [r3, #0]

    /* Return the pbuf chain */
    return p;
    6e6c:	687b      	ldr	r3, [r7, #4]
    6e6e:	e007      	b.n	6e80 <ip_reass+0x334>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
    6e70:	2300      	movs	r3, #0
    6e72:	e005      	b.n	6e80 <ip_reass+0x334>
  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
    6e74:	46c0      	nop			; (mov r8, r8)
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
    6e76:	687b      	ldr	r3, [r7, #4]
    6e78:	0018      	movs	r0, r3
    6e7a:	4b10      	ldr	r3, [pc, #64]	; (6ebc <ip_reass+0x370>)
    6e7c:	4798      	blx	r3
  return NULL;
    6e7e:	2300      	movs	r3, #0
}
    6e80:	0018      	movs	r0, r3
    6e82:	46bd      	mov	sp, r7
    6e84:	b00b      	add	sp, #44	; 0x2c
    6e86:	bd90      	pop	{r4, r7, pc}
    6e88:	0000561d 	.word	0x0000561d
    6e8c:	00008431 	.word	0x00008431
    6e90:	20000b1c 	.word	0x20000b1c
    6e94:	000065ad 	.word	0x000065ad
    6e98:	20000b18 	.word	0x20000b18
    6e9c:	00006699 	.word	0x00006699
    6ea0:	0000fc43 	.word	0x0000fc43
    6ea4:	00006769 	.word	0x00006769
    6ea8:	000055f1 	.word	0x000055f1
    6eac:	00005ba5 	.word	0x00005ba5
    6eb0:	00008235 	.word	0x00008235
    6eb4:	00008491 	.word	0x00008491
    6eb8:	00006729 	.word	0x00006729
    6ebc:	00008349 	.word	0x00008349

00006ec0 <ip_frag_alloc_pbuf_custom_ref>:

#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
    6ec0:	b580      	push	{r7, lr}
    6ec2:	af00      	add	r7, sp, #0
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
    6ec4:	2005      	movs	r0, #5
    6ec6:	4b03      	ldr	r3, [pc, #12]	; (6ed4 <ip_frag_alloc_pbuf_custom_ref+0x14>)
    6ec8:	4798      	blx	r3
    6eca:	0003      	movs	r3, r0
}
    6ecc:	0018      	movs	r0, r3
    6ece:	46bd      	mov	sp, r7
    6ed0:	bd80      	pop	{r7, pc}
    6ed2:	46c0      	nop			; (mov r8, r8)
    6ed4:	00007af1 	.word	0x00007af1

00006ed8 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
    6ed8:	b580      	push	{r7, lr}
    6eda:	b082      	sub	sp, #8
    6edc:	af00      	add	r7, sp, #0
    6ede:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
    6ee0:	687b      	ldr	r3, [r7, #4]
    6ee2:	0019      	movs	r1, r3
    6ee4:	2005      	movs	r0, #5
    6ee6:	4b03      	ldr	r3, [pc, #12]	; (6ef4 <ip_frag_free_pbuf_custom_ref+0x1c>)
    6ee8:	4798      	blx	r3
}
    6eea:	46c0      	nop			; (mov r8, r8)
    6eec:	46bd      	mov	sp, r7
    6eee:	b002      	add	sp, #8
    6ef0:	bd80      	pop	{r7, pc}
    6ef2:	46c0      	nop			; (mov r8, r8)
    6ef4:	00007b39 	.word	0x00007b39

00006ef8 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
    6ef8:	b580      	push	{r7, lr}
    6efa:	b084      	sub	sp, #16
    6efc:	af00      	add	r7, sp, #0
    6efe:	6078      	str	r0, [r7, #4]
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
    6f00:	687b      	ldr	r3, [r7, #4]
    6f02:	60fb      	str	r3, [r7, #12]
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
    6f04:	68fb      	ldr	r3, [r7, #12]
    6f06:	695b      	ldr	r3, [r3, #20]
    6f08:	2b00      	cmp	r3, #0
    6f0a:	d004      	beq.n	6f16 <ipfrag_free_pbuf_custom+0x1e>
    pbuf_free(pcr->original);
    6f0c:	68fb      	ldr	r3, [r7, #12]
    6f0e:	695b      	ldr	r3, [r3, #20]
    6f10:	0018      	movs	r0, r3
    6f12:	4b05      	ldr	r3, [pc, #20]	; (6f28 <ipfrag_free_pbuf_custom+0x30>)
    6f14:	4798      	blx	r3
  }
  ip_frag_free_pbuf_custom_ref(pcr);
    6f16:	68fb      	ldr	r3, [r7, #12]
    6f18:	0018      	movs	r0, r3
    6f1a:	4b04      	ldr	r3, [pc, #16]	; (6f2c <ipfrag_free_pbuf_custom+0x34>)
    6f1c:	4798      	blx	r3
}
    6f1e:	46c0      	nop			; (mov r8, r8)
    6f20:	46bd      	mov	sp, r7
    6f22:	b004      	add	sp, #16
    6f24:	bd80      	pop	{r7, pc}
    6f26:	46c0      	nop			; (mov r8, r8)
    6f28:	00008349 	.word	0x00008349
    6f2c:	00006ed9 	.word	0x00006ed9

00006f30 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
    6f30:	b590      	push	{r4, r7, lr}
    6f32:	b093      	sub	sp, #76	; 0x4c
    6f34:	af02      	add	r7, sp, #8
    6f36:	60f8      	str	r0, [r7, #12]
    6f38:	60b9      	str	r1, [r7, #8]
    6f3a:	607a      	str	r2, [r7, #4]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
    6f3c:	2332      	movs	r3, #50	; 0x32
    6f3e:	18fb      	adds	r3, r7, r3
    6f40:	68ba      	ldr	r2, [r7, #8]
    6f42:	8c92      	ldrh	r2, [r2, #36]	; 0x24
    6f44:	801a      	strh	r2, [r3, #0]
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
    6f46:	233a      	movs	r3, #58	; 0x3a
    6f48:	18fb      	adds	r3, r7, r3
    6f4a:	2214      	movs	r2, #20
    6f4c:	801a      	strh	r2, [r3, #0]
  u16_t tmp;
#if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
  u16_t newpbuflen = 0;
    6f4e:	2336      	movs	r3, #54	; 0x36
    6f50:	18fb      	adds	r3, r7, r3
    6f52:	2200      	movs	r2, #0
    6f54:	801a      	strh	r2, [r3, #0]

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
    6f56:	68fb      	ldr	r3, [r7, #12]
    6f58:	685b      	ldr	r3, [r3, #4]
    6f5a:	62fb      	str	r3, [r7, #44]	; 0x2c
  iphdr = original_iphdr;
    6f5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    6f5e:	62bb      	str	r3, [r7, #40]	; 0x28
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
    6f60:	6abb      	ldr	r3, [r7, #40]	; 0x28
    6f62:	799a      	ldrb	r2, [r3, #6]
    6f64:	79db      	ldrb	r3, [r3, #7]
    6f66:	021b      	lsls	r3, r3, #8
    6f68:	4313      	orrs	r3, r2
    6f6a:	b29b      	uxth	r3, r3
    6f6c:	2238      	movs	r2, #56	; 0x38
    6f6e:	18bc      	adds	r4, r7, r2
    6f70:	0018      	movs	r0, r3
    6f72:	4bc9      	ldr	r3, [pc, #804]	; (7298 <ip_frag+0x368>)
    6f74:	4798      	blx	r3
    6f76:	0003      	movs	r3, r0
    6f78:	8023      	strh	r3, [r4, #0]
  ofo = tmp & IP_OFFMASK;
    6f7a:	233c      	movs	r3, #60	; 0x3c
    6f7c:	18fb      	adds	r3, r7, r3
    6f7e:	2238      	movs	r2, #56	; 0x38
    6f80:	18ba      	adds	r2, r7, r2
    6f82:	8812      	ldrh	r2, [r2, #0]
    6f84:	04d2      	lsls	r2, r2, #19
    6f86:	0cd2      	lsrs	r2, r2, #19
    6f88:	801a      	strh	r2, [r3, #0]
  omf = tmp & IP_MF;
    6f8a:	2326      	movs	r3, #38	; 0x26
    6f8c:	18fb      	adds	r3, r7, r3
    6f8e:	2238      	movs	r2, #56	; 0x38
    6f90:	18ba      	adds	r2, r7, r2
    6f92:	8811      	ldrh	r1, [r2, #0]
    6f94:	2280      	movs	r2, #128	; 0x80
    6f96:	0192      	lsls	r2, r2, #6
    6f98:	400a      	ands	r2, r1
    6f9a:	801a      	strh	r2, [r3, #0]

  left = p->tot_len - IP_HLEN;
    6f9c:	68fb      	ldr	r3, [r7, #12]
    6f9e:	891a      	ldrh	r2, [r3, #8]
    6fa0:	233e      	movs	r3, #62	; 0x3e
    6fa2:	18fb      	adds	r3, r7, r3
    6fa4:	3a14      	subs	r2, #20
    6fa6:	801a      	strh	r2, [r3, #0]

  nfb = (mtu - IP_HLEN) / 8;
    6fa8:	2332      	movs	r3, #50	; 0x32
    6faa:	18fb      	adds	r3, r7, r3
    6fac:	881b      	ldrh	r3, [r3, #0]
    6fae:	3b14      	subs	r3, #20
    6fb0:	2b00      	cmp	r3, #0
    6fb2:	da00      	bge.n	6fb6 <ip_frag+0x86>
    6fb4:	3307      	adds	r3, #7
    6fb6:	10db      	asrs	r3, r3, #3
    6fb8:	001a      	movs	r2, r3
    6fba:	2324      	movs	r3, #36	; 0x24
    6fbc:	18fb      	adds	r3, r7, r3
    6fbe:	801a      	strh	r2, [r3, #0]

  while (left) {
    6fc0:	e15e      	b.n	7280 <ip_frag+0x350>
    last = (left <= mtu - IP_HLEN);
    6fc2:	233e      	movs	r3, #62	; 0x3e
    6fc4:	18fb      	adds	r3, r7, r3
    6fc6:	881b      	ldrh	r3, [r3, #0]
    6fc8:	2232      	movs	r2, #50	; 0x32
    6fca:	18ba      	adds	r2, r7, r2
    6fcc:	8812      	ldrh	r2, [r2, #0]
    6fce:	3a14      	subs	r2, #20
    6fd0:	0fd8      	lsrs	r0, r3, #31
    6fd2:	17d1      	asrs	r1, r2, #31
    6fd4:	429a      	cmp	r2, r3
    6fd6:	4148      	adcs	r0, r1
    6fd8:	0003      	movs	r3, r0
    6fda:	b2da      	uxtb	r2, r3
    6fdc:	2322      	movs	r3, #34	; 0x22
    6fde:	18fb      	adds	r3, r7, r3
    6fe0:	801a      	strh	r2, [r3, #0]

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    6fe2:	233c      	movs	r3, #60	; 0x3c
    6fe4:	18fb      	adds	r3, r7, r3
    6fe6:	881b      	ldrh	r3, [r3, #0]
    6fe8:	04db      	lsls	r3, r3, #19
    6fea:	0cdb      	lsrs	r3, r3, #19
    6fec:	b299      	uxth	r1, r3
    6fee:	2338      	movs	r3, #56	; 0x38
    6ff0:	18fb      	adds	r3, r7, r3
    6ff2:	2226      	movs	r2, #38	; 0x26
    6ff4:	18ba      	adds	r2, r7, r2
    6ff6:	8812      	ldrh	r2, [r2, #0]
    6ff8:	430a      	orrs	r2, r1
    6ffa:	801a      	strh	r2, [r3, #0]
    if (!last) {
    6ffc:	2322      	movs	r3, #34	; 0x22
    6ffe:	18fb      	adds	r3, r7, r3
    7000:	881b      	ldrh	r3, [r3, #0]
    7002:	2b00      	cmp	r3, #0
    7004:	d108      	bne.n	7018 <ip_frag+0xe8>
      tmp = tmp | IP_MF;
    7006:	2338      	movs	r3, #56	; 0x38
    7008:	18fb      	adds	r3, r7, r3
    700a:	2238      	movs	r2, #56	; 0x38
    700c:	18ba      	adds	r2, r7, r2
    700e:	8812      	ldrh	r2, [r2, #0]
    7010:	2180      	movs	r1, #128	; 0x80
    7012:	0189      	lsls	r1, r1, #6
    7014:	430a      	orrs	r2, r1
    7016:	801a      	strh	r2, [r3, #0]
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
    7018:	2322      	movs	r3, #34	; 0x22
    701a:	18fb      	adds	r3, r7, r3
    701c:	881b      	ldrh	r3, [r3, #0]
    701e:	2b00      	cmp	r3, #0
    7020:	d105      	bne.n	702e <ip_frag+0xfe>
    7022:	2324      	movs	r3, #36	; 0x24
    7024:	18fb      	adds	r3, r7, r3
    7026:	881b      	ldrh	r3, [r3, #0]
    7028:	00db      	lsls	r3, r3, #3
    702a:	b29b      	uxth	r3, r3
    702c:	e002      	b.n	7034 <ip_frag+0x104>
    702e:	233e      	movs	r3, #62	; 0x3e
    7030:	18fb      	adds	r3, r7, r3
    7032:	881b      	ldrh	r3, [r3, #0]
    7034:	2220      	movs	r2, #32
    7036:	18ba      	adds	r2, r7, r2
    7038:	8013      	strh	r3, [r2, #0]
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
    703a:	2200      	movs	r2, #0
    703c:	2114      	movs	r1, #20
    703e:	2002      	movs	r0, #2
    7040:	4b96      	ldr	r3, [pc, #600]	; (729c <ip_frag+0x36c>)
    7042:	4798      	blx	r3
    7044:	0003      	movs	r3, r0
    7046:	61fb      	str	r3, [r7, #28]
    if (rambuf == NULL) {
    7048:	69fb      	ldr	r3, [r7, #28]
    704a:	2b00      	cmp	r3, #0
    704c:	d102      	bne.n	7054 <ip_frag+0x124>
      return ERR_MEM;
    704e:	2301      	movs	r3, #1
    7050:	425b      	negs	r3, r3
    7052:	e11c      	b.n	728e <ip_frag+0x35e>
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
    7054:	69fb      	ldr	r3, [r7, #28]
    7056:	685b      	ldr	r3, [r3, #4]
    7058:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    705a:	2214      	movs	r2, #20
    705c:	0018      	movs	r0, r3
    705e:	4b90      	ldr	r3, [pc, #576]	; (72a0 <ip_frag+0x370>)
    7060:	4798      	blx	r3
    iphdr = (struct ip_hdr *)rambuf->payload;
    7062:	69fb      	ldr	r3, [r7, #28]
    7064:	685b      	ldr	r3, [r3, #4]
    7066:	62bb      	str	r3, [r7, #40]	; 0x28

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    7068:	68fb      	ldr	r3, [r7, #12]
    706a:	685a      	ldr	r2, [r3, #4]
    706c:	233a      	movs	r3, #58	; 0x3a
    706e:	18fb      	adds	r3, r7, r3
    7070:	881b      	ldrh	r3, [r3, #0]
    7072:	18d2      	adds	r2, r2, r3
    7074:	68fb      	ldr	r3, [r7, #12]
    7076:	605a      	str	r2, [r3, #4]
    p->len -= poff;
    7078:	68fb      	ldr	r3, [r7, #12]
    707a:	895a      	ldrh	r2, [r3, #10]
    707c:	233a      	movs	r3, #58	; 0x3a
    707e:	18fb      	adds	r3, r7, r3
    7080:	881b      	ldrh	r3, [r3, #0]
    7082:	1ad3      	subs	r3, r2, r3
    7084:	b29a      	uxth	r2, r3
    7086:	68fb      	ldr	r3, [r7, #12]
    7088:	815a      	strh	r2, [r3, #10]

    left_to_copy = cop;
    708a:	2334      	movs	r3, #52	; 0x34
    708c:	18fb      	adds	r3, r7, r3
    708e:	2220      	movs	r2, #32
    7090:	18ba      	adds	r2, r7, r2
    7092:	8812      	ldrh	r2, [r2, #0]
    7094:	801a      	strh	r2, [r3, #0]
    while (left_to_copy) {
    7096:	e06c      	b.n	7172 <ip_frag+0x242>
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
    7098:	68fb      	ldr	r3, [r7, #12]
    709a:	8959      	ldrh	r1, [r3, #10]
    709c:	2336      	movs	r3, #54	; 0x36
    709e:	18fa      	adds	r2, r7, r3
    70a0:	2334      	movs	r3, #52	; 0x34
    70a2:	18fb      	adds	r3, r7, r3
    70a4:	881c      	ldrh	r4, [r3, #0]
    70a6:	1c0b      	adds	r3, r1, #0
    70a8:	b298      	uxth	r0, r3
    70aa:	b2a1      	uxth	r1, r4
    70ac:	4288      	cmp	r0, r1
    70ae:	d900      	bls.n	70b2 <ip_frag+0x182>
    70b0:	1c23      	adds	r3, r4, #0
    70b2:	8013      	strh	r3, [r2, #0]
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
    70b4:	2336      	movs	r3, #54	; 0x36
    70b6:	18fb      	adds	r3, r7, r3
    70b8:	881b      	ldrh	r3, [r3, #0]
    70ba:	2b00      	cmp	r3, #0
    70bc:	d109      	bne.n	70d2 <ip_frag+0x1a2>
        p = p->next;
    70be:	68fb      	ldr	r3, [r7, #12]
    70c0:	681b      	ldr	r3, [r3, #0]
    70c2:	60fb      	str	r3, [r7, #12]
    70c4:	2334      	movs	r3, #52	; 0x34
    70c6:	18fb      	adds	r3, r7, r3
    70c8:	2234      	movs	r2, #52	; 0x34
    70ca:	18ba      	adds	r2, r7, r2
    70cc:	8812      	ldrh	r2, [r2, #0]
    70ce:	801a      	strh	r2, [r3, #0]
        continue;
    70d0:	e04f      	b.n	7172 <ip_frag+0x242>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
    70d2:	4b74      	ldr	r3, [pc, #464]	; (72a4 <ip_frag+0x374>)
    70d4:	4798      	blx	r3
    70d6:	0003      	movs	r3, r0
    70d8:	61bb      	str	r3, [r7, #24]
      if (pcr == NULL) {
    70da:	69bb      	ldr	r3, [r7, #24]
    70dc:	2b00      	cmp	r3, #0
    70de:	d106      	bne.n	70ee <ip_frag+0x1be>
        pbuf_free(rambuf);
    70e0:	69fb      	ldr	r3, [r7, #28]
    70e2:	0018      	movs	r0, r3
    70e4:	4b70      	ldr	r3, [pc, #448]	; (72a8 <ip_frag+0x378>)
    70e6:	4798      	blx	r3
        return ERR_MEM;
    70e8:	2301      	movs	r3, #1
    70ea:	425b      	negs	r3, r3
    70ec:	e0cf      	b.n	728e <ip_frag+0x35e>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
    70ee:	69b8      	ldr	r0, [r7, #24]
    70f0:	68fb      	ldr	r3, [r7, #12]
    70f2:	685b      	ldr	r3, [r3, #4]
    70f4:	2236      	movs	r2, #54	; 0x36
    70f6:	18ba      	adds	r2, r7, r2
    70f8:	8811      	ldrh	r1, [r2, #0]
    70fa:	2236      	movs	r2, #54	; 0x36
    70fc:	18ba      	adds	r2, r7, r2
    70fe:	8812      	ldrh	r2, [r2, #0]
    7100:	9201      	str	r2, [sp, #4]
    7102:	9300      	str	r3, [sp, #0]
    7104:	0003      	movs	r3, r0
    7106:	2202      	movs	r2, #2
    7108:	2003      	movs	r0, #3
    710a:	4c68      	ldr	r4, [pc, #416]	; (72ac <ip_frag+0x37c>)
    710c:	47a0      	blx	r4
    710e:	0003      	movs	r3, r0
    7110:	617b      	str	r3, [r7, #20]
      if (newpbuf == NULL) {
    7112:	697b      	ldr	r3, [r7, #20]
    7114:	2b00      	cmp	r3, #0
    7116:	d10a      	bne.n	712e <ip_frag+0x1fe>
        ip_frag_free_pbuf_custom_ref(pcr);
    7118:	69bb      	ldr	r3, [r7, #24]
    711a:	0018      	movs	r0, r3
    711c:	4b64      	ldr	r3, [pc, #400]	; (72b0 <ip_frag+0x380>)
    711e:	4798      	blx	r3
        pbuf_free(rambuf);
    7120:	69fb      	ldr	r3, [r7, #28]
    7122:	0018      	movs	r0, r3
    7124:	4b60      	ldr	r3, [pc, #384]	; (72a8 <ip_frag+0x378>)
    7126:	4798      	blx	r3
        return ERR_MEM;
    7128:	2301      	movs	r3, #1
    712a:	425b      	negs	r3, r3
    712c:	e0af      	b.n	728e <ip_frag+0x35e>
      }
      pbuf_ref(p);
    712e:	68fb      	ldr	r3, [r7, #12]
    7130:	0018      	movs	r0, r3
    7132:	4b60      	ldr	r3, [pc, #384]	; (72b4 <ip_frag+0x384>)
    7134:	4798      	blx	r3
      pcr->original = p;
    7136:	69bb      	ldr	r3, [r7, #24]
    7138:	68fa      	ldr	r2, [r7, #12]
    713a:	615a      	str	r2, [r3, #20]
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
    713c:	69bb      	ldr	r3, [r7, #24]
    713e:	4a5e      	ldr	r2, [pc, #376]	; (72b8 <ip_frag+0x388>)
    7140:	611a      	str	r2, [r3, #16]

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
    7142:	697a      	ldr	r2, [r7, #20]
    7144:	69fb      	ldr	r3, [r7, #28]
    7146:	0011      	movs	r1, r2
    7148:	0018      	movs	r0, r3
    714a:	4b5c      	ldr	r3, [pc, #368]	; (72bc <ip_frag+0x38c>)
    714c:	4798      	blx	r3
      left_to_copy -= newpbuflen;
    714e:	2334      	movs	r3, #52	; 0x34
    7150:	18fb      	adds	r3, r7, r3
    7152:	2234      	movs	r2, #52	; 0x34
    7154:	18b9      	adds	r1, r7, r2
    7156:	2236      	movs	r2, #54	; 0x36
    7158:	18ba      	adds	r2, r7, r2
    715a:	8809      	ldrh	r1, [r1, #0]
    715c:	8812      	ldrh	r2, [r2, #0]
    715e:	1a8a      	subs	r2, r1, r2
    7160:	801a      	strh	r2, [r3, #0]
      if (left_to_copy) {
    7162:	2334      	movs	r3, #52	; 0x34
    7164:	18fb      	adds	r3, r7, r3
    7166:	881b      	ldrh	r3, [r3, #0]
    7168:	2b00      	cmp	r3, #0
    716a:	d002      	beq.n	7172 <ip_frag+0x242>
        p = p->next;
    716c:	68fb      	ldr	r3, [r7, #12]
    716e:	681b      	ldr	r3, [r3, #0]
    7170:	60fb      	str	r3, [r7, #12]
    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
    7172:	2334      	movs	r3, #52	; 0x34
    7174:	18fb      	adds	r3, r7, r3
    7176:	881b      	ldrh	r3, [r3, #0]
    7178:	2b00      	cmp	r3, #0
    717a:	d18d      	bne.n	7098 <ip_frag+0x168>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
      }
    }
    poff = newpbuflen;
    717c:	233a      	movs	r3, #58	; 0x3a
    717e:	18fb      	adds	r3, r7, r3
    7180:	2236      	movs	r2, #54	; 0x36
    7182:	18ba      	adds	r2, r7, r2
    7184:	8812      	ldrh	r2, [r2, #0]
    7186:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    7188:	2338      	movs	r3, #56	; 0x38
    718a:	18fb      	adds	r3, r7, r3
    718c:	881b      	ldrh	r3, [r3, #0]
    718e:	0018      	movs	r0, r3
    7190:	4b4b      	ldr	r3, [pc, #300]	; (72c0 <ip_frag+0x390>)
    7192:	4798      	blx	r3
    7194:	0003      	movs	r3, r0
    7196:	001a      	movs	r2, r3
    7198:	6abb      	ldr	r3, [r7, #40]	; 0x28
    719a:	21ff      	movs	r1, #255	; 0xff
    719c:	4011      	ands	r1, r2
    719e:	000c      	movs	r4, r1
    71a0:	7999      	ldrb	r1, [r3, #6]
    71a2:	2000      	movs	r0, #0
    71a4:	4001      	ands	r1, r0
    71a6:	1c08      	adds	r0, r1, #0
    71a8:	1c21      	adds	r1, r4, #0
    71aa:	4301      	orrs	r1, r0
    71ac:	7199      	strb	r1, [r3, #6]
    71ae:	0a12      	lsrs	r2, r2, #8
    71b0:	b290      	uxth	r0, r2
    71b2:	79da      	ldrb	r2, [r3, #7]
    71b4:	2100      	movs	r1, #0
    71b6:	400a      	ands	r2, r1
    71b8:	1c11      	adds	r1, r2, #0
    71ba:	1c02      	adds	r2, r0, #0
    71bc:	430a      	orrs	r2, r1
    71be:	71da      	strb	r2, [r3, #7]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    71c0:	2320      	movs	r3, #32
    71c2:	18fb      	adds	r3, r7, r3
    71c4:	881b      	ldrh	r3, [r3, #0]
    71c6:	3314      	adds	r3, #20
    71c8:	b29b      	uxth	r3, r3
    71ca:	0018      	movs	r0, r3
    71cc:	4b3c      	ldr	r3, [pc, #240]	; (72c0 <ip_frag+0x390>)
    71ce:	4798      	blx	r3
    71d0:	0003      	movs	r3, r0
    71d2:	001a      	movs	r2, r3
    71d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    71d6:	21ff      	movs	r1, #255	; 0xff
    71d8:	4011      	ands	r1, r2
    71da:	000c      	movs	r4, r1
    71dc:	7899      	ldrb	r1, [r3, #2]
    71de:	2000      	movs	r0, #0
    71e0:	4001      	ands	r1, r0
    71e2:	1c08      	adds	r0, r1, #0
    71e4:	1c21      	adds	r1, r4, #0
    71e6:	4301      	orrs	r1, r0
    71e8:	7099      	strb	r1, [r3, #2]
    71ea:	0a12      	lsrs	r2, r2, #8
    71ec:	b290      	uxth	r0, r2
    71ee:	78da      	ldrb	r2, [r3, #3]
    71f0:	2100      	movs	r1, #0
    71f2:	400a      	ands	r2, r1
    71f4:	1c11      	adds	r1, r2, #0
    71f6:	1c02      	adds	r2, r0, #0
    71f8:	430a      	orrs	r2, r1
    71fa:	70da      	strb	r2, [r3, #3]
    IPH_CHKSUM_SET(iphdr, 0);
    71fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    71fe:	7a9a      	ldrb	r2, [r3, #10]
    7200:	2100      	movs	r1, #0
    7202:	400a      	ands	r2, r1
    7204:	729a      	strb	r2, [r3, #10]
    7206:	7ada      	ldrb	r2, [r3, #11]
    7208:	2100      	movs	r1, #0
    720a:	400a      	ands	r2, r1
    720c:	72da      	strb	r2, [r3, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
    720e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    7210:	2114      	movs	r1, #20
    7212:	0018      	movs	r0, r3
    7214:	4b2b      	ldr	r3, [pc, #172]	; (72c4 <ip_frag+0x394>)
    7216:	4798      	blx	r3
    7218:	0003      	movs	r3, r0
    721a:	001a      	movs	r2, r3
    721c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    721e:	21ff      	movs	r1, #255	; 0xff
    7220:	4011      	ands	r1, r2
    7222:	000c      	movs	r4, r1
    7224:	7a99      	ldrb	r1, [r3, #10]
    7226:	2000      	movs	r0, #0
    7228:	4001      	ands	r1, r0
    722a:	1c08      	adds	r0, r1, #0
    722c:	1c21      	adds	r1, r4, #0
    722e:	4301      	orrs	r1, r0
    7230:	7299      	strb	r1, [r3, #10]
    7232:	0a12      	lsrs	r2, r2, #8
    7234:	b290      	uxth	r0, r2
    7236:	7ada      	ldrb	r2, [r3, #11]
    7238:	2100      	movs	r1, #0
    723a:	400a      	ands	r2, r1
    723c:	1c11      	adds	r1, r2, #0
    723e:	1c02      	adds	r2, r0, #0
    7240:	430a      	orrs	r2, r1
    7242:	72da      	strb	r2, [r3, #11]
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
    7244:	68bb      	ldr	r3, [r7, #8]
    7246:	695b      	ldr	r3, [r3, #20]
    7248:	687a      	ldr	r2, [r7, #4]
    724a:	69f9      	ldr	r1, [r7, #28]
    724c:	68b8      	ldr	r0, [r7, #8]
    724e:	4798      	blx	r3
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
    7250:	69fb      	ldr	r3, [r7, #28]
    7252:	0018      	movs	r0, r3
    7254:	4b14      	ldr	r3, [pc, #80]	; (72a8 <ip_frag+0x378>)
    7256:	4798      	blx	r3
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    7258:	233e      	movs	r3, #62	; 0x3e
    725a:	18fb      	adds	r3, r7, r3
    725c:	223e      	movs	r2, #62	; 0x3e
    725e:	18b9      	adds	r1, r7, r2
    7260:	2220      	movs	r2, #32
    7262:	18ba      	adds	r2, r7, r2
    7264:	8809      	ldrh	r1, [r1, #0]
    7266:	8812      	ldrh	r2, [r2, #0]
    7268:	1a8a      	subs	r2, r1, r2
    726a:	801a      	strh	r2, [r3, #0]
    ofo += nfb;
    726c:	233c      	movs	r3, #60	; 0x3c
    726e:	18fb      	adds	r3, r7, r3
    7270:	223c      	movs	r2, #60	; 0x3c
    7272:	18b9      	adds	r1, r7, r2
    7274:	2224      	movs	r2, #36	; 0x24
    7276:	18ba      	adds	r2, r7, r2
    7278:	8809      	ldrh	r1, [r1, #0]
    727a:	8812      	ldrh	r2, [r2, #0]
    727c:	188a      	adds	r2, r1, r2
    727e:	801a      	strh	r2, [r3, #0]

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    7280:	233e      	movs	r3, #62	; 0x3e
    7282:	18fb      	adds	r3, r7, r3
    7284:	881b      	ldrh	r3, [r3, #0]
    7286:	2b00      	cmp	r3, #0
    7288:	d000      	beq.n	728c <ip_frag+0x35c>
    728a:	e69a      	b.n	6fc2 <ip_frag+0x92>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
    728c:	2300      	movs	r3, #0
}
    728e:	0018      	movs	r0, r3
    7290:	46bd      	mov	sp, r7
    7292:	b011      	add	sp, #68	; 0x44
    7294:	bd90      	pop	{r4, r7, pc}
    7296:	46c0      	nop			; (mov r8, r8)
    7298:	0000561d 	.word	0x0000561d
    729c:	00007e19 	.word	0x00007e19
    72a0:	0000fc43 	.word	0x0000fc43
    72a4:	00006ec1 	.word	0x00006ec1
    72a8:	00008349 	.word	0x00008349
    72ac:	0000806d 	.word	0x0000806d
    72b0:	00006ed9 	.word	0x00006ed9
    72b4:	0000846d 	.word	0x0000846d
    72b8:	00006ef9 	.word	0x00006ef9
    72bc:	00008491 	.word	0x00008491
    72c0:	000055f1 	.word	0x000055f1
    72c4:	00005ba5 	.word	0x00005ba5

000072c8 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
    72c8:	b580      	push	{r7, lr}
    72ca:	af00      	add	r7, sp, #0
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
#endif /* !NO_SYS */
  mem_init();
    72cc:	4b07      	ldr	r3, [pc, #28]	; (72ec <lwip_init+0x24>)
    72ce:	4798      	blx	r3
  memp_init();
    72d0:	4b07      	ldr	r3, [pc, #28]	; (72f0 <lwip_init+0x28>)
    72d2:	4798      	blx	r3
  pbuf_init();
  netif_init();
    72d4:	4b07      	ldr	r3, [pc, #28]	; (72f4 <lwip_init+0x2c>)
    72d6:	4798      	blx	r3
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
    72d8:	4b07      	ldr	r3, [pc, #28]	; (72f8 <lwip_init+0x30>)
    72da:	4798      	blx	r3
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
    72dc:	4b07      	ldr	r3, [pc, #28]	; (72fc <lwip_init+0x34>)
    72de:	4798      	blx	r3
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
    72e0:	4b07      	ldr	r3, [pc, #28]	; (7300 <lwip_init+0x38>)
    72e2:	4798      	blx	r3
#endif /* LWIP_TIMERS */
}
    72e4:	46c0      	nop			; (mov r8, r8)
    72e6:	46bd      	mov	sp, r7
    72e8:	bd80      	pop	{r7, pc}
    72ea:	46c0      	nop			; (mov r8, r8)
    72ec:	000075e5 	.word	0x000075e5
    72f0:	00007a39 	.word	0x00007a39
    72f4:	00007b79 	.word	0x00007b79
    72f8:	0000d1e5 	.word	0x0000d1e5
    72fc:	000087a9 	.word	0x000087a9
    7300:	000073fd 	.word	0x000073fd

00007304 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
    7304:	b580      	push	{r7, lr}
    7306:	b082      	sub	sp, #8
    7308:	af00      	add	r7, sp, #0
    730a:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
    730c:	4b0b      	ldr	r3, [pc, #44]	; (733c <tcpip_tcp_timer+0x38>)
    730e:	4798      	blx	r3
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
    7310:	4b0b      	ldr	r3, [pc, #44]	; (7340 <tcpip_tcp_timer+0x3c>)
    7312:	681b      	ldr	r3, [r3, #0]
    7314:	2b00      	cmp	r3, #0
    7316:	d103      	bne.n	7320 <tcpip_tcp_timer+0x1c>
    7318:	4b0a      	ldr	r3, [pc, #40]	; (7344 <tcpip_tcp_timer+0x40>)
    731a:	681b      	ldr	r3, [r3, #0]
    731c:	2b00      	cmp	r3, #0
    731e:	d006      	beq.n	732e <tcpip_tcp_timer+0x2a>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    7320:	4b09      	ldr	r3, [pc, #36]	; (7348 <tcpip_tcp_timer+0x44>)
    7322:	2200      	movs	r2, #0
    7324:	0019      	movs	r1, r3
    7326:	20fa      	movs	r0, #250	; 0xfa
    7328:	4b08      	ldr	r3, [pc, #32]	; (734c <tcpip_tcp_timer+0x48>)
    732a:	4798      	blx	r3
    732c:	e002      	b.n	7334 <tcpip_tcp_timer+0x30>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
    732e:	4b08      	ldr	r3, [pc, #32]	; (7350 <tcpip_tcp_timer+0x4c>)
    7330:	2200      	movs	r2, #0
    7332:	601a      	str	r2, [r3, #0]
  }
}
    7334:	46c0      	nop			; (mov r8, r8)
    7336:	46bd      	mov	sp, r7
    7338:	b002      	add	sp, #8
    733a:	bd80      	pop	{r7, pc}
    733c:	000087b5 	.word	0x000087b5
    7340:	20003ec4 	.word	0x20003ec4
    7344:	20003ed8 	.word	0x20003ed8
    7348:	00007305 	.word	0x00007305
    734c:	00007445 	.word	0x00007445
    7350:	20000b28 	.word	0x20000b28

00007354 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
    7354:	b580      	push	{r7, lr}
    7356:	af00      	add	r7, sp, #0
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    7358:	4b0b      	ldr	r3, [pc, #44]	; (7388 <tcp_timer_needed+0x34>)
    735a:	681b      	ldr	r3, [r3, #0]
    735c:	2b00      	cmp	r3, #0
    735e:	d110      	bne.n	7382 <tcp_timer_needed+0x2e>
    7360:	4b0a      	ldr	r3, [pc, #40]	; (738c <tcp_timer_needed+0x38>)
    7362:	681b      	ldr	r3, [r3, #0]
    7364:	2b00      	cmp	r3, #0
    7366:	d103      	bne.n	7370 <tcp_timer_needed+0x1c>
    7368:	4b09      	ldr	r3, [pc, #36]	; (7390 <tcp_timer_needed+0x3c>)
    736a:	681b      	ldr	r3, [r3, #0]
    736c:	2b00      	cmp	r3, #0
    736e:	d008      	beq.n	7382 <tcp_timer_needed+0x2e>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
    7370:	4b05      	ldr	r3, [pc, #20]	; (7388 <tcp_timer_needed+0x34>)
    7372:	2201      	movs	r2, #1
    7374:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
    7376:	4b07      	ldr	r3, [pc, #28]	; (7394 <tcp_timer_needed+0x40>)
    7378:	2200      	movs	r2, #0
    737a:	0019      	movs	r1, r3
    737c:	20fa      	movs	r0, #250	; 0xfa
    737e:	4b06      	ldr	r3, [pc, #24]	; (7398 <tcp_timer_needed+0x44>)
    7380:	4798      	blx	r3
  }
}
    7382:	46c0      	nop			; (mov r8, r8)
    7384:	46bd      	mov	sp, r7
    7386:	bd80      	pop	{r7, pc}
    7388:	20000b28 	.word	0x20000b28
    738c:	20003ec4 	.word	0x20003ec4
    7390:	20003ed8 	.word	0x20003ed8
    7394:	00007305 	.word	0x00007305
    7398:	00007445 	.word	0x00007445

0000739c <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
    739c:	b580      	push	{r7, lr}
    739e:	b082      	sub	sp, #8
    73a0:	af00      	add	r7, sp, #0
    73a2:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
    73a4:	4b06      	ldr	r3, [pc, #24]	; (73c0 <ip_reass_timer+0x24>)
    73a6:	4798      	blx	r3
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    73a8:	4906      	ldr	r1, [pc, #24]	; (73c4 <ip_reass_timer+0x28>)
    73aa:	23fa      	movs	r3, #250	; 0xfa
    73ac:	009b      	lsls	r3, r3, #2
    73ae:	2200      	movs	r2, #0
    73b0:	0018      	movs	r0, r3
    73b2:	4b05      	ldr	r3, [pc, #20]	; (73c8 <ip_reass_timer+0x2c>)
    73b4:	4798      	blx	r3
}
    73b6:	46c0      	nop			; (mov r8, r8)
    73b8:	46bd      	mov	sp, r7
    73ba:	b002      	add	sp, #8
    73bc:	bd80      	pop	{r7, pc}
    73be:	46c0      	nop			; (mov r8, r8)
    73c0:	00006415 	.word	0x00006415
    73c4:	0000739d 	.word	0x0000739d
    73c8:	00007445 	.word	0x00007445

000073cc <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
    73cc:	b580      	push	{r7, lr}
    73ce:	b082      	sub	sp, #8
    73d0:	af00      	add	r7, sp, #0
    73d2:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
    73d4:	4b05      	ldr	r3, [pc, #20]	; (73ec <arp_timer+0x20>)
    73d6:	4798      	blx	r3
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    73d8:	4b05      	ldr	r3, [pc, #20]	; (73f0 <arp_timer+0x24>)
    73da:	4806      	ldr	r0, [pc, #24]	; (73f4 <arp_timer+0x28>)
    73dc:	2200      	movs	r2, #0
    73de:	0019      	movs	r1, r3
    73e0:	4b05      	ldr	r3, [pc, #20]	; (73f8 <arp_timer+0x2c>)
    73e2:	4798      	blx	r3
}
    73e4:	46c0      	nop			; (mov r8, r8)
    73e6:	46bd      	mov	sp, r7
    73e8:	b002      	add	sp, #8
    73ea:	bd80      	pop	{r7, pc}
    73ec:	0000d8d1 	.word	0x0000d8d1
    73f0:	000073cd 	.word	0x000073cd
    73f4:	00001388 	.word	0x00001388
    73f8:	00007445 	.word	0x00007445

000073fc <sys_timeouts_init>:
}
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
    73fc:	b580      	push	{r7, lr}
    73fe:	af00      	add	r7, sp, #0
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
    7400:	490a      	ldr	r1, [pc, #40]	; (742c <sys_timeouts_init+0x30>)
    7402:	23fa      	movs	r3, #250	; 0xfa
    7404:	009b      	lsls	r3, r3, #2
    7406:	2200      	movs	r2, #0
    7408:	0018      	movs	r0, r3
    740a:	4b09      	ldr	r3, [pc, #36]	; (7430 <sys_timeouts_init+0x34>)
    740c:	4798      	blx	r3
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
    740e:	4b09      	ldr	r3, [pc, #36]	; (7434 <sys_timeouts_init+0x38>)
    7410:	4809      	ldr	r0, [pc, #36]	; (7438 <sys_timeouts_init+0x3c>)
    7412:	2200      	movs	r2, #0
    7414:	0019      	movs	r1, r3
    7416:	4b06      	ldr	r3, [pc, #24]	; (7430 <sys_timeouts_init+0x34>)
    7418:	4798      	blx	r3
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
    741a:	4b08      	ldr	r3, [pc, #32]	; (743c <sys_timeouts_init+0x40>)
    741c:	4798      	blx	r3
    741e:	0002      	movs	r2, r0
    7420:	4b07      	ldr	r3, [pc, #28]	; (7440 <sys_timeouts_init+0x44>)
    7422:	601a      	str	r2, [r3, #0]
#endif
}
    7424:	46c0      	nop			; (mov r8, r8)
    7426:	46bd      	mov	sp, r7
    7428:	bd80      	pop	{r7, pc}
    742a:	46c0      	nop			; (mov r8, r8)
    742c:	0000739d 	.word	0x0000739d
    7430:	00007445 	.word	0x00007445
    7434:	000073cd 	.word	0x000073cd
    7438:	00001388 	.word	0x00001388
    743c:	0000f809 	.word	0x0000f809
    7440:	20000b24 	.word	0x20000b24

00007444 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
    7444:	b580      	push	{r7, lr}
    7446:	b086      	sub	sp, #24
    7448:	af00      	add	r7, sp, #0
    744a:	60f8      	str	r0, [r7, #12]
    744c:	60b9      	str	r1, [r7, #8]
    744e:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
    7450:	2006      	movs	r0, #6
    7452:	4b33      	ldr	r3, [pc, #204]	; (7520 <sys_timeout+0xdc>)
    7454:	4798      	blx	r3
    7456:	0003      	movs	r3, r0
    7458:	613b      	str	r3, [r7, #16]
  if (timeout == NULL) {
    745a:	693b      	ldr	r3, [r7, #16]
    745c:	2b00      	cmp	r3, #0
    745e:	d05b      	beq.n	7518 <sys_timeout+0xd4>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
    7460:	693b      	ldr	r3, [r7, #16]
    7462:	2200      	movs	r2, #0
    7464:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
    7466:	693b      	ldr	r3, [r7, #16]
    7468:	68ba      	ldr	r2, [r7, #8]
    746a:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
    746c:	693b      	ldr	r3, [r7, #16]
    746e:	687a      	ldr	r2, [r7, #4]
    7470:	60da      	str	r2, [r3, #12]
  timeout->time = msecs;
    7472:	693b      	ldr	r3, [r7, #16]
    7474:	68fa      	ldr	r2, [r7, #12]
    7476:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
    7478:	4b2a      	ldr	r3, [pc, #168]	; (7524 <sys_timeout+0xe0>)
    747a:	681b      	ldr	r3, [r3, #0]
    747c:	2b00      	cmp	r3, #0
    747e:	d103      	bne.n	7488 <sys_timeout+0x44>
    next_timeout = timeout;
    7480:	4b28      	ldr	r3, [pc, #160]	; (7524 <sys_timeout+0xe0>)
    7482:	693a      	ldr	r2, [r7, #16]
    7484:	601a      	str	r2, [r3, #0]
    return;
    7486:	e048      	b.n	751a <sys_timeout+0xd6>
  }

  if (next_timeout->time > msecs) {
    7488:	4b26      	ldr	r3, [pc, #152]	; (7524 <sys_timeout+0xe0>)
    748a:	681b      	ldr	r3, [r3, #0]
    748c:	685a      	ldr	r2, [r3, #4]
    748e:	68fb      	ldr	r3, [r7, #12]
    7490:	429a      	cmp	r2, r3
    7492:	d90f      	bls.n	74b4 <sys_timeout+0x70>
    next_timeout->time -= msecs;
    7494:	4b23      	ldr	r3, [pc, #140]	; (7524 <sys_timeout+0xe0>)
    7496:	681b      	ldr	r3, [r3, #0]
    7498:	4a22      	ldr	r2, [pc, #136]	; (7524 <sys_timeout+0xe0>)
    749a:	6812      	ldr	r2, [r2, #0]
    749c:	6851      	ldr	r1, [r2, #4]
    749e:	68fa      	ldr	r2, [r7, #12]
    74a0:	1a8a      	subs	r2, r1, r2
    74a2:	605a      	str	r2, [r3, #4]
    timeout->next = next_timeout;
    74a4:	4b1f      	ldr	r3, [pc, #124]	; (7524 <sys_timeout+0xe0>)
    74a6:	681a      	ldr	r2, [r3, #0]
    74a8:	693b      	ldr	r3, [r7, #16]
    74aa:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
    74ac:	4b1d      	ldr	r3, [pc, #116]	; (7524 <sys_timeout+0xe0>)
    74ae:	693a      	ldr	r2, [r7, #16]
    74b0:	601a      	str	r2, [r3, #0]
    74b2:	e032      	b.n	751a <sys_timeout+0xd6>
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
    74b4:	4b1b      	ldr	r3, [pc, #108]	; (7524 <sys_timeout+0xe0>)
    74b6:	681b      	ldr	r3, [r3, #0]
    74b8:	617b      	str	r3, [r7, #20]
    74ba:	e029      	b.n	7510 <sys_timeout+0xcc>
      timeout->time -= t->time;
    74bc:	693b      	ldr	r3, [r7, #16]
    74be:	685a      	ldr	r2, [r3, #4]
    74c0:	697b      	ldr	r3, [r7, #20]
    74c2:	685b      	ldr	r3, [r3, #4]
    74c4:	1ad2      	subs	r2, r2, r3
    74c6:	693b      	ldr	r3, [r7, #16]
    74c8:	605a      	str	r2, [r3, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
    74ca:	697b      	ldr	r3, [r7, #20]
    74cc:	681b      	ldr	r3, [r3, #0]
    74ce:	2b00      	cmp	r3, #0
    74d0:	d006      	beq.n	74e0 <sys_timeout+0x9c>
    74d2:	697b      	ldr	r3, [r7, #20]
    74d4:	681b      	ldr	r3, [r3, #0]
    74d6:	685a      	ldr	r2, [r3, #4]
    74d8:	693b      	ldr	r3, [r7, #16]
    74da:	685b      	ldr	r3, [r3, #4]
    74dc:	429a      	cmp	r2, r3
    74de:	d914      	bls.n	750a <sys_timeout+0xc6>
        if (t->next != NULL) {
    74e0:	697b      	ldr	r3, [r7, #20]
    74e2:	681b      	ldr	r3, [r3, #0]
    74e4:	2b00      	cmp	r3, #0
    74e6:	d008      	beq.n	74fa <sys_timeout+0xb6>
          t->next->time -= timeout->time;
    74e8:	697b      	ldr	r3, [r7, #20]
    74ea:	681b      	ldr	r3, [r3, #0]
    74ec:	697a      	ldr	r2, [r7, #20]
    74ee:	6812      	ldr	r2, [r2, #0]
    74f0:	6851      	ldr	r1, [r2, #4]
    74f2:	693a      	ldr	r2, [r7, #16]
    74f4:	6852      	ldr	r2, [r2, #4]
    74f6:	1a8a      	subs	r2, r1, r2
    74f8:	605a      	str	r2, [r3, #4]
        }
        timeout->next = t->next;
    74fa:	697b      	ldr	r3, [r7, #20]
    74fc:	681a      	ldr	r2, [r3, #0]
    74fe:	693b      	ldr	r3, [r7, #16]
    7500:	601a      	str	r2, [r3, #0]
        t->next = timeout;
    7502:	697b      	ldr	r3, [r7, #20]
    7504:	693a      	ldr	r2, [r7, #16]
    7506:	601a      	str	r2, [r3, #0]
        break;
    7508:	e007      	b.n	751a <sys_timeout+0xd6>
  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
    750a:	697b      	ldr	r3, [r7, #20]
    750c:	681b      	ldr	r3, [r3, #0]
    750e:	617b      	str	r3, [r7, #20]
    7510:	697b      	ldr	r3, [r7, #20]
    7512:	2b00      	cmp	r3, #0
    7514:	d1d2      	bne.n	74bc <sys_timeout+0x78>
    7516:	e000      	b.n	751a <sys_timeout+0xd6>
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
    7518:	46c0      	nop			; (mov r8, r8)
        t->next = timeout;
        break;
      }
    }
  }
}
    751a:	46bd      	mov	sp, r7
    751c:	b006      	add	sp, #24
    751e:	bd80      	pop	{r7, pc}
    7520:	00007af1 	.word	0x00007af1
    7524:	20000b20 	.word	0x20000b20

00007528 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
    7528:	b580      	push	{r7, lr}
    752a:	b084      	sub	sp, #16
    752c:	af00      	add	r7, sp, #0
    752e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
    7530:	4b29      	ldr	r3, [pc, #164]	; (75d8 <plug_holes+0xb0>)
    7532:	681b      	ldr	r3, [r3, #0]
    7534:	687a      	ldr	r2, [r7, #4]
    7536:	8812      	ldrh	r2, [r2, #0]
    7538:	189b      	adds	r3, r3, r2
    753a:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    753c:	687a      	ldr	r2, [r7, #4]
    753e:	68fb      	ldr	r3, [r7, #12]
    7540:	429a      	cmp	r2, r3
    7542:	d01f      	beq.n	7584 <plug_holes+0x5c>
    7544:	68fb      	ldr	r3, [r7, #12]
    7546:	791b      	ldrb	r3, [r3, #4]
    7548:	2b00      	cmp	r3, #0
    754a:	d11b      	bne.n	7584 <plug_holes+0x5c>
    754c:	4b23      	ldr	r3, [pc, #140]	; (75dc <plug_holes+0xb4>)
    754e:	681b      	ldr	r3, [r3, #0]
    7550:	68fa      	ldr	r2, [r7, #12]
    7552:	429a      	cmp	r2, r3
    7554:	d016      	beq.n	7584 <plug_holes+0x5c>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
    7556:	4b22      	ldr	r3, [pc, #136]	; (75e0 <plug_holes+0xb8>)
    7558:	681a      	ldr	r2, [r3, #0]
    755a:	68fb      	ldr	r3, [r7, #12]
    755c:	429a      	cmp	r2, r3
    755e:	d102      	bne.n	7566 <plug_holes+0x3e>
      lfree = mem;
    7560:	4b1f      	ldr	r3, [pc, #124]	; (75e0 <plug_holes+0xb8>)
    7562:	687a      	ldr	r2, [r7, #4]
    7564:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
    7566:	68fb      	ldr	r3, [r7, #12]
    7568:	881a      	ldrh	r2, [r3, #0]
    756a:	687b      	ldr	r3, [r7, #4]
    756c:	801a      	strh	r2, [r3, #0]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
    756e:	4b1a      	ldr	r3, [pc, #104]	; (75d8 <plug_holes+0xb0>)
    7570:	681b      	ldr	r3, [r3, #0]
    7572:	68fa      	ldr	r2, [r7, #12]
    7574:	8812      	ldrh	r2, [r2, #0]
    7576:	189a      	adds	r2, r3, r2
    7578:	6879      	ldr	r1, [r7, #4]
    757a:	4b17      	ldr	r3, [pc, #92]	; (75d8 <plug_holes+0xb0>)
    757c:	681b      	ldr	r3, [r3, #0]
    757e:	1acb      	subs	r3, r1, r3
    7580:	b29b      	uxth	r3, r3
    7582:	8053      	strh	r3, [r2, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
    7584:	4b14      	ldr	r3, [pc, #80]	; (75d8 <plug_holes+0xb0>)
    7586:	681b      	ldr	r3, [r3, #0]
    7588:	687a      	ldr	r2, [r7, #4]
    758a:	8852      	ldrh	r2, [r2, #2]
    758c:	189b      	adds	r3, r3, r2
    758e:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
    7590:	68ba      	ldr	r2, [r7, #8]
    7592:	687b      	ldr	r3, [r7, #4]
    7594:	429a      	cmp	r2, r3
    7596:	d01a      	beq.n	75ce <plug_holes+0xa6>
    7598:	68bb      	ldr	r3, [r7, #8]
    759a:	791b      	ldrb	r3, [r3, #4]
    759c:	2b00      	cmp	r3, #0
    759e:	d116      	bne.n	75ce <plug_holes+0xa6>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
    75a0:	4b0f      	ldr	r3, [pc, #60]	; (75e0 <plug_holes+0xb8>)
    75a2:	681a      	ldr	r2, [r3, #0]
    75a4:	687b      	ldr	r3, [r7, #4]
    75a6:	429a      	cmp	r2, r3
    75a8:	d102      	bne.n	75b0 <plug_holes+0x88>
      lfree = pmem;
    75aa:	4b0d      	ldr	r3, [pc, #52]	; (75e0 <plug_holes+0xb8>)
    75ac:	68ba      	ldr	r2, [r7, #8]
    75ae:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
    75b0:	687b      	ldr	r3, [r7, #4]
    75b2:	881a      	ldrh	r2, [r3, #0]
    75b4:	68bb      	ldr	r3, [r7, #8]
    75b6:	801a      	strh	r2, [r3, #0]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
    75b8:	4b07      	ldr	r3, [pc, #28]	; (75d8 <plug_holes+0xb0>)
    75ba:	681b      	ldr	r3, [r3, #0]
    75bc:	687a      	ldr	r2, [r7, #4]
    75be:	8812      	ldrh	r2, [r2, #0]
    75c0:	189a      	adds	r2, r3, r2
    75c2:	68b9      	ldr	r1, [r7, #8]
    75c4:	4b04      	ldr	r3, [pc, #16]	; (75d8 <plug_holes+0xb0>)
    75c6:	681b      	ldr	r3, [r3, #0]
    75c8:	1acb      	subs	r3, r1, r3
    75ca:	b29b      	uxth	r3, r3
    75cc:	8053      	strh	r3, [r2, #2]
  }
}
    75ce:	46c0      	nop			; (mov r8, r8)
    75d0:	46bd      	mov	sp, r7
    75d2:	b004      	add	sp, #16
    75d4:	bd80      	pop	{r7, pc}
    75d6:	46c0      	nop			; (mov r8, r8)
    75d8:	20000b2c 	.word	0x20000b2c
    75dc:	20000b30 	.word	0x20000b30
    75e0:	20000b34 	.word	0x20000b34

000075e4 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
    75e4:	b580      	push	{r7, lr}
    75e6:	b082      	sub	sp, #8
    75e8:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
    75ea:	4b18      	ldr	r3, [pc, #96]	; (764c <mem_init+0x68>)
    75ec:	3303      	adds	r3, #3
    75ee:	2203      	movs	r2, #3
    75f0:	4393      	bics	r3, r2
    75f2:	001a      	movs	r2, r3
    75f4:	4b16      	ldr	r3, [pc, #88]	; (7650 <mem_init+0x6c>)
    75f6:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
    75f8:	4b15      	ldr	r3, [pc, #84]	; (7650 <mem_init+0x6c>)
    75fa:	681b      	ldr	r3, [r3, #0]
    75fc:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
    75fe:	687b      	ldr	r3, [r7, #4]
    7600:	2280      	movs	r2, #128	; 0x80
    7602:	0152      	lsls	r2, r2, #5
    7604:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
    7606:	687b      	ldr	r3, [r7, #4]
    7608:	2200      	movs	r2, #0
    760a:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
    760c:	687b      	ldr	r3, [r7, #4]
    760e:	2200      	movs	r2, #0
    7610:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
    7612:	4b0f      	ldr	r3, [pc, #60]	; (7650 <mem_init+0x6c>)
    7614:	681b      	ldr	r3, [r3, #0]
    7616:	2280      	movs	r2, #128	; 0x80
    7618:	0152      	lsls	r2, r2, #5
    761a:	189a      	adds	r2, r3, r2
    761c:	4b0d      	ldr	r3, [pc, #52]	; (7654 <mem_init+0x70>)
    761e:	601a      	str	r2, [r3, #0]
  ram_end->used = 1;
    7620:	4b0c      	ldr	r3, [pc, #48]	; (7654 <mem_init+0x70>)
    7622:	681b      	ldr	r3, [r3, #0]
    7624:	2201      	movs	r2, #1
    7626:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
    7628:	4b0a      	ldr	r3, [pc, #40]	; (7654 <mem_init+0x70>)
    762a:	681b      	ldr	r3, [r3, #0]
    762c:	2280      	movs	r2, #128	; 0x80
    762e:	0152      	lsls	r2, r2, #5
    7630:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
    7632:	4b08      	ldr	r3, [pc, #32]	; (7654 <mem_init+0x70>)
    7634:	681b      	ldr	r3, [r3, #0]
    7636:	2280      	movs	r2, #128	; 0x80
    7638:	0152      	lsls	r2, r2, #5
    763a:	805a      	strh	r2, [r3, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
    763c:	4b04      	ldr	r3, [pc, #16]	; (7650 <mem_init+0x6c>)
    763e:	681a      	ldr	r2, [r3, #0]
    7640:	4b05      	ldr	r3, [pc, #20]	; (7658 <mem_init+0x74>)
    7642:	601a      	str	r2, [r3, #0]
  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
    7644:	46c0      	nop			; (mov r8, r8)
    7646:	46bd      	mov	sp, r7
    7648:	b002      	add	sp, #8
    764a:	bd80      	pop	{r7, pc}
    764c:	20002ea0 	.word	0x20002ea0
    7650:	20000b2c 	.word	0x20000b2c
    7654:	20000b30 	.word	0x20000b30
    7658:	20000b34 	.word	0x20000b34

0000765c <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
    765c:	b580      	push	{r7, lr}
    765e:	b084      	sub	sp, #16
    7660:	af00      	add	r7, sp, #0
    7662:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    7664:	687b      	ldr	r3, [r7, #4]
    7666:	2b00      	cmp	r3, #0
    7668:	d01c      	beq.n	76a4 <mem_free+0x48>
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    766a:	4b11      	ldr	r3, [pc, #68]	; (76b0 <mem_free+0x54>)
    766c:	681b      	ldr	r3, [r3, #0]
    766e:	687a      	ldr	r2, [r7, #4]
    7670:	429a      	cmp	r2, r3
    7672:	d319      	bcc.n	76a8 <mem_free+0x4c>
    7674:	4b0f      	ldr	r3, [pc, #60]	; (76b4 <mem_free+0x58>)
    7676:	681b      	ldr	r3, [r3, #0]
    7678:	687a      	ldr	r2, [r7, #4]
    767a:	429a      	cmp	r2, r3
    767c:	d214      	bcs.n	76a8 <mem_free+0x4c>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    767e:	687b      	ldr	r3, [r7, #4]
    7680:	3b08      	subs	r3, #8
    7682:	60fb      	str	r3, [r7, #12]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
    7684:	68fb      	ldr	r3, [r7, #12]
    7686:	2200      	movs	r2, #0
    7688:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
    768a:	4b0b      	ldr	r3, [pc, #44]	; (76b8 <mem_free+0x5c>)
    768c:	681b      	ldr	r3, [r3, #0]
    768e:	68fa      	ldr	r2, [r7, #12]
    7690:	429a      	cmp	r2, r3
    7692:	d202      	bcs.n	769a <mem_free+0x3e>
    /* the newly freed struct is now the lowest */
    lfree = mem;
    7694:	4b08      	ldr	r3, [pc, #32]	; (76b8 <mem_free+0x5c>)
    7696:	68fa      	ldr	r2, [r7, #12]
    7698:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
    769a:	68fb      	ldr	r3, [r7, #12]
    769c:	0018      	movs	r0, r3
    769e:	4b07      	ldr	r3, [pc, #28]	; (76bc <mem_free+0x60>)
    76a0:	4798      	blx	r3
    76a2:	e002      	b.n	76aa <mem_free+0x4e>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
    76a4:	46c0      	nop			; (mov r8, r8)
    76a6:	e000      	b.n	76aa <mem_free+0x4e>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
    76a8:	46c0      	nop			; (mov r8, r8)
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
    76aa:	46bd      	mov	sp, r7
    76ac:	b004      	add	sp, #16
    76ae:	bd80      	pop	{r7, pc}
    76b0:	20000b2c 	.word	0x20000b2c
    76b4:	20000b30 	.word	0x20000b30
    76b8:	20000b34 	.word	0x20000b34
    76bc:	00007529 	.word	0x00007529

000076c0 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
    76c0:	b580      	push	{r7, lr}
    76c2:	b086      	sub	sp, #24
    76c4:	af00      	add	r7, sp, #0
    76c6:	6078      	str	r0, [r7, #4]
    76c8:	000a      	movs	r2, r1
    76ca:	1cbb      	adds	r3, r7, #2
    76cc:	801a      	strh	r2, [r3, #0]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
    76ce:	1cbb      	adds	r3, r7, #2
    76d0:	881b      	ldrh	r3, [r3, #0]
    76d2:	3303      	adds	r3, #3
    76d4:	b29a      	uxth	r2, r3
    76d6:	1cbb      	adds	r3, r7, #2
    76d8:	2103      	movs	r1, #3
    76da:	438a      	bics	r2, r1
    76dc:	801a      	strh	r2, [r3, #0]

  if(newsize < MIN_SIZE_ALIGNED) {
    76de:	1cbb      	adds	r3, r7, #2
    76e0:	881b      	ldrh	r3, [r3, #0]
    76e2:	2b0b      	cmp	r3, #11
    76e4:	d802      	bhi.n	76ec <mem_trim+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
    76e6:	1cbb      	adds	r3, r7, #2
    76e8:	220c      	movs	r2, #12
    76ea:	801a      	strh	r2, [r3, #0]
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    76ec:	1cbb      	adds	r3, r7, #2
    76ee:	881a      	ldrh	r2, [r3, #0]
    76f0:	2380      	movs	r3, #128	; 0x80
    76f2:	015b      	lsls	r3, r3, #5
    76f4:	429a      	cmp	r2, r3
    76f6:	d901      	bls.n	76fc <mem_trim+0x3c>
    return NULL;
    76f8:	2300      	movs	r3, #0
    76fa:	e0c6      	b.n	788a <mem_trim+0x1ca>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
    76fc:	4b65      	ldr	r3, [pc, #404]	; (7894 <mem_trim+0x1d4>)
    76fe:	681b      	ldr	r3, [r3, #0]
    7700:	687a      	ldr	r2, [r7, #4]
    7702:	429a      	cmp	r2, r3
    7704:	d304      	bcc.n	7710 <mem_trim+0x50>
    7706:	4b64      	ldr	r3, [pc, #400]	; (7898 <mem_trim+0x1d8>)
    7708:	681b      	ldr	r3, [r3, #0]
    770a:	687a      	ldr	r2, [r7, #4]
    770c:	429a      	cmp	r2, r3
    770e:	d301      	bcc.n	7714 <mem_trim+0x54>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
    7710:	687b      	ldr	r3, [r7, #4]
    7712:	e0ba      	b.n	788a <mem_trim+0x1ca>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
    7714:	687b      	ldr	r3, [r7, #4]
    7716:	3b08      	subs	r3, #8
    7718:	617b      	str	r3, [r7, #20]
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
    771a:	697a      	ldr	r2, [r7, #20]
    771c:	4b5d      	ldr	r3, [pc, #372]	; (7894 <mem_trim+0x1d4>)
    771e:	681b      	ldr	r3, [r3, #0]
    7720:	1ad2      	subs	r2, r2, r3
    7722:	2312      	movs	r3, #18
    7724:	18fb      	adds	r3, r7, r3
    7726:	801a      	strh	r2, [r3, #0]

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
    7728:	697b      	ldr	r3, [r7, #20]
    772a:	881a      	ldrh	r2, [r3, #0]
    772c:	2312      	movs	r3, #18
    772e:	18fb      	adds	r3, r7, r3
    7730:	881b      	ldrh	r3, [r3, #0]
    7732:	1ad3      	subs	r3, r2, r3
    7734:	b29a      	uxth	r2, r3
    7736:	2310      	movs	r3, #16
    7738:	18fb      	adds	r3, r7, r3
    773a:	3a08      	subs	r2, #8
    773c:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
    773e:	1cba      	adds	r2, r7, #2
    7740:	2310      	movs	r3, #16
    7742:	18fb      	adds	r3, r7, r3
    7744:	8812      	ldrh	r2, [r2, #0]
    7746:	881b      	ldrh	r3, [r3, #0]
    7748:	429a      	cmp	r2, r3
    774a:	d901      	bls.n	7750 <mem_trim+0x90>
    /* not supported */
    return NULL;
    774c:	2300      	movs	r3, #0
    774e:	e09c      	b.n	788a <mem_trim+0x1ca>
  }
  if (newsize == size) {
    7750:	1cba      	adds	r2, r7, #2
    7752:	2310      	movs	r3, #16
    7754:	18fb      	adds	r3, r7, r3
    7756:	8812      	ldrh	r2, [r2, #0]
    7758:	881b      	ldrh	r3, [r3, #0]
    775a:	429a      	cmp	r2, r3
    775c:	d101      	bne.n	7762 <mem_trim+0xa2>
    /* No change in size, simply return */
    return rmem;
    775e:	687b      	ldr	r3, [r7, #4]
    7760:	e093      	b.n	788a <mem_trim+0x1ca>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();

  mem2 = (struct mem *)(void *)&ram[mem->next];
    7762:	4b4c      	ldr	r3, [pc, #304]	; (7894 <mem_trim+0x1d4>)
    7764:	681b      	ldr	r3, [r3, #0]
    7766:	697a      	ldr	r2, [r7, #20]
    7768:	8812      	ldrh	r2, [r2, #0]
    776a:	189b      	adds	r3, r3, r2
    776c:	60fb      	str	r3, [r7, #12]
  if(mem2->used == 0) {
    776e:	68fb      	ldr	r3, [r7, #12]
    7770:	791b      	ldrb	r3, [r3, #4]
    7772:	2b00      	cmp	r3, #0
    7774:	d145      	bne.n	7802 <mem_trim+0x142>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    7776:	230a      	movs	r3, #10
    7778:	18fb      	adds	r3, r7, r3
    777a:	68fa      	ldr	r2, [r7, #12]
    777c:	8812      	ldrh	r2, [r2, #0]
    777e:	801a      	strh	r2, [r3, #0]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    7780:	2312      	movs	r3, #18
    7782:	18fa      	adds	r2, r7, r3
    7784:	1cbb      	adds	r3, r7, #2
    7786:	8812      	ldrh	r2, [r2, #0]
    7788:	881b      	ldrh	r3, [r3, #0]
    778a:	18d3      	adds	r3, r2, r3
    778c:	b29a      	uxth	r2, r3
    778e:	2308      	movs	r3, #8
    7790:	18fb      	adds	r3, r7, r3
    7792:	3208      	adds	r2, #8
    7794:	801a      	strh	r2, [r3, #0]
    if (lfree == mem2) {
    7796:	4b41      	ldr	r3, [pc, #260]	; (789c <mem_trim+0x1dc>)
    7798:	681a      	ldr	r2, [r3, #0]
    779a:	68fb      	ldr	r3, [r7, #12]
    779c:	429a      	cmp	r2, r3
    779e:	d107      	bne.n	77b0 <mem_trim+0xf0>
      lfree = (struct mem *)(void *)&ram[ptr2];
    77a0:	4b3c      	ldr	r3, [pc, #240]	; (7894 <mem_trim+0x1d4>)
    77a2:	681a      	ldr	r2, [r3, #0]
    77a4:	2308      	movs	r3, #8
    77a6:	18fb      	adds	r3, r7, r3
    77a8:	881b      	ldrh	r3, [r3, #0]
    77aa:	18d2      	adds	r2, r2, r3
    77ac:	4b3b      	ldr	r3, [pc, #236]	; (789c <mem_trim+0x1dc>)
    77ae:	601a      	str	r2, [r3, #0]
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    77b0:	4b38      	ldr	r3, [pc, #224]	; (7894 <mem_trim+0x1d4>)
    77b2:	681a      	ldr	r2, [r3, #0]
    77b4:	2308      	movs	r3, #8
    77b6:	18fb      	adds	r3, r7, r3
    77b8:	881b      	ldrh	r3, [r3, #0]
    77ba:	18d3      	adds	r3, r2, r3
    77bc:	60fb      	str	r3, [r7, #12]
    mem2->used = 0;
    77be:	68fb      	ldr	r3, [r7, #12]
    77c0:	2200      	movs	r2, #0
    77c2:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
    77c4:	68fb      	ldr	r3, [r7, #12]
    77c6:	220a      	movs	r2, #10
    77c8:	18ba      	adds	r2, r7, r2
    77ca:	8812      	ldrh	r2, [r2, #0]
    77cc:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
    77ce:	68fb      	ldr	r3, [r7, #12]
    77d0:	2212      	movs	r2, #18
    77d2:	18ba      	adds	r2, r7, r2
    77d4:	8812      	ldrh	r2, [r2, #0]
    77d6:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
    77d8:	697b      	ldr	r3, [r7, #20]
    77da:	2208      	movs	r2, #8
    77dc:	18ba      	adds	r2, r7, r2
    77de:	8812      	ldrh	r2, [r2, #0]
    77e0:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
    77e2:	68fb      	ldr	r3, [r7, #12]
    77e4:	881a      	ldrh	r2, [r3, #0]
    77e6:	2380      	movs	r3, #128	; 0x80
    77e8:	015b      	lsls	r3, r3, #5
    77ea:	429a      	cmp	r2, r3
    77ec:	d04c      	beq.n	7888 <mem_trim+0x1c8>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    77ee:	4b29      	ldr	r3, [pc, #164]	; (7894 <mem_trim+0x1d4>)
    77f0:	681b      	ldr	r3, [r3, #0]
    77f2:	68fa      	ldr	r2, [r7, #12]
    77f4:	8812      	ldrh	r2, [r2, #0]
    77f6:	189b      	adds	r3, r3, r2
    77f8:	2208      	movs	r2, #8
    77fa:	18ba      	adds	r2, r7, r2
    77fc:	8812      	ldrh	r2, [r2, #0]
    77fe:	805a      	strh	r2, [r3, #2]
    7800:	e042      	b.n	7888 <mem_trim+0x1c8>
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
    7802:	1cbb      	adds	r3, r7, #2
    7804:	881b      	ldrh	r3, [r3, #0]
    7806:	3314      	adds	r3, #20
    7808:	001a      	movs	r2, r3
    780a:	2310      	movs	r3, #16
    780c:	18fb      	adds	r3, r7, r3
    780e:	881b      	ldrh	r3, [r3, #0]
    7810:	429a      	cmp	r2, r3
    7812:	d839      	bhi.n	7888 <mem_trim+0x1c8>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    7814:	2312      	movs	r3, #18
    7816:	18fa      	adds	r2, r7, r3
    7818:	1cbb      	adds	r3, r7, #2
    781a:	8812      	ldrh	r2, [r2, #0]
    781c:	881b      	ldrh	r3, [r3, #0]
    781e:	18d3      	adds	r3, r2, r3
    7820:	b29a      	uxth	r2, r3
    7822:	2308      	movs	r3, #8
    7824:	18fb      	adds	r3, r7, r3
    7826:	3208      	adds	r2, #8
    7828:	801a      	strh	r2, [r3, #0]
    mem2 = (struct mem *)(void *)&ram[ptr2];
    782a:	4b1a      	ldr	r3, [pc, #104]	; (7894 <mem_trim+0x1d4>)
    782c:	681a      	ldr	r2, [r3, #0]
    782e:	2308      	movs	r3, #8
    7830:	18fb      	adds	r3, r7, r3
    7832:	881b      	ldrh	r3, [r3, #0]
    7834:	18d3      	adds	r3, r2, r3
    7836:	60fb      	str	r3, [r7, #12]
    if (mem2 < lfree) {
    7838:	4b18      	ldr	r3, [pc, #96]	; (789c <mem_trim+0x1dc>)
    783a:	681b      	ldr	r3, [r3, #0]
    783c:	68fa      	ldr	r2, [r7, #12]
    783e:	429a      	cmp	r2, r3
    7840:	d202      	bcs.n	7848 <mem_trim+0x188>
      lfree = mem2;
    7842:	4b16      	ldr	r3, [pc, #88]	; (789c <mem_trim+0x1dc>)
    7844:	68fa      	ldr	r2, [r7, #12]
    7846:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
    7848:	68fb      	ldr	r3, [r7, #12]
    784a:	2200      	movs	r2, #0
    784c:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
    784e:	697b      	ldr	r3, [r7, #20]
    7850:	881a      	ldrh	r2, [r3, #0]
    7852:	68fb      	ldr	r3, [r7, #12]
    7854:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
    7856:	68fb      	ldr	r3, [r7, #12]
    7858:	2212      	movs	r2, #18
    785a:	18ba      	adds	r2, r7, r2
    785c:	8812      	ldrh	r2, [r2, #0]
    785e:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
    7860:	697b      	ldr	r3, [r7, #20]
    7862:	2208      	movs	r2, #8
    7864:	18ba      	adds	r2, r7, r2
    7866:	8812      	ldrh	r2, [r2, #0]
    7868:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
    786a:	68fb      	ldr	r3, [r7, #12]
    786c:	881a      	ldrh	r2, [r3, #0]
    786e:	2380      	movs	r3, #128	; 0x80
    7870:	015b      	lsls	r3, r3, #5
    7872:	429a      	cmp	r2, r3
    7874:	d008      	beq.n	7888 <mem_trim+0x1c8>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    7876:	4b07      	ldr	r3, [pc, #28]	; (7894 <mem_trim+0x1d4>)
    7878:	681b      	ldr	r3, [r3, #0]
    787a:	68fa      	ldr	r2, [r7, #12]
    787c:	8812      	ldrh	r2, [r2, #0]
    787e:	189b      	adds	r3, r3, r2
    7880:	2208      	movs	r2, #8
    7882:	18ba      	adds	r2, r7, r2
    7884:	8812      	ldrh	r2, [r2, #0]
    7886:	805a      	strh	r2, [r3, #2]
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
    7888:	687b      	ldr	r3, [r7, #4]
}
    788a:	0018      	movs	r0, r3
    788c:	46bd      	mov	sp, r7
    788e:	b006      	add	sp, #24
    7890:	bd80      	pop	{r7, pc}
    7892:	46c0      	nop			; (mov r8, r8)
    7894:	20000b2c 	.word	0x20000b2c
    7898:	20000b30 	.word	0x20000b30
    789c:	20000b34 	.word	0x20000b34

000078a0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
    78a0:	b580      	push	{r7, lr}
    78a2:	b088      	sub	sp, #32
    78a4:	af00      	add	r7, sp, #0
    78a6:	0002      	movs	r2, r0
    78a8:	1dbb      	adds	r3, r7, #6
    78aa:	801a      	strh	r2, [r3, #0]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    78ac:	1dbb      	adds	r3, r7, #6
    78ae:	881b      	ldrh	r3, [r3, #0]
    78b0:	2b00      	cmp	r3, #0
    78b2:	d101      	bne.n	78b8 <mem_malloc+0x18>
    return NULL;
    78b4:	2300      	movs	r3, #0
    78b6:	e0b4      	b.n	7a22 <mem_malloc+0x182>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
    78b8:	1dbb      	adds	r3, r7, #6
    78ba:	881b      	ldrh	r3, [r3, #0]
    78bc:	3303      	adds	r3, #3
    78be:	b29a      	uxth	r2, r3
    78c0:	1dbb      	adds	r3, r7, #6
    78c2:	2103      	movs	r1, #3
    78c4:	438a      	bics	r2, r1
    78c6:	801a      	strh	r2, [r3, #0]

  if(size < MIN_SIZE_ALIGNED) {
    78c8:	1dbb      	adds	r3, r7, #6
    78ca:	881b      	ldrh	r3, [r3, #0]
    78cc:	2b0b      	cmp	r3, #11
    78ce:	d802      	bhi.n	78d6 <mem_malloc+0x36>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
    78d0:	1dbb      	adds	r3, r7, #6
    78d2:	220c      	movs	r2, #12
    78d4:	801a      	strh	r2, [r3, #0]
  }

  if (size > MEM_SIZE_ALIGNED) {
    78d6:	1dbb      	adds	r3, r7, #6
    78d8:	881a      	ldrh	r2, [r3, #0]
    78da:	2380      	movs	r3, #128	; 0x80
    78dc:	015b      	lsls	r3, r3, #5
    78de:	429a      	cmp	r2, r3
    78e0:	d901      	bls.n	78e6 <mem_malloc+0x46>
    return NULL;
    78e2:	2300      	movs	r3, #0
    78e4:	e09d      	b.n	7a22 <mem_malloc+0x182>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    78e6:	4b51      	ldr	r3, [pc, #324]	; (7a2c <mem_malloc+0x18c>)
    78e8:	681b      	ldr	r3, [r3, #0]
    78ea:	001a      	movs	r2, r3
    78ec:	4b50      	ldr	r3, [pc, #320]	; (7a30 <mem_malloc+0x190>)
    78ee:	681b      	ldr	r3, [r3, #0]
    78f0:	1ad2      	subs	r2, r2, r3
    78f2:	231e      	movs	r3, #30
    78f4:	18fb      	adds	r3, r7, r3
    78f6:	801a      	strh	r2, [r3, #0]
    78f8:	e087      	b.n	7a0a <mem_malloc+0x16a>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
    78fa:	4b4d      	ldr	r3, [pc, #308]	; (7a30 <mem_malloc+0x190>)
    78fc:	681a      	ldr	r2, [r3, #0]
    78fe:	231e      	movs	r3, #30
    7900:	18fb      	adds	r3, r7, r3
    7902:	881b      	ldrh	r3, [r3, #0]
    7904:	18d3      	adds	r3, r2, r3
    7906:	617b      	str	r3, [r7, #20]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    7908:	697b      	ldr	r3, [r7, #20]
    790a:	791b      	ldrb	r3, [r3, #4]
    790c:	2b00      	cmp	r3, #0
    790e:	d000      	beq.n	7912 <mem_malloc+0x72>
    7910:	e071      	b.n	79f6 <mem_malloc+0x156>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
    7912:	697b      	ldr	r3, [r7, #20]
    7914:	881b      	ldrh	r3, [r3, #0]
    7916:	001a      	movs	r2, r3
    7918:	231e      	movs	r3, #30
    791a:	18fb      	adds	r3, r7, r3
    791c:	881b      	ldrh	r3, [r3, #0]
    791e:	1ad3      	subs	r3, r2, r3
    7920:	3b08      	subs	r3, #8
    7922:	001a      	movs	r2, r3
    7924:	1dbb      	adds	r3, r7, #6
    7926:	881b      	ldrh	r3, [r3, #0]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
    7928:	429a      	cmp	r2, r3
    792a:	d364      	bcc.n	79f6 <mem_malloc+0x156>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
    792c:	697b      	ldr	r3, [r7, #20]
    792e:	881b      	ldrh	r3, [r3, #0]
    7930:	001a      	movs	r2, r3
    7932:	231e      	movs	r3, #30
    7934:	18fb      	adds	r3, r7, r3
    7936:	881b      	ldrh	r3, [r3, #0]
    7938:	1ad3      	subs	r3, r2, r3
    793a:	3b08      	subs	r3, #8
    793c:	001a      	movs	r2, r3
    793e:	1dbb      	adds	r3, r7, #6
    7940:	881b      	ldrh	r3, [r3, #0]
    7942:	3314      	adds	r3, #20
    7944:	429a      	cmp	r2, r3
    7946:	d335      	bcc.n	79b4 <mem_malloc+0x114>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
    7948:	231e      	movs	r3, #30
    794a:	18fa      	adds	r2, r7, r3
    794c:	1dbb      	adds	r3, r7, #6
    794e:	8812      	ldrh	r2, [r2, #0]
    7950:	881b      	ldrh	r3, [r3, #0]
    7952:	18d3      	adds	r3, r2, r3
    7954:	b29a      	uxth	r2, r3
    7956:	2312      	movs	r3, #18
    7958:	18fb      	adds	r3, r7, r3
    795a:	3208      	adds	r2, #8
    795c:	801a      	strh	r2, [r3, #0]
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
    795e:	4b34      	ldr	r3, [pc, #208]	; (7a30 <mem_malloc+0x190>)
    7960:	681a      	ldr	r2, [r3, #0]
    7962:	2312      	movs	r3, #18
    7964:	18fb      	adds	r3, r7, r3
    7966:	881b      	ldrh	r3, [r3, #0]
    7968:	18d3      	adds	r3, r2, r3
    796a:	60fb      	str	r3, [r7, #12]
          mem2->used = 0;
    796c:	68fb      	ldr	r3, [r7, #12]
    796e:	2200      	movs	r2, #0
    7970:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
    7972:	697b      	ldr	r3, [r7, #20]
    7974:	881a      	ldrh	r2, [r3, #0]
    7976:	68fb      	ldr	r3, [r7, #12]
    7978:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
    797a:	68fb      	ldr	r3, [r7, #12]
    797c:	221e      	movs	r2, #30
    797e:	18ba      	adds	r2, r7, r2
    7980:	8812      	ldrh	r2, [r2, #0]
    7982:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
    7984:	697b      	ldr	r3, [r7, #20]
    7986:	2212      	movs	r2, #18
    7988:	18ba      	adds	r2, r7, r2
    798a:	8812      	ldrh	r2, [r2, #0]
    798c:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
    798e:	697b      	ldr	r3, [r7, #20]
    7990:	2201      	movs	r2, #1
    7992:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
    7994:	68fb      	ldr	r3, [r7, #12]
    7996:	881a      	ldrh	r2, [r3, #0]
    7998:	2380      	movs	r3, #128	; 0x80
    799a:	015b      	lsls	r3, r3, #5
    799c:	429a      	cmp	r2, r3
    799e:	d00c      	beq.n	79ba <mem_malloc+0x11a>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    79a0:	4b23      	ldr	r3, [pc, #140]	; (7a30 <mem_malloc+0x190>)
    79a2:	681b      	ldr	r3, [r3, #0]
    79a4:	68fa      	ldr	r2, [r7, #12]
    79a6:	8812      	ldrh	r2, [r2, #0]
    79a8:	189b      	adds	r3, r3, r2
    79aa:	2212      	movs	r2, #18
    79ac:	18ba      	adds	r2, r7, r2
    79ae:	8812      	ldrh	r2, [r2, #0]
    79b0:	805a      	strh	r2, [r3, #2]
    79b2:	e002      	b.n	79ba <mem_malloc+0x11a>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
    79b4:	697b      	ldr	r3, [r7, #20]
    79b6:	2201      	movs	r2, #1
    79b8:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
    79ba:	4b1c      	ldr	r3, [pc, #112]	; (7a2c <mem_malloc+0x18c>)
    79bc:	681b      	ldr	r3, [r3, #0]
    79be:	697a      	ldr	r2, [r7, #20]
    79c0:	429a      	cmp	r2, r3
    79c2:	d115      	bne.n	79f0 <mem_malloc+0x150>
          struct mem *cur = lfree;
    79c4:	4b19      	ldr	r3, [pc, #100]	; (7a2c <mem_malloc+0x18c>)
    79c6:	681b      	ldr	r3, [r3, #0]
    79c8:	61bb      	str	r3, [r7, #24]
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
    79ca:	e005      	b.n	79d8 <mem_malloc+0x138>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
    79cc:	4b18      	ldr	r3, [pc, #96]	; (7a30 <mem_malloc+0x190>)
    79ce:	681b      	ldr	r3, [r3, #0]
    79d0:	69ba      	ldr	r2, [r7, #24]
    79d2:	8812      	ldrh	r2, [r2, #0]
    79d4:	189b      	adds	r3, r3, r2
    79d6:	61bb      	str	r3, [r7, #24]
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
    79d8:	69bb      	ldr	r3, [r7, #24]
    79da:	791b      	ldrb	r3, [r3, #4]
    79dc:	2b00      	cmp	r3, #0
    79de:	d004      	beq.n	79ea <mem_malloc+0x14a>
    79e0:	4b14      	ldr	r3, [pc, #80]	; (7a34 <mem_malloc+0x194>)
    79e2:	681b      	ldr	r3, [r3, #0]
    79e4:	69ba      	ldr	r2, [r7, #24]
    79e6:	429a      	cmp	r2, r3
    79e8:	d1f0      	bne.n	79cc <mem_malloc+0x12c>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
    79ea:	4b10      	ldr	r3, [pc, #64]	; (7a2c <mem_malloc+0x18c>)
    79ec:	69ba      	ldr	r2, [r7, #24]
    79ee:	601a      	str	r2, [r3, #0]
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
    79f0:	697b      	ldr	r3, [r7, #20]
    79f2:	3308      	adds	r3, #8
    79f4:	e015      	b.n	7a22 <mem_malloc+0x182>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
    79f6:	4b0e      	ldr	r3, [pc, #56]	; (7a30 <mem_malloc+0x190>)
    79f8:	681a      	ldr	r2, [r3, #0]
    79fa:	231e      	movs	r3, #30
    79fc:	18fb      	adds	r3, r7, r3
    79fe:	881b      	ldrh	r3, [r3, #0]
    7a00:	18d2      	adds	r2, r2, r3
    7a02:	231e      	movs	r3, #30
    7a04:	18fb      	adds	r3, r7, r3
    7a06:	8812      	ldrh	r2, [r2, #0]
    7a08:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
    7a0a:	231e      	movs	r3, #30
    7a0c:	18fb      	adds	r3, r7, r3
    7a0e:	881a      	ldrh	r2, [r3, #0]
    7a10:	1dbb      	adds	r3, r7, #6
    7a12:	881b      	ldrh	r3, [r3, #0]
    7a14:	2180      	movs	r1, #128	; 0x80
    7a16:	0149      	lsls	r1, r1, #5
    7a18:	1acb      	subs	r3, r1, r3
    7a1a:	429a      	cmp	r2, r3
    7a1c:	da00      	bge.n	7a20 <mem_malloc+0x180>
    7a1e:	e76c      	b.n	78fa <mem_malloc+0x5a>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
    7a20:	2300      	movs	r3, #0
}
    7a22:	0018      	movs	r0, r3
    7a24:	46bd      	mov	sp, r7
    7a26:	b008      	add	sp, #32
    7a28:	bd80      	pop	{r7, pc}
    7a2a:	46c0      	nop			; (mov r8, r8)
    7a2c:	20000b34 	.word	0x20000b34
    7a30:	20000b2c 	.word	0x20000b2c
    7a34:	20000b30 	.word	0x20000b30

00007a38 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
    7a38:	b580      	push	{r7, lr}
    7a3a:	b082      	sub	sp, #8
    7a3c:	af00      	add	r7, sp, #0
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
    7a3e:	1cbb      	adds	r3, r7, #2
    7a40:	2200      	movs	r2, #0
    7a42:	801a      	strh	r2, [r3, #0]
    7a44:	e004      	b.n	7a50 <memp_init+0x18>
    7a46:	1cbb      	adds	r3, r7, #2
    7a48:	1cba      	adds	r2, r7, #2
    7a4a:	8812      	ldrh	r2, [r2, #0]
    7a4c:	3201      	adds	r2, #1
    7a4e:	801a      	strh	r2, [r3, #0]
    7a50:	1cbb      	adds	r3, r7, #2
    7a52:	881b      	ldrh	r3, [r3, #0]
    7a54:	2b08      	cmp	r3, #8
    7a56:	d9f6      	bls.n	7a46 <memp_init+0xe>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
    7a58:	4b21      	ldr	r3, [pc, #132]	; (7ae0 <memp_init+0xa8>)
    7a5a:	3303      	adds	r3, #3
    7a5c:	2203      	movs	r2, #3
    7a5e:	4393      	bics	r3, r2
    7a60:	607b      	str	r3, [r7, #4]
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    7a62:	1cbb      	adds	r3, r7, #2
    7a64:	2200      	movs	r2, #0
    7a66:	801a      	strh	r2, [r3, #0]
    7a68:	e032      	b.n	7ad0 <memp_init+0x98>
    memp_tab[i] = NULL;
    7a6a:	1cbb      	adds	r3, r7, #2
    7a6c:	881a      	ldrh	r2, [r3, #0]
    7a6e:	4b1d      	ldr	r3, [pc, #116]	; (7ae4 <memp_init+0xac>)
    7a70:	0092      	lsls	r2, r2, #2
    7a72:	2100      	movs	r1, #0
    7a74:	50d1      	str	r1, [r2, r3]
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    7a76:	003b      	movs	r3, r7
    7a78:	2200      	movs	r2, #0
    7a7a:	801a      	strh	r2, [r3, #0]
    7a7c:	e01a      	b.n	7ab4 <memp_init+0x7c>
      memp->next = memp_tab[i];
    7a7e:	1cbb      	adds	r3, r7, #2
    7a80:	881a      	ldrh	r2, [r3, #0]
    7a82:	4b18      	ldr	r3, [pc, #96]	; (7ae4 <memp_init+0xac>)
    7a84:	0092      	lsls	r2, r2, #2
    7a86:	58d2      	ldr	r2, [r2, r3]
    7a88:	687b      	ldr	r3, [r7, #4]
    7a8a:	601a      	str	r2, [r3, #0]
      memp_tab[i] = memp;
    7a8c:	1cbb      	adds	r3, r7, #2
    7a8e:	881a      	ldrh	r2, [r3, #0]
    7a90:	4b14      	ldr	r3, [pc, #80]	; (7ae4 <memp_init+0xac>)
    7a92:	0092      	lsls	r2, r2, #2
    7a94:	6879      	ldr	r1, [r7, #4]
    7a96:	50d1      	str	r1, [r2, r3]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
    7a98:	1cbb      	adds	r3, r7, #2
    7a9a:	881a      	ldrh	r2, [r3, #0]
    7a9c:	4b12      	ldr	r3, [pc, #72]	; (7ae8 <memp_init+0xb0>)
    7a9e:	0052      	lsls	r2, r2, #1
    7aa0:	5ad3      	ldrh	r3, [r2, r3]
    7aa2:	001a      	movs	r2, r3
    7aa4:	687b      	ldr	r3, [r7, #4]
    7aa6:	189b      	adds	r3, r3, r2
    7aa8:	607b      	str	r3, [r7, #4]
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
    7aaa:	003b      	movs	r3, r7
    7aac:	003a      	movs	r2, r7
    7aae:	8812      	ldrh	r2, [r2, #0]
    7ab0:	3201      	adds	r2, #1
    7ab2:	801a      	strh	r2, [r3, #0]
    7ab4:	1cbb      	adds	r3, r7, #2
    7ab6:	881a      	ldrh	r2, [r3, #0]
    7ab8:	4b0c      	ldr	r3, [pc, #48]	; (7aec <memp_init+0xb4>)
    7aba:	0052      	lsls	r2, r2, #1
    7abc:	5ad3      	ldrh	r3, [r2, r3]
    7abe:	003a      	movs	r2, r7
    7ac0:	8812      	ldrh	r2, [r2, #0]
    7ac2:	429a      	cmp	r2, r3
    7ac4:	d3db      	bcc.n	7a7e <memp_init+0x46>

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    7ac6:	1cbb      	adds	r3, r7, #2
    7ac8:	1cba      	adds	r2, r7, #2
    7aca:	8812      	ldrh	r2, [r2, #0]
    7acc:	3201      	adds	r2, #1
    7ace:	801a      	strh	r2, [r3, #0]
    7ad0:	1cbb      	adds	r3, r7, #2
    7ad2:	881b      	ldrh	r3, [r3, #0]
    7ad4:	2b08      	cmp	r3, #8
    7ad6:	d9c8      	bls.n	7a6a <memp_init+0x32>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
    7ad8:	46c0      	nop			; (mov r8, r8)
    7ada:	46bd      	mov	sp, r7
    7adc:	b002      	add	sp, #8
    7ade:	bd80      	pop	{r7, pc}
    7ae0:	20000b5c 	.word	0x20000b5c
    7ae4:	20000b38 	.word	0x20000b38
    7ae8:	0000fd60 	.word	0x0000fd60
    7aec:	0000fd74 	.word	0x0000fd74

00007af0 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
    7af0:	b580      	push	{r7, lr}
    7af2:	b084      	sub	sp, #16
    7af4:	af00      	add	r7, sp, #0
    7af6:	0002      	movs	r2, r0
    7af8:	1dfb      	adds	r3, r7, #7
    7afa:	701a      	strb	r2, [r3, #0]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
    7afc:	1dfb      	adds	r3, r7, #7
    7afe:	781b      	ldrb	r3, [r3, #0]
    7b00:	2b08      	cmp	r3, #8
    7b02:	d901      	bls.n	7b08 <memp_malloc+0x18>
    7b04:	2300      	movs	r3, #0
    7b06:	e010      	b.n	7b2a <memp_malloc+0x3a>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
    7b08:	1dfb      	adds	r3, r7, #7
    7b0a:	781a      	ldrb	r2, [r3, #0]
    7b0c:	4b09      	ldr	r3, [pc, #36]	; (7b34 <memp_malloc+0x44>)
    7b0e:	0092      	lsls	r2, r2, #2
    7b10:	58d3      	ldr	r3, [r2, r3]
    7b12:	60fb      	str	r3, [r7, #12]
  
  if (memp != NULL) {
    7b14:	68fb      	ldr	r3, [r7, #12]
    7b16:	2b00      	cmp	r3, #0
    7b18:	d006      	beq.n	7b28 <memp_malloc+0x38>
    memp_tab[type] = memp->next;
    7b1a:	1dfb      	adds	r3, r7, #7
    7b1c:	781a      	ldrb	r2, [r3, #0]
    7b1e:	68fb      	ldr	r3, [r7, #12]
    7b20:	6819      	ldr	r1, [r3, #0]
    7b22:	4b04      	ldr	r3, [pc, #16]	; (7b34 <memp_malloc+0x44>)
    7b24:	0092      	lsls	r2, r2, #2
    7b26:	50d1      	str	r1, [r2, r3]
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
    7b28:	68fb      	ldr	r3, [r7, #12]
}
    7b2a:	0018      	movs	r0, r3
    7b2c:	46bd      	mov	sp, r7
    7b2e:	b004      	add	sp, #16
    7b30:	bd80      	pop	{r7, pc}
    7b32:	46c0      	nop			; (mov r8, r8)
    7b34:	20000b38 	.word	0x20000b38

00007b38 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
    7b38:	b580      	push	{r7, lr}
    7b3a:	b084      	sub	sp, #16
    7b3c:	af00      	add	r7, sp, #0
    7b3e:	0002      	movs	r2, r0
    7b40:	6039      	str	r1, [r7, #0]
    7b42:	1dfb      	adds	r3, r7, #7
    7b44:	701a      	strb	r2, [r3, #0]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    7b46:	683b      	ldr	r3, [r7, #0]
    7b48:	2b00      	cmp	r3, #0
    7b4a:	d00f      	beq.n	7b6c <memp_free+0x34>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
    7b4c:	683b      	ldr	r3, [r7, #0]
    7b4e:	60fb      	str	r3, [r7, #12]
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
    7b50:	1dfb      	adds	r3, r7, #7
    7b52:	781a      	ldrb	r2, [r3, #0]
    7b54:	4b07      	ldr	r3, [pc, #28]	; (7b74 <memp_free+0x3c>)
    7b56:	0092      	lsls	r2, r2, #2
    7b58:	58d2      	ldr	r2, [r2, r3]
    7b5a:	68fb      	ldr	r3, [r7, #12]
    7b5c:	601a      	str	r2, [r3, #0]
  memp_tab[type] = memp;
    7b5e:	1dfb      	adds	r3, r7, #7
    7b60:	781a      	ldrb	r2, [r3, #0]
    7b62:	4b04      	ldr	r3, [pc, #16]	; (7b74 <memp_free+0x3c>)
    7b64:	0092      	lsls	r2, r2, #2
    7b66:	68f9      	ldr	r1, [r7, #12]
    7b68:	50d1      	str	r1, [r2, r3]
    7b6a:	e000      	b.n	7b6e <memp_free+0x36>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
    7b6c:	46c0      	nop			; (mov r8, r8)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
    7b6e:	46bd      	mov	sp, r7
    7b70:	b004      	add	sp, #16
    7b72:	bd80      	pop	{r7, pc}
    7b74:	20000b38 	.word	0x20000b38

00007b78 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
    7b78:	b580      	push	{r7, lr}
    7b7a:	af00      	add	r7, sp, #0
  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
    7b7c:	46c0      	nop			; (mov r8, r8)
    7b7e:	46bd      	mov	sp, r7
    7b80:	bd80      	pop	{r7, pc}
    7b82:	46c0      	nop			; (mov r8, r8)

00007b84 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
    7b84:	b590      	push	{r4, r7, lr}
    7b86:	b085      	sub	sp, #20
    7b88:	af00      	add	r7, sp, #0
    7b8a:	60f8      	str	r0, [r7, #12]
    7b8c:	60b9      	str	r1, [r7, #8]
    7b8e:	607a      	str	r2, [r7, #4]
    7b90:	603b      	str	r3, [r7, #0]

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
    7b92:	68fb      	ldr	r3, [r7, #12]
    7b94:	2200      	movs	r2, #0
    7b96:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero(&netif->netmask);
    7b98:	68fb      	ldr	r3, [r7, #12]
    7b9a:	2200      	movs	r2, #0
    7b9c:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero(&netif->gw);
    7b9e:	68fb      	ldr	r3, [r7, #12]
    7ba0:	2200      	movs	r2, #0
    7ba2:	60da      	str	r2, [r3, #12]
  netif->flags = 0;
    7ba4:	68fb      	ldr	r3, [r7, #12]
    7ba6:	222d      	movs	r2, #45	; 0x2d
    7ba8:	2100      	movs	r1, #0
    7baa:	5499      	strb	r1, [r3, r2]
#if LWIP_AUTOIP
  /* netif not under AutoIP control by default */
  netif->autoip = NULL;
#endif /* LWIP_AUTOIP */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
    7bac:	68fb      	ldr	r3, [r7, #12]
    7bae:	2200      	movs	r2, #0
    7bb0:	61da      	str	r2, [r3, #28]
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
    7bb2:	68fb      	ldr	r3, [r7, #12]
    7bb4:	6a3a      	ldr	r2, [r7, #32]
    7bb6:	621a      	str	r2, [r3, #32]
  netif->num = netif_num++;
    7bb8:	4b12      	ldr	r3, [pc, #72]	; (7c04 <netif_add+0x80>)
    7bba:	781b      	ldrb	r3, [r3, #0]
    7bbc:	1c5a      	adds	r2, r3, #1
    7bbe:	b2d1      	uxtb	r1, r2
    7bc0:	4a10      	ldr	r2, [pc, #64]	; (7c04 <netif_add+0x80>)
    7bc2:	7011      	strb	r1, [r2, #0]
    7bc4:	68fa      	ldr	r2, [r7, #12]
    7bc6:	2130      	movs	r1, #48	; 0x30
    7bc8:	5453      	strb	r3, [r2, r1]
  netif->input = input;
    7bca:	68fb      	ldr	r3, [r7, #12]
    7bcc:	6aba      	ldr	r2, [r7, #40]	; 0x28
    7bce:	611a      	str	r2, [r3, #16]
  NETIF_SET_HWADDRHINT(netif, NULL);
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
    7bd0:	683b      	ldr	r3, [r7, #0]
    7bd2:	687a      	ldr	r2, [r7, #4]
    7bd4:	68b9      	ldr	r1, [r7, #8]
    7bd6:	68f8      	ldr	r0, [r7, #12]
    7bd8:	4c0b      	ldr	r4, [pc, #44]	; (7c08 <netif_add+0x84>)
    7bda:	47a0      	blx	r4

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    7bdc:	68fa      	ldr	r2, [r7, #12]
    7bde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    7be0:	0010      	movs	r0, r2
    7be2:	4798      	blx	r3
    7be4:	1e03      	subs	r3, r0, #0
    7be6:	d001      	beq.n	7bec <netif_add+0x68>
    return NULL;
    7be8:	2300      	movs	r3, #0
    7bea:	e007      	b.n	7bfc <netif_add+0x78>
  }

  /* add this netif to the list */
  netif->next = netif_list;
    7bec:	4b07      	ldr	r3, [pc, #28]	; (7c0c <netif_add+0x88>)
    7bee:	681a      	ldr	r2, [r3, #0]
    7bf0:	68fb      	ldr	r3, [r7, #12]
    7bf2:	601a      	str	r2, [r3, #0]
  netif_list = netif;
    7bf4:	4b05      	ldr	r3, [pc, #20]	; (7c0c <netif_add+0x88>)
    7bf6:	68fa      	ldr	r2, [r7, #12]
    7bf8:	601a      	str	r2, [r3, #0]
  //LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  //ip_addr_debug_print(NETIF_DEBUG, netmask);
  //LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  //ip_addr_debug_print(NETIF_DEBUG, gw);
  //LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
    7bfa:	68fb      	ldr	r3, [r7, #12]
}
    7bfc:	0018      	movs	r0, r3
    7bfe:	46bd      	mov	sp, r7
    7c00:	b005      	add	sp, #20
    7c02:	bd90      	pop	{r4, r7, pc}
    7c04:	20002c6b 	.word	0x20002c6b
    7c08:	00007c11 	.word	0x00007c11
    7c0c:	20003eb4 	.word	0x20003eb4

00007c10 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
    7c10:	b580      	push	{r7, lr}
    7c12:	b084      	sub	sp, #16
    7c14:	af00      	add	r7, sp, #0
    7c16:	60f8      	str	r0, [r7, #12]
    7c18:	60b9      	str	r1, [r7, #8]
    7c1a:	607a      	str	r2, [r7, #4]
    7c1c:	603b      	str	r3, [r7, #0]
  netif_set_ipaddr(netif, ipaddr);
    7c1e:	68ba      	ldr	r2, [r7, #8]
    7c20:	68fb      	ldr	r3, [r7, #12]
    7c22:	0011      	movs	r1, r2
    7c24:	0018      	movs	r0, r3
    7c26:	4b09      	ldr	r3, [pc, #36]	; (7c4c <netif_set_addr+0x3c>)
    7c28:	4798      	blx	r3
  netif_set_netmask(netif, netmask);
    7c2a:	687a      	ldr	r2, [r7, #4]
    7c2c:	68fb      	ldr	r3, [r7, #12]
    7c2e:	0011      	movs	r1, r2
    7c30:	0018      	movs	r0, r3
    7c32:	4b07      	ldr	r3, [pc, #28]	; (7c50 <netif_set_addr+0x40>)
    7c34:	4798      	blx	r3
  netif_set_gw(netif, gw);
    7c36:	683a      	ldr	r2, [r7, #0]
    7c38:	68fb      	ldr	r3, [r7, #12]
    7c3a:	0011      	movs	r1, r2
    7c3c:	0018      	movs	r0, r3
    7c3e:	4b05      	ldr	r3, [pc, #20]	; (7c54 <netif_set_addr+0x44>)
    7c40:	4798      	blx	r3
}
    7c42:	46c0      	nop			; (mov r8, r8)
    7c44:	46bd      	mov	sp, r7
    7c46:	b004      	add	sp, #16
    7c48:	bd80      	pop	{r7, pc}
    7c4a:	46c0      	nop			; (mov r8, r8)
    7c4c:	00007c59 	.word	0x00007c59
    7c50:	00007d35 	.word	0x00007d35
    7c54:	00007d11 	.word	0x00007d11

00007c58 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
    7c58:	b580      	push	{r7, lr}
    7c5a:	b086      	sub	sp, #24
    7c5c:	af00      	add	r7, sp, #0
    7c5e:	6078      	str	r0, [r7, #4]
    7c60:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    7c62:	683b      	ldr	r3, [r7, #0]
    7c64:	2b00      	cmp	r3, #0
    7c66:	d03f      	beq.n	7ce8 <netif_set_ipaddr+0x90>
    7c68:	683b      	ldr	r3, [r7, #0]
    7c6a:	681a      	ldr	r2, [r3, #0]
    7c6c:	687b      	ldr	r3, [r7, #4]
    7c6e:	685b      	ldr	r3, [r3, #4]
    7c70:	429a      	cmp	r2, r3
    7c72:	d039      	beq.n	7ce8 <netif_set_ipaddr+0x90>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    7c74:	4b23      	ldr	r3, [pc, #140]	; (7d04 <netif_set_ipaddr+0xac>)
    7c76:	681b      	ldr	r3, [r3, #0]
    7c78:	617b      	str	r3, [r7, #20]
    while (pcb != NULL) {
    7c7a:	e012      	b.n	7ca2 <netif_set_ipaddr+0x4a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
    7c7c:	697b      	ldr	r3, [r7, #20]
    7c7e:	681a      	ldr	r2, [r3, #0]
    7c80:	687b      	ldr	r3, [r7, #4]
    7c82:	685b      	ldr	r3, [r3, #4]
    7c84:	429a      	cmp	r2, r3
    7c86:	d109      	bne.n	7c9c <netif_set_ipaddr+0x44>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
    7c88:	697b      	ldr	r3, [r7, #20]
    7c8a:	68db      	ldr	r3, [r3, #12]
    7c8c:	60fb      	str	r3, [r7, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
    7c8e:	697b      	ldr	r3, [r7, #20]
    7c90:	0018      	movs	r0, r3
    7c92:	4b1d      	ldr	r3, [pc, #116]	; (7d08 <netif_set_ipaddr+0xb0>)
    7c94:	4798      	blx	r3
        pcb = next;
    7c96:	68fb      	ldr	r3, [r7, #12]
    7c98:	617b      	str	r3, [r7, #20]
    7c9a:	e002      	b.n	7ca2 <netif_set_ipaddr+0x4a>
      } else {
        pcb = pcb->next;
    7c9c:	697b      	ldr	r3, [r7, #20]
    7c9e:	68db      	ldr	r3, [r3, #12]
    7ca0:	617b      	str	r3, [r7, #20]
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
    7ca2:	697b      	ldr	r3, [r7, #20]
    7ca4:	2b00      	cmp	r3, #0
    7ca6:	d1e9      	bne.n	7c7c <netif_set_ipaddr+0x24>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    7ca8:	4b18      	ldr	r3, [pc, #96]	; (7d0c <netif_set_ipaddr+0xb4>)
    7caa:	681b      	ldr	r3, [r3, #0]
    7cac:	613b      	str	r3, [r7, #16]
    7cae:	e018      	b.n	7ce2 <netif_set_ipaddr+0x8a>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    7cb0:	693b      	ldr	r3, [r7, #16]
    7cb2:	2b00      	cmp	r3, #0
    7cb4:	d012      	beq.n	7cdc <netif_set_ipaddr+0x84>
    7cb6:	693b      	ldr	r3, [r7, #16]
    7cb8:	681b      	ldr	r3, [r3, #0]
    7cba:	2b00      	cmp	r3, #0
    7cbc:	d00e      	beq.n	7cdc <netif_set_ipaddr+0x84>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
    7cbe:	693b      	ldr	r3, [r7, #16]
    7cc0:	681a      	ldr	r2, [r3, #0]
    7cc2:	687b      	ldr	r3, [r7, #4]
    7cc4:	685b      	ldr	r3, [r3, #4]
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
    7cc6:	429a      	cmp	r2, r3
    7cc8:	d108      	bne.n	7cdc <netif_set_ipaddr+0x84>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
    7cca:	683b      	ldr	r3, [r7, #0]
    7ccc:	2b00      	cmp	r3, #0
    7cce:	d002      	beq.n	7cd6 <netif_set_ipaddr+0x7e>
    7cd0:	683b      	ldr	r3, [r7, #0]
    7cd2:	681a      	ldr	r2, [r3, #0]
    7cd4:	e000      	b.n	7cd8 <netif_set_ipaddr+0x80>
    7cd6:	2200      	movs	r2, #0
    7cd8:	693b      	ldr	r3, [r7, #16]
    7cda:	601a      	str	r2, [r3, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    7cdc:	693b      	ldr	r3, [r7, #16]
    7cde:	68db      	ldr	r3, [r3, #12]
    7ce0:	613b      	str	r3, [r7, #16]
    7ce2:	693b      	ldr	r3, [r7, #16]
    7ce4:	2b00      	cmp	r3, #0
    7ce6:	d1e3      	bne.n	7cb0 <netif_set_ipaddr+0x58>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
    7ce8:	683b      	ldr	r3, [r7, #0]
    7cea:	2b00      	cmp	r3, #0
    7cec:	d002      	beq.n	7cf4 <netif_set_ipaddr+0x9c>
    7cee:	683b      	ldr	r3, [r7, #0]
    7cf0:	681a      	ldr	r2, [r3, #0]
    7cf2:	e000      	b.n	7cf6 <netif_set_ipaddr+0x9e>
    7cf4:	2200      	movs	r2, #0
    7cf6:	687b      	ldr	r3, [r7, #4]
    7cf8:	605a      	str	r2, [r3, #4]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
    7cfa:	46c0      	nop			; (mov r8, r8)
    7cfc:	46bd      	mov	sp, r7
    7cfe:	b006      	add	sp, #24
    7d00:	bd80      	pop	{r7, pc}
    7d02:	46c0      	nop			; (mov r8, r8)
    7d04:	20003ec4 	.word	0x20003ec4
    7d08:	00008bbd 	.word	0x00008bbd
    7d0c:	20003ecc 	.word	0x20003ecc

00007d10 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
    7d10:	b580      	push	{r7, lr}
    7d12:	b082      	sub	sp, #8
    7d14:	af00      	add	r7, sp, #0
    7d16:	6078      	str	r0, [r7, #4]
    7d18:	6039      	str	r1, [r7, #0]
  ip_addr_set(&(netif->gw), gw);
    7d1a:	683b      	ldr	r3, [r7, #0]
    7d1c:	2b00      	cmp	r3, #0
    7d1e:	d002      	beq.n	7d26 <netif_set_gw+0x16>
    7d20:	683b      	ldr	r3, [r7, #0]
    7d22:	681a      	ldr	r2, [r3, #0]
    7d24:	e000      	b.n	7d28 <netif_set_gw+0x18>
    7d26:	2200      	movs	r2, #0
    7d28:	687b      	ldr	r3, [r7, #4]
    7d2a:	60da      	str	r2, [r3, #12]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->gw),
    ip4_addr2_16(&netif->gw),
    ip4_addr3_16(&netif->gw),
    ip4_addr4_16(&netif->gw)));
}
    7d2c:	46c0      	nop			; (mov r8, r8)
    7d2e:	46bd      	mov	sp, r7
    7d30:	b002      	add	sp, #8
    7d32:	bd80      	pop	{r7, pc}

00007d34 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
    7d34:	b580      	push	{r7, lr}
    7d36:	b082      	sub	sp, #8
    7d38:	af00      	add	r7, sp, #0
    7d3a:	6078      	str	r0, [r7, #4]
    7d3c:	6039      	str	r1, [r7, #0]
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
    7d3e:	683b      	ldr	r3, [r7, #0]
    7d40:	2b00      	cmp	r3, #0
    7d42:	d002      	beq.n	7d4a <netif_set_netmask+0x16>
    7d44:	683b      	ldr	r3, [r7, #0]
    7d46:	681a      	ldr	r2, [r3, #0]
    7d48:	e000      	b.n	7d4c <netif_set_netmask+0x18>
    7d4a:	2200      	movs	r2, #0
    7d4c:	687b      	ldr	r3, [r7, #4]
    7d4e:	609a      	str	r2, [r3, #8]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->netmask),
    ip4_addr2_16(&netif->netmask),
    ip4_addr3_16(&netif->netmask),
    ip4_addr4_16(&netif->netmask)));
}
    7d50:	46c0      	nop			; (mov r8, r8)
    7d52:	46bd      	mov	sp, r7
    7d54:	b002      	add	sp, #8
    7d56:	bd80      	pop	{r7, pc}

00007d58 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
    7d58:	b580      	push	{r7, lr}
    7d5a:	b082      	sub	sp, #8
    7d5c:	af00      	add	r7, sp, #0
    7d5e:	6078      	str	r0, [r7, #4]
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
    7d60:	4b03      	ldr	r3, [pc, #12]	; (7d70 <netif_set_default+0x18>)
    7d62:	687a      	ldr	r2, [r7, #4]
    7d64:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
    7d66:	46c0      	nop			; (mov r8, r8)
    7d68:	46bd      	mov	sp, r7
    7d6a:	b002      	add	sp, #8
    7d6c:	bd80      	pop	{r7, pc}
    7d6e:	46c0      	nop			; (mov r8, r8)
    7d70:	20003eb8 	.word	0x20003eb8

00007d74 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
    7d74:	b580      	push	{r7, lr}
    7d76:	b082      	sub	sp, #8
    7d78:	af00      	add	r7, sp, #0
    7d7a:	6078      	str	r0, [r7, #4]
  if (!(netif->flags & NETIF_FLAG_UP)) {
    7d7c:	687b      	ldr	r3, [r7, #4]
    7d7e:	222d      	movs	r2, #45	; 0x2d
    7d80:	5c9b      	ldrb	r3, [r3, r2]
    7d82:	001a      	movs	r2, r3
    7d84:	2301      	movs	r3, #1
    7d86:	4013      	ands	r3, r2
    7d88:	d126      	bne.n	7dd8 <netif_set_up+0x64>
    netif->flags |= NETIF_FLAG_UP;
    7d8a:	687b      	ldr	r3, [r7, #4]
    7d8c:	222d      	movs	r2, #45	; 0x2d
    7d8e:	5c9b      	ldrb	r3, [r3, r2]
    7d90:	2201      	movs	r2, #1
    7d92:	4313      	orrs	r3, r2
    7d94:	b2d9      	uxtb	r1, r3
    7d96:	687b      	ldr	r3, [r7, #4]
    7d98:	222d      	movs	r2, #45	; 0x2d
    7d9a:	5499      	strb	r1, [r3, r2]
    
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_STATUS_CALLBACK(netif);
    7d9c:	687b      	ldr	r3, [r7, #4]
    7d9e:	69db      	ldr	r3, [r3, #28]
    7da0:	2b00      	cmp	r3, #0
    7da2:	d004      	beq.n	7dae <netif_set_up+0x3a>
    7da4:	687b      	ldr	r3, [r7, #4]
    7da6:	69db      	ldr	r3, [r3, #28]
    7da8:	687a      	ldr	r2, [r7, #4]
    7daa:	0010      	movs	r0, r2
    7dac:	4798      	blx	r3

    if (netif->flags & NETIF_FLAG_LINK_UP) {
    7dae:	687b      	ldr	r3, [r7, #4]
    7db0:	222d      	movs	r2, #45	; 0x2d
    7db2:	5c9b      	ldrb	r3, [r3, r2]
    7db4:	001a      	movs	r2, r3
    7db6:	2310      	movs	r3, #16
    7db8:	4013      	ands	r3, r2
    7dba:	d00d      	beq.n	7dd8 <netif_set_up+0x64>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
    7dbc:	687b      	ldr	r3, [r7, #4]
    7dbe:	222d      	movs	r2, #45	; 0x2d
    7dc0:	5c9b      	ldrb	r3, [r3, r2]
    7dc2:	001a      	movs	r2, r3
    7dc4:	2320      	movs	r3, #32
    7dc6:	4013      	ands	r3, r2
    7dc8:	d006      	beq.n	7dd8 <netif_set_up+0x64>
        etharp_gratuitous(netif);
    7dca:	687b      	ldr	r3, [r7, #4]
    7dcc:	1d1a      	adds	r2, r3, #4
    7dce:	687b      	ldr	r3, [r7, #4]
    7dd0:	0011      	movs	r1, r2
    7dd2:	0018      	movs	r0, r3
    7dd4:	4b02      	ldr	r3, [pc, #8]	; (7de0 <netif_set_up+0x6c>)
    7dd6:	4798      	blx	r3
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
  }
}
    7dd8:	46c0      	nop			; (mov r8, r8)
    7dda:	46bd      	mov	sp, r7
    7ddc:	b002      	add	sp, #8
    7dde:	bd80      	pop	{r7, pc}
    7de0:	0000e69d 	.word	0x0000e69d

00007de4 <netif_set_status_callback>:
#if LWIP_NETIF_STATUS_CALLBACK
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
    7de4:	b580      	push	{r7, lr}
    7de6:	b082      	sub	sp, #8
    7de8:	af00      	add	r7, sp, #0
    7dea:	6078      	str	r0, [r7, #4]
    7dec:	6039      	str	r1, [r7, #0]
  if (netif) {
    7dee:	687b      	ldr	r3, [r7, #4]
    7df0:	2b00      	cmp	r3, #0
    7df2:	d002      	beq.n	7dfa <netif_set_status_callback+0x16>
    netif->status_callback = status_callback;
    7df4:	687b      	ldr	r3, [r7, #4]
    7df6:	683a      	ldr	r2, [r7, #0]
    7df8:	61da      	str	r2, [r3, #28]
  }
}
    7dfa:	46c0      	nop			; (mov r8, r8)
    7dfc:	46bd      	mov	sp, r7
    7dfe:	b002      	add	sp, #8
    7e00:	bd80      	pop	{r7, pc}
    7e02:	46c0      	nop			; (mov r8, r8)

00007e04 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
    7e04:	b580      	push	{r7, lr}
    7e06:	af00      	add	r7, sp, #0
#ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 1;
    7e08:	4b02      	ldr	r3, [pc, #8]	; (7e14 <pbuf_pool_is_empty+0x10>)
    7e0a:	2201      	movs	r2, #1
    7e0c:	701a      	strb	r2, [r3, #0]
  if(!queued) {
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
    7e0e:	46c0      	nop			; (mov r8, r8)
    7e10:	46bd      	mov	sp, r7
    7e12:	bd80      	pop	{r7, pc}
    7e14:	20003ebc 	.word	0x20003ebc

00007e18 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
    7e18:	b590      	push	{r4, r7, lr}
    7e1a:	b089      	sub	sp, #36	; 0x24
    7e1c:	af00      	add	r7, sp, #0
    7e1e:	0004      	movs	r4, r0
    7e20:	0008      	movs	r0, r1
    7e22:	0011      	movs	r1, r2
    7e24:	1dfb      	adds	r3, r7, #7
    7e26:	1c22      	adds	r2, r4, #0
    7e28:	701a      	strb	r2, [r3, #0]
    7e2a:	1d3b      	adds	r3, r7, #4
    7e2c:	1c02      	adds	r2, r0, #0
    7e2e:	801a      	strh	r2, [r3, #0]
    7e30:	1dbb      	adds	r3, r7, #6
    7e32:	1c0a      	adds	r2, r1, #0
    7e34:	701a      	strb	r2, [r3, #0]
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
    7e36:	1dfb      	adds	r3, r7, #7
    7e38:	781b      	ldrb	r3, [r3, #0]
    7e3a:	2b01      	cmp	r3, #1
    7e3c:	d00d      	beq.n	7e5a <pbuf_alloc+0x42>
    7e3e:	dc02      	bgt.n	7e46 <pbuf_alloc+0x2e>
    7e40:	2b00      	cmp	r3, #0
    7e42:	d005      	beq.n	7e50 <pbuf_alloc+0x38>
    7e44:	e018      	b.n	7e78 <pbuf_alloc+0x60>
    7e46:	2b02      	cmp	r3, #2
    7e48:	d00c      	beq.n	7e64 <pbuf_alloc+0x4c>
    7e4a:	2b03      	cmp	r3, #3
    7e4c:	d00f      	beq.n	7e6e <pbuf_alloc+0x56>
    7e4e:	e013      	b.n	7e78 <pbuf_alloc+0x60>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    7e50:	2316      	movs	r3, #22
    7e52:	18fb      	adds	r3, r7, r3
    7e54:	2236      	movs	r2, #54	; 0x36
    7e56:	801a      	strh	r2, [r3, #0]
    break;
    7e58:	e010      	b.n	7e7c <pbuf_alloc+0x64>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    7e5a:	2316      	movs	r3, #22
    7e5c:	18fb      	adds	r3, r7, r3
    7e5e:	2222      	movs	r2, #34	; 0x22
    7e60:	801a      	strh	r2, [r3, #0]
    break;
    7e62:	e00b      	b.n	7e7c <pbuf_alloc+0x64>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    7e64:	2316      	movs	r3, #22
    7e66:	18fb      	adds	r3, r7, r3
    7e68:	220e      	movs	r2, #14
    7e6a:	801a      	strh	r2, [r3, #0]
    break;
    7e6c:	e006      	b.n	7e7c <pbuf_alloc+0x64>
  case PBUF_RAW:
    offset = 0;
    7e6e:	2316      	movs	r3, #22
    7e70:	18fb      	adds	r3, r7, r3
    7e72:	2200      	movs	r2, #0
    7e74:	801a      	strh	r2, [r3, #0]
    break;
    7e76:	e001      	b.n	7e7c <pbuf_alloc+0x64>
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
    7e78:	2300      	movs	r3, #0
    7e7a:	e0eb      	b.n	8054 <pbuf_alloc+0x23c>
  }

  switch (type) {
    7e7c:	1dbb      	adds	r3, r7, #6
    7e7e:	781b      	ldrb	r3, [r3, #0]
    7e80:	2b02      	cmp	r3, #2
    7e82:	dc06      	bgt.n	7e92 <pbuf_alloc+0x7a>
    7e84:	2b01      	cmp	r3, #1
    7e86:	db00      	blt.n	7e8a <pbuf_alloc+0x72>
    7e88:	e0be      	b.n	8008 <pbuf_alloc+0x1f0>
    7e8a:	2b00      	cmp	r3, #0
    7e8c:	d100      	bne.n	7e90 <pbuf_alloc+0x78>
    7e8e:	e084      	b.n	7f9a <pbuf_alloc+0x182>
    7e90:	e0d7      	b.n	8042 <pbuf_alloc+0x22a>
    7e92:	2b03      	cmp	r3, #3
    7e94:	d000      	beq.n	7e98 <pbuf_alloc+0x80>
    7e96:	e0d4      	b.n	8042 <pbuf_alloc+0x22a>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    7e98:	2008      	movs	r0, #8
    7e9a:	4b70      	ldr	r3, [pc, #448]	; (805c <pbuf_alloc+0x244>)
    7e9c:	4798      	blx	r3
    7e9e:	0003      	movs	r3, r0
    7ea0:	61fb      	str	r3, [r7, #28]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
    7ea2:	69fb      	ldr	r3, [r7, #28]
    7ea4:	2b00      	cmp	r3, #0
    7ea6:	d103      	bne.n	7eb0 <pbuf_alloc+0x98>
      PBUF_POOL_IS_EMPTY();
    7ea8:	4b6d      	ldr	r3, [pc, #436]	; (8060 <pbuf_alloc+0x248>)
    7eaa:	4798      	blx	r3
      return NULL;
    7eac:	2300      	movs	r3, #0
    7eae:	e0d1      	b.n	8054 <pbuf_alloc+0x23c>
    }
    p->type = type;
    7eb0:	69fb      	ldr	r3, [r7, #28]
    7eb2:	1dba      	adds	r2, r7, #6
    7eb4:	7812      	ldrb	r2, [r2, #0]
    7eb6:	731a      	strb	r2, [r3, #12]
    p->next = NULL;
    7eb8:	69fb      	ldr	r3, [r7, #28]
    7eba:	2200      	movs	r2, #0
    7ebc:	601a      	str	r2, [r3, #0]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    7ebe:	2316      	movs	r3, #22
    7ec0:	18fb      	adds	r3, r7, r3
    7ec2:	881b      	ldrh	r3, [r3, #0]
    7ec4:	3310      	adds	r3, #16
    7ec6:	69fa      	ldr	r2, [r7, #28]
    7ec8:	18d3      	adds	r3, r2, r3
    7eca:	3303      	adds	r3, #3
    7ecc:	2203      	movs	r2, #3
    7ece:	4393      	bics	r3, r2
    7ed0:	001a      	movs	r2, r3
    7ed2:	69fb      	ldr	r3, [r7, #28]
    7ed4:	605a      	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    7ed6:	69fb      	ldr	r3, [r7, #28]
    7ed8:	1d3a      	adds	r2, r7, #4
    7eda:	8812      	ldrh	r2, [r2, #0]
    7edc:	811a      	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    7ede:	2316      	movs	r3, #22
    7ee0:	18fb      	adds	r3, r7, r3
    7ee2:	881b      	ldrh	r3, [r3, #0]
    7ee4:	3303      	adds	r3, #3
    7ee6:	2203      	movs	r2, #3
    7ee8:	4393      	bics	r3, r2
    7eea:	22be      	movs	r2, #190	; 0xbe
    7eec:	00d2      	lsls	r2, r2, #3
    7eee:	1ad2      	subs	r2, r2, r3
    7ef0:	1d3b      	adds	r3, r7, #4
    7ef2:	881b      	ldrh	r3, [r3, #0]
    7ef4:	429a      	cmp	r2, r3
    7ef6:	dd00      	ble.n	7efa <pbuf_alloc+0xe2>
    7ef8:	001a      	movs	r2, r3
    7efa:	b292      	uxth	r2, r2
    7efc:	69fb      	ldr	r3, [r7, #28]
    7efe:	815a      	strh	r2, [r3, #10]
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
    7f00:	69fb      	ldr	r3, [r7, #28]
    7f02:	2201      	movs	r2, #1
    7f04:	81da      	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    7f06:	69fb      	ldr	r3, [r7, #28]
    7f08:	61bb      	str	r3, [r7, #24]
    /* remaining length to be allocated */
    rem_len = length - p->len;
    7f0a:	1d3b      	adds	r3, r7, #4
    7f0c:	881b      	ldrh	r3, [r3, #0]
    7f0e:	69fa      	ldr	r2, [r7, #28]
    7f10:	8952      	ldrh	r2, [r2, #10]
    7f12:	1a9b      	subs	r3, r3, r2
    7f14:	613b      	str	r3, [r7, #16]
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    7f16:	e03c      	b.n	7f92 <pbuf_alloc+0x17a>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
    7f18:	2008      	movs	r0, #8
    7f1a:	4b50      	ldr	r3, [pc, #320]	; (805c <pbuf_alloc+0x244>)
    7f1c:	4798      	blx	r3
    7f1e:	0003      	movs	r3, r0
    7f20:	60fb      	str	r3, [r7, #12]
      if (q == NULL) {
    7f22:	68fb      	ldr	r3, [r7, #12]
    7f24:	2b00      	cmp	r3, #0
    7f26:	d107      	bne.n	7f38 <pbuf_alloc+0x120>
        PBUF_POOL_IS_EMPTY();
    7f28:	4b4d      	ldr	r3, [pc, #308]	; (8060 <pbuf_alloc+0x248>)
    7f2a:	4798      	blx	r3
        /* free chain so far allocated */
        pbuf_free(p);
    7f2c:	69fb      	ldr	r3, [r7, #28]
    7f2e:	0018      	movs	r0, r3
    7f30:	4b4c      	ldr	r3, [pc, #304]	; (8064 <pbuf_alloc+0x24c>)
    7f32:	4798      	blx	r3
        /* bail out unsuccesfully */
        return NULL;
    7f34:	2300      	movs	r3, #0
    7f36:	e08d      	b.n	8054 <pbuf_alloc+0x23c>
      }
      q->type = type;
    7f38:	68fb      	ldr	r3, [r7, #12]
    7f3a:	1dba      	adds	r2, r7, #6
    7f3c:	7812      	ldrb	r2, [r2, #0]
    7f3e:	731a      	strb	r2, [r3, #12]
      q->flags = 0;
    7f40:	68fb      	ldr	r3, [r7, #12]
    7f42:	2200      	movs	r2, #0
    7f44:	735a      	strb	r2, [r3, #13]
      q->next = NULL;
    7f46:	68fb      	ldr	r3, [r7, #12]
    7f48:	2200      	movs	r2, #0
    7f4a:	601a      	str	r2, [r3, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
    7f4c:	69bb      	ldr	r3, [r7, #24]
    7f4e:	68fa      	ldr	r2, [r7, #12]
    7f50:	601a      	str	r2, [r3, #0]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
    7f52:	693b      	ldr	r3, [r7, #16]
    7f54:	b29a      	uxth	r2, r3
    7f56:	68fb      	ldr	r3, [r7, #12]
    7f58:	811a      	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
    7f5a:	693b      	ldr	r3, [r7, #16]
    7f5c:	041b      	lsls	r3, r3, #16
    7f5e:	0c1b      	lsrs	r3, r3, #16
    7f60:	22be      	movs	r2, #190	; 0xbe
    7f62:	00d2      	lsls	r2, r2, #3
    7f64:	4293      	cmp	r3, r2
    7f66:	dd01      	ble.n	7f6c <pbuf_alloc+0x154>
    7f68:	23be      	movs	r3, #190	; 0xbe
    7f6a:	00db      	lsls	r3, r3, #3
    7f6c:	b29a      	uxth	r2, r3
    7f6e:	68fb      	ldr	r3, [r7, #12]
    7f70:	815a      	strh	r2, [r3, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
    7f72:	68fb      	ldr	r3, [r7, #12]
    7f74:	3310      	adds	r3, #16
    7f76:	001a      	movs	r2, r3
    7f78:	68fb      	ldr	r3, [r7, #12]
    7f7a:	605a      	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
    7f7c:	68fb      	ldr	r3, [r7, #12]
    7f7e:	2201      	movs	r2, #1
    7f80:	81da      	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
    7f82:	68fb      	ldr	r3, [r7, #12]
    7f84:	895b      	ldrh	r3, [r3, #10]
    7f86:	001a      	movs	r2, r3
    7f88:	693b      	ldr	r3, [r7, #16]
    7f8a:	1a9b      	subs	r3, r3, r2
    7f8c:	613b      	str	r3, [r7, #16]
      /* remember this pbuf for linkage in next iteration */
      r = q;
    7f8e:	68fb      	ldr	r3, [r7, #12]
    7f90:	61bb      	str	r3, [r7, #24]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
    7f92:	693b      	ldr	r3, [r7, #16]
    7f94:	2b00      	cmp	r3, #0
    7f96:	dcbf      	bgt.n	7f18 <pbuf_alloc+0x100>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
    7f98:	e055      	b.n	8046 <pbuf_alloc+0x22e>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    7f9a:	2316      	movs	r3, #22
    7f9c:	18fb      	adds	r3, r7, r3
    7f9e:	881b      	ldrh	r3, [r3, #0]
    7fa0:	3313      	adds	r3, #19
    7fa2:	b29b      	uxth	r3, r3
    7fa4:	2203      	movs	r2, #3
    7fa6:	4393      	bics	r3, r2
    7fa8:	b29a      	uxth	r2, r3
    7faa:	1d3b      	adds	r3, r7, #4
    7fac:	881b      	ldrh	r3, [r3, #0]
    7fae:	3303      	adds	r3, #3
    7fb0:	b29b      	uxth	r3, r3
    7fb2:	2103      	movs	r1, #3
    7fb4:	438b      	bics	r3, r1
    7fb6:	b29b      	uxth	r3, r3
    7fb8:	18d3      	adds	r3, r2, r3
    7fba:	b29b      	uxth	r3, r3
    7fbc:	0018      	movs	r0, r3
    7fbe:	4b2a      	ldr	r3, [pc, #168]	; (8068 <pbuf_alloc+0x250>)
    7fc0:	4798      	blx	r3
    7fc2:	0003      	movs	r3, r0
    7fc4:	61fb      	str	r3, [r7, #28]
    if (p == NULL) {
    7fc6:	69fb      	ldr	r3, [r7, #28]
    7fc8:	2b00      	cmp	r3, #0
    7fca:	d101      	bne.n	7fd0 <pbuf_alloc+0x1b8>
      return NULL;
    7fcc:	2300      	movs	r3, #0
    7fce:	e041      	b.n	8054 <pbuf_alloc+0x23c>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
    7fd0:	2316      	movs	r3, #22
    7fd2:	18fb      	adds	r3, r7, r3
    7fd4:	881b      	ldrh	r3, [r3, #0]
    7fd6:	3310      	adds	r3, #16
    7fd8:	69fa      	ldr	r2, [r7, #28]
    7fda:	18d3      	adds	r3, r2, r3
    7fdc:	3303      	adds	r3, #3
    7fde:	2203      	movs	r2, #3
    7fe0:	4393      	bics	r3, r2
    7fe2:	001a      	movs	r2, r3
    7fe4:	69fb      	ldr	r3, [r7, #28]
    7fe6:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
    7fe8:	69fb      	ldr	r3, [r7, #28]
    7fea:	1d3a      	adds	r2, r7, #4
    7fec:	8812      	ldrh	r2, [r2, #0]
    7fee:	811a      	strh	r2, [r3, #8]
    7ff0:	69fb      	ldr	r3, [r7, #28]
    7ff2:	891a      	ldrh	r2, [r3, #8]
    7ff4:	69fb      	ldr	r3, [r7, #28]
    7ff6:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
    7ff8:	69fb      	ldr	r3, [r7, #28]
    7ffa:	2200      	movs	r2, #0
    7ffc:	601a      	str	r2, [r3, #0]
    p->type = type;
    7ffe:	69fb      	ldr	r3, [r7, #28]
    8000:	1dba      	adds	r2, r7, #6
    8002:	7812      	ldrb	r2, [r2, #0]
    8004:	731a      	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
    8006:	e01e      	b.n	8046 <pbuf_alloc+0x22e>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
    8008:	2007      	movs	r0, #7
    800a:	4b14      	ldr	r3, [pc, #80]	; (805c <pbuf_alloc+0x244>)
    800c:	4798      	blx	r3
    800e:	0003      	movs	r3, r0
    8010:	61fb      	str	r3, [r7, #28]
    if (p == NULL) {
    8012:	69fb      	ldr	r3, [r7, #28]
    8014:	2b00      	cmp	r3, #0
    8016:	d101      	bne.n	801c <pbuf_alloc+0x204>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    8018:	2300      	movs	r3, #0
    801a:	e01b      	b.n	8054 <pbuf_alloc+0x23c>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    801c:	69fb      	ldr	r3, [r7, #28]
    801e:	2200      	movs	r2, #0
    8020:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
    8022:	69fb      	ldr	r3, [r7, #28]
    8024:	1d3a      	adds	r2, r7, #4
    8026:	8812      	ldrh	r2, [r2, #0]
    8028:	811a      	strh	r2, [r3, #8]
    802a:	69fb      	ldr	r3, [r7, #28]
    802c:	891a      	ldrh	r2, [r3, #8]
    802e:	69fb      	ldr	r3, [r7, #28]
    8030:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
    8032:	69fb      	ldr	r3, [r7, #28]
    8034:	2200      	movs	r2, #0
    8036:	601a      	str	r2, [r3, #0]
    p->type = type;
    8038:	69fb      	ldr	r3, [r7, #28]
    803a:	1dba      	adds	r2, r7, #6
    803c:	7812      	ldrb	r2, [r2, #0]
    803e:	731a      	strb	r2, [r3, #12]
    break;
    8040:	e001      	b.n	8046 <pbuf_alloc+0x22e>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
    8042:	2300      	movs	r3, #0
    8044:	e006      	b.n	8054 <pbuf_alloc+0x23c>
  }
  /* set reference count */
  p->ref = 1;
    8046:	69fb      	ldr	r3, [r7, #28]
    8048:	2201      	movs	r2, #1
    804a:	81da      	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
    804c:	69fb      	ldr	r3, [r7, #28]
    804e:	2200      	movs	r2, #0
    8050:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
    8052:	69fb      	ldr	r3, [r7, #28]
}
    8054:	0018      	movs	r0, r3
    8056:	46bd      	mov	sp, r7
    8058:	b009      	add	sp, #36	; 0x24
    805a:	bd90      	pop	{r4, r7, pc}
    805c:	00007af1 	.word	0x00007af1
    8060:	00007e05 	.word	0x00007e05
    8064:	00008349 	.word	0x00008349
    8068:	000078a1 	.word	0x000078a1

0000806c <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
    806c:	b590      	push	{r4, r7, lr}
    806e:	b085      	sub	sp, #20
    8070:	af00      	add	r7, sp, #0
    8072:	0004      	movs	r4, r0
    8074:	0008      	movs	r0, r1
    8076:	0011      	movs	r1, r2
    8078:	603b      	str	r3, [r7, #0]
    807a:	1dfb      	adds	r3, r7, #7
    807c:	1c22      	adds	r2, r4, #0
    807e:	701a      	strb	r2, [r3, #0]
    8080:	1d3b      	adds	r3, r7, #4
    8082:	1c02      	adds	r2, r0, #0
    8084:	801a      	strh	r2, [r3, #0]
    8086:	1dbb      	adds	r3, r7, #6
    8088:	1c0a      	adds	r2, r1, #0
    808a:	701a      	strb	r2, [r3, #0]
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
    808c:	1dfb      	adds	r3, r7, #7
    808e:	781b      	ldrb	r3, [r3, #0]
    8090:	2b01      	cmp	r3, #1
    8092:	d00d      	beq.n	80b0 <pbuf_alloced_custom+0x44>
    8094:	dc02      	bgt.n	809c <pbuf_alloced_custom+0x30>
    8096:	2b00      	cmp	r3, #0
    8098:	d005      	beq.n	80a6 <pbuf_alloced_custom+0x3a>
    809a:	e018      	b.n	80ce <pbuf_alloced_custom+0x62>
    809c:	2b02      	cmp	r3, #2
    809e:	d00c      	beq.n	80ba <pbuf_alloced_custom+0x4e>
    80a0:	2b03      	cmp	r3, #3
    80a2:	d00f      	beq.n	80c4 <pbuf_alloced_custom+0x58>
    80a4:	e013      	b.n	80ce <pbuf_alloced_custom+0x62>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    80a6:	230e      	movs	r3, #14
    80a8:	18fb      	adds	r3, r7, r3
    80aa:	2236      	movs	r2, #54	; 0x36
    80ac:	801a      	strh	r2, [r3, #0]
    break;
    80ae:	e010      	b.n	80d2 <pbuf_alloced_custom+0x66>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    80b0:	230e      	movs	r3, #14
    80b2:	18fb      	adds	r3, r7, r3
    80b4:	2222      	movs	r2, #34	; 0x22
    80b6:	801a      	strh	r2, [r3, #0]
    break;
    80b8:	e00b      	b.n	80d2 <pbuf_alloced_custom+0x66>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    80ba:	230e      	movs	r3, #14
    80bc:	18fb      	adds	r3, r7, r3
    80be:	220e      	movs	r2, #14
    80c0:	801a      	strh	r2, [r3, #0]
    break;
    80c2:	e006      	b.n	80d2 <pbuf_alloced_custom+0x66>
  case PBUF_RAW:
    offset = 0;
    80c4:	230e      	movs	r3, #14
    80c6:	18fb      	adds	r3, r7, r3
    80c8:	2200      	movs	r2, #0
    80ca:	801a      	strh	r2, [r3, #0]
    break;
    80cc:	e001      	b.n	80d2 <pbuf_alloced_custom+0x66>
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
    80ce:	2300      	movs	r3, #0
    80d0:	e039      	b.n	8146 <pbuf_alloced_custom+0xda>
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
    80d2:	230e      	movs	r3, #14
    80d4:	18fb      	adds	r3, r7, r3
    80d6:	881b      	ldrh	r3, [r3, #0]
    80d8:	3303      	adds	r3, #3
    80da:	2203      	movs	r2, #3
    80dc:	4393      	bics	r3, r2
    80de:	001a      	movs	r2, r3
    80e0:	1d3b      	adds	r3, r7, #4
    80e2:	881b      	ldrh	r3, [r3, #0]
    80e4:	18d2      	adds	r2, r2, r3
    80e6:	2324      	movs	r3, #36	; 0x24
    80e8:	18fb      	adds	r3, r7, r3
    80ea:	881b      	ldrh	r3, [r3, #0]
    80ec:	429a      	cmp	r2, r3
    80ee:	dd01      	ble.n	80f4 <pbuf_alloced_custom+0x88>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
    80f0:	2300      	movs	r3, #0
    80f2:	e028      	b.n	8146 <pbuf_alloced_custom+0xda>
  }

  p->pbuf.next = NULL;
    80f4:	683b      	ldr	r3, [r7, #0]
    80f6:	2200      	movs	r2, #0
    80f8:	601a      	str	r2, [r3, #0]
  if (payload_mem != NULL) {
    80fa:	6a3b      	ldr	r3, [r7, #32]
    80fc:	2b00      	cmp	r3, #0
    80fe:	d00c      	beq.n	811a <pbuf_alloced_custom+0xae>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
    8100:	230e      	movs	r3, #14
    8102:	18fb      	adds	r3, r7, r3
    8104:	881b      	ldrh	r3, [r3, #0]
    8106:	3303      	adds	r3, #3
    8108:	001a      	movs	r2, r3
    810a:	2303      	movs	r3, #3
    810c:	439a      	bics	r2, r3
    810e:	0013      	movs	r3, r2
    8110:	6a3a      	ldr	r2, [r7, #32]
    8112:	18d2      	adds	r2, r2, r3
    8114:	683b      	ldr	r3, [r7, #0]
    8116:	605a      	str	r2, [r3, #4]
    8118:	e002      	b.n	8120 <pbuf_alloced_custom+0xb4>
  } else {
    p->pbuf.payload = NULL;
    811a:	683b      	ldr	r3, [r7, #0]
    811c:	2200      	movs	r2, #0
    811e:	605a      	str	r2, [r3, #4]
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
    8120:	683b      	ldr	r3, [r7, #0]
    8122:	2202      	movs	r2, #2
    8124:	735a      	strb	r2, [r3, #13]
  p->pbuf.len = p->pbuf.tot_len = length;
    8126:	683b      	ldr	r3, [r7, #0]
    8128:	1d3a      	adds	r2, r7, #4
    812a:	8812      	ldrh	r2, [r2, #0]
    812c:	811a      	strh	r2, [r3, #8]
    812e:	683b      	ldr	r3, [r7, #0]
    8130:	891a      	ldrh	r2, [r3, #8]
    8132:	683b      	ldr	r3, [r7, #0]
    8134:	815a      	strh	r2, [r3, #10]
  p->pbuf.type = type;
    8136:	683b      	ldr	r3, [r7, #0]
    8138:	1dba      	adds	r2, r7, #6
    813a:	7812      	ldrb	r2, [r2, #0]
    813c:	731a      	strb	r2, [r3, #12]
  p->pbuf.ref = 1;
    813e:	683b      	ldr	r3, [r7, #0]
    8140:	2201      	movs	r2, #1
    8142:	81da      	strh	r2, [r3, #14]
  return &p->pbuf;
    8144:	683b      	ldr	r3, [r7, #0]
}
    8146:	0018      	movs	r0, r3
    8148:	46bd      	mov	sp, r7
    814a:	b005      	add	sp, #20
    814c:	bd90      	pop	{r4, r7, pc}
    814e:	46c0      	nop			; (mov r8, r8)

00008150 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
    8150:	b580      	push	{r7, lr}
    8152:	b086      	sub	sp, #24
    8154:	af00      	add	r7, sp, #0
    8156:	6078      	str	r0, [r7, #4]
    8158:	000a      	movs	r2, r1
    815a:	1cbb      	adds	r3, r7, #2
    815c:	801a      	strh	r2, [r3, #0]
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    815e:	687b      	ldr	r3, [r7, #4]
    8160:	891b      	ldrh	r3, [r3, #8]
    8162:	1cba      	adds	r2, r7, #2
    8164:	8812      	ldrh	r2, [r2, #0]
    8166:	429a      	cmp	r2, r3
    8168:	d25b      	bcs.n	8222 <pbuf_realloc+0xd2>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
    816a:	1cbb      	adds	r3, r7, #2
    816c:	881b      	ldrh	r3, [r3, #0]
    816e:	687a      	ldr	r2, [r7, #4]
    8170:	8912      	ldrh	r2, [r2, #8]
    8172:	1a9b      	subs	r3, r3, r2
    8174:	60fb      	str	r3, [r7, #12]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
    8176:	2312      	movs	r3, #18
    8178:	18fb      	adds	r3, r7, r3
    817a:	1cba      	adds	r2, r7, #2
    817c:	8812      	ldrh	r2, [r2, #0]
    817e:	801a      	strh	r2, [r3, #0]
  q = p;
    8180:	687b      	ldr	r3, [r7, #4]
    8182:	617b      	str	r3, [r7, #20]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    8184:	e013      	b.n	81ae <pbuf_realloc+0x5e>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    8186:	697b      	ldr	r3, [r7, #20]
    8188:	895a      	ldrh	r2, [r3, #10]
    818a:	2312      	movs	r3, #18
    818c:	18fb      	adds	r3, r7, r3
    818e:	2112      	movs	r1, #18
    8190:	1879      	adds	r1, r7, r1
    8192:	8809      	ldrh	r1, [r1, #0]
    8194:	1a8a      	subs	r2, r1, r2
    8196:	801a      	strh	r2, [r3, #0]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
    8198:	697b      	ldr	r3, [r7, #20]
    819a:	891a      	ldrh	r2, [r3, #8]
    819c:	68fb      	ldr	r3, [r7, #12]
    819e:	b29b      	uxth	r3, r3
    81a0:	18d3      	adds	r3, r2, r3
    81a2:	b29a      	uxth	r2, r3
    81a4:	697b      	ldr	r3, [r7, #20]
    81a6:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
    81a8:	697b      	ldr	r3, [r7, #20]
    81aa:	681b      	ldr	r3, [r3, #0]
    81ac:	617b      	str	r3, [r7, #20]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    81ae:	697b      	ldr	r3, [r7, #20]
    81b0:	895b      	ldrh	r3, [r3, #10]
    81b2:	2212      	movs	r2, #18
    81b4:	18ba      	adds	r2, r7, r2
    81b6:	8812      	ldrh	r2, [r2, #0]
    81b8:	429a      	cmp	r2, r3
    81ba:	d8e4      	bhi.n	8186 <pbuf_realloc+0x36>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    81bc:	697b      	ldr	r3, [r7, #20]
    81be:	7b1b      	ldrb	r3, [r3, #12]
    81c0:	2b00      	cmp	r3, #0
    81c2:	d118      	bne.n	81f6 <pbuf_realloc+0xa6>
    81c4:	697b      	ldr	r3, [r7, #20]
    81c6:	895b      	ldrh	r3, [r3, #10]
    81c8:	2212      	movs	r2, #18
    81ca:	18ba      	adds	r2, r7, r2
    81cc:	8812      	ldrh	r2, [r2, #0]
    81ce:	429a      	cmp	r2, r3
    81d0:	d011      	beq.n	81f6 <pbuf_realloc+0xa6>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    81d2:	697b      	ldr	r3, [r7, #20]
    81d4:	685b      	ldr	r3, [r3, #4]
    81d6:	001a      	movs	r2, r3
    81d8:	697b      	ldr	r3, [r7, #20]
    81da:	1ad3      	subs	r3, r2, r3
    81dc:	b29a      	uxth	r2, r3
    81de:	2312      	movs	r3, #18
    81e0:	18fb      	adds	r3, r7, r3
    81e2:	881b      	ldrh	r3, [r3, #0]
    81e4:	18d3      	adds	r3, r2, r3
    81e6:	b29a      	uxth	r2, r3
    81e8:	697b      	ldr	r3, [r7, #20]
    81ea:	0011      	movs	r1, r2
    81ec:	0018      	movs	r0, r3
    81ee:	4b0f      	ldr	r3, [pc, #60]	; (822c <pbuf_realloc+0xdc>)
    81f0:	4798      	blx	r3
    81f2:	0003      	movs	r3, r0
    81f4:	617b      	str	r3, [r7, #20]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
    81f6:	697b      	ldr	r3, [r7, #20]
    81f8:	2212      	movs	r2, #18
    81fa:	18ba      	adds	r2, r7, r2
    81fc:	8812      	ldrh	r2, [r2, #0]
    81fe:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
    8200:	697b      	ldr	r3, [r7, #20]
    8202:	895a      	ldrh	r2, [r3, #10]
    8204:	697b      	ldr	r3, [r7, #20]
    8206:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
    8208:	697b      	ldr	r3, [r7, #20]
    820a:	681b      	ldr	r3, [r3, #0]
    820c:	2b00      	cmp	r3, #0
    820e:	d004      	beq.n	821a <pbuf_realloc+0xca>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
    8210:	697b      	ldr	r3, [r7, #20]
    8212:	681b      	ldr	r3, [r3, #0]
    8214:	0018      	movs	r0, r3
    8216:	4b06      	ldr	r3, [pc, #24]	; (8230 <pbuf_realloc+0xe0>)
    8218:	4798      	blx	r3
  }
  /* q is last packet in chain */
  q->next = NULL;
    821a:	697b      	ldr	r3, [r7, #20]
    821c:	2200      	movs	r2, #0
    821e:	601a      	str	r2, [r3, #0]
    8220:	e000      	b.n	8224 <pbuf_realloc+0xd4>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
    8222:	46c0      	nop			; (mov r8, r8)
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
    8224:	46bd      	mov	sp, r7
    8226:	b006      	add	sp, #24
    8228:	bd80      	pop	{r7, pc}
    822a:	46c0      	nop			; (mov r8, r8)
    822c:	000076c1 	.word	0x000076c1
    8230:	00008349 	.word	0x00008349

00008234 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
    8234:	b580      	push	{r7, lr}
    8236:	b084      	sub	sp, #16
    8238:	af00      	add	r7, sp, #0
    823a:	6078      	str	r0, [r7, #4]
    823c:	000a      	movs	r2, r1
    823e:	1cbb      	adds	r3, r7, #2
    8240:	801a      	strh	r2, [r3, #0]
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
    8242:	1cbb      	adds	r3, r7, #2
    8244:	2200      	movs	r2, #0
    8246:	5e9b      	ldrsh	r3, [r3, r2]
    8248:	2b00      	cmp	r3, #0
    824a:	d002      	beq.n	8252 <pbuf_header+0x1e>
    824c:	687b      	ldr	r3, [r7, #4]
    824e:	2b00      	cmp	r3, #0
    8250:	d101      	bne.n	8256 <pbuf_header+0x22>
    return 0;
    8252:	2300      	movs	r3, #0
    8254:	e073      	b.n	833e <pbuf_header+0x10a>
  }
 
  if (header_size_increment < 0){
    8256:	1cbb      	adds	r3, r7, #2
    8258:	2200      	movs	r2, #0
    825a:	5e9b      	ldrsh	r3, [r3, r2]
    825c:	2b00      	cmp	r3, #0
    825e:	da0e      	bge.n	827e <pbuf_header+0x4a>
    increment_magnitude = -header_size_increment;
    8260:	1cbb      	adds	r3, r7, #2
    8262:	881a      	ldrh	r2, [r3, #0]
    8264:	230e      	movs	r3, #14
    8266:	18fb      	adds	r3, r7, r3
    8268:	4252      	negs	r2, r2
    826a:	801a      	strh	r2, [r3, #0]
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
    826c:	687b      	ldr	r3, [r7, #4]
    826e:	895b      	ldrh	r3, [r3, #10]
    8270:	220e      	movs	r2, #14
    8272:	18ba      	adds	r2, r7, r2
    8274:	8812      	ldrh	r2, [r2, #0]
    8276:	429a      	cmp	r2, r3
    8278:	d906      	bls.n	8288 <pbuf_header+0x54>
    827a:	2301      	movs	r3, #1
    827c:	e05f      	b.n	833e <pbuf_header+0x10a>
  } else {
    increment_magnitude = header_size_increment;
    827e:	230e      	movs	r3, #14
    8280:	18fb      	adds	r3, r7, r3
    8282:	1cba      	adds	r2, r7, #2
    8284:	8812      	ldrh	r2, [r2, #0]
    8286:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
    8288:	687b      	ldr	r3, [r7, #4]
    828a:	7b1a      	ldrb	r2, [r3, #12]
    828c:	230c      	movs	r3, #12
    828e:	18fb      	adds	r3, r7, r3
    8290:	801a      	strh	r2, [r3, #0]
  /* remember current payload pointer */
  payload = p->payload;
    8292:	687b      	ldr	r3, [r7, #4]
    8294:	685b      	ldr	r3, [r3, #4]
    8296:	60bb      	str	r3, [r7, #8]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    8298:	230c      	movs	r3, #12
    829a:	18fb      	adds	r3, r7, r3
    829c:	881b      	ldrh	r3, [r3, #0]
    829e:	2b00      	cmp	r3, #0
    82a0:	d004      	beq.n	82ac <pbuf_header+0x78>
    82a2:	230c      	movs	r3, #12
    82a4:	18fb      	adds	r3, r7, r3
    82a6:	881b      	ldrh	r3, [r3, #0]
    82a8:	2b03      	cmp	r3, #3
    82aa:	d113      	bne.n	82d4 <pbuf_header+0xa0>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    82ac:	687b      	ldr	r3, [r7, #4]
    82ae:	685a      	ldr	r2, [r3, #4]
    82b0:	1cbb      	adds	r3, r7, #2
    82b2:	2100      	movs	r1, #0
    82b4:	5e5b      	ldrsh	r3, [r3, r1]
    82b6:	425b      	negs	r3, r3
    82b8:	18d2      	adds	r2, r2, r3
    82ba:	687b      	ldr	r3, [r7, #4]
    82bc:	605a      	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
    82be:	687b      	ldr	r3, [r7, #4]
    82c0:	685a      	ldr	r2, [r3, #4]
    82c2:	687b      	ldr	r3, [r7, #4]
    82c4:	3310      	adds	r3, #16
    82c6:	429a      	cmp	r2, r3
    82c8:	d228      	bcs.n	831c <pbuf_header+0xe8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
    82ca:	687b      	ldr	r3, [r7, #4]
    82cc:	68ba      	ldr	r2, [r7, #8]
    82ce:	605a      	str	r2, [r3, #4]
      /* bail out unsuccesfully */
      return 1;
    82d0:	2301      	movs	r3, #1
    82d2:	e034      	b.n	833e <pbuf_header+0x10a>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    82d4:	230c      	movs	r3, #12
    82d6:	18fb      	adds	r3, r7, r3
    82d8:	881b      	ldrh	r3, [r3, #0]
    82da:	2b02      	cmp	r3, #2
    82dc:	d004      	beq.n	82e8 <pbuf_header+0xb4>
    82de:	230c      	movs	r3, #12
    82e0:	18fb      	adds	r3, r7, r3
    82e2:	881b      	ldrh	r3, [r3, #0]
    82e4:	2b01      	cmp	r3, #1
    82e6:	d117      	bne.n	8318 <pbuf_header+0xe4>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    82e8:	1cbb      	adds	r3, r7, #2
    82ea:	2200      	movs	r2, #0
    82ec:	5e9b      	ldrsh	r3, [r3, r2]
    82ee:	2b00      	cmp	r3, #0
    82f0:	da10      	bge.n	8314 <pbuf_header+0xe0>
    82f2:	687b      	ldr	r3, [r7, #4]
    82f4:	895b      	ldrh	r3, [r3, #10]
    82f6:	220e      	movs	r2, #14
    82f8:	18ba      	adds	r2, r7, r2
    82fa:	8812      	ldrh	r2, [r2, #0]
    82fc:	429a      	cmp	r2, r3
    82fe:	d809      	bhi.n	8314 <pbuf_header+0xe0>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    8300:	687b      	ldr	r3, [r7, #4]
    8302:	685a      	ldr	r2, [r3, #4]
    8304:	1cbb      	adds	r3, r7, #2
    8306:	2100      	movs	r1, #0
    8308:	5e5b      	ldrsh	r3, [r3, r1]
    830a:	425b      	negs	r3, r3
    830c:	18d2      	adds	r2, r2, r3
    830e:	687b      	ldr	r3, [r7, #4]
    8310:	605a      	str	r2, [r3, #4]
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
    8312:	e003      	b.n	831c <pbuf_header+0xe8>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
    8314:	2301      	movs	r3, #1
    8316:	e012      	b.n	833e <pbuf_header+0x10a>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
    8318:	2301      	movs	r3, #1
    831a:	e010      	b.n	833e <pbuf_header+0x10a>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
    831c:	687b      	ldr	r3, [r7, #4]
    831e:	895a      	ldrh	r2, [r3, #10]
    8320:	1cbb      	adds	r3, r7, #2
    8322:	881b      	ldrh	r3, [r3, #0]
    8324:	18d3      	adds	r3, r2, r3
    8326:	b29a      	uxth	r2, r3
    8328:	687b      	ldr	r3, [r7, #4]
    832a:	815a      	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
    832c:	687b      	ldr	r3, [r7, #4]
    832e:	891a      	ldrh	r2, [r3, #8]
    8330:	1cbb      	adds	r3, r7, #2
    8332:	881b      	ldrh	r3, [r3, #0]
    8334:	18d3      	adds	r3, r2, r3
    8336:	b29a      	uxth	r2, r3
    8338:	687b      	ldr	r3, [r7, #4]
    833a:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
    833c:	2300      	movs	r3, #0
}
    833e:	0018      	movs	r0, r3
    8340:	46bd      	mov	sp, r7
    8342:	b004      	add	sp, #16
    8344:	bd80      	pop	{r7, pc}
    8346:	46c0      	nop			; (mov r8, r8)

00008348 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
    8348:	b580      	push	{r7, lr}
    834a:	b086      	sub	sp, #24
    834c:	af00      	add	r7, sp, #0
    834e:	6078      	str	r0, [r7, #4]
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    8350:	687b      	ldr	r3, [r7, #4]
    8352:	2b00      	cmp	r3, #0
    8354:	d101      	bne.n	835a <pbuf_free+0x12>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
    8356:	2300      	movs	r3, #0
    8358:	e061      	b.n	841e <pbuf_free+0xd6>

  LWIP_ASSERT("pbuf_free: sane type",
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
    835a:	2317      	movs	r3, #23
    835c:	18fb      	adds	r3, r7, r3
    835e:	2200      	movs	r2, #0
    8360:	701a      	strb	r2, [r3, #0]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    8362:	e056      	b.n	8412 <pbuf_free+0xca>
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    8364:	687b      	ldr	r3, [r7, #4]
    8366:	89db      	ldrh	r3, [r3, #14]
    8368:	3b01      	subs	r3, #1
    836a:	b29a      	uxth	r2, r3
    836c:	687b      	ldr	r3, [r7, #4]
    836e:	81da      	strh	r2, [r3, #14]
    8370:	2314      	movs	r3, #20
    8372:	18fb      	adds	r3, r7, r3
    8374:	687a      	ldr	r2, [r7, #4]
    8376:	89d2      	ldrh	r2, [r2, #14]
    8378:	801a      	strh	r2, [r3, #0]
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
    837a:	2314      	movs	r3, #20
    837c:	18fb      	adds	r3, r7, r3
    837e:	881b      	ldrh	r3, [r3, #0]
    8380:	2b00      	cmp	r3, #0
    8382:	d13e      	bne.n	8402 <pbuf_free+0xba>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
    8384:	687b      	ldr	r3, [r7, #4]
    8386:	681b      	ldr	r3, [r3, #0]
    8388:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
    838a:	687b      	ldr	r3, [r7, #4]
    838c:	7b1a      	ldrb	r2, [r3, #12]
    838e:	230e      	movs	r3, #14
    8390:	18fb      	adds	r3, r7, r3
    8392:	801a      	strh	r2, [r3, #0]
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
    8394:	687b      	ldr	r3, [r7, #4]
    8396:	7b5b      	ldrb	r3, [r3, #13]
    8398:	001a      	movs	r2, r3
    839a:	2302      	movs	r3, #2
    839c:	4013      	ands	r3, r2
    839e:	d007      	beq.n	83b0 <pbuf_free+0x68>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
    83a0:	687b      	ldr	r3, [r7, #4]
    83a2:	60bb      	str	r3, [r7, #8]
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
    83a4:	68bb      	ldr	r3, [r7, #8]
    83a6:	691b      	ldr	r3, [r3, #16]
    83a8:	687a      	ldr	r2, [r7, #4]
    83aa:	0010      	movs	r0, r2
    83ac:	4798      	blx	r3
    83ae:	e01e      	b.n	83ee <pbuf_free+0xa6>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
    83b0:	230e      	movs	r3, #14
    83b2:	18fb      	adds	r3, r7, r3
    83b4:	881b      	ldrh	r3, [r3, #0]
    83b6:	2b03      	cmp	r3, #3
    83b8:	d105      	bne.n	83c6 <pbuf_free+0x7e>
          memp_free(MEMP_PBUF_POOL, p);
    83ba:	687b      	ldr	r3, [r7, #4]
    83bc:	0019      	movs	r1, r3
    83be:	2008      	movs	r0, #8
    83c0:	4b19      	ldr	r3, [pc, #100]	; (8428 <pbuf_free+0xe0>)
    83c2:	4798      	blx	r3
    83c4:	e013      	b.n	83ee <pbuf_free+0xa6>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
    83c6:	230e      	movs	r3, #14
    83c8:	18fb      	adds	r3, r7, r3
    83ca:	881b      	ldrh	r3, [r3, #0]
    83cc:	2b01      	cmp	r3, #1
    83ce:	d004      	beq.n	83da <pbuf_free+0x92>
    83d0:	230e      	movs	r3, #14
    83d2:	18fb      	adds	r3, r7, r3
    83d4:	881b      	ldrh	r3, [r3, #0]
    83d6:	2b02      	cmp	r3, #2
    83d8:	d105      	bne.n	83e6 <pbuf_free+0x9e>
          memp_free(MEMP_PBUF, p);
    83da:	687b      	ldr	r3, [r7, #4]
    83dc:	0019      	movs	r1, r3
    83de:	2007      	movs	r0, #7
    83e0:	4b11      	ldr	r3, [pc, #68]	; (8428 <pbuf_free+0xe0>)
    83e2:	4798      	blx	r3
    83e4:	e003      	b.n	83ee <pbuf_free+0xa6>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
    83e6:	687b      	ldr	r3, [r7, #4]
    83e8:	0018      	movs	r0, r3
    83ea:	4b10      	ldr	r3, [pc, #64]	; (842c <pbuf_free+0xe4>)
    83ec:	4798      	blx	r3
        }
      }
      count++;
    83ee:	2317      	movs	r3, #23
    83f0:	18fb      	adds	r3, r7, r3
    83f2:	781a      	ldrb	r2, [r3, #0]
    83f4:	2317      	movs	r3, #23
    83f6:	18fb      	adds	r3, r7, r3
    83f8:	3201      	adds	r2, #1
    83fa:	701a      	strb	r2, [r3, #0]
      /* proceed to next pbuf */
      p = q;
    83fc:	693b      	ldr	r3, [r7, #16]
    83fe:	607b      	str	r3, [r7, #4]
    8400:	e007      	b.n	8412 <pbuf_free+0xca>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
    8402:	2300      	movs	r3, #0
    8404:	607b      	str	r3, [r7, #4]
    8406:	2317      	movs	r3, #23
    8408:	18fb      	adds	r3, r7, r3
    840a:	2217      	movs	r2, #23
    840c:	18ba      	adds	r2, r7, r2
    840e:	7812      	ldrb	r2, [r2, #0]
    8410:	701a      	strb	r2, [r3, #0]
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
    8412:	687b      	ldr	r3, [r7, #4]
    8414:	2b00      	cmp	r3, #0
    8416:	d1a5      	bne.n	8364 <pbuf_free+0x1c>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
    8418:	2317      	movs	r3, #23
    841a:	18fb      	adds	r3, r7, r3
    841c:	781b      	ldrb	r3, [r3, #0]
}
    841e:	0018      	movs	r0, r3
    8420:	46bd      	mov	sp, r7
    8422:	b006      	add	sp, #24
    8424:	bd80      	pop	{r7, pc}
    8426:	46c0      	nop			; (mov r8, r8)
    8428:	00007b39 	.word	0x00007b39
    842c:	0000765d 	.word	0x0000765d

00008430 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
    8430:	b580      	push	{r7, lr}
    8432:	b084      	sub	sp, #16
    8434:	af00      	add	r7, sp, #0
    8436:	6078      	str	r0, [r7, #4]
  u8_t len;

  len = 0;
    8438:	230f      	movs	r3, #15
    843a:	18fb      	adds	r3, r7, r3
    843c:	2200      	movs	r2, #0
    843e:	701a      	strb	r2, [r3, #0]
  while (p != NULL) {
    8440:	e009      	b.n	8456 <pbuf_clen+0x26>
    ++len;
    8442:	230f      	movs	r3, #15
    8444:	18fb      	adds	r3, r7, r3
    8446:	220f      	movs	r2, #15
    8448:	18ba      	adds	r2, r7, r2
    844a:	7812      	ldrb	r2, [r2, #0]
    844c:	3201      	adds	r2, #1
    844e:	701a      	strb	r2, [r3, #0]
    p = p->next;
    8450:	687b      	ldr	r3, [r7, #4]
    8452:	681b      	ldr	r3, [r3, #0]
    8454:	607b      	str	r3, [r7, #4]
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    8456:	687b      	ldr	r3, [r7, #4]
    8458:	2b00      	cmp	r3, #0
    845a:	d1f2      	bne.n	8442 <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
    845c:	230f      	movs	r3, #15
    845e:	18fb      	adds	r3, r7, r3
    8460:	781b      	ldrb	r3, [r3, #0]
}
    8462:	0018      	movs	r0, r3
    8464:	46bd      	mov	sp, r7
    8466:	b004      	add	sp, #16
    8468:	bd80      	pop	{r7, pc}
    846a:	46c0      	nop			; (mov r8, r8)

0000846c <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
    846c:	b580      	push	{r7, lr}
    846e:	b082      	sub	sp, #8
    8470:	af00      	add	r7, sp, #0
    8472:	6078      	str	r0, [r7, #4]
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    8474:	687b      	ldr	r3, [r7, #4]
    8476:	2b00      	cmp	r3, #0
    8478:	d005      	beq.n	8486 <pbuf_ref+0x1a>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    847a:	687b      	ldr	r3, [r7, #4]
    847c:	89db      	ldrh	r3, [r3, #14]
    847e:	3301      	adds	r3, #1
    8480:	b29a      	uxth	r2, r3
    8482:	687b      	ldr	r3, [r7, #4]
    8484:	81da      	strh	r2, [r3, #14]
    SYS_ARCH_UNPROTECT(old_level);
  }
}
    8486:	46c0      	nop			; (mov r8, r8)
    8488:	46bd      	mov	sp, r7
    848a:	b002      	add	sp, #8
    848c:	bd80      	pop	{r7, pc}
    848e:	46c0      	nop			; (mov r8, r8)

00008490 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
    8490:	b580      	push	{r7, lr}
    8492:	b084      	sub	sp, #16
    8494:	af00      	add	r7, sp, #0
    8496:	6078      	str	r0, [r7, #4]
    8498:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    849a:	687b      	ldr	r3, [r7, #4]
    849c:	2b00      	cmp	r3, #0
    849e:	d020      	beq.n	84e2 <pbuf_cat+0x52>
    84a0:	683b      	ldr	r3, [r7, #0]
    84a2:	2b00      	cmp	r3, #0
    84a4:	d01d      	beq.n	84e2 <pbuf_cat+0x52>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    84a6:	687b      	ldr	r3, [r7, #4]
    84a8:	60fb      	str	r3, [r7, #12]
    84aa:	e00a      	b.n	84c2 <pbuf_cat+0x32>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
    84ac:	68fb      	ldr	r3, [r7, #12]
    84ae:	891a      	ldrh	r2, [r3, #8]
    84b0:	683b      	ldr	r3, [r7, #0]
    84b2:	891b      	ldrh	r3, [r3, #8]
    84b4:	18d3      	adds	r3, r2, r3
    84b6:	b29a      	uxth	r2, r3
    84b8:	68fb      	ldr	r3, [r7, #12]
    84ba:	811a      	strh	r2, [r3, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    84bc:	68fb      	ldr	r3, [r7, #12]
    84be:	681b      	ldr	r3, [r3, #0]
    84c0:	60fb      	str	r3, [r7, #12]
    84c2:	68fb      	ldr	r3, [r7, #12]
    84c4:	681b      	ldr	r3, [r3, #0]
    84c6:	2b00      	cmp	r3, #0
    84c8:	d1f0      	bne.n	84ac <pbuf_cat+0x1c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
    84ca:	68fb      	ldr	r3, [r7, #12]
    84cc:	891a      	ldrh	r2, [r3, #8]
    84ce:	683b      	ldr	r3, [r7, #0]
    84d0:	891b      	ldrh	r3, [r3, #8]
    84d2:	18d3      	adds	r3, r2, r3
    84d4:	b29a      	uxth	r2, r3
    84d6:	68fb      	ldr	r3, [r7, #12]
    84d8:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
    84da:	68fb      	ldr	r3, [r7, #12]
    84dc:	683a      	ldr	r2, [r7, #0]
    84de:	601a      	str	r2, [r3, #0]
    84e0:	e000      	b.n	84e4 <pbuf_cat+0x54>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
    84e2:	46c0      	nop			; (mov r8, r8)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
    84e4:	46bd      	mov	sp, r7
    84e6:	b004      	add	sp, #16
    84e8:	bd80      	pop	{r7, pc}
    84ea:	46c0      	nop			; (mov r8, r8)

000084ec <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
    84ec:	b580      	push	{r7, lr}
    84ee:	b082      	sub	sp, #8
    84f0:	af00      	add	r7, sp, #0
    84f2:	6078      	str	r0, [r7, #4]
    84f4:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
    84f6:	683a      	ldr	r2, [r7, #0]
    84f8:	687b      	ldr	r3, [r7, #4]
    84fa:	0011      	movs	r1, r2
    84fc:	0018      	movs	r0, r3
    84fe:	4b05      	ldr	r3, [pc, #20]	; (8514 <pbuf_chain+0x28>)
    8500:	4798      	blx	r3
  /* t is now referenced by h */
  pbuf_ref(t);
    8502:	683b      	ldr	r3, [r7, #0]
    8504:	0018      	movs	r0, r3
    8506:	4b04      	ldr	r3, [pc, #16]	; (8518 <pbuf_chain+0x2c>)
    8508:	4798      	blx	r3
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
    850a:	46c0      	nop			; (mov r8, r8)
    850c:	46bd      	mov	sp, r7
    850e:	b002      	add	sp, #8
    8510:	bd80      	pop	{r7, pc}
    8512:	46c0      	nop			; (mov r8, r8)
    8514:	00008491 	.word	0x00008491
    8518:	0000846d 	.word	0x0000846d

0000851c <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
    851c:	b580      	push	{r7, lr}
    851e:	b084      	sub	sp, #16
    8520:	af00      	add	r7, sp, #0
    8522:	6078      	str	r0, [r7, #4]
    8524:	6039      	str	r1, [r7, #0]
  u16_t offset_to=0, offset_from=0, len;
    8526:	230e      	movs	r3, #14
    8528:	18fb      	adds	r3, r7, r3
    852a:	2200      	movs	r2, #0
    852c:	801a      	strh	r2, [r3, #0]
    852e:	230c      	movs	r3, #12
    8530:	18fb      	adds	r3, r7, r3
    8532:	2200      	movs	r2, #0
    8534:	801a      	strh	r2, [r3, #0]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
    8536:	687b      	ldr	r3, [r7, #4]
    8538:	2b00      	cmp	r3, #0
    853a:	d008      	beq.n	854e <pbuf_copy+0x32>
    853c:	683b      	ldr	r3, [r7, #0]
    853e:	2b00      	cmp	r3, #0
    8540:	d005      	beq.n	854e <pbuf_copy+0x32>
    8542:	687b      	ldr	r3, [r7, #4]
    8544:	891a      	ldrh	r2, [r3, #8]
    8546:	683b      	ldr	r3, [r7, #0]
    8548:	891b      	ldrh	r3, [r3, #8]
    854a:	429a      	cmp	r2, r3
    854c:	d202      	bcs.n	8554 <pbuf_copy+0x38>
    854e:	230e      	movs	r3, #14
    8550:	425b      	negs	r3, r3
    8552:	e092      	b.n	867a <pbuf_copy+0x15e>

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
    8554:	687b      	ldr	r3, [r7, #4]
    8556:	895b      	ldrh	r3, [r3, #10]
    8558:	001a      	movs	r2, r3
    855a:	230e      	movs	r3, #14
    855c:	18fb      	adds	r3, r7, r3
    855e:	881b      	ldrh	r3, [r3, #0]
    8560:	1ad2      	subs	r2, r2, r3
    8562:	683b      	ldr	r3, [r7, #0]
    8564:	895b      	ldrh	r3, [r3, #10]
    8566:	0019      	movs	r1, r3
    8568:	230c      	movs	r3, #12
    856a:	18fb      	adds	r3, r7, r3
    856c:	881b      	ldrh	r3, [r3, #0]
    856e:	1acb      	subs	r3, r1, r3
    8570:	429a      	cmp	r2, r3
    8572:	db09      	blt.n	8588 <pbuf_copy+0x6c>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    8574:	683b      	ldr	r3, [r7, #0]
    8576:	8959      	ldrh	r1, [r3, #10]
    8578:	230a      	movs	r3, #10
    857a:	18fb      	adds	r3, r7, r3
    857c:	220c      	movs	r2, #12
    857e:	18ba      	adds	r2, r7, r2
    8580:	8812      	ldrh	r2, [r2, #0]
    8582:	1a8a      	subs	r2, r1, r2
    8584:	801a      	strh	r2, [r3, #0]
    8586:	e008      	b.n	859a <pbuf_copy+0x7e>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    8588:	687b      	ldr	r3, [r7, #4]
    858a:	8959      	ldrh	r1, [r3, #10]
    858c:	230a      	movs	r3, #10
    858e:	18fb      	adds	r3, r7, r3
    8590:	220e      	movs	r2, #14
    8592:	18ba      	adds	r2, r7, r2
    8594:	8812      	ldrh	r2, [r2, #0]
    8596:	1a8a      	subs	r2, r1, r2
    8598:	801a      	strh	r2, [r3, #0]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    859a:	687b      	ldr	r3, [r7, #4]
    859c:	685a      	ldr	r2, [r3, #4]
    859e:	230e      	movs	r3, #14
    85a0:	18fb      	adds	r3, r7, r3
    85a2:	881b      	ldrh	r3, [r3, #0]
    85a4:	18d0      	adds	r0, r2, r3
    85a6:	683b      	ldr	r3, [r7, #0]
    85a8:	685a      	ldr	r2, [r3, #4]
    85aa:	230c      	movs	r3, #12
    85ac:	18fb      	adds	r3, r7, r3
    85ae:	881b      	ldrh	r3, [r3, #0]
    85b0:	18d1      	adds	r1, r2, r3
    85b2:	230a      	movs	r3, #10
    85b4:	18fb      	adds	r3, r7, r3
    85b6:	881b      	ldrh	r3, [r3, #0]
    85b8:	001a      	movs	r2, r3
    85ba:	4b32      	ldr	r3, [pc, #200]	; (8684 <pbuf_copy+0x168>)
    85bc:	4798      	blx	r3
    offset_to += len;
    85be:	230e      	movs	r3, #14
    85c0:	18fb      	adds	r3, r7, r3
    85c2:	220e      	movs	r2, #14
    85c4:	18b9      	adds	r1, r7, r2
    85c6:	220a      	movs	r2, #10
    85c8:	18ba      	adds	r2, r7, r2
    85ca:	8809      	ldrh	r1, [r1, #0]
    85cc:	8812      	ldrh	r2, [r2, #0]
    85ce:	188a      	adds	r2, r1, r2
    85d0:	801a      	strh	r2, [r3, #0]
    offset_from += len;
    85d2:	230c      	movs	r3, #12
    85d4:	18fb      	adds	r3, r7, r3
    85d6:	220c      	movs	r2, #12
    85d8:	18b9      	adds	r1, r7, r2
    85da:	220a      	movs	r2, #10
    85dc:	18ba      	adds	r2, r7, r2
    85de:	8809      	ldrh	r1, [r1, #0]
    85e0:	8812      	ldrh	r2, [r2, #0]
    85e2:	188a      	adds	r2, r1, r2
    85e4:	801a      	strh	r2, [r3, #0]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
    85e6:	683b      	ldr	r3, [r7, #0]
    85e8:	895b      	ldrh	r3, [r3, #10]
    85ea:	220c      	movs	r2, #12
    85ec:	18ba      	adds	r2, r7, r2
    85ee:	8812      	ldrh	r2, [r2, #0]
    85f0:	429a      	cmp	r2, r3
    85f2:	d306      	bcc.n	8602 <pbuf_copy+0xe6>
      /* on to next p_from (if any) */
      offset_from = 0;
    85f4:	230c      	movs	r3, #12
    85f6:	18fb      	adds	r3, r7, r3
    85f8:	2200      	movs	r2, #0
    85fa:	801a      	strh	r2, [r3, #0]
      p_from = p_from->next;
    85fc:	683b      	ldr	r3, [r7, #0]
    85fe:	681b      	ldr	r3, [r3, #0]
    8600:	603b      	str	r3, [r7, #0]
    }
    if (offset_to == p_to->len) {
    8602:	687b      	ldr	r3, [r7, #4]
    8604:	895b      	ldrh	r3, [r3, #10]
    8606:	220e      	movs	r2, #14
    8608:	18ba      	adds	r2, r7, r2
    860a:	8812      	ldrh	r2, [r2, #0]
    860c:	429a      	cmp	r2, r3
    860e:	d10f      	bne.n	8630 <pbuf_copy+0x114>
      /* on to next p_to (if any) */
      offset_to = 0;
    8610:	230e      	movs	r3, #14
    8612:	18fb      	adds	r3, r7, r3
    8614:	2200      	movs	r2, #0
    8616:	801a      	strh	r2, [r3, #0]
      p_to = p_to->next;
    8618:	687b      	ldr	r3, [r7, #4]
    861a:	681b      	ldr	r3, [r3, #0]
    861c:	607b      	str	r3, [r7, #4]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    861e:	687b      	ldr	r3, [r7, #4]
    8620:	2b00      	cmp	r3, #0
    8622:	d105      	bne.n	8630 <pbuf_copy+0x114>
    8624:	683b      	ldr	r3, [r7, #0]
    8626:	2b00      	cmp	r3, #0
    8628:	d002      	beq.n	8630 <pbuf_copy+0x114>
    862a:	230e      	movs	r3, #14
    862c:	425b      	negs	r3, r3
    862e:	e024      	b.n	867a <pbuf_copy+0x15e>
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
    8630:	683b      	ldr	r3, [r7, #0]
    8632:	2b00      	cmp	r3, #0
    8634:	d00c      	beq.n	8650 <pbuf_copy+0x134>
    8636:	683b      	ldr	r3, [r7, #0]
    8638:	895a      	ldrh	r2, [r3, #10]
    863a:	683b      	ldr	r3, [r7, #0]
    863c:	891b      	ldrh	r3, [r3, #8]
    863e:	429a      	cmp	r2, r3
    8640:	d106      	bne.n	8650 <pbuf_copy+0x134>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    8642:	683b      	ldr	r3, [r7, #0]
    8644:	681b      	ldr	r3, [r3, #0]
    8646:	2b00      	cmp	r3, #0
    8648:	d002      	beq.n	8650 <pbuf_copy+0x134>
    864a:	2306      	movs	r3, #6
    864c:	425b      	negs	r3, r3
    864e:	e014      	b.n	867a <pbuf_copy+0x15e>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
    8650:	687b      	ldr	r3, [r7, #4]
    8652:	2b00      	cmp	r3, #0
    8654:	d00c      	beq.n	8670 <pbuf_copy+0x154>
    8656:	687b      	ldr	r3, [r7, #4]
    8658:	895a      	ldrh	r2, [r3, #10]
    865a:	687b      	ldr	r3, [r7, #4]
    865c:	891b      	ldrh	r3, [r3, #8]
    865e:	429a      	cmp	r2, r3
    8660:	d106      	bne.n	8670 <pbuf_copy+0x154>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
    8662:	687b      	ldr	r3, [r7, #4]
    8664:	681b      	ldr	r3, [r3, #0]
    8666:	2b00      	cmp	r3, #0
    8668:	d002      	beq.n	8670 <pbuf_copy+0x154>
    866a:	2306      	movs	r3, #6
    866c:	425b      	negs	r3, r3
    866e:	e004      	b.n	867a <pbuf_copy+0x15e>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
    8670:	683b      	ldr	r3, [r7, #0]
    8672:	2b00      	cmp	r3, #0
    8674:	d000      	beq.n	8678 <pbuf_copy+0x15c>
    8676:	e76d      	b.n	8554 <pbuf_copy+0x38>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
    8678:	2300      	movs	r3, #0
}
    867a:	0018      	movs	r0, r3
    867c:	46bd      	mov	sp, r7
    867e:	b004      	add	sp, #16
    8680:	bd80      	pop	{r7, pc}
    8682:	46c0      	nop			; (mov r8, r8)
    8684:	0000fc43 	.word	0x0000fc43

00008688 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
    8688:	b580      	push	{r7, lr}
    868a:	b088      	sub	sp, #32
    868c:	af00      	add	r7, sp, #0
    868e:	60f8      	str	r0, [r7, #12]
    8690:	60b9      	str	r1, [r7, #8]
    8692:	0019      	movs	r1, r3
    8694:	1dbb      	adds	r3, r7, #6
    8696:	801a      	strh	r2, [r3, #0]
    8698:	1d3b      	adds	r3, r7, #4
    869a:	1c0a      	adds	r2, r1, #0
    869c:	801a      	strh	r2, [r3, #0]
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
    869e:	2316      	movs	r3, #22
    86a0:	18fb      	adds	r3, r7, r3
    86a2:	2200      	movs	r2, #0
    86a4:	801a      	strh	r2, [r3, #0]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
    86a6:	68fb      	ldr	r3, [r7, #12]
    86a8:	2b00      	cmp	r3, #0
    86aa:	d101      	bne.n	86b0 <pbuf_copy_partial+0x28>
    86ac:	2300      	movs	r3, #0
    86ae:	e075      	b.n	879c <pbuf_copy_partial+0x114>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
    86b0:	68bb      	ldr	r3, [r7, #8]
    86b2:	2b00      	cmp	r3, #0
    86b4:	d101      	bne.n	86ba <pbuf_copy_partial+0x32>
    86b6:	2300      	movs	r3, #0
    86b8:	e070      	b.n	879c <pbuf_copy_partial+0x114>

  left = 0;
    86ba:	231a      	movs	r3, #26
    86bc:	18fb      	adds	r3, r7, r3
    86be:	2200      	movs	r2, #0
    86c0:	801a      	strh	r2, [r3, #0]

  if((buf == NULL) || (dataptr == NULL)) {
    86c2:	68fb      	ldr	r3, [r7, #12]
    86c4:	2b00      	cmp	r3, #0
    86c6:	d002      	beq.n	86ce <pbuf_copy_partial+0x46>
    86c8:	68bb      	ldr	r3, [r7, #8]
    86ca:	2b00      	cmp	r3, #0
    86cc:	d101      	bne.n	86d2 <pbuf_copy_partial+0x4a>
    return 0;
    86ce:	2300      	movs	r3, #0
    86d0:	e064      	b.n	879c <pbuf_copy_partial+0x114>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    86d2:	68fb      	ldr	r3, [r7, #12]
    86d4:	61fb      	str	r3, [r7, #28]
    86d6:	e057      	b.n	8788 <pbuf_copy_partial+0x100>
    if ((offset != 0) && (offset >= p->len)) {
    86d8:	1d3b      	adds	r3, r7, #4
    86da:	881b      	ldrh	r3, [r3, #0]
    86dc:	2b00      	cmp	r3, #0
    86de:	d00d      	beq.n	86fc <pbuf_copy_partial+0x74>
    86e0:	69fb      	ldr	r3, [r7, #28]
    86e2:	895b      	ldrh	r3, [r3, #10]
    86e4:	1d3a      	adds	r2, r7, #4
    86e6:	8812      	ldrh	r2, [r2, #0]
    86e8:	429a      	cmp	r2, r3
    86ea:	d307      	bcc.n	86fc <pbuf_copy_partial+0x74>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    86ec:	69fb      	ldr	r3, [r7, #28]
    86ee:	895a      	ldrh	r2, [r3, #10]
    86f0:	1d3b      	adds	r3, r7, #4
    86f2:	1d39      	adds	r1, r7, #4
    86f4:	8809      	ldrh	r1, [r1, #0]
    86f6:	1a8a      	subs	r2, r1, r2
    86f8:	801a      	strh	r2, [r3, #0]
    86fa:	e042      	b.n	8782 <pbuf_copy_partial+0xfa>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
    86fc:	69fb      	ldr	r3, [r7, #28]
    86fe:	8959      	ldrh	r1, [r3, #10]
    8700:	2318      	movs	r3, #24
    8702:	18fb      	adds	r3, r7, r3
    8704:	1d3a      	adds	r2, r7, #4
    8706:	8812      	ldrh	r2, [r2, #0]
    8708:	1a8a      	subs	r2, r1, r2
    870a:	801a      	strh	r2, [r3, #0]
      if (buf_copy_len > len)
    870c:	2318      	movs	r3, #24
    870e:	18fa      	adds	r2, r7, r3
    8710:	1dbb      	adds	r3, r7, #6
    8712:	8812      	ldrh	r2, [r2, #0]
    8714:	881b      	ldrh	r3, [r3, #0]
    8716:	429a      	cmp	r2, r3
    8718:	d904      	bls.n	8724 <pbuf_copy_partial+0x9c>
          buf_copy_len = len;
    871a:	2318      	movs	r3, #24
    871c:	18fb      	adds	r3, r7, r3
    871e:	1dba      	adds	r2, r7, #6
    8720:	8812      	ldrh	r2, [r2, #0]
    8722:	801a      	strh	r2, [r3, #0]
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
    8724:	231a      	movs	r3, #26
    8726:	18fb      	adds	r3, r7, r3
    8728:	881b      	ldrh	r3, [r3, #0]
    872a:	68ba      	ldr	r2, [r7, #8]
    872c:	18d0      	adds	r0, r2, r3
    872e:	69fb      	ldr	r3, [r7, #28]
    8730:	685a      	ldr	r2, [r3, #4]
    8732:	1d3b      	adds	r3, r7, #4
    8734:	881b      	ldrh	r3, [r3, #0]
    8736:	18d1      	adds	r1, r2, r3
    8738:	2318      	movs	r3, #24
    873a:	18fb      	adds	r3, r7, r3
    873c:	881b      	ldrh	r3, [r3, #0]
    873e:	001a      	movs	r2, r3
    8740:	4b18      	ldr	r3, [pc, #96]	; (87a4 <pbuf_copy_partial+0x11c>)
    8742:	4798      	blx	r3
      copied_total += buf_copy_len;
    8744:	2316      	movs	r3, #22
    8746:	18fb      	adds	r3, r7, r3
    8748:	2216      	movs	r2, #22
    874a:	18b9      	adds	r1, r7, r2
    874c:	2218      	movs	r2, #24
    874e:	18ba      	adds	r2, r7, r2
    8750:	8809      	ldrh	r1, [r1, #0]
    8752:	8812      	ldrh	r2, [r2, #0]
    8754:	188a      	adds	r2, r1, r2
    8756:	801a      	strh	r2, [r3, #0]
      left += buf_copy_len;
    8758:	231a      	movs	r3, #26
    875a:	18fb      	adds	r3, r7, r3
    875c:	221a      	movs	r2, #26
    875e:	18b9      	adds	r1, r7, r2
    8760:	2218      	movs	r2, #24
    8762:	18ba      	adds	r2, r7, r2
    8764:	8809      	ldrh	r1, [r1, #0]
    8766:	8812      	ldrh	r2, [r2, #0]
    8768:	188a      	adds	r2, r1, r2
    876a:	801a      	strh	r2, [r3, #0]
      len -= buf_copy_len;
    876c:	1dbb      	adds	r3, r7, #6
    876e:	1db9      	adds	r1, r7, #6
    8770:	2218      	movs	r2, #24
    8772:	18ba      	adds	r2, r7, r2
    8774:	8809      	ldrh	r1, [r1, #0]
    8776:	8812      	ldrh	r2, [r2, #0]
    8778:	1a8a      	subs	r2, r1, r2
    877a:	801a      	strh	r2, [r3, #0]
      offset = 0;
    877c:	1d3b      	adds	r3, r7, #4
    877e:	2200      	movs	r2, #0
    8780:	801a      	strh	r2, [r3, #0]
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    8782:	69fb      	ldr	r3, [r7, #28]
    8784:	681b      	ldr	r3, [r3, #0]
    8786:	61fb      	str	r3, [r7, #28]
    8788:	1dbb      	adds	r3, r7, #6
    878a:	881b      	ldrh	r3, [r3, #0]
    878c:	2b00      	cmp	r3, #0
    878e:	d002      	beq.n	8796 <pbuf_copy_partial+0x10e>
    8790:	69fb      	ldr	r3, [r7, #28]
    8792:	2b00      	cmp	r3, #0
    8794:	d1a0      	bne.n	86d8 <pbuf_copy_partial+0x50>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
    8796:	2316      	movs	r3, #22
    8798:	18fb      	adds	r3, r7, r3
    879a:	881b      	ldrh	r3, [r3, #0]
}
    879c:	0018      	movs	r0, r3
    879e:	46bd      	mov	sp, r7
    87a0:	b008      	add	sp, #32
    87a2:	bd80      	pop	{r7, pc}
    87a4:	0000fc43 	.word	0x0000fc43

000087a8 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
    87a8:	b580      	push	{r7, lr}
    87aa:	af00      	add	r7, sp, #0
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
    87ac:	46c0      	nop			; (mov r8, r8)
    87ae:	46bd      	mov	sp, r7
    87b0:	bd80      	pop	{r7, pc}
    87b2:	46c0      	nop			; (mov r8, r8)

000087b4 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
    87b4:	b580      	push	{r7, lr}
    87b6:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
    87b8:	4b09      	ldr	r3, [pc, #36]	; (87e0 <tcp_tmr+0x2c>)
    87ba:	4798      	blx	r3

  if (++tcp_timer & 1) {
    87bc:	4b09      	ldr	r3, [pc, #36]	; (87e4 <tcp_tmr+0x30>)
    87be:	781b      	ldrb	r3, [r3, #0]
    87c0:	3301      	adds	r3, #1
    87c2:	b2da      	uxtb	r2, r3
    87c4:	4b07      	ldr	r3, [pc, #28]	; (87e4 <tcp_tmr+0x30>)
    87c6:	701a      	strb	r2, [r3, #0]
    87c8:	4b06      	ldr	r3, [pc, #24]	; (87e4 <tcp_tmr+0x30>)
    87ca:	781b      	ldrb	r3, [r3, #0]
    87cc:	001a      	movs	r2, r3
    87ce:	2301      	movs	r3, #1
    87d0:	4013      	ands	r3, r2
    87d2:	d001      	beq.n	87d8 <tcp_tmr+0x24>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
    87d4:	4b04      	ldr	r3, [pc, #16]	; (87e8 <tcp_tmr+0x34>)
    87d6:	4798      	blx	r3
  }
}
    87d8:	46c0      	nop			; (mov r8, r8)
    87da:	46bd      	mov	sp, r7
    87dc:	bd80      	pop	{r7, pc}
    87de:	46c0      	nop			; (mov r8, r8)
    87e0:	000091d9 	.word	0x000091d9
    87e4:	20002c6c 	.word	0x20002c6c
    87e8:	00008cc9 	.word	0x00008cc9

000087ec <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
    87ec:	b5b0      	push	{r4, r5, r7, lr}
    87ee:	b086      	sub	sp, #24
    87f0:	af02      	add	r7, sp, #8
    87f2:	6078      	str	r0, [r7, #4]
    87f4:	000a      	movs	r2, r1
    87f6:	1cfb      	adds	r3, r7, #3
    87f8:	701a      	strb	r2, [r3, #0]
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    87fa:	1cfb      	adds	r3, r7, #3
    87fc:	781b      	ldrb	r3, [r3, #0]
    87fe:	2b00      	cmp	r3, #0
    8800:	d100      	bne.n	8804 <tcp_close_shutdown+0x18>
    8802:	e068      	b.n	88d6 <tcp_close_shutdown+0xea>
    8804:	687b      	ldr	r3, [r7, #4]
    8806:	7e1b      	ldrb	r3, [r3, #24]
    8808:	2b04      	cmp	r3, #4
    880a:	d003      	beq.n	8814 <tcp_close_shutdown+0x28>
    880c:	687b      	ldr	r3, [r7, #4]
    880e:	7e1b      	ldrb	r3, [r3, #24]
    8810:	2b07      	cmp	r3, #7
    8812:	d160      	bne.n	88d6 <tcp_close_shutdown+0xea>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
    8814:	687b      	ldr	r3, [r7, #4]
    8816:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    8818:	2b00      	cmp	r3, #0
    881a:	d104      	bne.n	8826 <tcp_close_shutdown+0x3a>
    881c:	687b      	ldr	r3, [r7, #4]
    881e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    8820:	4a8d      	ldr	r2, [pc, #564]	; (8a58 <tcp_close_shutdown+0x26c>)
    8822:	4293      	cmp	r3, r2
    8824:	d057      	beq.n	88d6 <tcp_close_shutdown+0xea>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    8826:	687b      	ldr	r3, [r7, #4]
    8828:	6d18      	ldr	r0, [r3, #80]	; 0x50
    882a:	687b      	ldr	r3, [r7, #4]
    882c:	6a99      	ldr	r1, [r3, #40]	; 0x28
    882e:	687c      	ldr	r4, [r7, #4]
    8830:	687b      	ldr	r3, [r7, #4]
    8832:	1d1d      	adds	r5, r3, #4
    8834:	687b      	ldr	r3, [r7, #4]
    8836:	8b5b      	ldrh	r3, [r3, #26]
    8838:	687a      	ldr	r2, [r7, #4]
    883a:	8b92      	ldrh	r2, [r2, #28]
    883c:	9201      	str	r2, [sp, #4]
    883e:	9300      	str	r3, [sp, #0]
    8840:	002b      	movs	r3, r5
    8842:	0022      	movs	r2, r4
    8844:	4c85      	ldr	r4, [pc, #532]	; (8a5c <tcp_close_shutdown+0x270>)
    8846:	47a0      	blx	r4
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
    8848:	687b      	ldr	r3, [r7, #4]
    884a:	0018      	movs	r0, r3
    884c:	4b84      	ldr	r3, [pc, #528]	; (8a60 <tcp_close_shutdown+0x274>)
    884e:	4798      	blx	r3
      TCP_RMV_ACTIVE(pcb);
    8850:	4b84      	ldr	r3, [pc, #528]	; (8a64 <tcp_close_shutdown+0x278>)
    8852:	681a      	ldr	r2, [r3, #0]
    8854:	687b      	ldr	r3, [r7, #4]
    8856:	429a      	cmp	r2, r3
    8858:	d105      	bne.n	8866 <tcp_close_shutdown+0x7a>
    885a:	4b82      	ldr	r3, [pc, #520]	; (8a64 <tcp_close_shutdown+0x278>)
    885c:	681b      	ldr	r3, [r3, #0]
    885e:	68da      	ldr	r2, [r3, #12]
    8860:	4b80      	ldr	r3, [pc, #512]	; (8a64 <tcp_close_shutdown+0x278>)
    8862:	601a      	str	r2, [r3, #0]
    8864:	e019      	b.n	889a <tcp_close_shutdown+0xae>
    8866:	4b7f      	ldr	r3, [pc, #508]	; (8a64 <tcp_close_shutdown+0x278>)
    8868:	681a      	ldr	r2, [r3, #0]
    886a:	4b7f      	ldr	r3, [pc, #508]	; (8a68 <tcp_close_shutdown+0x27c>)
    886c:	601a      	str	r2, [r3, #0]
    886e:	e010      	b.n	8892 <tcp_close_shutdown+0xa6>
    8870:	4b7d      	ldr	r3, [pc, #500]	; (8a68 <tcp_close_shutdown+0x27c>)
    8872:	681b      	ldr	r3, [r3, #0]
    8874:	68da      	ldr	r2, [r3, #12]
    8876:	687b      	ldr	r3, [r7, #4]
    8878:	429a      	cmp	r2, r3
    887a:	d105      	bne.n	8888 <tcp_close_shutdown+0x9c>
    887c:	4b7a      	ldr	r3, [pc, #488]	; (8a68 <tcp_close_shutdown+0x27c>)
    887e:	681b      	ldr	r3, [r3, #0]
    8880:	687a      	ldr	r2, [r7, #4]
    8882:	68d2      	ldr	r2, [r2, #12]
    8884:	60da      	str	r2, [r3, #12]
    8886:	e008      	b.n	889a <tcp_close_shutdown+0xae>
    8888:	4b77      	ldr	r3, [pc, #476]	; (8a68 <tcp_close_shutdown+0x27c>)
    888a:	681b      	ldr	r3, [r3, #0]
    888c:	68da      	ldr	r2, [r3, #12]
    888e:	4b76      	ldr	r3, [pc, #472]	; (8a68 <tcp_close_shutdown+0x27c>)
    8890:	601a      	str	r2, [r3, #0]
    8892:	4b75      	ldr	r3, [pc, #468]	; (8a68 <tcp_close_shutdown+0x27c>)
    8894:	681b      	ldr	r3, [r3, #0]
    8896:	2b00      	cmp	r3, #0
    8898:	d1ea      	bne.n	8870 <tcp_close_shutdown+0x84>
    889a:	687b      	ldr	r3, [r7, #4]
    889c:	2200      	movs	r2, #0
    889e:	60da      	str	r2, [r3, #12]
    88a0:	4b72      	ldr	r3, [pc, #456]	; (8a6c <tcp_close_shutdown+0x280>)
    88a2:	2201      	movs	r2, #1
    88a4:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
    88a6:	687b      	ldr	r3, [r7, #4]
    88a8:	7e1b      	ldrb	r3, [r3, #24]
    88aa:	2b04      	cmp	r3, #4
    88ac:	d10c      	bne.n	88c8 <tcp_close_shutdown+0xdc>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
    88ae:	687b      	ldr	r3, [r7, #4]
    88b0:	220a      	movs	r2, #10
    88b2:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
    88b4:	4b6e      	ldr	r3, [pc, #440]	; (8a70 <tcp_close_shutdown+0x284>)
    88b6:	681a      	ldr	r2, [r3, #0]
    88b8:	687b      	ldr	r3, [r7, #4]
    88ba:	60da      	str	r2, [r3, #12]
    88bc:	4b6c      	ldr	r3, [pc, #432]	; (8a70 <tcp_close_shutdown+0x284>)
    88be:	687a      	ldr	r2, [r7, #4]
    88c0:	601a      	str	r2, [r3, #0]
    88c2:	4b6c      	ldr	r3, [pc, #432]	; (8a74 <tcp_close_shutdown+0x288>)
    88c4:	4798      	blx	r3
    88c6:	e004      	b.n	88d2 <tcp_close_shutdown+0xe6>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
    88c8:	687b      	ldr	r3, [r7, #4]
    88ca:	0019      	movs	r1, r3
    88cc:	2001      	movs	r0, #1
    88ce:	4b6a      	ldr	r3, [pc, #424]	; (8a78 <tcp_close_shutdown+0x28c>)
    88d0:	4798      	blx	r3
      }
      return ERR_OK;
    88d2:	2300      	movs	r3, #0
    88d4:	e0bb      	b.n	8a4e <tcp_close_shutdown+0x262>
    }
  }

  switch (pcb->state) {
    88d6:	687b      	ldr	r3, [r7, #4]
    88d8:	7e1b      	ldrb	r3, [r3, #24]
    88da:	2b07      	cmp	r3, #7
    88dc:	d900      	bls.n	88e0 <tcp_close_shutdown+0xf4>
    88de:	e099      	b.n	8a14 <tcp_close_shutdown+0x228>
    88e0:	009a      	lsls	r2, r3, #2
    88e2:	4b66      	ldr	r3, [pc, #408]	; (8a7c <tcp_close_shutdown+0x290>)
    88e4:	18d3      	adds	r3, r2, r3
    88e6:	681b      	ldr	r3, [r3, #0]
    88e8:	469f      	mov	pc, r3
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    88ea:	230f      	movs	r3, #15
    88ec:	18fb      	adds	r3, r7, r3
    88ee:	2200      	movs	r2, #0
    88f0:	701a      	strb	r2, [r3, #0]
    if (pcb->local_port != 0) {
    88f2:	687b      	ldr	r3, [r7, #4]
    88f4:	8b5b      	ldrh	r3, [r3, #26]
    88f6:	2b00      	cmp	r3, #0
    88f8:	d027      	beq.n	894a <tcp_close_shutdown+0x15e>
      TCP_RMV(&tcp_bound_pcbs, pcb);
    88fa:	4b61      	ldr	r3, [pc, #388]	; (8a80 <tcp_close_shutdown+0x294>)
    88fc:	681a      	ldr	r2, [r3, #0]
    88fe:	687b      	ldr	r3, [r7, #4]
    8900:	429a      	cmp	r2, r3
    8902:	d105      	bne.n	8910 <tcp_close_shutdown+0x124>
    8904:	4b5e      	ldr	r3, [pc, #376]	; (8a80 <tcp_close_shutdown+0x294>)
    8906:	681b      	ldr	r3, [r3, #0]
    8908:	68da      	ldr	r2, [r3, #12]
    890a:	4b5d      	ldr	r3, [pc, #372]	; (8a80 <tcp_close_shutdown+0x294>)
    890c:	601a      	str	r2, [r3, #0]
    890e:	e019      	b.n	8944 <tcp_close_shutdown+0x158>
    8910:	4b5b      	ldr	r3, [pc, #364]	; (8a80 <tcp_close_shutdown+0x294>)
    8912:	681a      	ldr	r2, [r3, #0]
    8914:	4b54      	ldr	r3, [pc, #336]	; (8a68 <tcp_close_shutdown+0x27c>)
    8916:	601a      	str	r2, [r3, #0]
    8918:	e010      	b.n	893c <tcp_close_shutdown+0x150>
    891a:	4b53      	ldr	r3, [pc, #332]	; (8a68 <tcp_close_shutdown+0x27c>)
    891c:	681b      	ldr	r3, [r3, #0]
    891e:	68da      	ldr	r2, [r3, #12]
    8920:	687b      	ldr	r3, [r7, #4]
    8922:	429a      	cmp	r2, r3
    8924:	d105      	bne.n	8932 <tcp_close_shutdown+0x146>
    8926:	4b50      	ldr	r3, [pc, #320]	; (8a68 <tcp_close_shutdown+0x27c>)
    8928:	681b      	ldr	r3, [r3, #0]
    892a:	687a      	ldr	r2, [r7, #4]
    892c:	68d2      	ldr	r2, [r2, #12]
    892e:	60da      	str	r2, [r3, #12]
    8930:	e008      	b.n	8944 <tcp_close_shutdown+0x158>
    8932:	4b4d      	ldr	r3, [pc, #308]	; (8a68 <tcp_close_shutdown+0x27c>)
    8934:	681b      	ldr	r3, [r3, #0]
    8936:	68da      	ldr	r2, [r3, #12]
    8938:	4b4b      	ldr	r3, [pc, #300]	; (8a68 <tcp_close_shutdown+0x27c>)
    893a:	601a      	str	r2, [r3, #0]
    893c:	4b4a      	ldr	r3, [pc, #296]	; (8a68 <tcp_close_shutdown+0x27c>)
    893e:	681b      	ldr	r3, [r3, #0]
    8940:	2b00      	cmp	r3, #0
    8942:	d1ea      	bne.n	891a <tcp_close_shutdown+0x12e>
    8944:	687b      	ldr	r3, [r7, #4]
    8946:	2200      	movs	r2, #0
    8948:	60da      	str	r2, [r3, #12]
    }
    memp_free(MEMP_TCP_PCB, pcb);
    894a:	687b      	ldr	r3, [r7, #4]
    894c:	0019      	movs	r1, r3
    894e:	2001      	movs	r0, #1
    8950:	4b49      	ldr	r3, [pc, #292]	; (8a78 <tcp_close_shutdown+0x28c>)
    8952:	4798      	blx	r3
    pcb = NULL;
    8954:	2300      	movs	r3, #0
    8956:	607b      	str	r3, [r7, #4]
    break;
    8958:	e068      	b.n	8a2c <tcp_close_shutdown+0x240>
  case LISTEN:
    err = ERR_OK;
    895a:	230f      	movs	r3, #15
    895c:	18fb      	adds	r3, r7, r3
    895e:	2200      	movs	r2, #0
    8960:	701a      	strb	r2, [r3, #0]
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
    8962:	687a      	ldr	r2, [r7, #4]
    8964:	4b47      	ldr	r3, [pc, #284]	; (8a84 <tcp_close_shutdown+0x298>)
    8966:	0011      	movs	r1, r2
    8968:	0018      	movs	r0, r3
    896a:	4b47      	ldr	r3, [pc, #284]	; (8a88 <tcp_close_shutdown+0x29c>)
    896c:	4798      	blx	r3
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    896e:	687b      	ldr	r3, [r7, #4]
    8970:	0019      	movs	r1, r3
    8972:	2002      	movs	r0, #2
    8974:	4b40      	ldr	r3, [pc, #256]	; (8a78 <tcp_close_shutdown+0x28c>)
    8976:	4798      	blx	r3
    pcb = NULL;
    8978:	2300      	movs	r3, #0
    897a:	607b      	str	r3, [r7, #4]
    break;
    897c:	e056      	b.n	8a2c <tcp_close_shutdown+0x240>
  case SYN_SENT:
    err = ERR_OK;
    897e:	230f      	movs	r3, #15
    8980:	18fb      	adds	r3, r7, r3
    8982:	2200      	movs	r2, #0
    8984:	701a      	strb	r2, [r3, #0]
    TCP_PCB_REMOVE_ACTIVE(pcb);
    8986:	687a      	ldr	r2, [r7, #4]
    8988:	4b36      	ldr	r3, [pc, #216]	; (8a64 <tcp_close_shutdown+0x278>)
    898a:	0011      	movs	r1, r2
    898c:	0018      	movs	r0, r3
    898e:	4b3e      	ldr	r3, [pc, #248]	; (8a88 <tcp_close_shutdown+0x29c>)
    8990:	4798      	blx	r3
    8992:	4b36      	ldr	r3, [pc, #216]	; (8a6c <tcp_close_shutdown+0x280>)
    8994:	2201      	movs	r2, #1
    8996:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
    8998:	687b      	ldr	r3, [r7, #4]
    899a:	0019      	movs	r1, r3
    899c:	2001      	movs	r0, #1
    899e:	4b36      	ldr	r3, [pc, #216]	; (8a78 <tcp_close_shutdown+0x28c>)
    89a0:	4798      	blx	r3
    pcb = NULL;
    89a2:	2300      	movs	r3, #0
    89a4:	607b      	str	r3, [r7, #4]
    snmp_inc_tcpattemptfails();
    break;
    89a6:	e041      	b.n	8a2c <tcp_close_shutdown+0x240>
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
    89a8:	230f      	movs	r3, #15
    89aa:	18fc      	adds	r4, r7, r3
    89ac:	687b      	ldr	r3, [r7, #4]
    89ae:	0018      	movs	r0, r3
    89b0:	4b36      	ldr	r3, [pc, #216]	; (8a8c <tcp_close_shutdown+0x2a0>)
    89b2:	4798      	blx	r3
    89b4:	0003      	movs	r3, r0
    89b6:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
    89b8:	230f      	movs	r3, #15
    89ba:	18fb      	adds	r3, r7, r3
    89bc:	781b      	ldrb	r3, [r3, #0]
    89be:	b25b      	sxtb	r3, r3
    89c0:	2b00      	cmp	r3, #0
    89c2:	d12e      	bne.n	8a22 <tcp_close_shutdown+0x236>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    89c4:	687b      	ldr	r3, [r7, #4]
    89c6:	2205      	movs	r2, #5
    89c8:	761a      	strb	r2, [r3, #24]
    }
    break;
    89ca:	e02a      	b.n	8a22 <tcp_close_shutdown+0x236>
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
    89cc:	230f      	movs	r3, #15
    89ce:	18fc      	adds	r4, r7, r3
    89d0:	687b      	ldr	r3, [r7, #4]
    89d2:	0018      	movs	r0, r3
    89d4:	4b2d      	ldr	r3, [pc, #180]	; (8a8c <tcp_close_shutdown+0x2a0>)
    89d6:	4798      	blx	r3
    89d8:	0003      	movs	r3, r0
    89da:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
    89dc:	230f      	movs	r3, #15
    89de:	18fb      	adds	r3, r7, r3
    89e0:	781b      	ldrb	r3, [r3, #0]
    89e2:	b25b      	sxtb	r3, r3
    89e4:	2b00      	cmp	r3, #0
    89e6:	d11e      	bne.n	8a26 <tcp_close_shutdown+0x23a>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    89e8:	687b      	ldr	r3, [r7, #4]
    89ea:	2205      	movs	r2, #5
    89ec:	761a      	strb	r2, [r3, #24]
    }
    break;
    89ee:	e01a      	b.n	8a26 <tcp_close_shutdown+0x23a>
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
    89f0:	230f      	movs	r3, #15
    89f2:	18fc      	adds	r4, r7, r3
    89f4:	687b      	ldr	r3, [r7, #4]
    89f6:	0018      	movs	r0, r3
    89f8:	4b24      	ldr	r3, [pc, #144]	; (8a8c <tcp_close_shutdown+0x2a0>)
    89fa:	4798      	blx	r3
    89fc:	0003      	movs	r3, r0
    89fe:	7023      	strb	r3, [r4, #0]
    if (err == ERR_OK) {
    8a00:	230f      	movs	r3, #15
    8a02:	18fb      	adds	r3, r7, r3
    8a04:	781b      	ldrb	r3, [r3, #0]
    8a06:	b25b      	sxtb	r3, r3
    8a08:	2b00      	cmp	r3, #0
    8a0a:	d10e      	bne.n	8a2a <tcp_close_shutdown+0x23e>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    8a0c:	687b      	ldr	r3, [r7, #4]
    8a0e:	2209      	movs	r2, #9
    8a10:	761a      	strb	r2, [r3, #24]
    }
    break;
    8a12:	e00a      	b.n	8a2a <tcp_close_shutdown+0x23e>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    8a14:	230f      	movs	r3, #15
    8a16:	18fb      	adds	r3, r7, r3
    8a18:	2200      	movs	r2, #0
    8a1a:	701a      	strb	r2, [r3, #0]
    pcb = NULL;
    8a1c:	2300      	movs	r3, #0
    8a1e:	607b      	str	r3, [r7, #4]
    break;
    8a20:	e004      	b.n	8a2c <tcp_close_shutdown+0x240>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
    8a22:	46c0      	nop			; (mov r8, r8)
    8a24:	e002      	b.n	8a2c <tcp_close_shutdown+0x240>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
    8a26:	46c0      	nop			; (mov r8, r8)
    8a28:	e000      	b.n	8a2c <tcp_close_shutdown+0x240>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
    8a2a:	46c0      	nop			; (mov r8, r8)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
    8a2c:	687b      	ldr	r3, [r7, #4]
    8a2e:	2b00      	cmp	r3, #0
    8a30:	d009      	beq.n	8a46 <tcp_close_shutdown+0x25a>
    8a32:	230f      	movs	r3, #15
    8a34:	18fb      	adds	r3, r7, r3
    8a36:	781b      	ldrb	r3, [r3, #0]
    8a38:	b25b      	sxtb	r3, r3
    8a3a:	2b00      	cmp	r3, #0
    8a3c:	d103      	bne.n	8a46 <tcp_close_shutdown+0x25a>
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
    8a3e:	687b      	ldr	r3, [r7, #4]
    8a40:	0018      	movs	r0, r3
    8a42:	4b13      	ldr	r3, [pc, #76]	; (8a90 <tcp_close_shutdown+0x2a4>)
    8a44:	4798      	blx	r3
  }
  return err;
    8a46:	230f      	movs	r3, #15
    8a48:	18fb      	adds	r3, r7, r3
    8a4a:	781b      	ldrb	r3, [r3, #0]
    8a4c:	b25b      	sxtb	r3, r3
}
    8a4e:	0018      	movs	r0, r3
    8a50:	46bd      	mov	sp, r7
    8a52:	b004      	add	sp, #16
    8a54:	bdb0      	pop	{r4, r5, r7, pc}
    8a56:	46c0      	nop			; (mov r8, r8)
    8a58:	00000b68 	.word	0x00000b68
    8a5c:	0000cc35 	.word	0x0000cc35
    8a60:	000096c1 	.word	0x000096c1
    8a64:	20003ec4 	.word	0x20003ec4
    8a68:	20003ed0 	.word	0x20003ed0
    8a6c:	20003ec0 	.word	0x20003ec0
    8a70:	20003ed8 	.word	0x20003ed8
    8a74:	00007355 	.word	0x00007355
    8a78:	00007b39 	.word	0x00007b39
    8a7c:	0000fda0 	.word	0x0000fda0
    8a80:	20003ed4 	.word	0x20003ed4
    8a84:	20003ecc 	.word	0x20003ecc
    8a88:	0000974d 	.word	0x0000974d
    8a8c:	0000c1c1 	.word	0x0000c1c1
    8a90:	0000c6bd 	.word	0x0000c6bd

00008a94 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
    8a94:	b580      	push	{r7, lr}
    8a96:	b082      	sub	sp, #8
    8a98:	af00      	add	r7, sp, #0
    8a9a:	6078      	str	r0, [r7, #4]
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
    8a9c:	687b      	ldr	r3, [r7, #4]
    8a9e:	7e1b      	ldrb	r3, [r3, #24]
    8aa0:	2b01      	cmp	r3, #1
    8aa2:	d006      	beq.n	8ab2 <tcp_close+0x1e>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    8aa4:	687b      	ldr	r3, [r7, #4]
    8aa6:	7f9b      	ldrb	r3, [r3, #30]
    8aa8:	2210      	movs	r2, #16
    8aaa:	4313      	orrs	r3, r2
    8aac:	b2da      	uxtb	r2, r3
    8aae:	687b      	ldr	r3, [r7, #4]
    8ab0:	779a      	strb	r2, [r3, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
    8ab2:	687b      	ldr	r3, [r7, #4]
    8ab4:	2101      	movs	r1, #1
    8ab6:	0018      	movs	r0, r3
    8ab8:	4b03      	ldr	r3, [pc, #12]	; (8ac8 <tcp_close+0x34>)
    8aba:	4798      	blx	r3
    8abc:	0003      	movs	r3, r0
}
    8abe:	0018      	movs	r0, r3
    8ac0:	46bd      	mov	sp, r7
    8ac2:	b002      	add	sp, #8
    8ac4:	bd80      	pop	{r7, pc}
    8ac6:	46c0      	nop			; (mov r8, r8)
    8ac8:	000087ed 	.word	0x000087ed

00008acc <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
    8acc:	b5b0      	push	{r4, r5, r7, lr}
    8ace:	b088      	sub	sp, #32
    8ad0:	af02      	add	r7, sp, #8
    8ad2:	6078      	str	r0, [r7, #4]
    8ad4:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    8ad6:	687b      	ldr	r3, [r7, #4]
    8ad8:	7e1b      	ldrb	r3, [r3, #24]
    8ada:	2b0a      	cmp	r3, #10
    8adc:	d10b      	bne.n	8af6 <tcp_abandon+0x2a>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    8ade:	687a      	ldr	r2, [r7, #4]
    8ae0:	4b2f      	ldr	r3, [pc, #188]	; (8ba0 <tcp_abandon+0xd4>)
    8ae2:	0011      	movs	r1, r2
    8ae4:	0018      	movs	r0, r3
    8ae6:	4b2f      	ldr	r3, [pc, #188]	; (8ba4 <tcp_abandon+0xd8>)
    8ae8:	4798      	blx	r3
    memp_free(MEMP_TCP_PCB, pcb);
    8aea:	687b      	ldr	r3, [r7, #4]
    8aec:	0019      	movs	r1, r3
    8aee:	2001      	movs	r0, #1
    8af0:	4b2d      	ldr	r3, [pc, #180]	; (8ba8 <tcp_abandon+0xdc>)
    8af2:	4798      	blx	r3
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
    8af4:	e050      	b.n	8b98 <tcp_abandon+0xcc>
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
    8af6:	687b      	ldr	r3, [r7, #4]
    8af8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    8afa:	617b      	str	r3, [r7, #20]
    ackno = pcb->rcv_nxt;
    8afc:	687b      	ldr	r3, [r7, #4]
    8afe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    8b00:	613b      	str	r3, [r7, #16]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
    8b02:	687b      	ldr	r3, [r7, #4]
    8b04:	228c      	movs	r2, #140	; 0x8c
    8b06:	589b      	ldr	r3, [r3, r2]
    8b08:	60fb      	str	r3, [r7, #12]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    8b0a:	687b      	ldr	r3, [r7, #4]
    8b0c:	691b      	ldr	r3, [r3, #16]
    8b0e:	60bb      	str	r3, [r7, #8]
    TCP_PCB_REMOVE_ACTIVE(pcb);
    8b10:	687a      	ldr	r2, [r7, #4]
    8b12:	4b26      	ldr	r3, [pc, #152]	; (8bac <tcp_abandon+0xe0>)
    8b14:	0011      	movs	r1, r2
    8b16:	0018      	movs	r0, r3
    8b18:	4b22      	ldr	r3, [pc, #136]	; (8ba4 <tcp_abandon+0xd8>)
    8b1a:	4798      	blx	r3
    8b1c:	4b24      	ldr	r3, [pc, #144]	; (8bb0 <tcp_abandon+0xe4>)
    8b1e:	2201      	movs	r2, #1
    8b20:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
    8b22:	687b      	ldr	r3, [r7, #4]
    8b24:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    8b26:	2b00      	cmp	r3, #0
    8b28:	d004      	beq.n	8b34 <tcp_abandon+0x68>
      tcp_segs_free(pcb->unacked);
    8b2a:	687b      	ldr	r3, [r7, #4]
    8b2c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    8b2e:	0018      	movs	r0, r3
    8b30:	4b20      	ldr	r3, [pc, #128]	; (8bb4 <tcp_abandon+0xe8>)
    8b32:	4798      	blx	r3
    }
    if (pcb->unsent != NULL) {
    8b34:	687b      	ldr	r3, [r7, #4]
    8b36:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8b38:	2b00      	cmp	r3, #0
    8b3a:	d004      	beq.n	8b46 <tcp_abandon+0x7a>
      tcp_segs_free(pcb->unsent);
    8b3c:	687b      	ldr	r3, [r7, #4]
    8b3e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    8b40:	0018      	movs	r0, r3
    8b42:	4b1c      	ldr	r3, [pc, #112]	; (8bb4 <tcp_abandon+0xe8>)
    8b44:	4798      	blx	r3
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
    8b46:	687b      	ldr	r3, [r7, #4]
    8b48:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8b4a:	2b00      	cmp	r3, #0
    8b4c:	d004      	beq.n	8b58 <tcp_abandon+0x8c>
      tcp_segs_free(pcb->ooseq);
    8b4e:	687b      	ldr	r3, [r7, #4]
    8b50:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8b52:	0018      	movs	r0, r3
    8b54:	4b17      	ldr	r3, [pc, #92]	; (8bb4 <tcp_abandon+0xe8>)
    8b56:	4798      	blx	r3
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
    8b58:	683b      	ldr	r3, [r7, #0]
    8b5a:	2b00      	cmp	r3, #0
    8b5c:	d00e      	beq.n	8b7c <tcp_abandon+0xb0>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    8b5e:	687c      	ldr	r4, [r7, #4]
    8b60:	687b      	ldr	r3, [r7, #4]
    8b62:	1d1d      	adds	r5, r3, #4
    8b64:	687b      	ldr	r3, [r7, #4]
    8b66:	8b5b      	ldrh	r3, [r3, #26]
    8b68:	687a      	ldr	r2, [r7, #4]
    8b6a:	8b92      	ldrh	r2, [r2, #28]
    8b6c:	6939      	ldr	r1, [r7, #16]
    8b6e:	6978      	ldr	r0, [r7, #20]
    8b70:	9201      	str	r2, [sp, #4]
    8b72:	9300      	str	r3, [sp, #0]
    8b74:	002b      	movs	r3, r5
    8b76:	0022      	movs	r2, r4
    8b78:	4c0f      	ldr	r4, [pc, #60]	; (8bb8 <tcp_abandon+0xec>)
    8b7a:	47a0      	blx	r4
    }
    memp_free(MEMP_TCP_PCB, pcb);
    8b7c:	687b      	ldr	r3, [r7, #4]
    8b7e:	0019      	movs	r1, r3
    8b80:	2001      	movs	r0, #1
    8b82:	4b09      	ldr	r3, [pc, #36]	; (8ba8 <tcp_abandon+0xdc>)
    8b84:	4798      	blx	r3
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
    8b86:	68fb      	ldr	r3, [r7, #12]
    8b88:	2b00      	cmp	r3, #0
    8b8a:	d005      	beq.n	8b98 <tcp_abandon+0xcc>
    8b8c:	230a      	movs	r3, #10
    8b8e:	4259      	negs	r1, r3
    8b90:	68ba      	ldr	r2, [r7, #8]
    8b92:	68fb      	ldr	r3, [r7, #12]
    8b94:	0010      	movs	r0, r2
    8b96:	4798      	blx	r3
  }
}
    8b98:	46c0      	nop			; (mov r8, r8)
    8b9a:	46bd      	mov	sp, r7
    8b9c:	b006      	add	sp, #24
    8b9e:	bdb0      	pop	{r4, r5, r7, pc}
    8ba0:	20003ed8 	.word	0x20003ed8
    8ba4:	0000974d 	.word	0x0000974d
    8ba8:	00007b39 	.word	0x00007b39
    8bac:	20003ec4 	.word	0x20003ec4
    8bb0:	20003ec0 	.word	0x20003ec0
    8bb4:	0000937d 	.word	0x0000937d
    8bb8:	0000cc35 	.word	0x0000cc35

00008bbc <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
    8bbc:	b580      	push	{r7, lr}
    8bbe:	b082      	sub	sp, #8
    8bc0:	af00      	add	r7, sp, #0
    8bc2:	6078      	str	r0, [r7, #4]
  tcp_abandon(pcb, 1);
    8bc4:	687b      	ldr	r3, [r7, #4]
    8bc6:	2101      	movs	r1, #1
    8bc8:	0018      	movs	r0, r3
    8bca:	4b03      	ldr	r3, [pc, #12]	; (8bd8 <tcp_abort+0x1c>)
    8bcc:	4798      	blx	r3
}
    8bce:	46c0      	nop			; (mov r8, r8)
    8bd0:	46bd      	mov	sp, r7
    8bd2:	b002      	add	sp, #8
    8bd4:	bd80      	pop	{r7, pc}
    8bd6:	46c0      	nop			; (mov r8, r8)
    8bd8:	00008acd 	.word	0x00008acd

00008bdc <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
    8bdc:	b580      	push	{r7, lr}
    8bde:	b084      	sub	sp, #16
    8be0:	af00      	add	r7, sp, #0
    8be2:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
    8be4:	687b      	ldr	r3, [r7, #4]
    8be6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    8be8:	687a      	ldr	r2, [r7, #4]
    8bea:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
    8bec:	189b      	adds	r3, r3, r2
    8bee:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
    8bf0:	687b      	ldr	r3, [r7, #4]
    8bf2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    8bf4:	687a      	ldr	r2, [r7, #4]
    8bf6:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
    8bf8:	4916      	ldr	r1, [pc, #88]	; (8c54 <tcp_update_rcv_ann_wnd+0x78>)
    8bfa:	428a      	cmp	r2, r1
    8bfc:	d802      	bhi.n	8c04 <tcp_update_rcv_ann_wnd+0x28>
    8bfe:	687a      	ldr	r2, [r7, #4]
    8c00:	8ed2      	ldrh	r2, [r2, #54]	; 0x36
    8c02:	e000      	b.n	8c06 <tcp_update_rcv_ann_wnd+0x2a>
    8c04:	4a13      	ldr	r2, [pc, #76]	; (8c54 <tcp_update_rcv_ann_wnd+0x78>)
    8c06:	189b      	adds	r3, r3, r2
    8c08:	68fa      	ldr	r2, [r7, #12]
    8c0a:	1ad3      	subs	r3, r2, r3
    8c0c:	d408      	bmi.n	8c20 <tcp_update_rcv_ann_wnd+0x44>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
    8c0e:	687b      	ldr	r3, [r7, #4]
    8c10:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    8c12:	687b      	ldr	r3, [r7, #4]
    8c14:	85da      	strh	r2, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
    8c16:	687b      	ldr	r3, [r7, #4]
    8c18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    8c1a:	68fa      	ldr	r2, [r7, #12]
    8c1c:	1ad3      	subs	r3, r2, r3
    8c1e:	e015      	b.n	8c4c <tcp_update_rcv_ann_wnd+0x70>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
    8c20:	687b      	ldr	r3, [r7, #4]
    8c22:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    8c24:	687b      	ldr	r3, [r7, #4]
    8c26:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    8c28:	1ad3      	subs	r3, r2, r3
    8c2a:	2b00      	cmp	r3, #0
    8c2c:	dd03      	ble.n	8c36 <tcp_update_rcv_ann_wnd+0x5a>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    8c2e:	687b      	ldr	r3, [r7, #4]
    8c30:	2200      	movs	r2, #0
    8c32:	85da      	strh	r2, [r3, #46]	; 0x2e
    8c34:	e009      	b.n	8c4a <tcp_update_rcv_ann_wnd+0x6e>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
    8c36:	687b      	ldr	r3, [r7, #4]
    8c38:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    8c3a:	687b      	ldr	r3, [r7, #4]
    8c3c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    8c3e:	1ad3      	subs	r3, r2, r3
    8c40:	60bb      	str	r3, [r7, #8]
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
    8c42:	68bb      	ldr	r3, [r7, #8]
    8c44:	b29a      	uxth	r2, r3
    8c46:	687b      	ldr	r3, [r7, #4]
    8c48:	85da      	strh	r2, [r3, #46]	; 0x2e
    }
    return 0;
    8c4a:	2300      	movs	r3, #0
  }
}
    8c4c:	0018      	movs	r0, r3
    8c4e:	46bd      	mov	sp, r7
    8c50:	b004      	add	sp, #16
    8c52:	bd80      	pop	{r7, pc}
    8c54:	000005b4 	.word	0x000005b4

00008c58 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
    8c58:	b580      	push	{r7, lr}
    8c5a:	b084      	sub	sp, #16
    8c5c:	af00      	add	r7, sp, #0
    8c5e:	6078      	str	r0, [r7, #4]
    8c60:	000a      	movs	r2, r1
    8c62:	1cbb      	adds	r3, r7, #2
    8c64:	801a      	strh	r2, [r3, #0]
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
    8c66:	687b      	ldr	r3, [r7, #4]
    8c68:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    8c6a:	1cbb      	adds	r3, r7, #2
    8c6c:	881b      	ldrh	r3, [r3, #0]
    8c6e:	18d3      	adds	r3, r2, r3
    8c70:	b29a      	uxth	r2, r3
    8c72:	687b      	ldr	r3, [r7, #4]
    8c74:	859a      	strh	r2, [r3, #44]	; 0x2c
  if (pcb->rcv_wnd > TCP_WND) {
    8c76:	687b      	ldr	r3, [r7, #4]
    8c78:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    8c7a:	4a0f      	ldr	r2, [pc, #60]	; (8cb8 <tcp_recved+0x60>)
    8c7c:	4293      	cmp	r3, r2
    8c7e:	d902      	bls.n	8c86 <tcp_recved+0x2e>
    pcb->rcv_wnd = TCP_WND;
    8c80:	687b      	ldr	r3, [r7, #4]
    8c82:	4a0d      	ldr	r2, [pc, #52]	; (8cb8 <tcp_recved+0x60>)
    8c84:	859a      	strh	r2, [r3, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
    8c86:	687b      	ldr	r3, [r7, #4]
    8c88:	0018      	movs	r0, r3
    8c8a:	4b0c      	ldr	r3, [pc, #48]	; (8cbc <tcp_recved+0x64>)
    8c8c:	4798      	blx	r3
    8c8e:	0003      	movs	r3, r0
    8c90:	60fb      	str	r3, [r7, #12]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    8c92:	68fb      	ldr	r3, [r7, #12]
    8c94:	4a0a      	ldr	r2, [pc, #40]	; (8cc0 <tcp_recved+0x68>)
    8c96:	4293      	cmp	r3, r2
    8c98:	dd0a      	ble.n	8cb0 <tcp_recved+0x58>
    tcp_ack_now(pcb);
    8c9a:	687b      	ldr	r3, [r7, #4]
    8c9c:	7f9b      	ldrb	r3, [r3, #30]
    8c9e:	2202      	movs	r2, #2
    8ca0:	4313      	orrs	r3, r2
    8ca2:	b2da      	uxtb	r2, r3
    8ca4:	687b      	ldr	r3, [r7, #4]
    8ca6:	779a      	strb	r2, [r3, #30]
    tcp_output(pcb);
    8ca8:	687b      	ldr	r3, [r7, #4]
    8caa:	0018      	movs	r0, r3
    8cac:	4b05      	ldr	r3, [pc, #20]	; (8cc4 <tcp_recved+0x6c>)
    8cae:	4798      	blx	r3
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
    8cb0:	46c0      	nop			; (mov r8, r8)
    8cb2:	46bd      	mov	sp, r7
    8cb4:	b004      	add	sp, #16
    8cb6:	bd80      	pop	{r7, pc}
    8cb8:	00000b68 	.word	0x00000b68
    8cbc:	00008bdd 	.word	0x00008bdd
    8cc0:	000002d9 	.word	0x000002d9
    8cc4:	0000c6bd 	.word	0x0000c6bd

00008cc8 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
    8cc8:	b5b0      	push	{r4, r5, r7, lr}
    8cca:	b08a      	sub	sp, #40	; 0x28
    8ccc:	af02      	add	r7, sp, #8
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
    8cce:	2315      	movs	r3, #21
    8cd0:	18fb      	adds	r3, r7, r3
    8cd2:	2200      	movs	r2, #0
    8cd4:	701a      	strb	r2, [r3, #0]

  ++tcp_ticks;
    8cd6:	4bca      	ldr	r3, [pc, #808]	; (9000 <tcp_slowtmr+0x338>)
    8cd8:	681b      	ldr	r3, [r3, #0]
    8cda:	1c5a      	adds	r2, r3, #1
    8cdc:	4bc8      	ldr	r3, [pc, #800]	; (9000 <tcp_slowtmr+0x338>)
    8cde:	601a      	str	r2, [r3, #0]
  ++tcp_timer_ctr;
    8ce0:	4bc8      	ldr	r3, [pc, #800]	; (9004 <tcp_slowtmr+0x33c>)
    8ce2:	781b      	ldrb	r3, [r3, #0]
    8ce4:	3301      	adds	r3, #1
    8ce6:	b2da      	uxtb	r2, r3
    8ce8:	4bc6      	ldr	r3, [pc, #792]	; (9004 <tcp_slowtmr+0x33c>)
    8cea:	701a      	strb	r2, [r3, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
    8cec:	2300      	movs	r3, #0
    8cee:	61bb      	str	r3, [r7, #24]
  pcb = tcp_active_pcbs;
    8cf0:	4bc5      	ldr	r3, [pc, #788]	; (9008 <tcp_slowtmr+0x340>)
    8cf2:	681b      	ldr	r3, [r3, #0]
    8cf4:	61fb      	str	r3, [r7, #28]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    8cf6:	e216      	b.n	9126 <tcp_slowtmr+0x45e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
    8cf8:	69fb      	ldr	r3, [r7, #28]
    8cfa:	2221      	movs	r2, #33	; 0x21
    8cfc:	5c9a      	ldrb	r2, [r3, r2]
    8cfe:	4bc1      	ldr	r3, [pc, #772]	; (9004 <tcp_slowtmr+0x33c>)
    8d00:	781b      	ldrb	r3, [r3, #0]
    8d02:	429a      	cmp	r2, r3
    8d04:	d103      	bne.n	8d0e <tcp_slowtmr+0x46>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
    8d06:	69fb      	ldr	r3, [r7, #28]
    8d08:	68db      	ldr	r3, [r3, #12]
    8d0a:	61fb      	str	r3, [r7, #28]
      continue;
    8d0c:	e20b      	b.n	9126 <tcp_slowtmr+0x45e>
    }
    pcb->last_timer = tcp_timer_ctr;
    8d0e:	4bbd      	ldr	r3, [pc, #756]	; (9004 <tcp_slowtmr+0x33c>)
    8d10:	7819      	ldrb	r1, [r3, #0]
    8d12:	69fb      	ldr	r3, [r7, #28]
    8d14:	2221      	movs	r2, #33	; 0x21
    8d16:	5499      	strb	r1, [r3, r2]

    pcb_remove = 0;
    8d18:	2317      	movs	r3, #23
    8d1a:	18fb      	adds	r3, r7, r3
    8d1c:	2200      	movs	r2, #0
    8d1e:	701a      	strb	r2, [r3, #0]
    pcb_reset = 0;
    8d20:	2316      	movs	r3, #22
    8d22:	18fb      	adds	r3, r7, r3
    8d24:	2200      	movs	r2, #0
    8d26:	701a      	strb	r2, [r3, #0]

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
    8d28:	69fb      	ldr	r3, [r7, #28]
    8d2a:	7e1b      	ldrb	r3, [r3, #24]
    8d2c:	2b02      	cmp	r3, #2
    8d2e:	d10c      	bne.n	8d4a <tcp_slowtmr+0x82>
    8d30:	69fb      	ldr	r3, [r7, #28]
    8d32:	2246      	movs	r2, #70	; 0x46
    8d34:	5c9b      	ldrb	r3, [r3, r2]
    8d36:	2b06      	cmp	r3, #6
    8d38:	d107      	bne.n	8d4a <tcp_slowtmr+0x82>
      ++pcb_remove;
    8d3a:	2317      	movs	r3, #23
    8d3c:	18fb      	adds	r3, r7, r3
    8d3e:	2217      	movs	r2, #23
    8d40:	18ba      	adds	r2, r7, r2
    8d42:	7812      	ldrb	r2, [r2, #0]
    8d44:	3201      	adds	r2, #1
    8d46:	701a      	strb	r2, [r3, #0]
    8d48:	e0a2      	b.n	8e90 <tcp_slowtmr+0x1c8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
    8d4a:	69fb      	ldr	r3, [r7, #28]
    8d4c:	2246      	movs	r2, #70	; 0x46
    8d4e:	5c9b      	ldrb	r3, [r3, r2]
    8d50:	2b0c      	cmp	r3, #12
    8d52:	d107      	bne.n	8d64 <tcp_slowtmr+0x9c>
      ++pcb_remove;
    8d54:	2317      	movs	r3, #23
    8d56:	18fb      	adds	r3, r7, r3
    8d58:	2217      	movs	r2, #23
    8d5a:	18ba      	adds	r2, r7, r2
    8d5c:	7812      	ldrb	r2, [r2, #0]
    8d5e:	3201      	adds	r2, #1
    8d60:	701a      	strb	r2, [r3, #0]
    8d62:	e095      	b.n	8e90 <tcp_slowtmr+0x1c8>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
    8d64:	69fb      	ldr	r3, [r7, #28]
    8d66:	2295      	movs	r2, #149	; 0x95
    8d68:	5c9b      	ldrb	r3, [r3, r2]
    8d6a:	2b00      	cmp	r3, #0
    8d6c:	d029      	beq.n	8dc2 <tcp_slowtmr+0xfa>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
    8d6e:	69fb      	ldr	r3, [r7, #28]
    8d70:	2294      	movs	r2, #148	; 0x94
    8d72:	5c9b      	ldrb	r3, [r3, r2]
    8d74:	3301      	adds	r3, #1
    8d76:	b2d9      	uxtb	r1, r3
    8d78:	69fb      	ldr	r3, [r7, #28]
    8d7a:	2294      	movs	r2, #148	; 0x94
    8d7c:	5499      	strb	r1, [r3, r2]
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
    8d7e:	69fb      	ldr	r3, [r7, #28]
    8d80:	2294      	movs	r2, #148	; 0x94
    8d82:	5c9a      	ldrb	r2, [r3, r2]
    8d84:	69fb      	ldr	r3, [r7, #28]
    8d86:	2195      	movs	r1, #149	; 0x95
    8d88:	5c5b      	ldrb	r3, [r3, r1]
    8d8a:	3b01      	subs	r3, #1
    8d8c:	499f      	ldr	r1, [pc, #636]	; (900c <tcp_slowtmr+0x344>)
    8d8e:	5ccb      	ldrb	r3, [r1, r3]
    8d90:	429a      	cmp	r2, r3
    8d92:	d200      	bcs.n	8d96 <tcp_slowtmr+0xce>
    8d94:	e07c      	b.n	8e90 <tcp_slowtmr+0x1c8>
          pcb->persist_cnt = 0;
    8d96:	69fb      	ldr	r3, [r7, #28]
    8d98:	2294      	movs	r2, #148	; 0x94
    8d9a:	2100      	movs	r1, #0
    8d9c:	5499      	strb	r1, [r3, r2]
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
    8d9e:	69fb      	ldr	r3, [r7, #28]
    8da0:	2295      	movs	r2, #149	; 0x95
    8da2:	5c9b      	ldrb	r3, [r3, r2]
    8da4:	2b06      	cmp	r3, #6
    8da6:	d807      	bhi.n	8db8 <tcp_slowtmr+0xf0>
            pcb->persist_backoff++;
    8da8:	69fb      	ldr	r3, [r7, #28]
    8daa:	2295      	movs	r2, #149	; 0x95
    8dac:	5c9b      	ldrb	r3, [r3, r2]
    8dae:	3301      	adds	r3, #1
    8db0:	b2d9      	uxtb	r1, r3
    8db2:	69fb      	ldr	r3, [r7, #28]
    8db4:	2295      	movs	r2, #149	; 0x95
    8db6:	5499      	strb	r1, [r3, r2]
          }
          tcp_zero_window_probe(pcb);
    8db8:	69fb      	ldr	r3, [r7, #28]
    8dba:	0018      	movs	r0, r3
    8dbc:	4b94      	ldr	r3, [pc, #592]	; (9010 <tcp_slowtmr+0x348>)
    8dbe:	4798      	blx	r3
    8dc0:	e066      	b.n	8e90 <tcp_slowtmr+0x1c8>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
    8dc2:	69fb      	ldr	r3, [r7, #28]
    8dc4:	2234      	movs	r2, #52	; 0x34
    8dc6:	5e9b      	ldrsh	r3, [r3, r2]
    8dc8:	2b00      	cmp	r3, #0
    8dca:	db08      	blt.n	8dde <tcp_slowtmr+0x116>
          ++pcb->rtime;
    8dcc:	69fb      	ldr	r3, [r7, #28]
    8dce:	2234      	movs	r2, #52	; 0x34
    8dd0:	5e9b      	ldrsh	r3, [r3, r2]
    8dd2:	b29b      	uxth	r3, r3
    8dd4:	3301      	adds	r3, #1
    8dd6:	b29b      	uxth	r3, r3
    8dd8:	b21a      	sxth	r2, r3
    8dda:	69fb      	ldr	r3, [r7, #28]
    8ddc:	869a      	strh	r2, [r3, #52]	; 0x34
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
    8dde:	69fb      	ldr	r3, [r7, #28]
    8de0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    8de2:	2b00      	cmp	r3, #0
    8de4:	d054      	beq.n	8e90 <tcp_slowtmr+0x1c8>
    8de6:	69fb      	ldr	r3, [r7, #28]
    8de8:	2234      	movs	r2, #52	; 0x34
    8dea:	5e9a      	ldrsh	r2, [r3, r2]
    8dec:	69fb      	ldr	r3, [r7, #28]
    8dee:	2144      	movs	r1, #68	; 0x44
    8df0:	5e5b      	ldrsh	r3, [r3, r1]
    8df2:	429a      	cmp	r2, r3
    8df4:	db4c      	blt.n	8e90 <tcp_slowtmr+0x1c8>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
    8df6:	69fb      	ldr	r3, [r7, #28]
    8df8:	7e1b      	ldrb	r3, [r3, #24]
    8dfa:	2b02      	cmp	r3, #2
    8dfc:	d014      	beq.n	8e28 <tcp_slowtmr+0x160>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
    8dfe:	69fb      	ldr	r3, [r7, #28]
    8e00:	2240      	movs	r2, #64	; 0x40
    8e02:	5e9b      	ldrsh	r3, [r3, r2]
    8e04:	10db      	asrs	r3, r3, #3
    8e06:	b21b      	sxth	r3, r3
    8e08:	0019      	movs	r1, r3
    8e0a:	69fb      	ldr	r3, [r7, #28]
    8e0c:	2242      	movs	r2, #66	; 0x42
    8e0e:	5e9b      	ldrsh	r3, [r3, r2]
    8e10:	18cb      	adds	r3, r1, r3
    8e12:	69fa      	ldr	r2, [r7, #28]
    8e14:	2146      	movs	r1, #70	; 0x46
    8e16:	5c52      	ldrb	r2, [r2, r1]
    8e18:	0011      	movs	r1, r2
    8e1a:	4a7e      	ldr	r2, [pc, #504]	; (9014 <tcp_slowtmr+0x34c>)
    8e1c:	5c52      	ldrb	r2, [r2, r1]
    8e1e:	4093      	lsls	r3, r2
    8e20:	b219      	sxth	r1, r3
    8e22:	69fb      	ldr	r3, [r7, #28]
    8e24:	2244      	movs	r2, #68	; 0x44
    8e26:	5299      	strh	r1, [r3, r2]
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
    8e28:	69fb      	ldr	r3, [r7, #28]
    8e2a:	2200      	movs	r2, #0
    8e2c:	869a      	strh	r2, [r3, #52]	; 0x34

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
    8e2e:	69fb      	ldr	r3, [r7, #28]
    8e30:	2260      	movs	r2, #96	; 0x60
    8e32:	5a99      	ldrh	r1, [r3, r2]
    8e34:	69fb      	ldr	r3, [r7, #28]
    8e36:	224c      	movs	r2, #76	; 0x4c
    8e38:	5a9b      	ldrh	r3, [r3, r2]
    8e3a:	2212      	movs	r2, #18
    8e3c:	18ba      	adds	r2, r7, r2
    8e3e:	1c1c      	adds	r4, r3, #0
    8e40:	1c0b      	adds	r3, r1, #0
    8e42:	b298      	uxth	r0, r3
    8e44:	b2a1      	uxth	r1, r4
    8e46:	4288      	cmp	r0, r1
    8e48:	d900      	bls.n	8e4c <tcp_slowtmr+0x184>
    8e4a:	1c23      	adds	r3, r4, #0
    8e4c:	8013      	strh	r3, [r2, #0]
          pcb->ssthresh = eff_wnd >> 1;
    8e4e:	2312      	movs	r3, #18
    8e50:	18fb      	adds	r3, r7, r3
    8e52:	881b      	ldrh	r3, [r3, #0]
    8e54:	085b      	lsrs	r3, r3, #1
    8e56:	b299      	uxth	r1, r3
    8e58:	69fb      	ldr	r3, [r7, #28]
    8e5a:	224e      	movs	r2, #78	; 0x4e
    8e5c:	5299      	strh	r1, [r3, r2]
          if (pcb->ssthresh < (pcb->mss << 1)) {
    8e5e:	69fb      	ldr	r3, [r7, #28]
    8e60:	224e      	movs	r2, #78	; 0x4e
    8e62:	5a9b      	ldrh	r3, [r3, r2]
    8e64:	001a      	movs	r2, r3
    8e66:	69fb      	ldr	r3, [r7, #28]
    8e68:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    8e6a:	005b      	lsls	r3, r3, #1
    8e6c:	429a      	cmp	r2, r3
    8e6e:	da06      	bge.n	8e7e <tcp_slowtmr+0x1b6>
            pcb->ssthresh = (pcb->mss << 1);
    8e70:	69fb      	ldr	r3, [r7, #28]
    8e72:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    8e74:	18db      	adds	r3, r3, r3
    8e76:	b299      	uxth	r1, r3
    8e78:	69fb      	ldr	r3, [r7, #28]
    8e7a:	224e      	movs	r2, #78	; 0x4e
    8e7c:	5299      	strh	r1, [r3, r2]
          }
          pcb->cwnd = pcb->mss;
    8e7e:	69fb      	ldr	r3, [r7, #28]
    8e80:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
    8e82:	69fb      	ldr	r3, [r7, #28]
    8e84:	224c      	movs	r2, #76	; 0x4c
    8e86:	5299      	strh	r1, [r3, r2]
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
    8e88:	69fb      	ldr	r3, [r7, #28]
    8e8a:	0018      	movs	r0, r3
    8e8c:	4b62      	ldr	r3, [pc, #392]	; (9018 <tcp_slowtmr+0x350>)
    8e8e:	4798      	blx	r3
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
    8e90:	69fb      	ldr	r3, [r7, #28]
    8e92:	7e1b      	ldrb	r3, [r3, #24]
    8e94:	2b06      	cmp	r3, #6
    8e96:	d113      	bne.n	8ec0 <tcp_slowtmr+0x1f8>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
    8e98:	69fb      	ldr	r3, [r7, #28]
    8e9a:	7f9b      	ldrb	r3, [r3, #30]
    8e9c:	001a      	movs	r2, r3
    8e9e:	2310      	movs	r3, #16
    8ea0:	4013      	ands	r3, r2
    8ea2:	d00d      	beq.n	8ec0 <tcp_slowtmr+0x1f8>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
    8ea4:	4b56      	ldr	r3, [pc, #344]	; (9000 <tcp_slowtmr+0x338>)
    8ea6:	681a      	ldr	r2, [r3, #0]
    8ea8:	69fb      	ldr	r3, [r7, #28]
    8eaa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8eac:	1ad3      	subs	r3, r2, r3
    8eae:	2b28      	cmp	r3, #40	; 0x28
    8eb0:	d906      	bls.n	8ec0 <tcp_slowtmr+0x1f8>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
    8eb2:	2317      	movs	r3, #23
    8eb4:	18fb      	adds	r3, r7, r3
    8eb6:	2217      	movs	r2, #23
    8eb8:	18ba      	adds	r2, r7, r2
    8eba:	7812      	ldrb	r2, [r2, #0]
    8ebc:	3201      	adds	r2, #1
    8ebe:	701a      	strb	r2, [r3, #0]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
    8ec0:	69fb      	ldr	r3, [r7, #28]
    8ec2:	7a1b      	ldrb	r3, [r3, #8]
    8ec4:	001a      	movs	r2, r3
    8ec6:	2308      	movs	r3, #8
    8ec8:	4013      	ands	r3, r2
    8eca:	d049      	beq.n	8f60 <tcp_slowtmr+0x298>
       ((pcb->state == ESTABLISHED) ||
    8ecc:	69fb      	ldr	r3, [r7, #28]
    8ece:	7e1b      	ldrb	r3, [r3, #24]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
    8ed0:	2b04      	cmp	r3, #4
    8ed2:	d003      	beq.n	8edc <tcp_slowtmr+0x214>
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
    8ed4:	69fb      	ldr	r3, [r7, #28]
    8ed6:	7e1b      	ldrb	r3, [r3, #24]
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
    8ed8:	2b07      	cmp	r3, #7
    8eda:	d141      	bne.n	8f60 <tcp_slowtmr+0x298>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
    8edc:	4b48      	ldr	r3, [pc, #288]	; (9000 <tcp_slowtmr+0x338>)
    8ede:	681a      	ldr	r2, [r3, #0]
    8ee0:	69fb      	ldr	r3, [r7, #28]
    8ee2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8ee4:	1ad4      	subs	r4, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
    8ee6:	69fb      	ldr	r3, [r7, #28]
    8ee8:	2290      	movs	r2, #144	; 0x90
    8eea:	589b      	ldr	r3, [r3, r2]
    8eec:	4a4b      	ldr	r2, [pc, #300]	; (901c <tcp_slowtmr+0x354>)
    8eee:	1898      	adds	r0, r3, r2
    8ef0:	4b4b      	ldr	r3, [pc, #300]	; (9020 <tcp_slowtmr+0x358>)
    8ef2:	22fa      	movs	r2, #250	; 0xfa
    8ef4:	0051      	lsls	r1, r2, #1
    8ef6:	4798      	blx	r3
    8ef8:	0003      	movs	r3, r0

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
    8efa:	429c      	cmp	r4, r3
    8efc:	d90e      	bls.n	8f1c <tcp_slowtmr+0x254>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
    8efe:	2317      	movs	r3, #23
    8f00:	18fb      	adds	r3, r7, r3
    8f02:	2217      	movs	r2, #23
    8f04:	18ba      	adds	r2, r7, r2
    8f06:	7812      	ldrb	r2, [r2, #0]
    8f08:	3201      	adds	r2, #1
    8f0a:	701a      	strb	r2, [r3, #0]
        ++pcb_reset;
    8f0c:	2316      	movs	r3, #22
    8f0e:	18fb      	adds	r3, r7, r3
    8f10:	2216      	movs	r2, #22
    8f12:	18ba      	adds	r2, r7, r2
    8f14:	7812      	ldrb	r2, [r2, #0]
    8f16:	3201      	adds	r2, #1
    8f18:	701a      	strb	r2, [r3, #0]
    8f1a:	e021      	b.n	8f60 <tcp_slowtmr+0x298>
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    8f1c:	4b38      	ldr	r3, [pc, #224]	; (9000 <tcp_slowtmr+0x338>)
    8f1e:	681a      	ldr	r2, [r3, #0]
    8f20:	69fb      	ldr	r3, [r7, #28]
    8f22:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8f24:	1ad4      	subs	r4, r2, r3
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
    8f26:	69fb      	ldr	r3, [r7, #28]
    8f28:	2290      	movs	r2, #144	; 0x90
    8f2a:	589a      	ldr	r2, [r3, r2]
    8f2c:	69fb      	ldr	r3, [r7, #28]
    8f2e:	2196      	movs	r1, #150	; 0x96
    8f30:	5c5b      	ldrb	r3, [r3, r1]
    8f32:	0019      	movs	r1, r3
    8f34:	4b3b      	ldr	r3, [pc, #236]	; (9024 <tcp_slowtmr+0x35c>)
    8f36:	434b      	muls	r3, r1
    8f38:	18d0      	adds	r0, r2, r3
              / TCP_SLOW_INTERVAL)
    8f3a:	4b39      	ldr	r3, [pc, #228]	; (9020 <tcp_slowtmr+0x358>)
    8f3c:	22fa      	movs	r2, #250	; 0xfa
    8f3e:	0051      	lsls	r1, r2, #1
    8f40:	4798      	blx	r3
    8f42:	0003      	movs	r3, r0
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
    8f44:	429c      	cmp	r4, r3
    8f46:	d90b      	bls.n	8f60 <tcp_slowtmr+0x298>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
    8f48:	69fb      	ldr	r3, [r7, #28]
    8f4a:	0018      	movs	r0, r3
    8f4c:	4b36      	ldr	r3, [pc, #216]	; (9028 <tcp_slowtmr+0x360>)
    8f4e:	4798      	blx	r3
        pcb->keep_cnt_sent++;
    8f50:	69fb      	ldr	r3, [r7, #28]
    8f52:	2296      	movs	r2, #150	; 0x96
    8f54:	5c9b      	ldrb	r3, [r3, r2]
    8f56:	3301      	adds	r3, #1
    8f58:	b2d9      	uxtb	r1, r3
    8f5a:	69fb      	ldr	r3, [r7, #28]
    8f5c:	2296      	movs	r2, #150	; 0x96
    8f5e:	5499      	strb	r1, [r3, r2]

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
    8f60:	69fb      	ldr	r3, [r7, #28]
    8f62:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8f64:	2b00      	cmp	r3, #0
    8f66:	d016      	beq.n	8f96 <tcp_slowtmr+0x2ce>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
    8f68:	4b25      	ldr	r3, [pc, #148]	; (9000 <tcp_slowtmr+0x338>)
    8f6a:	681a      	ldr	r2, [r3, #0]
    8f6c:	69fb      	ldr	r3, [r7, #28]
    8f6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8f70:	1ad2      	subs	r2, r2, r3
    8f72:	69fb      	ldr	r3, [r7, #28]
    8f74:	2144      	movs	r1, #68	; 0x44
    8f76:	5e5b      	ldrsh	r3, [r3, r1]
    8f78:	0019      	movs	r1, r3
    8f7a:	000b      	movs	r3, r1
    8f7c:	005b      	lsls	r3, r3, #1
    8f7e:	185b      	adds	r3, r3, r1
    8f80:	005b      	lsls	r3, r3, #1

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
    8f82:	429a      	cmp	r2, r3
    8f84:	d307      	bcc.n	8f96 <tcp_slowtmr+0x2ce>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
    8f86:	69fb      	ldr	r3, [r7, #28]
    8f88:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8f8a:	0018      	movs	r0, r3
    8f8c:	4b27      	ldr	r3, [pc, #156]	; (902c <tcp_slowtmr+0x364>)
    8f8e:	4798      	blx	r3
      pcb->ooseq = NULL;
    8f90:	69fb      	ldr	r3, [r7, #28]
    8f92:	2200      	movs	r2, #0
    8f94:	675a      	str	r2, [r3, #116]	; 0x74
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
    8f96:	69fb      	ldr	r3, [r7, #28]
    8f98:	7e1b      	ldrb	r3, [r3, #24]
    8f9a:	2b03      	cmp	r3, #3
    8f9c:	d10d      	bne.n	8fba <tcp_slowtmr+0x2f2>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
    8f9e:	4b18      	ldr	r3, [pc, #96]	; (9000 <tcp_slowtmr+0x338>)
    8fa0:	681a      	ldr	r2, [r3, #0]
    8fa2:	69fb      	ldr	r3, [r7, #28]
    8fa4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8fa6:	1ad3      	subs	r3, r2, r3
    8fa8:	2b28      	cmp	r3, #40	; 0x28
    8faa:	d906      	bls.n	8fba <tcp_slowtmr+0x2f2>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
    8fac:	2317      	movs	r3, #23
    8fae:	18fb      	adds	r3, r7, r3
    8fb0:	2217      	movs	r2, #23
    8fb2:	18ba      	adds	r2, r7, r2
    8fb4:	7812      	ldrb	r2, [r2, #0]
    8fb6:	3201      	adds	r2, #1
    8fb8:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
    8fba:	69fb      	ldr	r3, [r7, #28]
    8fbc:	7e1b      	ldrb	r3, [r3, #24]
    8fbe:	2b09      	cmp	r3, #9
    8fc0:	d10d      	bne.n	8fde <tcp_slowtmr+0x316>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    8fc2:	4b0f      	ldr	r3, [pc, #60]	; (9000 <tcp_slowtmr+0x338>)
    8fc4:	681a      	ldr	r2, [r3, #0]
    8fc6:	69fb      	ldr	r3, [r7, #28]
    8fc8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8fca:	1ad3      	subs	r3, r2, r3
    8fcc:	2bf0      	cmp	r3, #240	; 0xf0
    8fce:	d906      	bls.n	8fde <tcp_slowtmr+0x316>
        ++pcb_remove;
    8fd0:	2317      	movs	r3, #23
    8fd2:	18fb      	adds	r3, r7, r3
    8fd4:	2217      	movs	r2, #23
    8fd6:	18ba      	adds	r2, r7, r2
    8fd8:	7812      	ldrb	r2, [r2, #0]
    8fda:	3201      	adds	r2, #1
    8fdc:	701a      	strb	r2, [r3, #0]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    8fde:	2317      	movs	r3, #23
    8fe0:	18fb      	adds	r3, r7, r3
    8fe2:	781b      	ldrb	r3, [r3, #0]
    8fe4:	2b00      	cmp	r3, #0
    8fe6:	d061      	beq.n	90ac <tcp_slowtmr+0x3e4>
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
    8fe8:	69fb      	ldr	r3, [r7, #28]
    8fea:	0018      	movs	r0, r3
    8fec:	4b10      	ldr	r3, [pc, #64]	; (9030 <tcp_slowtmr+0x368>)
    8fee:	4798      	blx	r3
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
    8ff0:	69bb      	ldr	r3, [r7, #24]
    8ff2:	2b00      	cmp	r3, #0
    8ff4:	d01e      	beq.n	9034 <tcp_slowtmr+0x36c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
    8ff6:	69fb      	ldr	r3, [r7, #28]
    8ff8:	68da      	ldr	r2, [r3, #12]
    8ffa:	69bb      	ldr	r3, [r7, #24]
    8ffc:	60da      	str	r2, [r3, #12]
    8ffe:	e01d      	b.n	903c <tcp_slowtmr+0x374>
    9000:	20003ec8 	.word	0x20003ec8
    9004:	20002c6d 	.word	0x20002c6d
    9008:	20003ec4 	.word	0x20003ec4
    900c:	0000fd98 	.word	0x0000fd98
    9010:	0000d07d 	.word	0x0000d07d
    9014:	0000fd88 	.word	0x0000fd88
    9018:	0000ce3d 	.word	0x0000ce3d
    901c:	000a4cb8 	.word	0x000a4cb8
    9020:	0000f8ed 	.word	0x0000f8ed
    9024:	000124f8 	.word	0x000124f8
    9028:	0000d011 	.word	0x0000d011
    902c:	0000937d 	.word	0x0000937d
    9030:	000096c1 	.word	0x000096c1
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
    9034:	69fb      	ldr	r3, [r7, #28]
    9036:	68da      	ldr	r2, [r3, #12]
    9038:	4b5f      	ldr	r3, [pc, #380]	; (91b8 <tcp_slowtmr+0x4f0>)
    903a:	601a      	str	r2, [r3, #0]
      }

      if (pcb_reset) {
    903c:	2316      	movs	r3, #22
    903e:	18fb      	adds	r3, r7, r3
    9040:	781b      	ldrb	r3, [r3, #0]
    9042:	2b00      	cmp	r3, #0
    9044:	d010      	beq.n	9068 <tcp_slowtmr+0x3a0>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
    9046:	69fb      	ldr	r3, [r7, #28]
    9048:	6d18      	ldr	r0, [r3, #80]	; 0x50
    904a:	69fb      	ldr	r3, [r7, #28]
    904c:	6a99      	ldr	r1, [r3, #40]	; 0x28
    904e:	69fc      	ldr	r4, [r7, #28]
    9050:	69fb      	ldr	r3, [r7, #28]
    9052:	1d1d      	adds	r5, r3, #4
    9054:	69fb      	ldr	r3, [r7, #28]
    9056:	8b5b      	ldrh	r3, [r3, #26]
    9058:	69fa      	ldr	r2, [r7, #28]
    905a:	8b92      	ldrh	r2, [r2, #28]
    905c:	9201      	str	r2, [sp, #4]
    905e:	9300      	str	r3, [sp, #0]
    9060:	002b      	movs	r3, r5
    9062:	0022      	movs	r2, r4
    9064:	4c55      	ldr	r4, [pc, #340]	; (91bc <tcp_slowtmr+0x4f4>)
    9066:	47a0      	blx	r4
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
    9068:	69fb      	ldr	r3, [r7, #28]
    906a:	228c      	movs	r2, #140	; 0x8c
    906c:	589b      	ldr	r3, [r3, r2]
    906e:	60fb      	str	r3, [r7, #12]
      err_arg = pcb->callback_arg;
    9070:	69fb      	ldr	r3, [r7, #28]
    9072:	691b      	ldr	r3, [r3, #16]
    9074:	60bb      	str	r3, [r7, #8]
      pcb2 = pcb;
    9076:	69fb      	ldr	r3, [r7, #28]
    9078:	607b      	str	r3, [r7, #4]
      pcb = pcb->next;
    907a:	69fb      	ldr	r3, [r7, #28]
    907c:	68db      	ldr	r3, [r3, #12]
    907e:	61fb      	str	r3, [r7, #28]
      memp_free(MEMP_TCP_PCB, pcb2);
    9080:	687b      	ldr	r3, [r7, #4]
    9082:	0019      	movs	r1, r3
    9084:	2001      	movs	r0, #1
    9086:	4b4e      	ldr	r3, [pc, #312]	; (91c0 <tcp_slowtmr+0x4f8>)
    9088:	4798      	blx	r3

      tcp_active_pcbs_changed = 0;
    908a:	4b4e      	ldr	r3, [pc, #312]	; (91c4 <tcp_slowtmr+0x4fc>)
    908c:	2200      	movs	r2, #0
    908e:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
    9090:	68fb      	ldr	r3, [r7, #12]
    9092:	2b00      	cmp	r3, #0
    9094:	d005      	beq.n	90a2 <tcp_slowtmr+0x3da>
    9096:	230a      	movs	r3, #10
    9098:	4259      	negs	r1, r3
    909a:	68ba      	ldr	r2, [r7, #8]
    909c:	68fb      	ldr	r3, [r7, #12]
    909e:	0010      	movs	r0, r2
    90a0:	4798      	blx	r3
      if (tcp_active_pcbs_changed) {
    90a2:	4b48      	ldr	r3, [pc, #288]	; (91c4 <tcp_slowtmr+0x4fc>)
    90a4:	781b      	ldrb	r3, [r3, #0]
    90a6:	2b00      	cmp	r3, #0
    90a8:	d03d      	beq.n	9126 <tcp_slowtmr+0x45e>
        goto tcp_slowtmr_start;
    90aa:	e61f      	b.n	8cec <tcp_slowtmr+0x24>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
    90ac:	69fb      	ldr	r3, [r7, #28]
    90ae:	61bb      	str	r3, [r7, #24]
      pcb = pcb->next;
    90b0:	69fb      	ldr	r3, [r7, #28]
    90b2:	68db      	ldr	r3, [r3, #12]
    90b4:	61fb      	str	r3, [r7, #28]

      /* We check if we should poll the connection. */
      ++prev->polltmr;
    90b6:	69bb      	ldr	r3, [r7, #24]
    90b8:	7fdb      	ldrb	r3, [r3, #31]
    90ba:	3301      	adds	r3, #1
    90bc:	b2da      	uxtb	r2, r3
    90be:	69bb      	ldr	r3, [r7, #24]
    90c0:	77da      	strb	r2, [r3, #31]
      if (prev->polltmr >= prev->pollinterval) {
    90c2:	69bb      	ldr	r3, [r7, #24]
    90c4:	7fda      	ldrb	r2, [r3, #31]
    90c6:	69bb      	ldr	r3, [r7, #24]
    90c8:	2120      	movs	r1, #32
    90ca:	5c5b      	ldrb	r3, [r3, r1]
    90cc:	429a      	cmp	r2, r3
    90ce:	d32a      	bcc.n	9126 <tcp_slowtmr+0x45e>
        prev->polltmr = 0;
    90d0:	69bb      	ldr	r3, [r7, #24]
    90d2:	2200      	movs	r2, #0
    90d4:	77da      	strb	r2, [r3, #31]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
    90d6:	4b3b      	ldr	r3, [pc, #236]	; (91c4 <tcp_slowtmr+0x4fc>)
    90d8:	2200      	movs	r2, #0
    90da:	701a      	strb	r2, [r3, #0]
        TCP_EVENT_POLL(prev, err);
    90dc:	69bb      	ldr	r3, [r7, #24]
    90de:	2288      	movs	r2, #136	; 0x88
    90e0:	589b      	ldr	r3, [r3, r2]
    90e2:	2b00      	cmp	r3, #0
    90e4:	d00c      	beq.n	9100 <tcp_slowtmr+0x438>
    90e6:	69bb      	ldr	r3, [r7, #24]
    90e8:	2288      	movs	r2, #136	; 0x88
    90ea:	589a      	ldr	r2, [r3, r2]
    90ec:	69bb      	ldr	r3, [r7, #24]
    90ee:	691b      	ldr	r3, [r3, #16]
    90f0:	2115      	movs	r1, #21
    90f2:	187c      	adds	r4, r7, r1
    90f4:	69b9      	ldr	r1, [r7, #24]
    90f6:	0018      	movs	r0, r3
    90f8:	4790      	blx	r2
    90fa:	0003      	movs	r3, r0
    90fc:	7023      	strb	r3, [r4, #0]
    90fe:	e003      	b.n	9108 <tcp_slowtmr+0x440>
    9100:	2315      	movs	r3, #21
    9102:	18fb      	adds	r3, r7, r3
    9104:	2200      	movs	r2, #0
    9106:	701a      	strb	r2, [r3, #0]
        if (tcp_active_pcbs_changed) {
    9108:	4b2e      	ldr	r3, [pc, #184]	; (91c4 <tcp_slowtmr+0x4fc>)
    910a:	781b      	ldrb	r3, [r3, #0]
    910c:	2b00      	cmp	r3, #0
    910e:	d000      	beq.n	9112 <tcp_slowtmr+0x44a>
          goto tcp_slowtmr_start;
    9110:	e5ec      	b.n	8cec <tcp_slowtmr+0x24>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
    9112:	2315      	movs	r3, #21
    9114:	18fb      	adds	r3, r7, r3
    9116:	781b      	ldrb	r3, [r3, #0]
    9118:	b25b      	sxtb	r3, r3
    911a:	2b00      	cmp	r3, #0
    911c:	d103      	bne.n	9126 <tcp_slowtmr+0x45e>
          tcp_output(prev);
    911e:	69bb      	ldr	r3, [r7, #24]
    9120:	0018      	movs	r0, r3
    9122:	4b29      	ldr	r3, [pc, #164]	; (91c8 <tcp_slowtmr+0x500>)
    9124:	4798      	blx	r3
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    9126:	69fb      	ldr	r3, [r7, #28]
    9128:	2b00      	cmp	r3, #0
    912a:	d000      	beq.n	912e <tcp_slowtmr+0x466>
    912c:	e5e4      	b.n	8cf8 <tcp_slowtmr+0x30>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
    912e:	2300      	movs	r3, #0
    9130:	61bb      	str	r3, [r7, #24]
  pcb = tcp_tw_pcbs;
    9132:	4b26      	ldr	r3, [pc, #152]	; (91cc <tcp_slowtmr+0x504>)
    9134:	681b      	ldr	r3, [r3, #0]
    9136:	61fb      	str	r3, [r7, #28]
  while (pcb != NULL) {
    9138:	e036      	b.n	91a8 <tcp_slowtmr+0x4e0>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
    913a:	2317      	movs	r3, #23
    913c:	18fb      	adds	r3, r7, r3
    913e:	2200      	movs	r2, #0
    9140:	701a      	strb	r2, [r3, #0]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
    9142:	4b23      	ldr	r3, [pc, #140]	; (91d0 <tcp_slowtmr+0x508>)
    9144:	681a      	ldr	r2, [r3, #0]
    9146:	69fb      	ldr	r3, [r7, #28]
    9148:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    914a:	1ad3      	subs	r3, r2, r3
    914c:	2bf0      	cmp	r3, #240	; 0xf0
    914e:	d906      	bls.n	915e <tcp_slowtmr+0x496>
      ++pcb_remove;
    9150:	2317      	movs	r3, #23
    9152:	18fb      	adds	r3, r7, r3
    9154:	2217      	movs	r2, #23
    9156:	18ba      	adds	r2, r7, r2
    9158:	7812      	ldrb	r2, [r2, #0]
    915a:	3201      	adds	r2, #1
    915c:	701a      	strb	r2, [r3, #0]
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
    915e:	2317      	movs	r3, #23
    9160:	18fb      	adds	r3, r7, r3
    9162:	781b      	ldrb	r3, [r3, #0]
    9164:	2b00      	cmp	r3, #0
    9166:	d01a      	beq.n	919e <tcp_slowtmr+0x4d6>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
    9168:	69fb      	ldr	r3, [r7, #28]
    916a:	0018      	movs	r0, r3
    916c:	4b19      	ldr	r3, [pc, #100]	; (91d4 <tcp_slowtmr+0x50c>)
    916e:	4798      	blx	r3
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
    9170:	69bb      	ldr	r3, [r7, #24]
    9172:	2b00      	cmp	r3, #0
    9174:	d004      	beq.n	9180 <tcp_slowtmr+0x4b8>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
    9176:	69fb      	ldr	r3, [r7, #28]
    9178:	68da      	ldr	r2, [r3, #12]
    917a:	69bb      	ldr	r3, [r7, #24]
    917c:	60da      	str	r2, [r3, #12]
    917e:	e003      	b.n	9188 <tcp_slowtmr+0x4c0>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
    9180:	69fb      	ldr	r3, [r7, #28]
    9182:	68da      	ldr	r2, [r3, #12]
    9184:	4b11      	ldr	r3, [pc, #68]	; (91cc <tcp_slowtmr+0x504>)
    9186:	601a      	str	r2, [r3, #0]
      }
      pcb2 = pcb;
    9188:	69fb      	ldr	r3, [r7, #28]
    918a:	603b      	str	r3, [r7, #0]
      pcb = pcb->next;
    918c:	69fb      	ldr	r3, [r7, #28]
    918e:	68db      	ldr	r3, [r3, #12]
    9190:	61fb      	str	r3, [r7, #28]
      memp_free(MEMP_TCP_PCB, pcb2);
    9192:	683b      	ldr	r3, [r7, #0]
    9194:	0019      	movs	r1, r3
    9196:	2001      	movs	r0, #1
    9198:	4b09      	ldr	r3, [pc, #36]	; (91c0 <tcp_slowtmr+0x4f8>)
    919a:	4798      	blx	r3
    919c:	e004      	b.n	91a8 <tcp_slowtmr+0x4e0>
    } else {
      prev = pcb;
    919e:	69fb      	ldr	r3, [r7, #28]
    91a0:	61bb      	str	r3, [r7, #24]
      pcb = pcb->next;
    91a2:	69fb      	ldr	r3, [r7, #28]
    91a4:	68db      	ldr	r3, [r3, #12]
    91a6:	61fb      	str	r3, [r7, #28]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    91a8:	69fb      	ldr	r3, [r7, #28]
    91aa:	2b00      	cmp	r3, #0
    91ac:	d1c5      	bne.n	913a <tcp_slowtmr+0x472>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
    91ae:	46c0      	nop			; (mov r8, r8)
    91b0:	46bd      	mov	sp, r7
    91b2:	b008      	add	sp, #32
    91b4:	bdb0      	pop	{r4, r5, r7, pc}
    91b6:	46c0      	nop			; (mov r8, r8)
    91b8:	20003ec4 	.word	0x20003ec4
    91bc:	0000cc35 	.word	0x0000cc35
    91c0:	00007b39 	.word	0x00007b39
    91c4:	20003ec0 	.word	0x20003ec0
    91c8:	0000c6bd 	.word	0x0000c6bd
    91cc:	20003ed8 	.word	0x20003ed8
    91d0:	20003ec8 	.word	0x20003ec8
    91d4:	000096c1 	.word	0x000096c1

000091d8 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
    91d8:	b580      	push	{r7, lr}
    91da:	b082      	sub	sp, #8
    91dc:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
    91de:	4b25      	ldr	r3, [pc, #148]	; (9274 <tcp_fasttmr+0x9c>)
    91e0:	781b      	ldrb	r3, [r3, #0]
    91e2:	3301      	adds	r3, #1
    91e4:	b2da      	uxtb	r2, r3
    91e6:	4b23      	ldr	r3, [pc, #140]	; (9274 <tcp_fasttmr+0x9c>)
    91e8:	701a      	strb	r2, [r3, #0]

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
    91ea:	4b23      	ldr	r3, [pc, #140]	; (9278 <tcp_fasttmr+0xa0>)
    91ec:	681b      	ldr	r3, [r3, #0]
    91ee:	607b      	str	r3, [r7, #4]

  while(pcb != NULL) {
    91f0:	e038      	b.n	9264 <tcp_fasttmr+0x8c>
    if (pcb->last_timer != tcp_timer_ctr) {
    91f2:	687b      	ldr	r3, [r7, #4]
    91f4:	2221      	movs	r2, #33	; 0x21
    91f6:	5c9a      	ldrb	r2, [r3, r2]
    91f8:	4b1e      	ldr	r3, [pc, #120]	; (9274 <tcp_fasttmr+0x9c>)
    91fa:	781b      	ldrb	r3, [r3, #0]
    91fc:	429a      	cmp	r2, r3
    91fe:	d031      	beq.n	9264 <tcp_fasttmr+0x8c>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
    9200:	4b1c      	ldr	r3, [pc, #112]	; (9274 <tcp_fasttmr+0x9c>)
    9202:	7819      	ldrb	r1, [r3, #0]
    9204:	687b      	ldr	r3, [r7, #4]
    9206:	2221      	movs	r2, #33	; 0x21
    9208:	5499      	strb	r1, [r3, r2]
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
    920a:	687b      	ldr	r3, [r7, #4]
    920c:	7f9b      	ldrb	r3, [r3, #30]
    920e:	001a      	movs	r2, r3
    9210:	2301      	movs	r3, #1
    9212:	4013      	ands	r3, r2
    9214:	d011      	beq.n	923a <tcp_fasttmr+0x62>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
    9216:	687b      	ldr	r3, [r7, #4]
    9218:	7f9b      	ldrb	r3, [r3, #30]
    921a:	2202      	movs	r2, #2
    921c:	4313      	orrs	r3, r2
    921e:	b2da      	uxtb	r2, r3
    9220:	687b      	ldr	r3, [r7, #4]
    9222:	779a      	strb	r2, [r3, #30]
        tcp_output(pcb);
    9224:	687b      	ldr	r3, [r7, #4]
    9226:	0018      	movs	r0, r3
    9228:	4b14      	ldr	r3, [pc, #80]	; (927c <tcp_fasttmr+0xa4>)
    922a:	4798      	blx	r3
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    922c:	687b      	ldr	r3, [r7, #4]
    922e:	7f9b      	ldrb	r3, [r3, #30]
    9230:	2203      	movs	r2, #3
    9232:	4393      	bics	r3, r2
    9234:	b2da      	uxtb	r2, r3
    9236:	687b      	ldr	r3, [r7, #4]
    9238:	779a      	strb	r2, [r3, #30]
      }

      next = pcb->next;
    923a:	687b      	ldr	r3, [r7, #4]
    923c:	68db      	ldr	r3, [r3, #12]
    923e:	603b      	str	r3, [r7, #0]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
    9240:	687b      	ldr	r3, [r7, #4]
    9242:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    9244:	2b00      	cmp	r3, #0
    9246:	d00b      	beq.n	9260 <tcp_fasttmr+0x88>
        tcp_active_pcbs_changed = 0;
    9248:	4b0d      	ldr	r3, [pc, #52]	; (9280 <tcp_fasttmr+0xa8>)
    924a:	2200      	movs	r2, #0
    924c:	701a      	strb	r2, [r3, #0]
        tcp_process_refused_data(pcb);
    924e:	687b      	ldr	r3, [r7, #4]
    9250:	0018      	movs	r0, r3
    9252:	4b0c      	ldr	r3, [pc, #48]	; (9284 <tcp_fasttmr+0xac>)
    9254:	4798      	blx	r3
        if (tcp_active_pcbs_changed) {
    9256:	4b0a      	ldr	r3, [pc, #40]	; (9280 <tcp_fasttmr+0xa8>)
    9258:	781b      	ldrb	r3, [r3, #0]
    925a:	2b00      	cmp	r3, #0
    925c:	d000      	beq.n	9260 <tcp_fasttmr+0x88>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
    925e:	e7c4      	b.n	91ea <tcp_fasttmr+0x12>
        }
      }
      pcb = next;
    9260:	683b      	ldr	r3, [r7, #0]
    9262:	607b      	str	r3, [r7, #4]
  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
    9264:	687b      	ldr	r3, [r7, #4]
    9266:	2b00      	cmp	r3, #0
    9268:	d1c3      	bne.n	91f2 <tcp_fasttmr+0x1a>
        }
      }
      pcb = next;
    }
  }
}
    926a:	46c0      	nop			; (mov r8, r8)
    926c:	46bd      	mov	sp, r7
    926e:	b002      	add	sp, #8
    9270:	bd80      	pop	{r7, pc}
    9272:	46c0      	nop			; (mov r8, r8)
    9274:	20002c6d 	.word	0x20002c6d
    9278:	20003ec4 	.word	0x20003ec4
    927c:	0000c6bd 	.word	0x0000c6bd
    9280:	20003ec0 	.word	0x20003ec0
    9284:	00009289 	.word	0x00009289

00009288 <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
    9288:	b5b0      	push	{r4, r5, r7, lr}
    928a:	b084      	sub	sp, #16
    928c:	af00      	add	r7, sp, #0
    928e:	6078      	str	r0, [r7, #4]
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
    9290:	687b      	ldr	r3, [r7, #4]
    9292:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    9294:	230e      	movs	r3, #14
    9296:	18fb      	adds	r3, r7, r3
    9298:	7b52      	ldrb	r2, [r2, #13]
    929a:	701a      	strb	r2, [r3, #0]
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
    929c:	687b      	ldr	r3, [r7, #4]
    929e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    92a0:	60bb      	str	r3, [r7, #8]
  pcb->refused_data = NULL;
    92a2:	687b      	ldr	r3, [r7, #4]
    92a4:	2200      	movs	r2, #0
    92a6:	679a      	str	r2, [r3, #120]	; 0x78
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
    92a8:	687b      	ldr	r3, [r7, #4]
    92aa:	2280      	movs	r2, #128	; 0x80
    92ac:	589b      	ldr	r3, [r3, r2]
    92ae:	2b00      	cmp	r3, #0
    92b0:	d00d      	beq.n	92ce <tcp_process_refused_data+0x46>
    92b2:	687b      	ldr	r3, [r7, #4]
    92b4:	2280      	movs	r2, #128	; 0x80
    92b6:	589d      	ldr	r5, [r3, r2]
    92b8:	687b      	ldr	r3, [r7, #4]
    92ba:	6918      	ldr	r0, [r3, #16]
    92bc:	230f      	movs	r3, #15
    92be:	18fc      	adds	r4, r7, r3
    92c0:	68ba      	ldr	r2, [r7, #8]
    92c2:	6879      	ldr	r1, [r7, #4]
    92c4:	2300      	movs	r3, #0
    92c6:	47a8      	blx	r5
    92c8:	0003      	movs	r3, r0
    92ca:	7023      	strb	r3, [r4, #0]
    92cc:	e009      	b.n	92e2 <tcp_process_refused_data+0x5a>
    92ce:	230f      	movs	r3, #15
    92d0:	18fc      	adds	r4, r7, r3
    92d2:	68ba      	ldr	r2, [r7, #8]
    92d4:	6879      	ldr	r1, [r7, #4]
    92d6:	2300      	movs	r3, #0
    92d8:	2000      	movs	r0, #0
    92da:	4d26      	ldr	r5, [pc, #152]	; (9374 <tcp_process_refused_data+0xec>)
    92dc:	47a8      	blx	r5
    92de:	0003      	movs	r3, r0
    92e0:	7023      	strb	r3, [r4, #0]
  if (err == ERR_OK) {
    92e2:	230f      	movs	r3, #15
    92e4:	18fb      	adds	r3, r7, r3
    92e6:	781b      	ldrb	r3, [r3, #0]
    92e8:	b25b      	sxtb	r3, r3
    92ea:	2b00      	cmp	r3, #0
    92ec:	d130      	bne.n	9350 <tcp_process_refused_data+0xc8>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
    92ee:	230e      	movs	r3, #14
    92f0:	18fb      	adds	r3, r7, r3
    92f2:	781b      	ldrb	r3, [r3, #0]
    92f4:	2220      	movs	r2, #32
    92f6:	4013      	ands	r3, r2
    92f8:	d036      	beq.n	9368 <tcp_process_refused_data+0xe0>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
    92fa:	687b      	ldr	r3, [r7, #4]
    92fc:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    92fe:	4a1e      	ldr	r2, [pc, #120]	; (9378 <tcp_process_refused_data+0xf0>)
    9300:	4293      	cmp	r3, r2
    9302:	d005      	beq.n	9310 <tcp_process_refused_data+0x88>
        pcb->rcv_wnd++;
    9304:	687b      	ldr	r3, [r7, #4]
    9306:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    9308:	3301      	adds	r3, #1
    930a:	b29a      	uxth	r2, r3
    930c:	687b      	ldr	r3, [r7, #4]
    930e:	859a      	strh	r2, [r3, #44]	; 0x2c
      }
      TCP_EVENT_CLOSED(pcb, err);
    9310:	687b      	ldr	r3, [r7, #4]
    9312:	2280      	movs	r2, #128	; 0x80
    9314:	589b      	ldr	r3, [r3, r2]
    9316:	2b00      	cmp	r3, #0
    9318:	d00d      	beq.n	9336 <tcp_process_refused_data+0xae>
    931a:	687b      	ldr	r3, [r7, #4]
    931c:	2280      	movs	r2, #128	; 0x80
    931e:	589d      	ldr	r5, [r3, r2]
    9320:	687b      	ldr	r3, [r7, #4]
    9322:	6918      	ldr	r0, [r3, #16]
    9324:	230f      	movs	r3, #15
    9326:	18fc      	adds	r4, r7, r3
    9328:	6879      	ldr	r1, [r7, #4]
    932a:	2300      	movs	r3, #0
    932c:	2200      	movs	r2, #0
    932e:	47a8      	blx	r5
    9330:	0003      	movs	r3, r0
    9332:	7023      	strb	r3, [r4, #0]
    9334:	e003      	b.n	933e <tcp_process_refused_data+0xb6>
    9336:	230f      	movs	r3, #15
    9338:	18fb      	adds	r3, r7, r3
    933a:	2200      	movs	r2, #0
    933c:	701a      	strb	r2, [r3, #0]
      if (err == ERR_ABRT) {
    933e:	230f      	movs	r3, #15
    9340:	18fb      	adds	r3, r7, r3
    9342:	781b      	ldrb	r3, [r3, #0]
    9344:	b25b      	sxtb	r3, r3
    9346:	330a      	adds	r3, #10
    9348:	d10e      	bne.n	9368 <tcp_process_refused_data+0xe0>
        return ERR_ABRT;
    934a:	230a      	movs	r3, #10
    934c:	425b      	negs	r3, r3
    934e:	e00c      	b.n	936a <tcp_process_refused_data+0xe2>
      }
    }
  } else if (err == ERR_ABRT) {
    9350:	230f      	movs	r3, #15
    9352:	18fb      	adds	r3, r7, r3
    9354:	781b      	ldrb	r3, [r3, #0]
    9356:	b25b      	sxtb	r3, r3
    9358:	330a      	adds	r3, #10
    935a:	d102      	bne.n	9362 <tcp_process_refused_data+0xda>
    /* if err == ERR_ABRT, 'pcb' is already deallocated */
    /* Drop incoming packets because pcb is "full" (only if the incoming
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
    935c:	230a      	movs	r3, #10
    935e:	425b      	negs	r3, r3
    9360:	e003      	b.n	936a <tcp_process_refused_data+0xe2>
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
    9362:	687b      	ldr	r3, [r7, #4]
    9364:	68ba      	ldr	r2, [r7, #8]
    9366:	679a      	str	r2, [r3, #120]	; 0x78
  }
  return ERR_OK;
    9368:	2300      	movs	r3, #0
}
    936a:	0018      	movs	r0, r3
    936c:	46bd      	mov	sp, r7
    936e:	b004      	add	sp, #16
    9370:	bdb0      	pop	{r4, r5, r7, pc}
    9372:	46c0      	nop			; (mov r8, r8)
    9374:	00009431 	.word	0x00009431
    9378:	00000b68 	.word	0x00000b68

0000937c <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
    937c:	b580      	push	{r7, lr}
    937e:	b084      	sub	sp, #16
    9380:	af00      	add	r7, sp, #0
    9382:	6078      	str	r0, [r7, #4]
  while (seg != NULL) {
    9384:	e008      	b.n	9398 <tcp_segs_free+0x1c>
    struct tcp_seg *next = seg->next;
    9386:	687b      	ldr	r3, [r7, #4]
    9388:	681b      	ldr	r3, [r3, #0]
    938a:	60fb      	str	r3, [r7, #12]
    tcp_seg_free(seg);
    938c:	687b      	ldr	r3, [r7, #4]
    938e:	0018      	movs	r0, r3
    9390:	4b05      	ldr	r3, [pc, #20]	; (93a8 <tcp_segs_free+0x2c>)
    9392:	4798      	blx	r3
    seg = next;
    9394:	68fb      	ldr	r3, [r7, #12]
    9396:	607b      	str	r3, [r7, #4]
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    9398:	687b      	ldr	r3, [r7, #4]
    939a:	2b00      	cmp	r3, #0
    939c:	d1f3      	bne.n	9386 <tcp_segs_free+0xa>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
    939e:	46c0      	nop			; (mov r8, r8)
    93a0:	46bd      	mov	sp, r7
    93a2:	b004      	add	sp, #16
    93a4:	bd80      	pop	{r7, pc}
    93a6:	46c0      	nop			; (mov r8, r8)
    93a8:	000093ad 	.word	0x000093ad

000093ac <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
    93ac:	b580      	push	{r7, lr}
    93ae:	b082      	sub	sp, #8
    93b0:	af00      	add	r7, sp, #0
    93b2:	6078      	str	r0, [r7, #4]
  if (seg != NULL) {
    93b4:	687b      	ldr	r3, [r7, #4]
    93b6:	2b00      	cmp	r3, #0
    93b8:	d00d      	beq.n	93d6 <tcp_seg_free+0x2a>
    if (seg->p != NULL) {
    93ba:	687b      	ldr	r3, [r7, #4]
    93bc:	685b      	ldr	r3, [r3, #4]
    93be:	2b00      	cmp	r3, #0
    93c0:	d004      	beq.n	93cc <tcp_seg_free+0x20>
      pbuf_free(seg->p);
    93c2:	687b      	ldr	r3, [r7, #4]
    93c4:	685b      	ldr	r3, [r3, #4]
    93c6:	0018      	movs	r0, r3
    93c8:	4b05      	ldr	r3, [pc, #20]	; (93e0 <tcp_seg_free+0x34>)
    93ca:	4798      	blx	r3
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
    93cc:	687b      	ldr	r3, [r7, #4]
    93ce:	0019      	movs	r1, r3
    93d0:	2003      	movs	r0, #3
    93d2:	4b04      	ldr	r3, [pc, #16]	; (93e4 <tcp_seg_free+0x38>)
    93d4:	4798      	blx	r3
  }
}
    93d6:	46c0      	nop			; (mov r8, r8)
    93d8:	46bd      	mov	sp, r7
    93da:	b002      	add	sp, #8
    93dc:	bd80      	pop	{r7, pc}
    93de:	46c0      	nop			; (mov r8, r8)
    93e0:	00008349 	.word	0x00008349
    93e4:	00007b39 	.word	0x00007b39

000093e8 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
    93e8:	b580      	push	{r7, lr}
    93ea:	b084      	sub	sp, #16
    93ec:	af00      	add	r7, sp, #0
    93ee:	6078      	str	r0, [r7, #4]
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    93f0:	2003      	movs	r0, #3
    93f2:	4b0c      	ldr	r3, [pc, #48]	; (9424 <tcp_seg_copy+0x3c>)
    93f4:	4798      	blx	r3
    93f6:	0003      	movs	r3, r0
    93f8:	60fb      	str	r3, [r7, #12]
  if (cseg == NULL) {
    93fa:	68fb      	ldr	r3, [r7, #12]
    93fc:	2b00      	cmp	r3, #0
    93fe:	d101      	bne.n	9404 <tcp_seg_copy+0x1c>
    return NULL;
    9400:	2300      	movs	r3, #0
    9402:	e00b      	b.n	941c <tcp_seg_copy+0x34>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
    9404:	6879      	ldr	r1, [r7, #4]
    9406:	68fb      	ldr	r3, [r7, #12]
    9408:	2210      	movs	r2, #16
    940a:	0018      	movs	r0, r3
    940c:	4b06      	ldr	r3, [pc, #24]	; (9428 <tcp_seg_copy+0x40>)
    940e:	4798      	blx	r3
  pbuf_ref(cseg->p);
    9410:	68fb      	ldr	r3, [r7, #12]
    9412:	685b      	ldr	r3, [r3, #4]
    9414:	0018      	movs	r0, r3
    9416:	4b05      	ldr	r3, [pc, #20]	; (942c <tcp_seg_copy+0x44>)
    9418:	4798      	blx	r3
  return cseg;
    941a:	68fb      	ldr	r3, [r7, #12]
}
    941c:	0018      	movs	r0, r3
    941e:	46bd      	mov	sp, r7
    9420:	b004      	add	sp, #16
    9422:	bd80      	pop	{r7, pc}
    9424:	00007af1 	.word	0x00007af1
    9428:	0000fc43 	.word	0x0000fc43
    942c:	0000846d 	.word	0x0000846d

00009430 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
    9430:	b580      	push	{r7, lr}
    9432:	b084      	sub	sp, #16
    9434:	af00      	add	r7, sp, #0
    9436:	60f8      	str	r0, [r7, #12]
    9438:	60b9      	str	r1, [r7, #8]
    943a:	607a      	str	r2, [r7, #4]
    943c:	001a      	movs	r2, r3
    943e:	1cfb      	adds	r3, r7, #3
    9440:	701a      	strb	r2, [r3, #0]
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    9442:	687b      	ldr	r3, [r7, #4]
    9444:	2b00      	cmp	r3, #0
    9446:	d00b      	beq.n	9460 <tcp_recv_null+0x30>
    tcp_recved(pcb, p->tot_len);
    9448:	687b      	ldr	r3, [r7, #4]
    944a:	891a      	ldrh	r2, [r3, #8]
    944c:	68bb      	ldr	r3, [r7, #8]
    944e:	0011      	movs	r1, r2
    9450:	0018      	movs	r0, r3
    9452:	4b0b      	ldr	r3, [pc, #44]	; (9480 <tcp_recv_null+0x50>)
    9454:	4798      	blx	r3
    pbuf_free(p);
    9456:	687b      	ldr	r3, [r7, #4]
    9458:	0018      	movs	r0, r3
    945a:	4b0a      	ldr	r3, [pc, #40]	; (9484 <tcp_recv_null+0x54>)
    945c:	4798      	blx	r3
    945e:	e00a      	b.n	9476 <tcp_recv_null+0x46>
  } else if (err == ERR_OK) {
    9460:	1cfb      	adds	r3, r7, #3
    9462:	781b      	ldrb	r3, [r3, #0]
    9464:	b25b      	sxtb	r3, r3
    9466:	2b00      	cmp	r3, #0
    9468:	d105      	bne.n	9476 <tcp_recv_null+0x46>
    return tcp_close(pcb);
    946a:	68bb      	ldr	r3, [r7, #8]
    946c:	0018      	movs	r0, r3
    946e:	4b06      	ldr	r3, [pc, #24]	; (9488 <tcp_recv_null+0x58>)
    9470:	4798      	blx	r3
    9472:	0003      	movs	r3, r0
    9474:	e000      	b.n	9478 <tcp_recv_null+0x48>
  }
  return ERR_OK;
    9476:	2300      	movs	r3, #0
}
    9478:	0018      	movs	r0, r3
    947a:	46bd      	mov	sp, r7
    947c:	b004      	add	sp, #16
    947e:	bd80      	pop	{r7, pc}
    9480:	00008c59 	.word	0x00008c59
    9484:	00008349 	.word	0x00008349
    9488:	00008a95 	.word	0x00008a95

0000948c <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
    948c:	b580      	push	{r7, lr}
    948e:	b086      	sub	sp, #24
    9490:	af00      	add	r7, sp, #0
    9492:	0002      	movs	r2, r0
    9494:	1dfb      	adds	r3, r7, #7
    9496:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
    9498:	230b      	movs	r3, #11
    949a:	18fb      	adds	r3, r7, r3
    949c:	227f      	movs	r2, #127	; 0x7f
    949e:	701a      	strb	r2, [r3, #0]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
    94a0:	2300      	movs	r3, #0
    94a2:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
    94a4:	2300      	movs	r3, #0
    94a6:	613b      	str	r3, [r7, #16]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    94a8:	4b1b      	ldr	r3, [pc, #108]	; (9518 <tcp_kill_prio+0x8c>)
    94aa:	681b      	ldr	r3, [r3, #0]
    94ac:	617b      	str	r3, [r7, #20]
    94ae:	e024      	b.n	94fa <tcp_kill_prio+0x6e>
    if (pcb->prio <= prio &&
    94b0:	697b      	ldr	r3, [r7, #20]
    94b2:	7e5b      	ldrb	r3, [r3, #25]
    94b4:	1dfa      	adds	r2, r7, #7
    94b6:	7812      	ldrb	r2, [r2, #0]
    94b8:	429a      	cmp	r2, r3
    94ba:	d31b      	bcc.n	94f4 <tcp_kill_prio+0x68>
       pcb->prio <= mprio &&
    94bc:	697b      	ldr	r3, [r7, #20]
    94be:	7e5b      	ldrb	r3, [r3, #25]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
    94c0:	220b      	movs	r2, #11
    94c2:	18ba      	adds	r2, r7, r2
    94c4:	7812      	ldrb	r2, [r2, #0]
    94c6:	429a      	cmp	r2, r3
    94c8:	d314      	bcc.n	94f4 <tcp_kill_prio+0x68>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    94ca:	4b14      	ldr	r3, [pc, #80]	; (951c <tcp_kill_prio+0x90>)
    94cc:	681a      	ldr	r2, [r3, #0]
    94ce:	697b      	ldr	r3, [r7, #20]
    94d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    94d2:	1ad2      	subs	r2, r2, r3
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
    94d4:	68fb      	ldr	r3, [r7, #12]
    94d6:	429a      	cmp	r2, r3
    94d8:	d30c      	bcc.n	94f4 <tcp_kill_prio+0x68>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
    94da:	4b10      	ldr	r3, [pc, #64]	; (951c <tcp_kill_prio+0x90>)
    94dc:	681a      	ldr	r2, [r3, #0]
    94de:	697b      	ldr	r3, [r7, #20]
    94e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    94e2:	1ad3      	subs	r3, r2, r3
    94e4:	60fb      	str	r3, [r7, #12]
      inactive = pcb;
    94e6:	697b      	ldr	r3, [r7, #20]
    94e8:	613b      	str	r3, [r7, #16]
      mprio = pcb->prio;
    94ea:	230b      	movs	r3, #11
    94ec:	18fb      	adds	r3, r7, r3
    94ee:	697a      	ldr	r2, [r7, #20]
    94f0:	7e52      	ldrb	r2, [r2, #25]
    94f2:	701a      	strb	r2, [r3, #0]
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    94f4:	697b      	ldr	r3, [r7, #20]
    94f6:	68db      	ldr	r3, [r3, #12]
    94f8:	617b      	str	r3, [r7, #20]
    94fa:	697b      	ldr	r3, [r7, #20]
    94fc:	2b00      	cmp	r3, #0
    94fe:	d1d7      	bne.n	94b0 <tcp_kill_prio+0x24>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
    9500:	693b      	ldr	r3, [r7, #16]
    9502:	2b00      	cmp	r3, #0
    9504:	d003      	beq.n	950e <tcp_kill_prio+0x82>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    9506:	693b      	ldr	r3, [r7, #16]
    9508:	0018      	movs	r0, r3
    950a:	4b05      	ldr	r3, [pc, #20]	; (9520 <tcp_kill_prio+0x94>)
    950c:	4798      	blx	r3
  }
}
    950e:	46c0      	nop			; (mov r8, r8)
    9510:	46bd      	mov	sp, r7
    9512:	b006      	add	sp, #24
    9514:	bd80      	pop	{r7, pc}
    9516:	46c0      	nop			; (mov r8, r8)
    9518:	20003ec4 	.word	0x20003ec4
    951c:	20003ec8 	.word	0x20003ec8
    9520:	00008bbd 	.word	0x00008bbd

00009524 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
    9524:	b580      	push	{r7, lr}
    9526:	b084      	sub	sp, #16
    9528:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
    952a:	2300      	movs	r3, #0
    952c:	607b      	str	r3, [r7, #4]
  inactive = NULL;
    952e:	2300      	movs	r3, #0
    9530:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    9532:	4b12      	ldr	r3, [pc, #72]	; (957c <tcp_kill_timewait+0x58>)
    9534:	681b      	ldr	r3, [r3, #0]
    9536:	60fb      	str	r3, [r7, #12]
    9538:	e012      	b.n	9560 <tcp_kill_timewait+0x3c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    953a:	4b11      	ldr	r3, [pc, #68]	; (9580 <tcp_kill_timewait+0x5c>)
    953c:	681a      	ldr	r2, [r3, #0]
    953e:	68fb      	ldr	r3, [r7, #12]
    9540:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    9542:	1ad2      	subs	r2, r2, r3
    9544:	687b      	ldr	r3, [r7, #4]
    9546:	429a      	cmp	r2, r3
    9548:	d307      	bcc.n	955a <tcp_kill_timewait+0x36>
      inactivity = tcp_ticks - pcb->tmr;
    954a:	4b0d      	ldr	r3, [pc, #52]	; (9580 <tcp_kill_timewait+0x5c>)
    954c:	681a      	ldr	r2, [r3, #0]
    954e:	68fb      	ldr	r3, [r7, #12]
    9550:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    9552:	1ad3      	subs	r3, r2, r3
    9554:	607b      	str	r3, [r7, #4]
      inactive = pcb;
    9556:	68fb      	ldr	r3, [r7, #12]
    9558:	60bb      	str	r3, [r7, #8]
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    955a:	68fb      	ldr	r3, [r7, #12]
    955c:	68db      	ldr	r3, [r3, #12]
    955e:	60fb      	str	r3, [r7, #12]
    9560:	68fb      	ldr	r3, [r7, #12]
    9562:	2b00      	cmp	r3, #0
    9564:	d1e9      	bne.n	953a <tcp_kill_timewait+0x16>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
    9566:	68bb      	ldr	r3, [r7, #8]
    9568:	2b00      	cmp	r3, #0
    956a:	d003      	beq.n	9574 <tcp_kill_timewait+0x50>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    956c:	68bb      	ldr	r3, [r7, #8]
    956e:	0018      	movs	r0, r3
    9570:	4b04      	ldr	r3, [pc, #16]	; (9584 <tcp_kill_timewait+0x60>)
    9572:	4798      	blx	r3
  }
}
    9574:	46c0      	nop			; (mov r8, r8)
    9576:	46bd      	mov	sp, r7
    9578:	b004      	add	sp, #16
    957a:	bd80      	pop	{r7, pc}
    957c:	20003ed8 	.word	0x20003ed8
    9580:	20003ec8 	.word	0x20003ec8
    9584:	00008bbd 	.word	0x00008bbd

00009588 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
    9588:	b580      	push	{r7, lr}
    958a:	b084      	sub	sp, #16
    958c:	af00      	add	r7, sp, #0
    958e:	0002      	movs	r2, r0
    9590:	1dfb      	adds	r3, r7, #7
    9592:	701a      	strb	r2, [r3, #0]
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    9594:	2001      	movs	r0, #1
    9596:	4b40      	ldr	r3, [pc, #256]	; (9698 <tcp_alloc+0x110>)
    9598:	4798      	blx	r3
    959a:	0003      	movs	r3, r0
    959c:	60fb      	str	r3, [r7, #12]
  if (pcb == NULL) {
    959e:	68fb      	ldr	r3, [r7, #12]
    95a0:	2b00      	cmp	r3, #0
    95a2:	d113      	bne.n	95cc <tcp_alloc+0x44>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    95a4:	4b3d      	ldr	r3, [pc, #244]	; (969c <tcp_alloc+0x114>)
    95a6:	4798      	blx	r3
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    95a8:	2001      	movs	r0, #1
    95aa:	4b3b      	ldr	r3, [pc, #236]	; (9698 <tcp_alloc+0x110>)
    95ac:	4798      	blx	r3
    95ae:	0003      	movs	r3, r0
    95b0:	60fb      	str	r3, [r7, #12]
    if (pcb == NULL) {
    95b2:	68fb      	ldr	r3, [r7, #12]
    95b4:	2b00      	cmp	r3, #0
    95b6:	d109      	bne.n	95cc <tcp_alloc+0x44>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
    95b8:	1dfb      	adds	r3, r7, #7
    95ba:	781b      	ldrb	r3, [r3, #0]
    95bc:	0018      	movs	r0, r3
    95be:	4b38      	ldr	r3, [pc, #224]	; (96a0 <tcp_alloc+0x118>)
    95c0:	4798      	blx	r3
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    95c2:	2001      	movs	r0, #1
    95c4:	4b34      	ldr	r3, [pc, #208]	; (9698 <tcp_alloc+0x110>)
    95c6:	4798      	blx	r3
    95c8:	0003      	movs	r3, r0
    95ca:	60fb      	str	r3, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    95cc:	68fb      	ldr	r3, [r7, #12]
    95ce:	2b00      	cmp	r3, #0
    95d0:	d05d      	beq.n	968e <tcp_alloc+0x106>
    memset(pcb, 0, sizeof(struct tcp_pcb));
    95d2:	68fb      	ldr	r3, [r7, #12]
    95d4:	2298      	movs	r2, #152	; 0x98
    95d6:	2100      	movs	r1, #0
    95d8:	0018      	movs	r0, r3
    95da:	4b32      	ldr	r3, [pc, #200]	; (96a4 <tcp_alloc+0x11c>)
    95dc:	4798      	blx	r3
    pcb->prio = prio;
    95de:	68fb      	ldr	r3, [r7, #12]
    95e0:	1dfa      	adds	r2, r7, #7
    95e2:	7812      	ldrb	r2, [r2, #0]
    95e4:	765a      	strb	r2, [r3, #25]
    pcb->snd_buf = TCP_SND_BUF;
    95e6:	68fb      	ldr	r3, [r7, #12]
    95e8:	2266      	movs	r2, #102	; 0x66
    95ea:	492f      	ldr	r1, [pc, #188]	; (96a8 <tcp_alloc+0x120>)
    95ec:	5299      	strh	r1, [r3, r2]
    pcb->snd_queuelen = 0;
    95ee:	68fb      	ldr	r3, [r7, #12]
    95f0:	2268      	movs	r2, #104	; 0x68
    95f2:	2100      	movs	r1, #0
    95f4:	5299      	strh	r1, [r3, r2]
    pcb->rcv_wnd = TCP_WND;
    95f6:	68fb      	ldr	r3, [r7, #12]
    95f8:	4a2b      	ldr	r2, [pc, #172]	; (96a8 <tcp_alloc+0x120>)
    95fa:	859a      	strh	r2, [r3, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
    95fc:	68fb      	ldr	r3, [r7, #12]
    95fe:	4a2a      	ldr	r2, [pc, #168]	; (96a8 <tcp_alloc+0x120>)
    9600:	85da      	strh	r2, [r3, #46]	; 0x2e
    pcb->tos = 0;
    9602:	68fb      	ldr	r3, [r7, #12]
    9604:	2200      	movs	r2, #0
    9606:	725a      	strb	r2, [r3, #9]
    pcb->ttl = TCP_TTL;
    9608:	68fb      	ldr	r3, [r7, #12]
    960a:	22ff      	movs	r2, #255	; 0xff
    960c:	729a      	strb	r2, [r3, #10]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    960e:	68fb      	ldr	r3, [r7, #12]
    9610:	2286      	movs	r2, #134	; 0x86
    9612:	0092      	lsls	r2, r2, #2
    9614:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    9616:	68fb      	ldr	r3, [r7, #12]
    9618:	2244      	movs	r2, #68	; 0x44
    961a:	2106      	movs	r1, #6
    961c:	5299      	strh	r1, [r3, r2]
    pcb->sa = 0;
    961e:	68fb      	ldr	r3, [r7, #12]
    9620:	2240      	movs	r2, #64	; 0x40
    9622:	2100      	movs	r1, #0
    9624:	5299      	strh	r1, [r3, r2]
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    9626:	68fb      	ldr	r3, [r7, #12]
    9628:	2242      	movs	r2, #66	; 0x42
    962a:	2106      	movs	r1, #6
    962c:	5299      	strh	r1, [r3, r2]
    pcb->rtime = -1;
    962e:	68fb      	ldr	r3, [r7, #12]
    9630:	2201      	movs	r2, #1
    9632:	4252      	negs	r2, r2
    9634:	869a      	strh	r2, [r3, #52]	; 0x34
    pcb->cwnd = 1;
    9636:	68fb      	ldr	r3, [r7, #12]
    9638:	224c      	movs	r2, #76	; 0x4c
    963a:	2101      	movs	r1, #1
    963c:	5299      	strh	r1, [r3, r2]
    iss = tcp_next_iss();
    963e:	4b1b      	ldr	r3, [pc, #108]	; (96ac <tcp_alloc+0x124>)
    9640:	4798      	blx	r3
    9642:	0003      	movs	r3, r0
    9644:	60bb      	str	r3, [r7, #8]
    pcb->snd_wl2 = iss;
    9646:	68fb      	ldr	r3, [r7, #12]
    9648:	68ba      	ldr	r2, [r7, #8]
    964a:	659a      	str	r2, [r3, #88]	; 0x58
    pcb->snd_nxt = iss;
    964c:	68fb      	ldr	r3, [r7, #12]
    964e:	68ba      	ldr	r2, [r7, #8]
    9650:	651a      	str	r2, [r3, #80]	; 0x50
    pcb->lastack = iss;
    9652:	68fb      	ldr	r3, [r7, #12]
    9654:	68ba      	ldr	r2, [r7, #8]
    9656:	649a      	str	r2, [r3, #72]	; 0x48
    pcb->snd_lbb = iss;   
    9658:	68fb      	ldr	r3, [r7, #12]
    965a:	68ba      	ldr	r2, [r7, #8]
    965c:	65da      	str	r2, [r3, #92]	; 0x5c
    pcb->tmr = tcp_ticks;
    965e:	4b14      	ldr	r3, [pc, #80]	; (96b0 <tcp_alloc+0x128>)
    9660:	681a      	ldr	r2, [r3, #0]
    9662:	68fb      	ldr	r3, [r7, #12]
    9664:	625a      	str	r2, [r3, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
    9666:	4b13      	ldr	r3, [pc, #76]	; (96b4 <tcp_alloc+0x12c>)
    9668:	7819      	ldrb	r1, [r3, #0]
    966a:	68fb      	ldr	r3, [r7, #12]
    966c:	2221      	movs	r2, #33	; 0x21
    966e:	5499      	strb	r1, [r3, r2]

    pcb->polltmr = 0;
    9670:	68fb      	ldr	r3, [r7, #12]
    9672:	2200      	movs	r2, #0
    9674:	77da      	strb	r2, [r3, #31]

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
    9676:	68fb      	ldr	r3, [r7, #12]
    9678:	2180      	movs	r1, #128	; 0x80
    967a:	4a0f      	ldr	r2, [pc, #60]	; (96b8 <tcp_alloc+0x130>)
    967c:	505a      	str	r2, [r3, r1]
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
    967e:	68fb      	ldr	r3, [r7, #12]
    9680:	2290      	movs	r2, #144	; 0x90
    9682:	490e      	ldr	r1, [pc, #56]	; (96bc <tcp_alloc+0x134>)
    9684:	5099      	str	r1, [r3, r2]
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
    9686:	68fb      	ldr	r3, [r7, #12]
    9688:	2296      	movs	r2, #150	; 0x96
    968a:	2100      	movs	r1, #0
    968c:	5499      	strb	r1, [r3, r2]
  }
  return pcb;
    968e:	68fb      	ldr	r3, [r7, #12]
}
    9690:	0018      	movs	r0, r3
    9692:	46bd      	mov	sp, r7
    9694:	b004      	add	sp, #16
    9696:	bd80      	pop	{r7, pc}
    9698:	00007af1 	.word	0x00007af1
    969c:	00009525 	.word	0x00009525
    96a0:	0000948d 	.word	0x0000948d
    96a4:	0000fc55 	.word	0x0000fc55
    96a8:	00000b68 	.word	0x00000b68
    96ac:	000097fd 	.word	0x000097fd
    96b0:	20003ec8 	.word	0x20003ec8
    96b4:	20002c6d 	.word	0x20002c6d
    96b8:	00009431 	.word	0x00009431
    96bc:	006ddd00 	.word	0x006ddd00

000096c0 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
    96c0:	b580      	push	{r7, lr}
    96c2:	b082      	sub	sp, #8
    96c4:	af00      	add	r7, sp, #0
    96c6:	6078      	str	r0, [r7, #4]
  if (pcb->state != CLOSED &&
    96c8:	687b      	ldr	r3, [r7, #4]
    96ca:	7e1b      	ldrb	r3, [r3, #24]
    96cc:	2b00      	cmp	r3, #0
    96ce:	d034      	beq.n	973a <tcp_pcb_purge+0x7a>
     pcb->state != TIME_WAIT &&
    96d0:	687b      	ldr	r3, [r7, #4]
    96d2:	7e1b      	ldrb	r3, [r3, #24]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
    96d4:	2b0a      	cmp	r3, #10
    96d6:	d030      	beq.n	973a <tcp_pcb_purge+0x7a>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
    96d8:	687b      	ldr	r3, [r7, #4]
    96da:	7e1b      	ldrb	r3, [r3, #24]
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
    96dc:	2b01      	cmp	r3, #1
    96de:	d02c      	beq.n	973a <tcp_pcb_purge+0x7a>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
    96e0:	687b      	ldr	r3, [r7, #4]
    96e2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    96e4:	2b00      	cmp	r3, #0
    96e6:	d007      	beq.n	96f8 <tcp_pcb_purge+0x38>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
    96e8:	687b      	ldr	r3, [r7, #4]
    96ea:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    96ec:	0018      	movs	r0, r3
    96ee:	4b15      	ldr	r3, [pc, #84]	; (9744 <tcp_pcb_purge+0x84>)
    96f0:	4798      	blx	r3
      pcb->refused_data = NULL;
    96f2:	687b      	ldr	r3, [r7, #4]
    96f4:	2200      	movs	r2, #0
    96f6:	679a      	str	r2, [r3, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
    96f8:	687b      	ldr	r3, [r7, #4]
    96fa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    96fc:	0018      	movs	r0, r3
    96fe:	4b12      	ldr	r3, [pc, #72]	; (9748 <tcp_pcb_purge+0x88>)
    9700:	4798      	blx	r3
    pcb->ooseq = NULL;
    9702:	687b      	ldr	r3, [r7, #4]
    9704:	2200      	movs	r2, #0
    9706:	675a      	str	r2, [r3, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
    9708:	687b      	ldr	r3, [r7, #4]
    970a:	2201      	movs	r2, #1
    970c:	4252      	negs	r2, r2
    970e:	869a      	strh	r2, [r3, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
    9710:	687b      	ldr	r3, [r7, #4]
    9712:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    9714:	0018      	movs	r0, r3
    9716:	4b0c      	ldr	r3, [pc, #48]	; (9748 <tcp_pcb_purge+0x88>)
    9718:	4798      	blx	r3
    tcp_segs_free(pcb->unacked);
    971a:	687b      	ldr	r3, [r7, #4]
    971c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    971e:	0018      	movs	r0, r3
    9720:	4b09      	ldr	r3, [pc, #36]	; (9748 <tcp_pcb_purge+0x88>)
    9722:	4798      	blx	r3
    pcb->unacked = pcb->unsent = NULL;
    9724:	687b      	ldr	r3, [r7, #4]
    9726:	2200      	movs	r2, #0
    9728:	66da      	str	r2, [r3, #108]	; 0x6c
    972a:	687b      	ldr	r3, [r7, #4]
    972c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    972e:	687b      	ldr	r3, [r7, #4]
    9730:	671a      	str	r2, [r3, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
    9732:	687b      	ldr	r3, [r7, #4]
    9734:	226a      	movs	r2, #106	; 0x6a
    9736:	2100      	movs	r1, #0
    9738:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */
  }
}
    973a:	46c0      	nop			; (mov r8, r8)
    973c:	46bd      	mov	sp, r7
    973e:	b002      	add	sp, #8
    9740:	bd80      	pop	{r7, pc}
    9742:	46c0      	nop			; (mov r8, r8)
    9744:	00008349 	.word	0x00008349
    9748:	0000937d 	.word	0x0000937d

0000974c <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    974c:	b580      	push	{r7, lr}
    974e:	b082      	sub	sp, #8
    9750:	af00      	add	r7, sp, #0
    9752:	6078      	str	r0, [r7, #4]
    9754:	6039      	str	r1, [r7, #0]
  TCP_RMV(pcblist, pcb);
    9756:	687b      	ldr	r3, [r7, #4]
    9758:	681a      	ldr	r2, [r3, #0]
    975a:	683b      	ldr	r3, [r7, #0]
    975c:	429a      	cmp	r2, r3
    975e:	d105      	bne.n	976c <tcp_pcb_remove+0x20>
    9760:	687b      	ldr	r3, [r7, #4]
    9762:	681b      	ldr	r3, [r3, #0]
    9764:	68da      	ldr	r2, [r3, #12]
    9766:	687b      	ldr	r3, [r7, #4]
    9768:	601a      	str	r2, [r3, #0]
    976a:	e019      	b.n	97a0 <tcp_pcb_remove+0x54>
    976c:	687b      	ldr	r3, [r7, #4]
    976e:	681a      	ldr	r2, [r3, #0]
    9770:	4b1f      	ldr	r3, [pc, #124]	; (97f0 <tcp_pcb_remove+0xa4>)
    9772:	601a      	str	r2, [r3, #0]
    9774:	e010      	b.n	9798 <tcp_pcb_remove+0x4c>
    9776:	4b1e      	ldr	r3, [pc, #120]	; (97f0 <tcp_pcb_remove+0xa4>)
    9778:	681b      	ldr	r3, [r3, #0]
    977a:	68da      	ldr	r2, [r3, #12]
    977c:	683b      	ldr	r3, [r7, #0]
    977e:	429a      	cmp	r2, r3
    9780:	d105      	bne.n	978e <tcp_pcb_remove+0x42>
    9782:	4b1b      	ldr	r3, [pc, #108]	; (97f0 <tcp_pcb_remove+0xa4>)
    9784:	681b      	ldr	r3, [r3, #0]
    9786:	683a      	ldr	r2, [r7, #0]
    9788:	68d2      	ldr	r2, [r2, #12]
    978a:	60da      	str	r2, [r3, #12]
    978c:	e008      	b.n	97a0 <tcp_pcb_remove+0x54>
    978e:	4b18      	ldr	r3, [pc, #96]	; (97f0 <tcp_pcb_remove+0xa4>)
    9790:	681b      	ldr	r3, [r3, #0]
    9792:	68da      	ldr	r2, [r3, #12]
    9794:	4b16      	ldr	r3, [pc, #88]	; (97f0 <tcp_pcb_remove+0xa4>)
    9796:	601a      	str	r2, [r3, #0]
    9798:	4b15      	ldr	r3, [pc, #84]	; (97f0 <tcp_pcb_remove+0xa4>)
    979a:	681b      	ldr	r3, [r3, #0]
    979c:	2b00      	cmp	r3, #0
    979e:	d1ea      	bne.n	9776 <tcp_pcb_remove+0x2a>
    97a0:	683b      	ldr	r3, [r7, #0]
    97a2:	2200      	movs	r2, #0
    97a4:	60da      	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
    97a6:	683b      	ldr	r3, [r7, #0]
    97a8:	0018      	movs	r0, r3
    97aa:	4b12      	ldr	r3, [pc, #72]	; (97f4 <tcp_pcb_remove+0xa8>)
    97ac:	4798      	blx	r3
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    97ae:	683b      	ldr	r3, [r7, #0]
    97b0:	7e1b      	ldrb	r3, [r3, #24]
    97b2:	2b0a      	cmp	r3, #10
    97b4:	d014      	beq.n	97e0 <tcp_pcb_remove+0x94>
     pcb->state != LISTEN &&
    97b6:	683b      	ldr	r3, [r7, #0]
    97b8:	7e1b      	ldrb	r3, [r3, #24]
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    97ba:	2b01      	cmp	r3, #1
    97bc:	d010      	beq.n	97e0 <tcp_pcb_remove+0x94>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    97be:	683b      	ldr	r3, [r7, #0]
    97c0:	7f9b      	ldrb	r3, [r3, #30]
    97c2:	001a      	movs	r2, r3
    97c4:	2301      	movs	r3, #1
    97c6:	4013      	ands	r3, r2

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
    97c8:	d00a      	beq.n	97e0 <tcp_pcb_remove+0x94>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
    97ca:	683b      	ldr	r3, [r7, #0]
    97cc:	7f9b      	ldrb	r3, [r3, #30]
    97ce:	2202      	movs	r2, #2
    97d0:	4313      	orrs	r3, r2
    97d2:	b2da      	uxtb	r2, r3
    97d4:	683b      	ldr	r3, [r7, #0]
    97d6:	779a      	strb	r2, [r3, #30]
    tcp_output(pcb);
    97d8:	683b      	ldr	r3, [r7, #0]
    97da:	0018      	movs	r0, r3
    97dc:	4b06      	ldr	r3, [pc, #24]	; (97f8 <tcp_pcb_remove+0xac>)
    97de:	4798      	blx	r3
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
    97e0:	683b      	ldr	r3, [r7, #0]
    97e2:	2200      	movs	r2, #0
    97e4:	761a      	strb	r2, [r3, #24]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    97e6:	46c0      	nop			; (mov r8, r8)
    97e8:	46bd      	mov	sp, r7
    97ea:	b002      	add	sp, #8
    97ec:	bd80      	pop	{r7, pc}
    97ee:	46c0      	nop			; (mov r8, r8)
    97f0:	20003ed0 	.word	0x20003ed0
    97f4:	000096c1 	.word	0x000096c1
    97f8:	0000c6bd 	.word	0x0000c6bd

000097fc <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
    97fc:	b580      	push	{r7, lr}
    97fe:	af00      	add	r7, sp, #0
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    9800:	4b05      	ldr	r3, [pc, #20]	; (9818 <tcp_next_iss+0x1c>)
    9802:	681a      	ldr	r2, [r3, #0]
    9804:	4b05      	ldr	r3, [pc, #20]	; (981c <tcp_next_iss+0x20>)
    9806:	681b      	ldr	r3, [r3, #0]
    9808:	18d2      	adds	r2, r2, r3
    980a:	4b03      	ldr	r3, [pc, #12]	; (9818 <tcp_next_iss+0x1c>)
    980c:	601a      	str	r2, [r3, #0]
  return iss;
    980e:	4b02      	ldr	r3, [pc, #8]	; (9818 <tcp_next_iss+0x1c>)
    9810:	681b      	ldr	r3, [r3, #0]
}
    9812:	0018      	movs	r0, r3
    9814:	46bd      	mov	sp, r7
    9816:	bd80      	pop	{r7, pc}
    9818:	2000000c 	.word	0x2000000c
    981c:	20003ec8 	.word	0x20003ec8

00009820 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    9820:	b590      	push	{r4, r7, lr}
    9822:	b085      	sub	sp, #20
    9824:	af00      	add	r7, sp, #0
    9826:	0002      	movs	r2, r0
    9828:	6039      	str	r1, [r7, #0]
    982a:	1dbb      	adds	r3, r7, #6
    982c:	801a      	strh	r2, [r3, #0]
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
    982e:	683b      	ldr	r3, [r7, #0]
    9830:	0018      	movs	r0, r3
    9832:	4b11      	ldr	r3, [pc, #68]	; (9878 <tcp_eff_send_mss+0x58>)
    9834:	4798      	blx	r3
    9836:	0003      	movs	r3, r0
    9838:	60fb      	str	r3, [r7, #12]
  if ((outif != NULL) && (outif->mtu != 0)) {
    983a:	68fb      	ldr	r3, [r7, #12]
    983c:	2b00      	cmp	r3, #0
    983e:	d015      	beq.n	986c <tcp_eff_send_mss+0x4c>
    9840:	68fb      	ldr	r3, [r7, #12]
    9842:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    9844:	2b00      	cmp	r3, #0
    9846:	d011      	beq.n	986c <tcp_eff_send_mss+0x4c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    9848:	68fb      	ldr	r3, [r7, #12]
    984a:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
    984c:	230a      	movs	r3, #10
    984e:	18fb      	adds	r3, r7, r3
    9850:	3a28      	subs	r2, #40	; 0x28
    9852:	801a      	strh	r2, [r3, #0]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
    9854:	1dba      	adds	r2, r7, #6
    9856:	230a      	movs	r3, #10
    9858:	18fb      	adds	r3, r7, r3
    985a:	1db9      	adds	r1, r7, #6
    985c:	880c      	ldrh	r4, [r1, #0]
    985e:	881b      	ldrh	r3, [r3, #0]
    9860:	b298      	uxth	r0, r3
    9862:	b2a1      	uxth	r1, r4
    9864:	4288      	cmp	r0, r1
    9866:	d900      	bls.n	986a <tcp_eff_send_mss+0x4a>
    9868:	1c23      	adds	r3, r4, #0
    986a:	8013      	strh	r3, [r2, #0]
  }
  return sendmss;
    986c:	1dbb      	adds	r3, r7, #6
    986e:	881b      	ldrh	r3, [r3, #0]
}
    9870:	0018      	movs	r0, r3
    9872:	46bd      	mov	sp, r7
    9874:	b005      	add	sp, #20
    9876:	bd90      	pop	{r4, r7, pc}
    9878:	00005c89 	.word	0x00005c89

0000987c <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
    987c:	b5b0      	push	{r4, r5, r7, lr}
    987e:	b088      	sub	sp, #32
    9880:	af02      	add	r7, sp, #8
    9882:	6078      	str	r0, [r7, #4]
    9884:	6039      	str	r1, [r7, #0]
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
    9886:	687b      	ldr	r3, [r7, #4]
    9888:	685a      	ldr	r2, [r3, #4]
    988a:	4bda      	ldr	r3, [pc, #872]	; (9bf4 <tcp_input+0x378>)
    988c:	601a      	str	r2, [r3, #0]
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
    988e:	687b      	ldr	r3, [r7, #4]
    9890:	685a      	ldr	r2, [r3, #4]
    9892:	4bd8      	ldr	r3, [pc, #864]	; (9bf4 <tcp_input+0x378>)
    9894:	681b      	ldr	r3, [r3, #0]
    9896:	781b      	ldrb	r3, [r3, #0]
    9898:	0019      	movs	r1, r3
    989a:	230f      	movs	r3, #15
    989c:	400b      	ands	r3, r1
    989e:	009b      	lsls	r3, r3, #2
    98a0:	18d2      	adds	r2, r2, r3
    98a2:	4bd5      	ldr	r3, [pc, #852]	; (9bf8 <tcp_input+0x37c>)
    98a4:	601a      	str	r2, [r3, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
    98a6:	4bd3      	ldr	r3, [pc, #844]	; (9bf4 <tcp_input+0x378>)
    98a8:	681b      	ldr	r3, [r3, #0]
    98aa:	781b      	ldrb	r3, [r3, #0]
    98ac:	b29b      	uxth	r3, r3
    98ae:	220f      	movs	r2, #15
    98b0:	4013      	ands	r3, r2
    98b2:	b29b      	uxth	r3, r3
    98b4:	009b      	lsls	r3, r3, #2
    98b6:	b29b      	uxth	r3, r3
    98b8:	425b      	negs	r3, r3
    98ba:	b29b      	uxth	r3, r3
    98bc:	b21a      	sxth	r2, r3
    98be:	687b      	ldr	r3, [r7, #4]
    98c0:	0011      	movs	r1, r2
    98c2:	0018      	movs	r0, r3
    98c4:	4bcd      	ldr	r3, [pc, #820]	; (9bfc <tcp_input+0x380>)
    98c6:	4798      	blx	r3
    98c8:	1e03      	subs	r3, r0, #0
    98ca:	d001      	beq.n	98d0 <tcp_input+0x54>
    98cc:	f000 fbd6 	bl	a07c <tcp_input+0x800>
    98d0:	687b      	ldr	r3, [r7, #4]
    98d2:	891b      	ldrh	r3, [r3, #8]
    98d4:	2b13      	cmp	r3, #19
    98d6:	d801      	bhi.n	98dc <tcp_input+0x60>
    98d8:	f000 fbd0 	bl	a07c <tcp_input+0x800>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    98dc:	4bc8      	ldr	r3, [pc, #800]	; (9c00 <tcp_input+0x384>)
    98de:	681b      	ldr	r3, [r3, #0]
    98e0:	683a      	ldr	r2, [r7, #0]
    98e2:	0011      	movs	r1, r2
    98e4:	0018      	movs	r0, r3
    98e6:	4bc7      	ldr	r3, [pc, #796]	; (9c04 <tcp_input+0x388>)
    98e8:	4798      	blx	r3
    98ea:	1e03      	subs	r3, r0, #0
    98ec:	d001      	beq.n	98f2 <tcp_input+0x76>
    98ee:	f000 fbc5 	bl	a07c <tcp_input+0x800>
      ip_addr_ismulticast(&current_iphdr_dest)) {
    98f2:	4bc3      	ldr	r3, [pc, #780]	; (9c00 <tcp_input+0x384>)
    98f4:	681b      	ldr	r3, [r3, #0]
    98f6:	22f0      	movs	r2, #240	; 0xf0
    98f8:	4013      	ands	r3, r2
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
    98fa:	2be0      	cmp	r3, #224	; 0xe0
    98fc:	d101      	bne.n	9902 <tcp_input+0x86>
    98fe:	f000 fbbd 	bl	a07c <tcp_input+0x800>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
    9902:	4bbd      	ldr	r3, [pc, #756]	; (9bf8 <tcp_input+0x37c>)
    9904:	681b      	ldr	r3, [r3, #0]
    9906:	7b1a      	ldrb	r2, [r3, #12]
    9908:	7b5b      	ldrb	r3, [r3, #13]
    990a:	021b      	lsls	r3, r3, #8
    990c:	4313      	orrs	r3, r2
    990e:	b29b      	uxth	r3, r3
    9910:	0018      	movs	r0, r3
    9912:	4bbd      	ldr	r3, [pc, #756]	; (9c08 <tcp_input+0x38c>)
    9914:	4798      	blx	r3
    9916:	0003      	movs	r3, r0
    9918:	0b1b      	lsrs	r3, r3, #12
    991a:	b29a      	uxth	r2, r3
    991c:	230a      	movs	r3, #10
    991e:	18fb      	adds	r3, r7, r3
    9920:	701a      	strb	r2, [r3, #0]
  if(pbuf_header(p, -(hdrlen * 4))){
    9922:	230a      	movs	r3, #10
    9924:	18fb      	adds	r3, r7, r3
    9926:	781b      	ldrb	r3, [r3, #0]
    9928:	b29b      	uxth	r3, r3
    992a:	2204      	movs	r2, #4
    992c:	4252      	negs	r2, r2
    992e:	4353      	muls	r3, r2
    9930:	b29b      	uxth	r3, r3
    9932:	b21a      	sxth	r2, r3
    9934:	687b      	ldr	r3, [r7, #4]
    9936:	0011      	movs	r1, r2
    9938:	0018      	movs	r0, r3
    993a:	4bb0      	ldr	r3, [pc, #704]	; (9bfc <tcp_input+0x380>)
    993c:	4798      	blx	r3
    993e:	1e03      	subs	r3, r0, #0
    9940:	d001      	beq.n	9946 <tcp_input+0xca>
    9942:	f000 fb9a 	bl	a07a <tcp_input+0x7fe>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
    9946:	4bac      	ldr	r3, [pc, #688]	; (9bf8 <tcp_input+0x37c>)
    9948:	681c      	ldr	r4, [r3, #0]
    994a:	4bab      	ldr	r3, [pc, #684]	; (9bf8 <tcp_input+0x37c>)
    994c:	681b      	ldr	r3, [r3, #0]
    994e:	781a      	ldrb	r2, [r3, #0]
    9950:	785b      	ldrb	r3, [r3, #1]
    9952:	021b      	lsls	r3, r3, #8
    9954:	4313      	orrs	r3, r2
    9956:	b29b      	uxth	r3, r3
    9958:	0018      	movs	r0, r3
    995a:	4bab      	ldr	r3, [pc, #684]	; (9c08 <tcp_input+0x38c>)
    995c:	4798      	blx	r3
    995e:	0003      	movs	r3, r0
    9960:	22ff      	movs	r2, #255	; 0xff
    9962:	401a      	ands	r2, r3
    9964:	0010      	movs	r0, r2
    9966:	7822      	ldrb	r2, [r4, #0]
    9968:	2100      	movs	r1, #0
    996a:	400a      	ands	r2, r1
    996c:	1c11      	adds	r1, r2, #0
    996e:	1c02      	adds	r2, r0, #0
    9970:	430a      	orrs	r2, r1
    9972:	7022      	strb	r2, [r4, #0]
    9974:	0a1b      	lsrs	r3, r3, #8
    9976:	b299      	uxth	r1, r3
    9978:	7863      	ldrb	r3, [r4, #1]
    997a:	2200      	movs	r2, #0
    997c:	4013      	ands	r3, r2
    997e:	1c1a      	adds	r2, r3, #0
    9980:	1c0b      	adds	r3, r1, #0
    9982:	4313      	orrs	r3, r2
    9984:	7063      	strb	r3, [r4, #1]
  tcphdr->dest = ntohs(tcphdr->dest);
    9986:	4b9c      	ldr	r3, [pc, #624]	; (9bf8 <tcp_input+0x37c>)
    9988:	681c      	ldr	r4, [r3, #0]
    998a:	4b9b      	ldr	r3, [pc, #620]	; (9bf8 <tcp_input+0x37c>)
    998c:	681b      	ldr	r3, [r3, #0]
    998e:	789a      	ldrb	r2, [r3, #2]
    9990:	78db      	ldrb	r3, [r3, #3]
    9992:	021b      	lsls	r3, r3, #8
    9994:	4313      	orrs	r3, r2
    9996:	b29b      	uxth	r3, r3
    9998:	0018      	movs	r0, r3
    999a:	4b9b      	ldr	r3, [pc, #620]	; (9c08 <tcp_input+0x38c>)
    999c:	4798      	blx	r3
    999e:	0003      	movs	r3, r0
    99a0:	22ff      	movs	r2, #255	; 0xff
    99a2:	401a      	ands	r2, r3
    99a4:	0010      	movs	r0, r2
    99a6:	78a2      	ldrb	r2, [r4, #2]
    99a8:	2100      	movs	r1, #0
    99aa:	400a      	ands	r2, r1
    99ac:	1c11      	adds	r1, r2, #0
    99ae:	1c02      	adds	r2, r0, #0
    99b0:	430a      	orrs	r2, r1
    99b2:	70a2      	strb	r2, [r4, #2]
    99b4:	0a1b      	lsrs	r3, r3, #8
    99b6:	b299      	uxth	r1, r3
    99b8:	78e3      	ldrb	r3, [r4, #3]
    99ba:	2200      	movs	r2, #0
    99bc:	4013      	ands	r3, r2
    99be:	1c1a      	adds	r2, r3, #0
    99c0:	1c0b      	adds	r3, r1, #0
    99c2:	4313      	orrs	r3, r2
    99c4:	70e3      	strb	r3, [r4, #3]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
    99c6:	4b8c      	ldr	r3, [pc, #560]	; (9bf8 <tcp_input+0x37c>)
    99c8:	681c      	ldr	r4, [r3, #0]
    99ca:	4b8b      	ldr	r3, [pc, #556]	; (9bf8 <tcp_input+0x37c>)
    99cc:	681b      	ldr	r3, [r3, #0]
    99ce:	791a      	ldrb	r2, [r3, #4]
    99d0:	7959      	ldrb	r1, [r3, #5]
    99d2:	0209      	lsls	r1, r1, #8
    99d4:	430a      	orrs	r2, r1
    99d6:	7999      	ldrb	r1, [r3, #6]
    99d8:	0409      	lsls	r1, r1, #16
    99da:	430a      	orrs	r2, r1
    99dc:	79db      	ldrb	r3, [r3, #7]
    99de:	061b      	lsls	r3, r3, #24
    99e0:	4313      	orrs	r3, r2
    99e2:	0018      	movs	r0, r3
    99e4:	4b89      	ldr	r3, [pc, #548]	; (9c0c <tcp_input+0x390>)
    99e6:	4798      	blx	r3
    99e8:	0003      	movs	r3, r0
    99ea:	22ff      	movs	r2, #255	; 0xff
    99ec:	401a      	ands	r2, r3
    99ee:	0010      	movs	r0, r2
    99f0:	7922      	ldrb	r2, [r4, #4]
    99f2:	2100      	movs	r1, #0
    99f4:	400a      	ands	r2, r1
    99f6:	1c11      	adds	r1, r2, #0
    99f8:	1c02      	adds	r2, r0, #0
    99fa:	430a      	orrs	r2, r1
    99fc:	7122      	strb	r2, [r4, #4]
    99fe:	0a1a      	lsrs	r2, r3, #8
    9a00:	21ff      	movs	r1, #255	; 0xff
    9a02:	400a      	ands	r2, r1
    9a04:	0010      	movs	r0, r2
    9a06:	7962      	ldrb	r2, [r4, #5]
    9a08:	2100      	movs	r1, #0
    9a0a:	400a      	ands	r2, r1
    9a0c:	1c11      	adds	r1, r2, #0
    9a0e:	1c02      	adds	r2, r0, #0
    9a10:	430a      	orrs	r2, r1
    9a12:	7162      	strb	r2, [r4, #5]
    9a14:	0c1a      	lsrs	r2, r3, #16
    9a16:	21ff      	movs	r1, #255	; 0xff
    9a18:	400a      	ands	r2, r1
    9a1a:	0010      	movs	r0, r2
    9a1c:	79a2      	ldrb	r2, [r4, #6]
    9a1e:	2100      	movs	r1, #0
    9a20:	400a      	ands	r2, r1
    9a22:	1c11      	adds	r1, r2, #0
    9a24:	1c02      	adds	r2, r0, #0
    9a26:	430a      	orrs	r2, r1
    9a28:	71a2      	strb	r2, [r4, #6]
    9a2a:	0e19      	lsrs	r1, r3, #24
    9a2c:	79e3      	ldrb	r3, [r4, #7]
    9a2e:	2200      	movs	r2, #0
    9a30:	4013      	ands	r3, r2
    9a32:	1c1a      	adds	r2, r3, #0
    9a34:	1c0b      	adds	r3, r1, #0
    9a36:	4313      	orrs	r3, r2
    9a38:	71e3      	strb	r3, [r4, #7]
    9a3a:	7923      	ldrb	r3, [r4, #4]
    9a3c:	7962      	ldrb	r2, [r4, #5]
    9a3e:	0212      	lsls	r2, r2, #8
    9a40:	4313      	orrs	r3, r2
    9a42:	79a2      	ldrb	r2, [r4, #6]
    9a44:	0412      	lsls	r2, r2, #16
    9a46:	4313      	orrs	r3, r2
    9a48:	79e2      	ldrb	r2, [r4, #7]
    9a4a:	0612      	lsls	r2, r2, #24
    9a4c:	4313      	orrs	r3, r2
    9a4e:	001a      	movs	r2, r3
    9a50:	4b6f      	ldr	r3, [pc, #444]	; (9c10 <tcp_input+0x394>)
    9a52:	601a      	str	r2, [r3, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
    9a54:	4b68      	ldr	r3, [pc, #416]	; (9bf8 <tcp_input+0x37c>)
    9a56:	681c      	ldr	r4, [r3, #0]
    9a58:	4b67      	ldr	r3, [pc, #412]	; (9bf8 <tcp_input+0x37c>)
    9a5a:	681b      	ldr	r3, [r3, #0]
    9a5c:	7a1a      	ldrb	r2, [r3, #8]
    9a5e:	7a59      	ldrb	r1, [r3, #9]
    9a60:	0209      	lsls	r1, r1, #8
    9a62:	430a      	orrs	r2, r1
    9a64:	7a99      	ldrb	r1, [r3, #10]
    9a66:	0409      	lsls	r1, r1, #16
    9a68:	430a      	orrs	r2, r1
    9a6a:	7adb      	ldrb	r3, [r3, #11]
    9a6c:	061b      	lsls	r3, r3, #24
    9a6e:	4313      	orrs	r3, r2
    9a70:	0018      	movs	r0, r3
    9a72:	4b66      	ldr	r3, [pc, #408]	; (9c0c <tcp_input+0x390>)
    9a74:	4798      	blx	r3
    9a76:	0003      	movs	r3, r0
    9a78:	22ff      	movs	r2, #255	; 0xff
    9a7a:	401a      	ands	r2, r3
    9a7c:	0010      	movs	r0, r2
    9a7e:	7a22      	ldrb	r2, [r4, #8]
    9a80:	2100      	movs	r1, #0
    9a82:	400a      	ands	r2, r1
    9a84:	1c11      	adds	r1, r2, #0
    9a86:	1c02      	adds	r2, r0, #0
    9a88:	430a      	orrs	r2, r1
    9a8a:	7222      	strb	r2, [r4, #8]
    9a8c:	0a1a      	lsrs	r2, r3, #8
    9a8e:	21ff      	movs	r1, #255	; 0xff
    9a90:	400a      	ands	r2, r1
    9a92:	0010      	movs	r0, r2
    9a94:	7a62      	ldrb	r2, [r4, #9]
    9a96:	2100      	movs	r1, #0
    9a98:	400a      	ands	r2, r1
    9a9a:	1c11      	adds	r1, r2, #0
    9a9c:	1c02      	adds	r2, r0, #0
    9a9e:	430a      	orrs	r2, r1
    9aa0:	7262      	strb	r2, [r4, #9]
    9aa2:	0c1a      	lsrs	r2, r3, #16
    9aa4:	21ff      	movs	r1, #255	; 0xff
    9aa6:	400a      	ands	r2, r1
    9aa8:	0010      	movs	r0, r2
    9aaa:	7aa2      	ldrb	r2, [r4, #10]
    9aac:	2100      	movs	r1, #0
    9aae:	400a      	ands	r2, r1
    9ab0:	1c11      	adds	r1, r2, #0
    9ab2:	1c02      	adds	r2, r0, #0
    9ab4:	430a      	orrs	r2, r1
    9ab6:	72a2      	strb	r2, [r4, #10]
    9ab8:	0e19      	lsrs	r1, r3, #24
    9aba:	7ae3      	ldrb	r3, [r4, #11]
    9abc:	2200      	movs	r2, #0
    9abe:	4013      	ands	r3, r2
    9ac0:	1c1a      	adds	r2, r3, #0
    9ac2:	1c0b      	adds	r3, r1, #0
    9ac4:	4313      	orrs	r3, r2
    9ac6:	72e3      	strb	r3, [r4, #11]
    9ac8:	7a23      	ldrb	r3, [r4, #8]
    9aca:	7a62      	ldrb	r2, [r4, #9]
    9acc:	0212      	lsls	r2, r2, #8
    9ace:	4313      	orrs	r3, r2
    9ad0:	7aa2      	ldrb	r2, [r4, #10]
    9ad2:	0412      	lsls	r2, r2, #16
    9ad4:	4313      	orrs	r3, r2
    9ad6:	7ae2      	ldrb	r2, [r4, #11]
    9ad8:	0612      	lsls	r2, r2, #24
    9ada:	4313      	orrs	r3, r2
    9adc:	001a      	movs	r2, r3
    9ade:	4b4d      	ldr	r3, [pc, #308]	; (9c14 <tcp_input+0x398>)
    9ae0:	601a      	str	r2, [r3, #0]
  tcphdr->wnd = ntohs(tcphdr->wnd);
    9ae2:	4b45      	ldr	r3, [pc, #276]	; (9bf8 <tcp_input+0x37c>)
    9ae4:	681c      	ldr	r4, [r3, #0]
    9ae6:	4b44      	ldr	r3, [pc, #272]	; (9bf8 <tcp_input+0x37c>)
    9ae8:	681b      	ldr	r3, [r3, #0]
    9aea:	7b9a      	ldrb	r2, [r3, #14]
    9aec:	7bdb      	ldrb	r3, [r3, #15]
    9aee:	021b      	lsls	r3, r3, #8
    9af0:	4313      	orrs	r3, r2
    9af2:	b29b      	uxth	r3, r3
    9af4:	0018      	movs	r0, r3
    9af6:	4b44      	ldr	r3, [pc, #272]	; (9c08 <tcp_input+0x38c>)
    9af8:	4798      	blx	r3
    9afa:	0003      	movs	r3, r0
    9afc:	22ff      	movs	r2, #255	; 0xff
    9afe:	401a      	ands	r2, r3
    9b00:	0010      	movs	r0, r2
    9b02:	7ba2      	ldrb	r2, [r4, #14]
    9b04:	2100      	movs	r1, #0
    9b06:	400a      	ands	r2, r1
    9b08:	1c11      	adds	r1, r2, #0
    9b0a:	1c02      	adds	r2, r0, #0
    9b0c:	430a      	orrs	r2, r1
    9b0e:	73a2      	strb	r2, [r4, #14]
    9b10:	0a1b      	lsrs	r3, r3, #8
    9b12:	b299      	uxth	r1, r3
    9b14:	7be3      	ldrb	r3, [r4, #15]
    9b16:	2200      	movs	r2, #0
    9b18:	4013      	ands	r3, r2
    9b1a:	1c1a      	adds	r2, r3, #0
    9b1c:	1c0b      	adds	r3, r1, #0
    9b1e:	4313      	orrs	r3, r2
    9b20:	73e3      	strb	r3, [r4, #15]

  flags = TCPH_FLAGS(tcphdr);
    9b22:	4b35      	ldr	r3, [pc, #212]	; (9bf8 <tcp_input+0x37c>)
    9b24:	681b      	ldr	r3, [r3, #0]
    9b26:	7b1a      	ldrb	r2, [r3, #12]
    9b28:	7b5b      	ldrb	r3, [r3, #13]
    9b2a:	021b      	lsls	r3, r3, #8
    9b2c:	4313      	orrs	r3, r2
    9b2e:	b29b      	uxth	r3, r3
    9b30:	0018      	movs	r0, r3
    9b32:	4b35      	ldr	r3, [pc, #212]	; (9c08 <tcp_input+0x38c>)
    9b34:	4798      	blx	r3
    9b36:	0003      	movs	r3, r0
    9b38:	b2db      	uxtb	r3, r3
    9b3a:	223f      	movs	r2, #63	; 0x3f
    9b3c:	4013      	ands	r3, r2
    9b3e:	b2da      	uxtb	r2, r3
    9b40:	4b35      	ldr	r3, [pc, #212]	; (9c18 <tcp_input+0x39c>)
    9b42:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
    9b44:	687b      	ldr	r3, [r7, #4]
    9b46:	891a      	ldrh	r2, [r3, #8]
    9b48:	4b33      	ldr	r3, [pc, #204]	; (9c18 <tcp_input+0x39c>)
    9b4a:	781b      	ldrb	r3, [r3, #0]
    9b4c:	0019      	movs	r1, r3
    9b4e:	2303      	movs	r3, #3
    9b50:	400b      	ands	r3, r1
    9b52:	1e59      	subs	r1, r3, #1
    9b54:	418b      	sbcs	r3, r1
    9b56:	b2db      	uxtb	r3, r3
    9b58:	b29b      	uxth	r3, r3
    9b5a:	18d3      	adds	r3, r2, r3
    9b5c:	b29a      	uxth	r2, r3
    9b5e:	4b2f      	ldr	r3, [pc, #188]	; (9c1c <tcp_input+0x3a0>)
    9b60:	801a      	strh	r2, [r3, #0]

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
    9b62:	2300      	movs	r3, #0
    9b64:	613b      	str	r3, [r7, #16]

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    9b66:	4b2e      	ldr	r3, [pc, #184]	; (9c20 <tcp_input+0x3a4>)
    9b68:	681b      	ldr	r3, [r3, #0]
    9b6a:	617b      	str	r3, [r7, #20]
    9b6c:	e035      	b.n	9bda <tcp_input+0x35e>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
    9b6e:	697b      	ldr	r3, [r7, #20]
    9b70:	8b9a      	ldrh	r2, [r3, #28]
    9b72:	4b21      	ldr	r3, [pc, #132]	; (9bf8 <tcp_input+0x37c>)
    9b74:	681b      	ldr	r3, [r3, #0]
    9b76:	7819      	ldrb	r1, [r3, #0]
    9b78:	785b      	ldrb	r3, [r3, #1]
    9b7a:	021b      	lsls	r3, r3, #8
    9b7c:	430b      	orrs	r3, r1
    9b7e:	b29b      	uxth	r3, r3
    9b80:	429a      	cmp	r2, r3
    9b82:	d125      	bne.n	9bd0 <tcp_input+0x354>
       pcb->local_port == tcphdr->dest &&
    9b84:	697b      	ldr	r3, [r7, #20]
    9b86:	8b5a      	ldrh	r2, [r3, #26]
    9b88:	4b1b      	ldr	r3, [pc, #108]	; (9bf8 <tcp_input+0x37c>)
    9b8a:	681b      	ldr	r3, [r3, #0]
    9b8c:	7899      	ldrb	r1, [r3, #2]
    9b8e:	78db      	ldrb	r3, [r3, #3]
    9b90:	021b      	lsls	r3, r3, #8
    9b92:	430b      	orrs	r3, r1
    9b94:	b29b      	uxth	r3, r3
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
    9b96:	429a      	cmp	r2, r3
    9b98:	d11a      	bne.n	9bd0 <tcp_input+0x354>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    9b9a:	697b      	ldr	r3, [r7, #20]
    9b9c:	685a      	ldr	r2, [r3, #4]
    9b9e:	4b21      	ldr	r3, [pc, #132]	; (9c24 <tcp_input+0x3a8>)
    9ba0:	681b      	ldr	r3, [r3, #0]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
    9ba2:	429a      	cmp	r2, r3
    9ba4:	d114      	bne.n	9bd0 <tcp_input+0x354>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    9ba6:	697b      	ldr	r3, [r7, #20]
    9ba8:	681a      	ldr	r2, [r3, #0]
    9baa:	4b15      	ldr	r3, [pc, #84]	; (9c00 <tcp_input+0x384>)
    9bac:	681b      	ldr	r3, [r3, #0]
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    9bae:	429a      	cmp	r2, r3
    9bb0:	d10e      	bne.n	9bd0 <tcp_input+0x354>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
    9bb2:	693b      	ldr	r3, [r7, #16]
    9bb4:	2b00      	cmp	r3, #0
    9bb6:	d014      	beq.n	9be2 <tcp_input+0x366>
        prev->next = pcb->next;
    9bb8:	697b      	ldr	r3, [r7, #20]
    9bba:	68da      	ldr	r2, [r3, #12]
    9bbc:	693b      	ldr	r3, [r7, #16]
    9bbe:	60da      	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
    9bc0:	4b17      	ldr	r3, [pc, #92]	; (9c20 <tcp_input+0x3a4>)
    9bc2:	681a      	ldr	r2, [r3, #0]
    9bc4:	697b      	ldr	r3, [r7, #20]
    9bc6:	60da      	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
    9bc8:	4b15      	ldr	r3, [pc, #84]	; (9c20 <tcp_input+0x3a4>)
    9bca:	697a      	ldr	r2, [r7, #20]
    9bcc:	601a      	str	r2, [r3, #0]
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
    9bce:	e008      	b.n	9be2 <tcp_input+0x366>
    }
    prev = pcb;
    9bd0:	697b      	ldr	r3, [r7, #20]
    9bd2:	613b      	str	r3, [r7, #16]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    9bd4:	697b      	ldr	r3, [r7, #20]
    9bd6:	68db      	ldr	r3, [r3, #12]
    9bd8:	617b      	str	r3, [r7, #20]
    9bda:	697b      	ldr	r3, [r7, #20]
    9bdc:	2b00      	cmp	r3, #0
    9bde:	d1c6      	bne.n	9b6e <tcp_input+0x2f2>
    9be0:	e000      	b.n	9be4 <tcp_input+0x368>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
    9be2:	46c0      	nop			; (mov r8, r8)
    }
    prev = pcb;
  }

  if (pcb == NULL) {
    9be4:	697b      	ldr	r3, [r7, #20]
    9be6:	2b00      	cmp	r3, #0
    9be8:	d000      	beq.n	9bec <tcp_input+0x370>
    9bea:	e090      	b.n	9d0e <tcp_input+0x492>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    9bec:	4b0e      	ldr	r3, [pc, #56]	; (9c28 <tcp_input+0x3ac>)
    9bee:	681b      	ldr	r3, [r3, #0]
    9bf0:	617b      	str	r3, [r7, #20]
    9bf2:	e049      	b.n	9c88 <tcp_input+0x40c>
    9bf4:	20002c84 	.word	0x20002c84
    9bf8:	20002c80 	.word	0x20002c80
    9bfc:	00008235 	.word	0x00008235
    9c00:	20002e98 	.word	0x20002e98
    9c04:	0000626d 	.word	0x0000626d
    9c08:	0000561d 	.word	0x0000561d
    9c0c:	00005675 	.word	0x00005675
    9c10:	20002c88 	.word	0x20002c88
    9c14:	20002c8c 	.word	0x20002c8c
    9c18:	20002c90 	.word	0x20002c90
    9c1c:	20002c92 	.word	0x20002c92
    9c20:	20003ec4 	.word	0x20003ec4
    9c24:	20002e90 	.word	0x20002e90
    9c28:	20003ed8 	.word	0x20003ed8
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
    9c2c:	697b      	ldr	r3, [r7, #20]
    9c2e:	8b9a      	ldrh	r2, [r3, #28]
    9c30:	4bce      	ldr	r3, [pc, #824]	; (9f6c <tcp_input+0x6f0>)
    9c32:	681b      	ldr	r3, [r3, #0]
    9c34:	7819      	ldrb	r1, [r3, #0]
    9c36:	785b      	ldrb	r3, [r3, #1]
    9c38:	021b      	lsls	r3, r3, #8
    9c3a:	430b      	orrs	r3, r1
    9c3c:	b29b      	uxth	r3, r3
    9c3e:	429a      	cmp	r2, r3
    9c40:	d11f      	bne.n	9c82 <tcp_input+0x406>
         pcb->local_port == tcphdr->dest &&
    9c42:	697b      	ldr	r3, [r7, #20]
    9c44:	8b5a      	ldrh	r2, [r3, #26]
    9c46:	4bc9      	ldr	r3, [pc, #804]	; (9f6c <tcp_input+0x6f0>)
    9c48:	681b      	ldr	r3, [r3, #0]
    9c4a:	7899      	ldrb	r1, [r3, #2]
    9c4c:	78db      	ldrb	r3, [r3, #3]
    9c4e:	021b      	lsls	r3, r3, #8
    9c50:	430b      	orrs	r3, r1
    9c52:	b29b      	uxth	r3, r3
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
    9c54:	429a      	cmp	r2, r3
    9c56:	d114      	bne.n	9c82 <tcp_input+0x406>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    9c58:	697b      	ldr	r3, [r7, #20]
    9c5a:	685a      	ldr	r2, [r3, #4]
    9c5c:	4bc4      	ldr	r3, [pc, #784]	; (9f70 <tcp_input+0x6f4>)
    9c5e:	681b      	ldr	r3, [r3, #0]
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
    9c60:	429a      	cmp	r2, r3
    9c62:	d10e      	bne.n	9c82 <tcp_input+0x406>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
    9c64:	697b      	ldr	r3, [r7, #20]
    9c66:	681a      	ldr	r2, [r3, #0]
    9c68:	4bc2      	ldr	r3, [pc, #776]	; (9f74 <tcp_input+0x6f8>)
    9c6a:	681b      	ldr	r3, [r3, #0]
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
    9c6c:	429a      	cmp	r2, r3
    9c6e:	d108      	bne.n	9c82 <tcp_input+0x406>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
    9c70:	697b      	ldr	r3, [r7, #20]
    9c72:	0018      	movs	r0, r3
    9c74:	4bc0      	ldr	r3, [pc, #768]	; (9f78 <tcp_input+0x6fc>)
    9c76:	4798      	blx	r3
        pbuf_free(p);
    9c78:	687b      	ldr	r3, [r7, #4]
    9c7a:	0018      	movs	r0, r3
    9c7c:	4bbf      	ldr	r3, [pc, #764]	; (9f7c <tcp_input+0x700>)
    9c7e:	4798      	blx	r3
        return;
    9c80:	e202      	b.n	a088 <tcp_input+0x80c>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    9c82:	697b      	ldr	r3, [r7, #20]
    9c84:	68db      	ldr	r3, [r3, #12]
    9c86:	617b      	str	r3, [r7, #20]
    9c88:	697b      	ldr	r3, [r7, #20]
    9c8a:	2b00      	cmp	r3, #0
    9c8c:	d1ce      	bne.n	9c2c <tcp_input+0x3b0>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    9c8e:	2300      	movs	r3, #0
    9c90:	613b      	str	r3, [r7, #16]
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9c92:	4bbb      	ldr	r3, [pc, #748]	; (9f80 <tcp_input+0x704>)
    9c94:	681b      	ldr	r3, [r3, #0]
    9c96:	60fb      	str	r3, [r7, #12]
    9c98:	e01c      	b.n	9cd4 <tcp_input+0x458>
      if (lpcb->local_port == tcphdr->dest) {
    9c9a:	68fb      	ldr	r3, [r7, #12]
    9c9c:	8b5a      	ldrh	r2, [r3, #26]
    9c9e:	4bb3      	ldr	r3, [pc, #716]	; (9f6c <tcp_input+0x6f0>)
    9ca0:	681b      	ldr	r3, [r3, #0]
    9ca2:	7899      	ldrb	r1, [r3, #2]
    9ca4:	78db      	ldrb	r3, [r3, #3]
    9ca6:	021b      	lsls	r3, r3, #8
    9ca8:	430b      	orrs	r3, r1
    9caa:	b29b      	uxth	r3, r3
    9cac:	429a      	cmp	r2, r3
    9cae:	d10c      	bne.n	9cca <tcp_input+0x44e>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
    9cb0:	68fb      	ldr	r3, [r7, #12]
    9cb2:	681a      	ldr	r2, [r3, #0]
    9cb4:	4baf      	ldr	r3, [pc, #700]	; (9f74 <tcp_input+0x6f8>)
    9cb6:	681b      	ldr	r3, [r3, #0]
    9cb8:	429a      	cmp	r2, r3
    9cba:	d00e      	beq.n	9cda <tcp_input+0x45e>
            ip_addr_isany(&(lpcb->local_ip))) {
    9cbc:	68fb      	ldr	r3, [r7, #12]
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
    9cbe:	2b00      	cmp	r3, #0
    9cc0:	d00b      	beq.n	9cda <tcp_input+0x45e>
            ip_addr_isany(&(lpcb->local_ip))) {
    9cc2:	68fb      	ldr	r3, [r7, #12]
    9cc4:	681b      	ldr	r3, [r3, #0]
    9cc6:	2b00      	cmp	r3, #0
    9cc8:	d007      	beq.n	9cda <tcp_input+0x45e>
          /* found a match */
          break;
        }
#endif /* SO_REUSE */
      }
      prev = (struct tcp_pcb *)lpcb;
    9cca:	68fb      	ldr	r3, [r7, #12]
    9ccc:	613b      	str	r3, [r7, #16]
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
    9cce:	68fb      	ldr	r3, [r7, #12]
    9cd0:	68db      	ldr	r3, [r3, #12]
    9cd2:	60fb      	str	r3, [r7, #12]
    9cd4:	68fb      	ldr	r3, [r7, #12]
    9cd6:	2b00      	cmp	r3, #0
    9cd8:	d1df      	bne.n	9c9a <tcp_input+0x41e>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
      prev = lpcb_prev;
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
    9cda:	68fb      	ldr	r3, [r7, #12]
    9cdc:	2b00      	cmp	r3, #0
    9cde:	d016      	beq.n	9d0e <tcp_input+0x492>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
    9ce0:	693b      	ldr	r3, [r7, #16]
    9ce2:	2b00      	cmp	r3, #0
    9ce4:	d00a      	beq.n	9cfc <tcp_input+0x480>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
    9ce6:	68fb      	ldr	r3, [r7, #12]
    9ce8:	68da      	ldr	r2, [r3, #12]
    9cea:	693b      	ldr	r3, [r7, #16]
    9cec:	60da      	str	r2, [r3, #12]
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
    9cee:	4ba4      	ldr	r3, [pc, #656]	; (9f80 <tcp_input+0x704>)
    9cf0:	681a      	ldr	r2, [r3, #0]
    9cf2:	68fb      	ldr	r3, [r7, #12]
    9cf4:	60da      	str	r2, [r3, #12]
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
    9cf6:	4ba2      	ldr	r3, [pc, #648]	; (9f80 <tcp_input+0x704>)
    9cf8:	68fa      	ldr	r2, [r7, #12]
    9cfa:	601a      	str	r2, [r3, #0]
      }
    
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
      tcp_listen_input(lpcb);
    9cfc:	68fb      	ldr	r3, [r7, #12]
    9cfe:	0018      	movs	r0, r3
    9d00:	4ba0      	ldr	r3, [pc, #640]	; (9f84 <tcp_input+0x708>)
    9d02:	4798      	blx	r3
      pbuf_free(p);
    9d04:	687b      	ldr	r3, [r7, #4]
    9d06:	0018      	movs	r0, r3
    9d08:	4b9c      	ldr	r3, [pc, #624]	; (9f7c <tcp_input+0x700>)
    9d0a:	4798      	blx	r3
      return;
    9d0c:	e1bc      	b.n	a088 <tcp_input+0x80c>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
    9d0e:	697b      	ldr	r3, [r7, #20]
    9d10:	2b00      	cmp	r3, #0
    9d12:	d100      	bne.n	9d16 <tcp_input+0x49a>
    9d14:	e17e      	b.n	a014 <tcp_input+0x798>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    9d16:	4b9c      	ldr	r3, [pc, #624]	; (9f88 <tcp_input+0x70c>)
    9d18:	2200      	movs	r2, #0
    9d1a:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
    9d1c:	687b      	ldr	r3, [r7, #4]
    9d1e:	891a      	ldrh	r2, [r3, #8]
    9d20:	4b99      	ldr	r3, [pc, #612]	; (9f88 <tcp_input+0x70c>)
    9d22:	811a      	strh	r2, [r3, #8]
    inseg.p = p;
    9d24:	4b98      	ldr	r3, [pc, #608]	; (9f88 <tcp_input+0x70c>)
    9d26:	687a      	ldr	r2, [r7, #4]
    9d28:	605a      	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
    9d2a:	4b90      	ldr	r3, [pc, #576]	; (9f6c <tcp_input+0x6f0>)
    9d2c:	681a      	ldr	r2, [r3, #0]
    9d2e:	4b96      	ldr	r3, [pc, #600]	; (9f88 <tcp_input+0x70c>)
    9d30:	60da      	str	r2, [r3, #12]

    recv_data = NULL;
    9d32:	4b96      	ldr	r3, [pc, #600]	; (9f8c <tcp_input+0x710>)
    9d34:	2200      	movs	r2, #0
    9d36:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
    9d38:	4b95      	ldr	r3, [pc, #596]	; (9f90 <tcp_input+0x714>)
    9d3a:	2200      	movs	r2, #0
    9d3c:	701a      	strb	r2, [r3, #0]

    if (flags & TCP_PSH) {
    9d3e:	4b95      	ldr	r3, [pc, #596]	; (9f94 <tcp_input+0x718>)
    9d40:	781b      	ldrb	r3, [r3, #0]
    9d42:	001a      	movs	r2, r3
    9d44:	2308      	movs	r3, #8
    9d46:	4013      	ands	r3, r2
    9d48:	d006      	beq.n	9d58 <tcp_input+0x4dc>
      p->flags |= PBUF_FLAG_PUSH;
    9d4a:	687b      	ldr	r3, [r7, #4]
    9d4c:	7b5b      	ldrb	r3, [r3, #13]
    9d4e:	2201      	movs	r2, #1
    9d50:	4313      	orrs	r3, r2
    9d52:	b2da      	uxtb	r2, r3
    9d54:	687b      	ldr	r3, [r7, #4]
    9d56:	735a      	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
    9d58:	697b      	ldr	r3, [r7, #20]
    9d5a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    9d5c:	2b00      	cmp	r3, #0
    9d5e:	d010      	beq.n	9d82 <tcp_input+0x506>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
    9d60:	697b      	ldr	r3, [r7, #20]
    9d62:	0018      	movs	r0, r3
    9d64:	4b8c      	ldr	r3, [pc, #560]	; (9f98 <tcp_input+0x71c>)
    9d66:	4798      	blx	r3
    9d68:	0003      	movs	r3, r0
    9d6a:	330a      	adds	r3, #10
    9d6c:	d100      	bne.n	9d70 <tcp_input+0x4f4>
    9d6e:	e13e      	b.n	9fee <tcp_input+0x772>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
    9d70:	697b      	ldr	r3, [r7, #20]
    9d72:	6f9b      	ldr	r3, [r3, #120]	; 0x78
      p->flags |= PBUF_FLAG_PUSH;
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
    9d74:	2b00      	cmp	r3, #0
    9d76:	d004      	beq.n	9d82 <tcp_input+0x506>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
    9d78:	4b88      	ldr	r3, [pc, #544]	; (9f9c <tcp_input+0x720>)
    9d7a:	881b      	ldrh	r3, [r3, #0]
    9d7c:	2b00      	cmp	r3, #0
    9d7e:	d000      	beq.n	9d82 <tcp_input+0x506>
    9d80:	e135      	b.n	9fee <tcp_input+0x772>
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
    9d82:	4b87      	ldr	r3, [pc, #540]	; (9fa0 <tcp_input+0x724>)
    9d84:	697a      	ldr	r2, [r7, #20]
    9d86:	601a      	str	r2, [r3, #0]
    err = tcp_process(pcb);
    9d88:	230b      	movs	r3, #11
    9d8a:	18fc      	adds	r4, r7, r3
    9d8c:	697b      	ldr	r3, [r7, #20]
    9d8e:	0018      	movs	r0, r3
    9d90:	4b84      	ldr	r3, [pc, #528]	; (9fa4 <tcp_input+0x728>)
    9d92:	4798      	blx	r3
    9d94:	0003      	movs	r3, r0
    9d96:	7023      	strb	r3, [r4, #0]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
    9d98:	230b      	movs	r3, #11
    9d9a:	18fb      	adds	r3, r7, r3
    9d9c:	781b      	ldrb	r3, [r3, #0]
    9d9e:	b25b      	sxtb	r3, r3
    9da0:	330a      	adds	r3, #10
    9da2:	d100      	bne.n	9da6 <tcp_input+0x52a>
    9da4:	e123      	b.n	9fee <tcp_input+0x772>
      if (recv_flags & TF_RESET) {
    9da6:	4b7a      	ldr	r3, [pc, #488]	; (9f90 <tcp_input+0x714>)
    9da8:	781b      	ldrb	r3, [r3, #0]
    9daa:	001a      	movs	r2, r3
    9dac:	2308      	movs	r3, #8
    9dae:	4013      	ands	r3, r2
    9db0:	d019      	beq.n	9de6 <tcp_input+0x56a>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
    9db2:	697b      	ldr	r3, [r7, #20]
    9db4:	228c      	movs	r2, #140	; 0x8c
    9db6:	589b      	ldr	r3, [r3, r2]
    9db8:	2b00      	cmp	r3, #0
    9dba:	d008      	beq.n	9dce <tcp_input+0x552>
    9dbc:	697b      	ldr	r3, [r7, #20]
    9dbe:	228c      	movs	r2, #140	; 0x8c
    9dc0:	589a      	ldr	r2, [r3, r2]
    9dc2:	697b      	ldr	r3, [r7, #20]
    9dc4:	6918      	ldr	r0, [r3, #16]
    9dc6:	230b      	movs	r3, #11
    9dc8:	425b      	negs	r3, r3
    9dca:	0019      	movs	r1, r3
    9dcc:	4790      	blx	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    9dce:	697a      	ldr	r2, [r7, #20]
    9dd0:	4b75      	ldr	r3, [pc, #468]	; (9fa8 <tcp_input+0x72c>)
    9dd2:	0011      	movs	r1, r2
    9dd4:	0018      	movs	r0, r3
    9dd6:	4b75      	ldr	r3, [pc, #468]	; (9fac <tcp_input+0x730>)
    9dd8:	4798      	blx	r3
        memp_free(MEMP_TCP_PCB, pcb);
    9dda:	697b      	ldr	r3, [r7, #20]
    9ddc:	0019      	movs	r1, r3
    9dde:	2001      	movs	r0, #1
    9de0:	4b73      	ldr	r3, [pc, #460]	; (9fb0 <tcp_input+0x734>)
    9de2:	4798      	blx	r3
    9de4:	e103      	b.n	9fee <tcp_input+0x772>
      } else if (recv_flags & TF_CLOSED) {
    9de6:	4b6a      	ldr	r3, [pc, #424]	; (9f90 <tcp_input+0x714>)
    9de8:	781b      	ldrb	r3, [r3, #0]
    9dea:	001a      	movs	r2, r3
    9dec:	2310      	movs	r3, #16
    9dee:	4013      	ands	r3, r2
    9df0:	d01f      	beq.n	9e32 <tcp_input+0x5b6>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
    9df2:	697b      	ldr	r3, [r7, #20]
    9df4:	7f9b      	ldrb	r3, [r3, #30]
    9df6:	001a      	movs	r2, r3
    9df8:	2310      	movs	r3, #16
    9dfa:	4013      	ands	r3, r2
    9dfc:	d10d      	bne.n	9e1a <tcp_input+0x59e>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
    9dfe:	697b      	ldr	r3, [r7, #20]
    9e00:	228c      	movs	r2, #140	; 0x8c
    9e02:	589b      	ldr	r3, [r3, r2]
    9e04:	2b00      	cmp	r3, #0
    9e06:	d008      	beq.n	9e1a <tcp_input+0x59e>
    9e08:	697b      	ldr	r3, [r7, #20]
    9e0a:	228c      	movs	r2, #140	; 0x8c
    9e0c:	589a      	ldr	r2, [r3, r2]
    9e0e:	697b      	ldr	r3, [r7, #20]
    9e10:	6918      	ldr	r0, [r3, #16]
    9e12:	230c      	movs	r3, #12
    9e14:	425b      	negs	r3, r3
    9e16:	0019      	movs	r1, r3
    9e18:	4790      	blx	r2
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
    9e1a:	697a      	ldr	r2, [r7, #20]
    9e1c:	4b62      	ldr	r3, [pc, #392]	; (9fa8 <tcp_input+0x72c>)
    9e1e:	0011      	movs	r1, r2
    9e20:	0018      	movs	r0, r3
    9e22:	4b62      	ldr	r3, [pc, #392]	; (9fac <tcp_input+0x730>)
    9e24:	4798      	blx	r3
        memp_free(MEMP_TCP_PCB, pcb);
    9e26:	697b      	ldr	r3, [r7, #20]
    9e28:	0019      	movs	r1, r3
    9e2a:	2001      	movs	r0, #1
    9e2c:	4b60      	ldr	r3, [pc, #384]	; (9fb0 <tcp_input+0x734>)
    9e2e:	4798      	blx	r3
    9e30:	e0dd      	b.n	9fee <tcp_input+0x772>
      } else {
        err = ERR_OK;
    9e32:	230b      	movs	r3, #11
    9e34:	18fb      	adds	r3, r7, r3
    9e36:	2200      	movs	r2, #0
    9e38:	701a      	strb	r2, [r3, #0]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
    9e3a:	697b      	ldr	r3, [r7, #20]
    9e3c:	2264      	movs	r2, #100	; 0x64
    9e3e:	5a9b      	ldrh	r3, [r3, r2]
    9e40:	2b00      	cmp	r3, #0
    9e42:	d01d      	beq.n	9e80 <tcp_input+0x604>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
    9e44:	697b      	ldr	r3, [r7, #20]
    9e46:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
    9e48:	2b00      	cmp	r3, #0
    9e4a:	d00e      	beq.n	9e6a <tcp_input+0x5ee>
    9e4c:	697b      	ldr	r3, [r7, #20]
    9e4e:	6fdd      	ldr	r5, [r3, #124]	; 0x7c
    9e50:	697b      	ldr	r3, [r7, #20]
    9e52:	6918      	ldr	r0, [r3, #16]
    9e54:	697b      	ldr	r3, [r7, #20]
    9e56:	2264      	movs	r2, #100	; 0x64
    9e58:	5a9a      	ldrh	r2, [r3, r2]
    9e5a:	230b      	movs	r3, #11
    9e5c:	18fc      	adds	r4, r7, r3
    9e5e:	697b      	ldr	r3, [r7, #20]
    9e60:	0019      	movs	r1, r3
    9e62:	47a8      	blx	r5
    9e64:	0003      	movs	r3, r0
    9e66:	7023      	strb	r3, [r4, #0]
    9e68:	e003      	b.n	9e72 <tcp_input+0x5f6>
    9e6a:	230b      	movs	r3, #11
    9e6c:	18fb      	adds	r3, r7, r3
    9e6e:	2200      	movs	r2, #0
    9e70:	701a      	strb	r2, [r3, #0]
          if (err == ERR_ABRT) {
    9e72:	230b      	movs	r3, #11
    9e74:	18fb      	adds	r3, r7, r3
    9e76:	781b      	ldrb	r3, [r3, #0]
    9e78:	b25b      	sxtb	r3, r3
    9e7a:	330a      	adds	r3, #10
    9e7c:	d100      	bne.n	9e80 <tcp_input+0x604>
    9e7e:	e0b1      	b.n	9fe4 <tcp_input+0x768>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
    9e80:	4b42      	ldr	r3, [pc, #264]	; (9f8c <tcp_input+0x710>)
    9e82:	681b      	ldr	r3, [r3, #0]
    9e84:	2b00      	cmp	r3, #0
    9e86:	d03f      	beq.n	9f08 <tcp_input+0x68c>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
    9e88:	697b      	ldr	r3, [r7, #20]
    9e8a:	7f9b      	ldrb	r3, [r3, #30]
    9e8c:	001a      	movs	r2, r3
    9e8e:	2310      	movs	r3, #16
    9e90:	4013      	ands	r3, r2
    9e92:	d009      	beq.n	9ea8 <tcp_input+0x62c>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
    9e94:	4b3d      	ldr	r3, [pc, #244]	; (9f8c <tcp_input+0x710>)
    9e96:	681b      	ldr	r3, [r3, #0]
    9e98:	0018      	movs	r0, r3
    9e9a:	4b38      	ldr	r3, [pc, #224]	; (9f7c <tcp_input+0x700>)
    9e9c:	4798      	blx	r3
            tcp_abort(pcb);
    9e9e:	697b      	ldr	r3, [r7, #20]
    9ea0:	0018      	movs	r0, r3
    9ea2:	4b44      	ldr	r3, [pc, #272]	; (9fb4 <tcp_input+0x738>)
    9ea4:	4798      	blx	r3
            goto aborted;
    9ea6:	e0a2      	b.n	9fee <tcp_input+0x772>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
    9ea8:	697b      	ldr	r3, [r7, #20]
    9eaa:	2280      	movs	r2, #128	; 0x80
    9eac:	589b      	ldr	r3, [r3, r2]
    9eae:	2b00      	cmp	r3, #0
    9eb0:	d00e      	beq.n	9ed0 <tcp_input+0x654>
    9eb2:	697b      	ldr	r3, [r7, #20]
    9eb4:	2280      	movs	r2, #128	; 0x80
    9eb6:	589d      	ldr	r5, [r3, r2]
    9eb8:	697b      	ldr	r3, [r7, #20]
    9eba:	6918      	ldr	r0, [r3, #16]
    9ebc:	4b33      	ldr	r3, [pc, #204]	; (9f8c <tcp_input+0x710>)
    9ebe:	681a      	ldr	r2, [r3, #0]
    9ec0:	230b      	movs	r3, #11
    9ec2:	18fc      	adds	r4, r7, r3
    9ec4:	6979      	ldr	r1, [r7, #20]
    9ec6:	2300      	movs	r3, #0
    9ec8:	47a8      	blx	r5
    9eca:	0003      	movs	r3, r0
    9ecc:	7023      	strb	r3, [r4, #0]
    9ece:	e00a      	b.n	9ee6 <tcp_input+0x66a>
    9ed0:	4b2e      	ldr	r3, [pc, #184]	; (9f8c <tcp_input+0x710>)
    9ed2:	681a      	ldr	r2, [r3, #0]
    9ed4:	230b      	movs	r3, #11
    9ed6:	18fc      	adds	r4, r7, r3
    9ed8:	6979      	ldr	r1, [r7, #20]
    9eda:	2300      	movs	r3, #0
    9edc:	2000      	movs	r0, #0
    9ede:	4d36      	ldr	r5, [pc, #216]	; (9fb8 <tcp_input+0x73c>)
    9ee0:	47a8      	blx	r5
    9ee2:	0003      	movs	r3, r0
    9ee4:	7023      	strb	r3, [r4, #0]
          if (err == ERR_ABRT) {
    9ee6:	230b      	movs	r3, #11
    9ee8:	18fb      	adds	r3, r7, r3
    9eea:	781b      	ldrb	r3, [r3, #0]
    9eec:	b25b      	sxtb	r3, r3
    9eee:	330a      	adds	r3, #10
    9ef0:	d100      	bne.n	9ef4 <tcp_input+0x678>
    9ef2:	e079      	b.n	9fe8 <tcp_input+0x76c>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
    9ef4:	230b      	movs	r3, #11
    9ef6:	18fb      	adds	r3, r7, r3
    9ef8:	781b      	ldrb	r3, [r3, #0]
    9efa:	b25b      	sxtb	r3, r3
    9efc:	2b00      	cmp	r3, #0
    9efe:	d003      	beq.n	9f08 <tcp_input+0x68c>
            pcb->refused_data = recv_data;
    9f00:	4b22      	ldr	r3, [pc, #136]	; (9f8c <tcp_input+0x710>)
    9f02:	681a      	ldr	r2, [r3, #0]
    9f04:	697b      	ldr	r3, [r7, #20]
    9f06:	679a      	str	r2, [r3, #120]	; 0x78
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
    9f08:	4b21      	ldr	r3, [pc, #132]	; (9f90 <tcp_input+0x714>)
    9f0a:	781b      	ldrb	r3, [r3, #0]
    9f0c:	001a      	movs	r2, r3
    9f0e:	2320      	movs	r3, #32
    9f10:	4013      	ands	r3, r2
    9f12:	d05f      	beq.n	9fd4 <tcp_input+0x758>
          if (pcb->refused_data != NULL) {
    9f14:	697b      	ldr	r3, [r7, #20]
    9f16:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    9f18:	2b00      	cmp	r3, #0
    9f1a:	d009      	beq.n	9f30 <tcp_input+0x6b4>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
    9f1c:	697b      	ldr	r3, [r7, #20]
    9f1e:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    9f20:	697b      	ldr	r3, [r7, #20]
    9f22:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    9f24:	7b5b      	ldrb	r3, [r3, #13]
    9f26:	2120      	movs	r1, #32
    9f28:	430b      	orrs	r3, r1
    9f2a:	b2db      	uxtb	r3, r3
    9f2c:	7353      	strb	r3, [r2, #13]
    9f2e:	e051      	b.n	9fd4 <tcp_input+0x758>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
    9f30:	697b      	ldr	r3, [r7, #20]
    9f32:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    9f34:	4a21      	ldr	r2, [pc, #132]	; (9fbc <tcp_input+0x740>)
    9f36:	4293      	cmp	r3, r2
    9f38:	d005      	beq.n	9f46 <tcp_input+0x6ca>
              pcb->rcv_wnd++;
    9f3a:	697b      	ldr	r3, [r7, #20]
    9f3c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    9f3e:	3301      	adds	r3, #1
    9f40:	b29a      	uxth	r2, r3
    9f42:	697b      	ldr	r3, [r7, #20]
    9f44:	859a      	strh	r2, [r3, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
    9f46:	697b      	ldr	r3, [r7, #20]
    9f48:	2280      	movs	r2, #128	; 0x80
    9f4a:	589b      	ldr	r3, [r3, r2]
    9f4c:	2b00      	cmp	r3, #0
    9f4e:	d037      	beq.n	9fc0 <tcp_input+0x744>
    9f50:	697b      	ldr	r3, [r7, #20]
    9f52:	2280      	movs	r2, #128	; 0x80
    9f54:	589d      	ldr	r5, [r3, r2]
    9f56:	697b      	ldr	r3, [r7, #20]
    9f58:	6918      	ldr	r0, [r3, #16]
    9f5a:	230b      	movs	r3, #11
    9f5c:	18fc      	adds	r4, r7, r3
    9f5e:	6979      	ldr	r1, [r7, #20]
    9f60:	2300      	movs	r3, #0
    9f62:	2200      	movs	r2, #0
    9f64:	47a8      	blx	r5
    9f66:	0003      	movs	r3, r0
    9f68:	7023      	strb	r3, [r4, #0]
    9f6a:	e02d      	b.n	9fc8 <tcp_input+0x74c>
    9f6c:	20002c80 	.word	0x20002c80
    9f70:	20002e90 	.word	0x20002e90
    9f74:	20002e98 	.word	0x20002e98
    9f78:	0000a2b5 	.word	0x0000a2b5
    9f7c:	00008349 	.word	0x00008349
    9f80:	20003ecc 	.word	0x20003ecc
    9f84:	0000a0c5 	.word	0x0000a0c5
    9f88:	20002c70 	.word	0x20002c70
    9f8c:	20002c98 	.word	0x20002c98
    9f90:	20002c94 	.word	0x20002c94
    9f94:	20002c90 	.word	0x20002c90
    9f98:	00009289 	.word	0x00009289
    9f9c:	20002c92 	.word	0x20002c92
    9fa0:	20003edc 	.word	0x20003edc
    9fa4:	0000a3a5 	.word	0x0000a3a5
    9fa8:	20003ec4 	.word	0x20003ec4
    9fac:	0000974d 	.word	0x0000974d
    9fb0:	00007b39 	.word	0x00007b39
    9fb4:	00008bbd 	.word	0x00008bbd
    9fb8:	00009431 	.word	0x00009431
    9fbc:	00000b68 	.word	0x00000b68
    9fc0:	230b      	movs	r3, #11
    9fc2:	18fb      	adds	r3, r7, r3
    9fc4:	2200      	movs	r2, #0
    9fc6:	701a      	strb	r2, [r3, #0]
            if (err == ERR_ABRT) {
    9fc8:	230b      	movs	r3, #11
    9fca:	18fb      	adds	r3, r7, r3
    9fcc:	781b      	ldrb	r3, [r3, #0]
    9fce:	b25b      	sxtb	r3, r3
    9fd0:	330a      	adds	r3, #10
    9fd2:	d00b      	beq.n	9fec <tcp_input+0x770>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
    9fd4:	4b2e      	ldr	r3, [pc, #184]	; (a090 <tcp_input+0x814>)
    9fd6:	2200      	movs	r2, #0
    9fd8:	601a      	str	r2, [r3, #0]
        /* Try to send something out. */
        tcp_output(pcb);
    9fda:	697b      	ldr	r3, [r7, #20]
    9fdc:	0018      	movs	r0, r3
    9fde:	4b2d      	ldr	r3, [pc, #180]	; (a094 <tcp_input+0x818>)
    9fe0:	4798      	blx	r3
    9fe2:	e004      	b.n	9fee <tcp_input+0x772>
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
          if (err == ERR_ABRT) {
            goto aborted;
    9fe4:	46c0      	nop			; (mov r8, r8)
    9fe6:	e002      	b.n	9fee <tcp_input+0x772>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
          if (err == ERR_ABRT) {
            goto aborted;
    9fe8:	46c0      	nop			; (mov r8, r8)
    9fea:	e000      	b.n	9fee <tcp_input+0x772>
            if (pcb->rcv_wnd != TCP_WND) {
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
            if (err == ERR_ABRT) {
              goto aborted;
    9fec:	46c0      	nop			; (mov r8, r8)
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
    9fee:	4b28      	ldr	r3, [pc, #160]	; (a090 <tcp_input+0x814>)
    9ff0:	2200      	movs	r2, #0
    9ff2:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
    9ff4:	4b28      	ldr	r3, [pc, #160]	; (a098 <tcp_input+0x81c>)
    9ff6:	2200      	movs	r2, #0
    9ff8:	601a      	str	r2, [r3, #0]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
    9ffa:	4b28      	ldr	r3, [pc, #160]	; (a09c <tcp_input+0x820>)
    9ffc:	685b      	ldr	r3, [r3, #4]
    9ffe:	2b00      	cmp	r3, #0
    a000:	d041      	beq.n	a086 <tcp_input+0x80a>
    {
      pbuf_free(inseg.p);
    a002:	4b26      	ldr	r3, [pc, #152]	; (a09c <tcp_input+0x820>)
    a004:	685b      	ldr	r3, [r3, #4]
    a006:	0018      	movs	r0, r3
    a008:	4b25      	ldr	r3, [pc, #148]	; (a0a0 <tcp_input+0x824>)
    a00a:	4798      	blx	r3
      inseg.p = NULL;
    a00c:	4b23      	ldr	r3, [pc, #140]	; (a09c <tcp_input+0x820>)
    a00e:	2200      	movs	r2, #0
    a010:	605a      	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
    a012:	e038      	b.n	a086 <tcp_input+0x80a>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
    a014:	4b23      	ldr	r3, [pc, #140]	; (a0a4 <tcp_input+0x828>)
    a016:	681b      	ldr	r3, [r3, #0]
    a018:	7b1a      	ldrb	r2, [r3, #12]
    a01a:	7b5b      	ldrb	r3, [r3, #13]
    a01c:	021b      	lsls	r3, r3, #8
    a01e:	4313      	orrs	r3, r2
    a020:	b29b      	uxth	r3, r3
    a022:	0018      	movs	r0, r3
    a024:	4b20      	ldr	r3, [pc, #128]	; (a0a8 <tcp_input+0x82c>)
    a026:	4798      	blx	r3
    a028:	0003      	movs	r3, r0
    a02a:	001a      	movs	r2, r3
    a02c:	2304      	movs	r3, #4
    a02e:	4013      	ands	r3, r2
    a030:	d11e      	bne.n	a070 <tcp_input+0x7f4>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    a032:	4b1e      	ldr	r3, [pc, #120]	; (a0ac <tcp_input+0x830>)
    a034:	6818      	ldr	r0, [r3, #0]
    a036:	4b1e      	ldr	r3, [pc, #120]	; (a0b0 <tcp_input+0x834>)
    a038:	881b      	ldrh	r3, [r3, #0]
    a03a:	001a      	movs	r2, r3
    a03c:	4b1d      	ldr	r3, [pc, #116]	; (a0b4 <tcp_input+0x838>)
    a03e:	681b      	ldr	r3, [r3, #0]
    a040:	18d4      	adds	r4, r2, r3
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    a042:	4b18      	ldr	r3, [pc, #96]	; (a0a4 <tcp_input+0x828>)
    a044:	681b      	ldr	r3, [r3, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    a046:	789a      	ldrb	r2, [r3, #2]
    a048:	78db      	ldrb	r3, [r3, #3]
    a04a:	021b      	lsls	r3, r3, #8
    a04c:	4313      	orrs	r3, r2
    a04e:	b29a      	uxth	r2, r3
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    a050:	4b14      	ldr	r3, [pc, #80]	; (a0a4 <tcp_input+0x828>)
    a052:	681b      	ldr	r3, [r3, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
    a054:	7819      	ldrb	r1, [r3, #0]
    a056:	785b      	ldrb	r3, [r3, #1]
    a058:	021b      	lsls	r3, r3, #8
    a05a:	430b      	orrs	r3, r1
    a05c:	b29b      	uxth	r3, r3
    a05e:	4d16      	ldr	r5, [pc, #88]	; (a0b8 <tcp_input+0x83c>)
    a060:	4916      	ldr	r1, [pc, #88]	; (a0bc <tcp_input+0x840>)
    a062:	9301      	str	r3, [sp, #4]
    a064:	9200      	str	r2, [sp, #0]
    a066:	002b      	movs	r3, r5
    a068:	000a      	movs	r2, r1
    a06a:	0021      	movs	r1, r4
    a06c:	4c14      	ldr	r4, [pc, #80]	; (a0c0 <tcp_input+0x844>)
    a06e:	47a0      	blx	r4
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
    a070:	687b      	ldr	r3, [r7, #4]
    a072:	0018      	movs	r0, r3
    a074:	4b0a      	ldr	r3, [pc, #40]	; (a0a0 <tcp_input+0x824>)
    a076:	4798      	blx	r3
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
    a078:	e005      	b.n	a086 <tcp_input+0x80a>
  hdrlen = TCPH_HDRLEN(tcphdr);
  if(pbuf_header(p, -(hdrlen * 4))){
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
    a07a:	46c0      	nop			; (mov r8, r8)
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
    a07c:	687b      	ldr	r3, [r7, #4]
    a07e:	0018      	movs	r0, r3
    a080:	4b07      	ldr	r3, [pc, #28]	; (a0a0 <tcp_input+0x824>)
    a082:	4798      	blx	r3
    a084:	e000      	b.n	a088 <tcp_input+0x80c>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
    a086:	46c0      	nop			; (mov r8, r8)
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
    a088:	46bd      	mov	sp, r7
    a08a:	b006      	add	sp, #24
    a08c:	bdb0      	pop	{r4, r5, r7, pc}
    a08e:	46c0      	nop			; (mov r8, r8)
    a090:	20003edc 	.word	0x20003edc
    a094:	0000c6bd 	.word	0x0000c6bd
    a098:	20002c98 	.word	0x20002c98
    a09c:	20002c70 	.word	0x20002c70
    a0a0:	00008349 	.word	0x00008349
    a0a4:	20002c80 	.word	0x20002c80
    a0a8:	0000561d 	.word	0x0000561d
    a0ac:	20002c8c 	.word	0x20002c8c
    a0b0:	20002c92 	.word	0x20002c92
    a0b4:	20002c88 	.word	0x20002c88
    a0b8:	20002e90 	.word	0x20002e90
    a0bc:	20002e98 	.word	0x20002e98
    a0c0:	0000cc35 	.word	0x0000cc35

0000a0c4 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
    a0c4:	b5b0      	push	{r4, r5, r7, lr}
    a0c6:	b086      	sub	sp, #24
    a0c8:	af02      	add	r7, sp, #8
    a0ca:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
    a0cc:	4b68      	ldr	r3, [pc, #416]	; (a270 <tcp_listen_input+0x1ac>)
    a0ce:	781b      	ldrb	r3, [r3, #0]
    a0d0:	001a      	movs	r2, r3
    a0d2:	2304      	movs	r3, #4
    a0d4:	4013      	ands	r3, r2
    a0d6:	d001      	beq.n	a0dc <tcp_listen_input+0x18>
    /* An incoming RST should be ignored. Return. */
    return ERR_OK;
    a0d8:	2300      	movs	r3, #0
    a0da:	e0c4      	b.n	a266 <tcp_listen_input+0x1a2>
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    a0dc:	4b64      	ldr	r3, [pc, #400]	; (a270 <tcp_listen_input+0x1ac>)
    a0de:	781b      	ldrb	r3, [r3, #0]
    a0e0:	001a      	movs	r2, r3
    a0e2:	2310      	movs	r3, #16
    a0e4:	4013      	ands	r3, r2
    a0e6:	d01f      	beq.n	a128 <tcp_listen_input+0x64>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    a0e8:	4b62      	ldr	r3, [pc, #392]	; (a274 <tcp_listen_input+0x1b0>)
    a0ea:	6818      	ldr	r0, [r3, #0]
    a0ec:	4b62      	ldr	r3, [pc, #392]	; (a278 <tcp_listen_input+0x1b4>)
    a0ee:	881b      	ldrh	r3, [r3, #0]
    a0f0:	001a      	movs	r2, r3
    a0f2:	4b62      	ldr	r3, [pc, #392]	; (a27c <tcp_listen_input+0x1b8>)
    a0f4:	681b      	ldr	r3, [r3, #0]
    a0f6:	18d4      	adds	r4, r2, r3
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    a0f8:	4b61      	ldr	r3, [pc, #388]	; (a280 <tcp_listen_input+0x1bc>)
    a0fa:	681b      	ldr	r3, [r3, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    a0fc:	789a      	ldrb	r2, [r3, #2]
    a0fe:	78db      	ldrb	r3, [r3, #3]
    a100:	021b      	lsls	r3, r3, #8
    a102:	4313      	orrs	r3, r2
    a104:	b29a      	uxth	r2, r3
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
    a106:	4b5e      	ldr	r3, [pc, #376]	; (a280 <tcp_listen_input+0x1bc>)
    a108:	681b      	ldr	r3, [r3, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
    a10a:	7819      	ldrb	r1, [r3, #0]
    a10c:	785b      	ldrb	r3, [r3, #1]
    a10e:	021b      	lsls	r3, r3, #8
    a110:	430b      	orrs	r3, r1
    a112:	b29b      	uxth	r3, r3
    a114:	4d5b      	ldr	r5, [pc, #364]	; (a284 <tcp_listen_input+0x1c0>)
    a116:	495c      	ldr	r1, [pc, #368]	; (a288 <tcp_listen_input+0x1c4>)
    a118:	9301      	str	r3, [sp, #4]
    a11a:	9200      	str	r2, [sp, #0]
    a11c:	002b      	movs	r3, r5
    a11e:	000a      	movs	r2, r1
    a120:	0021      	movs	r1, r4
    a122:	4c5a      	ldr	r4, [pc, #360]	; (a28c <tcp_listen_input+0x1c8>)
    a124:	47a0      	blx	r4
    a126:	e09d      	b.n	a264 <tcp_listen_input+0x1a0>
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
    a128:	4b51      	ldr	r3, [pc, #324]	; (a270 <tcp_listen_input+0x1ac>)
    a12a:	781b      	ldrb	r3, [r3, #0]
    a12c:	001a      	movs	r2, r3
    a12e:	2302      	movs	r3, #2
    a130:	4013      	ands	r3, r2
    a132:	d100      	bne.n	a136 <tcp_listen_input+0x72>
    a134:	e096      	b.n	a264 <tcp_listen_input+0x1a0>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
    a136:	687b      	ldr	r3, [r7, #4]
    a138:	7e5b      	ldrb	r3, [r3, #25]
    a13a:	0018      	movs	r0, r3
    a13c:	4b54      	ldr	r3, [pc, #336]	; (a290 <tcp_listen_input+0x1cc>)
    a13e:	4798      	blx	r3
    a140:	0003      	movs	r3, r0
    a142:	60fb      	str	r3, [r7, #12]
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
    a144:	68fb      	ldr	r3, [r7, #12]
    a146:	2b00      	cmp	r3, #0
    a148:	d102      	bne.n	a150 <tcp_listen_input+0x8c>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
    a14a:	2301      	movs	r3, #1
    a14c:	425b      	negs	r3, r3
    a14e:	e08a      	b.n	a266 <tcp_listen_input+0x1a2>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    a150:	4b4d      	ldr	r3, [pc, #308]	; (a288 <tcp_listen_input+0x1c4>)
    a152:	681a      	ldr	r2, [r3, #0]
    a154:	68fb      	ldr	r3, [r7, #12]
    a156:	601a      	str	r2, [r3, #0]
    npcb->local_port = pcb->local_port;
    a158:	687b      	ldr	r3, [r7, #4]
    a15a:	8b5a      	ldrh	r2, [r3, #26]
    a15c:	68fb      	ldr	r3, [r7, #12]
    a15e:	835a      	strh	r2, [r3, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    a160:	4b48      	ldr	r3, [pc, #288]	; (a284 <tcp_listen_input+0x1c0>)
    a162:	681a      	ldr	r2, [r3, #0]
    a164:	68fb      	ldr	r3, [r7, #12]
    a166:	605a      	str	r2, [r3, #4]
    npcb->remote_port = tcphdr->src;
    a168:	4b45      	ldr	r3, [pc, #276]	; (a280 <tcp_listen_input+0x1bc>)
    a16a:	681b      	ldr	r3, [r3, #0]
    a16c:	781a      	ldrb	r2, [r3, #0]
    a16e:	785b      	ldrb	r3, [r3, #1]
    a170:	021b      	lsls	r3, r3, #8
    a172:	4313      	orrs	r3, r2
    a174:	b29a      	uxth	r2, r3
    a176:	68fb      	ldr	r3, [r7, #12]
    a178:	839a      	strh	r2, [r3, #28]
    npcb->state = SYN_RCVD;
    a17a:	68fb      	ldr	r3, [r7, #12]
    a17c:	2203      	movs	r2, #3
    a17e:	761a      	strb	r2, [r3, #24]
    npcb->rcv_nxt = seqno + 1;
    a180:	4b3e      	ldr	r3, [pc, #248]	; (a27c <tcp_listen_input+0x1b8>)
    a182:	681b      	ldr	r3, [r3, #0]
    a184:	1c5a      	adds	r2, r3, #1
    a186:	68fb      	ldr	r3, [r7, #12]
    a188:	629a      	str	r2, [r3, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    a18a:	68fb      	ldr	r3, [r7, #12]
    a18c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    a18e:	68fb      	ldr	r3, [r7, #12]
    a190:	631a      	str	r2, [r3, #48]	; 0x30
    npcb->snd_wnd = tcphdr->wnd;
    a192:	4b3b      	ldr	r3, [pc, #236]	; (a280 <tcp_listen_input+0x1bc>)
    a194:	681b      	ldr	r3, [r3, #0]
    a196:	7b9a      	ldrb	r2, [r3, #14]
    a198:	7bdb      	ldrb	r3, [r3, #15]
    a19a:	021b      	lsls	r3, r3, #8
    a19c:	4313      	orrs	r3, r2
    a19e:	b299      	uxth	r1, r3
    a1a0:	68fb      	ldr	r3, [r7, #12]
    a1a2:	2260      	movs	r2, #96	; 0x60
    a1a4:	5299      	strh	r1, [r3, r2]
    npcb->snd_wnd_max = tcphdr->wnd;
    a1a6:	4b36      	ldr	r3, [pc, #216]	; (a280 <tcp_listen_input+0x1bc>)
    a1a8:	681b      	ldr	r3, [r3, #0]
    a1aa:	7b9a      	ldrb	r2, [r3, #14]
    a1ac:	7bdb      	ldrb	r3, [r3, #15]
    a1ae:	021b      	lsls	r3, r3, #8
    a1b0:	4313      	orrs	r3, r2
    a1b2:	b299      	uxth	r1, r3
    a1b4:	68fb      	ldr	r3, [r7, #12]
    a1b6:	2262      	movs	r2, #98	; 0x62
    a1b8:	5299      	strh	r1, [r3, r2]
    npcb->ssthresh = npcb->snd_wnd;
    a1ba:	68fb      	ldr	r3, [r7, #12]
    a1bc:	2260      	movs	r2, #96	; 0x60
    a1be:	5a99      	ldrh	r1, [r3, r2]
    a1c0:	68fb      	ldr	r3, [r7, #12]
    a1c2:	224e      	movs	r2, #78	; 0x4e
    a1c4:	5299      	strh	r1, [r3, r2]
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    a1c6:	4b2d      	ldr	r3, [pc, #180]	; (a27c <tcp_listen_input+0x1b8>)
    a1c8:	681b      	ldr	r3, [r3, #0]
    a1ca:	1e5a      	subs	r2, r3, #1
    a1cc:	68fb      	ldr	r3, [r7, #12]
    a1ce:	655a      	str	r2, [r3, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
    a1d0:	687b      	ldr	r3, [r7, #4]
    a1d2:	691a      	ldr	r2, [r3, #16]
    a1d4:	68fb      	ldr	r3, [r7, #12]
    a1d6:	611a      	str	r2, [r3, #16]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
    a1d8:	687b      	ldr	r3, [r7, #4]
    a1da:	695a      	ldr	r2, [r3, #20]
    a1dc:	68fb      	ldr	r3, [r7, #12]
    a1de:	615a      	str	r2, [r3, #20]
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    a1e0:	687b      	ldr	r3, [r7, #4]
    a1e2:	7a1b      	ldrb	r3, [r3, #8]
    a1e4:	2273      	movs	r2, #115	; 0x73
    a1e6:	4393      	bics	r3, r2
    a1e8:	b2da      	uxtb	r2, r3
    a1ea:	68fb      	ldr	r3, [r7, #12]
    a1ec:	721a      	strb	r2, [r3, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
    a1ee:	4b29      	ldr	r3, [pc, #164]	; (a294 <tcp_listen_input+0x1d0>)
    a1f0:	681a      	ldr	r2, [r3, #0]
    a1f2:	68fb      	ldr	r3, [r7, #12]
    a1f4:	60da      	str	r2, [r3, #12]
    a1f6:	4b27      	ldr	r3, [pc, #156]	; (a294 <tcp_listen_input+0x1d0>)
    a1f8:	68fa      	ldr	r2, [r7, #12]
    a1fa:	601a      	str	r2, [r3, #0]
    a1fc:	4b26      	ldr	r3, [pc, #152]	; (a298 <tcp_listen_input+0x1d4>)
    a1fe:	4798      	blx	r3
    a200:	4b26      	ldr	r3, [pc, #152]	; (a29c <tcp_listen_input+0x1d8>)
    a202:	2201      	movs	r2, #1
    a204:	701a      	strb	r2, [r3, #0]

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
    a206:	68fb      	ldr	r3, [r7, #12]
    a208:	0018      	movs	r0, r3
    a20a:	4b25      	ldr	r3, [pc, #148]	; (a2a0 <tcp_listen_input+0x1dc>)
    a20c:	4798      	blx	r3
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
    a20e:	68fb      	ldr	r3, [r7, #12]
    a210:	8eda      	ldrh	r2, [r3, #54]	; 0x36
    a212:	68fb      	ldr	r3, [r7, #12]
    a214:	3304      	adds	r3, #4
    a216:	0019      	movs	r1, r3
    a218:	0010      	movs	r0, r2
    a21a:	4b22      	ldr	r3, [pc, #136]	; (a2a4 <tcp_listen_input+0x1e0>)
    a21c:	4798      	blx	r3
    a21e:	0003      	movs	r3, r0
    a220:	001a      	movs	r2, r3
    a222:	68fb      	ldr	r3, [r7, #12]
    a224:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    a226:	230b      	movs	r3, #11
    a228:	18fc      	adds	r4, r7, r3
    a22a:	68fb      	ldr	r3, [r7, #12]
    a22c:	2112      	movs	r1, #18
    a22e:	0018      	movs	r0, r3
    a230:	4b1d      	ldr	r3, [pc, #116]	; (a2a8 <tcp_listen_input+0x1e4>)
    a232:	4798      	blx	r3
    a234:	0003      	movs	r3, r0
    a236:	7023      	strb	r3, [r4, #0]
    if (rc != ERR_OK) {
    a238:	230b      	movs	r3, #11
    a23a:	18fb      	adds	r3, r7, r3
    a23c:	781b      	ldrb	r3, [r3, #0]
    a23e:	b25b      	sxtb	r3, r3
    a240:	2b00      	cmp	r3, #0
    a242:	d009      	beq.n	a258 <tcp_listen_input+0x194>
      tcp_abandon(npcb, 0);
    a244:	68fb      	ldr	r3, [r7, #12]
    a246:	2100      	movs	r1, #0
    a248:	0018      	movs	r0, r3
    a24a:	4b18      	ldr	r3, [pc, #96]	; (a2ac <tcp_listen_input+0x1e8>)
    a24c:	4798      	blx	r3
      return rc;
    a24e:	230b      	movs	r3, #11
    a250:	18fb      	adds	r3, r7, r3
    a252:	781b      	ldrb	r3, [r3, #0]
    a254:	b25b      	sxtb	r3, r3
    a256:	e006      	b.n	a266 <tcp_listen_input+0x1a2>
    }
    return tcp_output(npcb);
    a258:	68fb      	ldr	r3, [r7, #12]
    a25a:	0018      	movs	r0, r3
    a25c:	4b14      	ldr	r3, [pc, #80]	; (a2b0 <tcp_listen_input+0x1ec>)
    a25e:	4798      	blx	r3
    a260:	0003      	movs	r3, r0
    a262:	e000      	b.n	a266 <tcp_listen_input+0x1a2>
  }
  return ERR_OK;
    a264:	2300      	movs	r3, #0
}
    a266:	0018      	movs	r0, r3
    a268:	46bd      	mov	sp, r7
    a26a:	b004      	add	sp, #16
    a26c:	bdb0      	pop	{r4, r5, r7, pc}
    a26e:	46c0      	nop			; (mov r8, r8)
    a270:	20002c90 	.word	0x20002c90
    a274:	20002c8c 	.word	0x20002c8c
    a278:	20002c92 	.word	0x20002c92
    a27c:	20002c88 	.word	0x20002c88
    a280:	20002c80 	.word	0x20002c80
    a284:	20002e90 	.word	0x20002e90
    a288:	20002e98 	.word	0x20002e98
    a28c:	0000cc35 	.word	0x0000cc35
    a290:	00009589 	.word	0x00009589
    a294:	20003ec4 	.word	0x20003ec4
    a298:	00007355 	.word	0x00007355
    a29c:	20003ec0 	.word	0x20003ec0
    a2a0:	0000be19 	.word	0x0000be19
    a2a4:	00009821 	.word	0x00009821
    a2a8:	0000c471 	.word	0x0000c471
    a2ac:	00008acd 	.word	0x00008acd
    a2b0:	0000c6bd 	.word	0x0000c6bd

0000a2b4 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
    a2b4:	b5b0      	push	{r4, r5, r7, lr}
    a2b6:	b084      	sub	sp, #16
    a2b8:	af02      	add	r7, sp, #8
    a2ba:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
    a2bc:	4b2f      	ldr	r3, [pc, #188]	; (a37c <tcp_timewait_input+0xc8>)
    a2be:	781b      	ldrb	r3, [r3, #0]
    a2c0:	001a      	movs	r2, r3
    a2c2:	2304      	movs	r3, #4
    a2c4:	4013      	ands	r3, r2
    a2c6:	d001      	beq.n	a2cc <tcp_timewait_input+0x18>
    return ERR_OK;
    a2c8:	2300      	movs	r3, #0
    a2ca:	e052      	b.n	a372 <tcp_timewait_input+0xbe>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
    a2cc:	4b2b      	ldr	r3, [pc, #172]	; (a37c <tcp_timewait_input+0xc8>)
    a2ce:	781b      	ldrb	r3, [r3, #0]
    a2d0:	001a      	movs	r2, r3
    a2d2:	2302      	movs	r3, #2
    a2d4:	4013      	ands	r3, r2
    a2d6:	d030      	beq.n	a33a <tcp_timewait_input+0x86>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
    a2d8:	4b29      	ldr	r3, [pc, #164]	; (a380 <tcp_timewait_input+0xcc>)
    a2da:	681a      	ldr	r2, [r3, #0]
    a2dc:	687b      	ldr	r3, [r7, #4]
    a2de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    a2e0:	1ad3      	subs	r3, r2, r3
    a2e2:	d434      	bmi.n	a34e <tcp_timewait_input+0x9a>
    a2e4:	4b26      	ldr	r3, [pc, #152]	; (a380 <tcp_timewait_input+0xcc>)
    a2e6:	681a      	ldr	r2, [r3, #0]
    a2e8:	687b      	ldr	r3, [r7, #4]
    a2ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    a2ec:	6879      	ldr	r1, [r7, #4]
    a2ee:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
    a2f0:	185b      	adds	r3, r3, r1
    a2f2:	1ad3      	subs	r3, r2, r3
    a2f4:	2b00      	cmp	r3, #0
    a2f6:	dc2a      	bgt.n	a34e <tcp_timewait_input+0x9a>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a2f8:	4b22      	ldr	r3, [pc, #136]	; (a384 <tcp_timewait_input+0xd0>)
    a2fa:	6818      	ldr	r0, [r3, #0]
    a2fc:	4b22      	ldr	r3, [pc, #136]	; (a388 <tcp_timewait_input+0xd4>)
    a2fe:	881b      	ldrh	r3, [r3, #0]
    a300:	001a      	movs	r2, r3
    a302:	4b1f      	ldr	r3, [pc, #124]	; (a380 <tcp_timewait_input+0xcc>)
    a304:	681b      	ldr	r3, [r3, #0]
    a306:	18d4      	adds	r4, r2, r3
        tcphdr->dest, tcphdr->src);
    a308:	4b20      	ldr	r3, [pc, #128]	; (a38c <tcp_timewait_input+0xd8>)
    a30a:	681b      	ldr	r3, [r3, #0]
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a30c:	789a      	ldrb	r2, [r3, #2]
    a30e:	78db      	ldrb	r3, [r3, #3]
    a310:	021b      	lsls	r3, r3, #8
    a312:	4313      	orrs	r3, r2
    a314:	b29a      	uxth	r2, r3
        tcphdr->dest, tcphdr->src);
    a316:	4b1d      	ldr	r3, [pc, #116]	; (a38c <tcp_timewait_input+0xd8>)
    a318:	681b      	ldr	r3, [r3, #0]
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a31a:	7819      	ldrb	r1, [r3, #0]
    a31c:	785b      	ldrb	r3, [r3, #1]
    a31e:	021b      	lsls	r3, r3, #8
    a320:	430b      	orrs	r3, r1
    a322:	b29b      	uxth	r3, r3
    a324:	4d1a      	ldr	r5, [pc, #104]	; (a390 <tcp_timewait_input+0xdc>)
    a326:	491b      	ldr	r1, [pc, #108]	; (a394 <tcp_timewait_input+0xe0>)
    a328:	9301      	str	r3, [sp, #4]
    a32a:	9200      	str	r2, [sp, #0]
    a32c:	002b      	movs	r3, r5
    a32e:	000a      	movs	r2, r1
    a330:	0021      	movs	r1, r4
    a332:	4c19      	ldr	r4, [pc, #100]	; (a398 <tcp_timewait_input+0xe4>)
    a334:	47a0      	blx	r4
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    a336:	2300      	movs	r3, #0
    a338:	e01b      	b.n	a372 <tcp_timewait_input+0xbe>
    }
  } else if (flags & TCP_FIN) {
    a33a:	4b10      	ldr	r3, [pc, #64]	; (a37c <tcp_timewait_input+0xc8>)
    a33c:	781b      	ldrb	r3, [r3, #0]
    a33e:	001a      	movs	r2, r3
    a340:	2301      	movs	r3, #1
    a342:	4013      	ands	r3, r2
    a344:	d003      	beq.n	a34e <tcp_timewait_input+0x9a>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
    a346:	4b15      	ldr	r3, [pc, #84]	; (a39c <tcp_timewait_input+0xe8>)
    a348:	681a      	ldr	r2, [r3, #0]
    a34a:	687b      	ldr	r3, [r7, #4]
    a34c:	625a      	str	r2, [r3, #36]	; 0x24
  }

  if ((tcplen > 0))  {
    a34e:	4b0e      	ldr	r3, [pc, #56]	; (a388 <tcp_timewait_input+0xd4>)
    a350:	881b      	ldrh	r3, [r3, #0]
    a352:	2b00      	cmp	r3, #0
    a354:	d00c      	beq.n	a370 <tcp_timewait_input+0xbc>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
    a356:	687b      	ldr	r3, [r7, #4]
    a358:	7f9b      	ldrb	r3, [r3, #30]
    a35a:	2202      	movs	r2, #2
    a35c:	4313      	orrs	r3, r2
    a35e:	b2da      	uxtb	r2, r3
    a360:	687b      	ldr	r3, [r7, #4]
    a362:	779a      	strb	r2, [r3, #30]
    return tcp_output(pcb);
    a364:	687b      	ldr	r3, [r7, #4]
    a366:	0018      	movs	r0, r3
    a368:	4b0d      	ldr	r3, [pc, #52]	; (a3a0 <tcp_timewait_input+0xec>)
    a36a:	4798      	blx	r3
    a36c:	0003      	movs	r3, r0
    a36e:	e000      	b.n	a372 <tcp_timewait_input+0xbe>
  }
  return ERR_OK;
    a370:	2300      	movs	r3, #0
}
    a372:	0018      	movs	r0, r3
    a374:	46bd      	mov	sp, r7
    a376:	b002      	add	sp, #8
    a378:	bdb0      	pop	{r4, r5, r7, pc}
    a37a:	46c0      	nop			; (mov r8, r8)
    a37c:	20002c90 	.word	0x20002c90
    a380:	20002c88 	.word	0x20002c88
    a384:	20002c8c 	.word	0x20002c8c
    a388:	20002c92 	.word	0x20002c92
    a38c:	20002c80 	.word	0x20002c80
    a390:	20002e90 	.word	0x20002e90
    a394:	20002e98 	.word	0x20002e98
    a398:	0000cc35 	.word	0x0000cc35
    a39c:	20003ec8 	.word	0x20003ec8
    a3a0:	0000c6bd 	.word	0x0000c6bd

0000a3a4 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
    a3a4:	b5b0      	push	{r4, r5, r7, lr}
    a3a6:	b088      	sub	sp, #32
    a3a8:	af02      	add	r7, sp, #8
    a3aa:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
    a3ac:	2317      	movs	r3, #23
    a3ae:	18fb      	adds	r3, r7, r3
    a3b0:	2200      	movs	r2, #0
    a3b2:	701a      	strb	r2, [r3, #0]
  err_t err;

  err = ERR_OK;
    a3b4:	2316      	movs	r3, #22
    a3b6:	18fb      	adds	r3, r7, r3
    a3b8:	2200      	movs	r2, #0
    a3ba:	701a      	strb	r2, [r3, #0]

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    a3bc:	4bd1      	ldr	r3, [pc, #836]	; (a704 <tcp_process+0x360>)
    a3be:	781b      	ldrb	r3, [r3, #0]
    a3c0:	001a      	movs	r2, r3
    a3c2:	2304      	movs	r3, #4
    a3c4:	4013      	ands	r3, r2
    a3c6:	d03a      	beq.n	a43e <tcp_process+0x9a>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
    a3c8:	687b      	ldr	r3, [r7, #4]
    a3ca:	7e1b      	ldrb	r3, [r3, #24]
    a3cc:	2b02      	cmp	r3, #2
    a3ce:	d10a      	bne.n	a3e6 <tcp_process+0x42>
      if (ackno == pcb->snd_nxt) {
    a3d0:	687b      	ldr	r3, [r7, #4]
    a3d2:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    a3d4:	4bcc      	ldr	r3, [pc, #816]	; (a708 <tcp_process+0x364>)
    a3d6:	681b      	ldr	r3, [r3, #0]
    a3d8:	429a      	cmp	r2, r3
    a3da:	d118      	bne.n	a40e <tcp_process+0x6a>
        acceptable = 1;
    a3dc:	2317      	movs	r3, #23
    a3de:	18fb      	adds	r3, r7, r3
    a3e0:	2201      	movs	r2, #1
    a3e2:	701a      	strb	r2, [r3, #0]
    a3e4:	e013      	b.n	a40e <tcp_process+0x6a>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    a3e6:	4bc9      	ldr	r3, [pc, #804]	; (a70c <tcp_process+0x368>)
    a3e8:	681a      	ldr	r2, [r3, #0]
    a3ea:	687b      	ldr	r3, [r7, #4]
    a3ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    a3ee:	1ad3      	subs	r3, r2, r3
    a3f0:	d40d      	bmi.n	a40e <tcp_process+0x6a>
    a3f2:	4bc6      	ldr	r3, [pc, #792]	; (a70c <tcp_process+0x368>)
    a3f4:	681a      	ldr	r2, [r3, #0]
    a3f6:	687b      	ldr	r3, [r7, #4]
    a3f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    a3fa:	6879      	ldr	r1, [r7, #4]
    a3fc:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
    a3fe:	185b      	adds	r3, r3, r1
    a400:	1ad3      	subs	r3, r2, r3
    a402:	2b00      	cmp	r3, #0
    a404:	dc03      	bgt.n	a40e <tcp_process+0x6a>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
    a406:	2317      	movs	r3, #23
    a408:	18fb      	adds	r3, r7, r3
    a40a:	2201      	movs	r2, #1
    a40c:	701a      	strb	r2, [r3, #0]
      }
    }

    if (acceptable) {
    a40e:	2317      	movs	r3, #23
    a410:	18fb      	adds	r3, r7, r3
    a412:	781b      	ldrb	r3, [r3, #0]
    a414:	2b00      	cmp	r3, #0
    a416:	d010      	beq.n	a43a <tcp_process+0x96>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
    a418:	4bbd      	ldr	r3, [pc, #756]	; (a710 <tcp_process+0x36c>)
    a41a:	781b      	ldrb	r3, [r3, #0]
    a41c:	2208      	movs	r2, #8
    a41e:	4313      	orrs	r3, r2
    a420:	b2da      	uxtb	r2, r3
    a422:	4bbb      	ldr	r3, [pc, #748]	; (a710 <tcp_process+0x36c>)
    a424:	701a      	strb	r2, [r3, #0]
      pcb->flags &= ~TF_ACK_DELAY;
    a426:	687b      	ldr	r3, [r7, #4]
    a428:	7f9b      	ldrb	r3, [r3, #30]
    a42a:	2201      	movs	r2, #1
    a42c:	4393      	bics	r3, r2
    a42e:	b2da      	uxtb	r2, r3
    a430:	687b      	ldr	r3, [r7, #4]
    a432:	779a      	strb	r2, [r3, #30]
      return ERR_RST;
    a434:	230b      	movs	r3, #11
    a436:	425b      	negs	r3, r3
    a438:	e364      	b.n	ab04 <tcp_process+0x760>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    a43a:	2300      	movs	r3, #0
    a43c:	e362      	b.n	ab04 <tcp_process+0x760>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
    a43e:	4bb1      	ldr	r3, [pc, #708]	; (a704 <tcp_process+0x360>)
    a440:	781b      	ldrb	r3, [r3, #0]
    a442:	001a      	movs	r2, r3
    a444:	2302      	movs	r3, #2
    a446:	4013      	ands	r3, r2
    a448:	d010      	beq.n	a46c <tcp_process+0xc8>
    a44a:	687b      	ldr	r3, [r7, #4]
    a44c:	7e1b      	ldrb	r3, [r3, #24]
    a44e:	2b02      	cmp	r3, #2
    a450:	d00c      	beq.n	a46c <tcp_process+0xc8>
    a452:	687b      	ldr	r3, [r7, #4]
    a454:	7e1b      	ldrb	r3, [r3, #24]
    a456:	2b03      	cmp	r3, #3
    a458:	d008      	beq.n	a46c <tcp_process+0xc8>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    a45a:	687b      	ldr	r3, [r7, #4]
    a45c:	7f9b      	ldrb	r3, [r3, #30]
    a45e:	2202      	movs	r2, #2
    a460:	4313      	orrs	r3, r2
    a462:	b2da      	uxtb	r2, r3
    a464:	687b      	ldr	r3, [r7, #4]
    a466:	779a      	strb	r2, [r3, #30]
    return ERR_OK;
    a468:	2300      	movs	r3, #0
    a46a:	e34b      	b.n	ab04 <tcp_process+0x760>
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
    a46c:	687b      	ldr	r3, [r7, #4]
    a46e:	7f9b      	ldrb	r3, [r3, #30]
    a470:	001a      	movs	r2, r3
    a472:	2310      	movs	r3, #16
    a474:	4013      	ands	r3, r2
    a476:	d103      	bne.n	a480 <tcp_process+0xdc>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
    a478:	4ba6      	ldr	r3, [pc, #664]	; (a714 <tcp_process+0x370>)
    a47a:	681a      	ldr	r2, [r3, #0]
    a47c:	687b      	ldr	r3, [r7, #4]
    a47e:	625a      	str	r2, [r3, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
    a480:	687b      	ldr	r3, [r7, #4]
    a482:	2296      	movs	r2, #150	; 0x96
    a484:	2100      	movs	r1, #0
    a486:	5499      	strb	r1, [r3, r2]

  tcp_parseopt(pcb);
    a488:	687b      	ldr	r3, [r7, #4]
    a48a:	0018      	movs	r0, r3
    a48c:	4ba2      	ldr	r3, [pc, #648]	; (a718 <tcp_process+0x374>)
    a48e:	4798      	blx	r3

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
    a490:	687b      	ldr	r3, [r7, #4]
    a492:	7e1b      	ldrb	r3, [r3, #24]
    a494:	2b09      	cmp	r3, #9
    a496:	d900      	bls.n	a49a <tcp_process+0xf6>
    a498:	e301      	b.n	aa9e <tcp_process+0x6fa>
    a49a:	009a      	lsls	r2, r3, #2
    a49c:	4b9f      	ldr	r3, [pc, #636]	; (a71c <tcp_process+0x378>)
    a49e:	18d3      	adds	r3, r2, r3
    a4a0:	681b      	ldr	r3, [r3, #0]
    a4a2:	469f      	mov	pc, r3
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
    a4a4:	4b97      	ldr	r3, [pc, #604]	; (a704 <tcp_process+0x360>)
    a4a6:	781b      	ldrb	r3, [r3, #0]
    a4a8:	001a      	movs	r2, r3
    a4aa:	2310      	movs	r3, #16
    a4ac:	4013      	ands	r3, r2
    a4ae:	d100      	bne.n	a4b2 <tcp_process+0x10e>
    a4b0:	e0be      	b.n	a630 <tcp_process+0x28c>
    a4b2:	4b94      	ldr	r3, [pc, #592]	; (a704 <tcp_process+0x360>)
    a4b4:	781b      	ldrb	r3, [r3, #0]
    a4b6:	001a      	movs	r2, r3
    a4b8:	2302      	movs	r3, #2
    a4ba:	4013      	ands	r3, r2
    a4bc:	d100      	bne.n	a4c0 <tcp_process+0x11c>
    a4be:	e0b7      	b.n	a630 <tcp_process+0x28c>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
    a4c0:	687b      	ldr	r3, [r7, #4]
    a4c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    a4c4:	68db      	ldr	r3, [r3, #12]
    a4c6:	791a      	ldrb	r2, [r3, #4]
    a4c8:	7959      	ldrb	r1, [r3, #5]
    a4ca:	0209      	lsls	r1, r1, #8
    a4cc:	430a      	orrs	r2, r1
    a4ce:	7999      	ldrb	r1, [r3, #6]
    a4d0:	0409      	lsls	r1, r1, #16
    a4d2:	430a      	orrs	r2, r1
    a4d4:	79db      	ldrb	r3, [r3, #7]
    a4d6:	061b      	lsls	r3, r3, #24
    a4d8:	4313      	orrs	r3, r2
    a4da:	0018      	movs	r0, r3
    a4dc:	4b90      	ldr	r3, [pc, #576]	; (a720 <tcp_process+0x37c>)
    a4de:	4798      	blx	r3
    a4e0:	0003      	movs	r3, r0
    a4e2:	1c5a      	adds	r2, r3, #1
    a4e4:	4b88      	ldr	r3, [pc, #544]	; (a708 <tcp_process+0x364>)
    a4e6:	681b      	ldr	r3, [r3, #0]
    a4e8:	429a      	cmp	r2, r3
    a4ea:	d000      	beq.n	a4ee <tcp_process+0x14a>
    a4ec:	e0a0      	b.n	a630 <tcp_process+0x28c>
      pcb->snd_buf++;
    a4ee:	687b      	ldr	r3, [r7, #4]
    a4f0:	2266      	movs	r2, #102	; 0x66
    a4f2:	5a9b      	ldrh	r3, [r3, r2]
    a4f4:	3301      	adds	r3, #1
    a4f6:	b299      	uxth	r1, r3
    a4f8:	687b      	ldr	r3, [r7, #4]
    a4fa:	2266      	movs	r2, #102	; 0x66
    a4fc:	5299      	strh	r1, [r3, r2]
      pcb->rcv_nxt = seqno + 1;
    a4fe:	4b83      	ldr	r3, [pc, #524]	; (a70c <tcp_process+0x368>)
    a500:	681b      	ldr	r3, [r3, #0]
    a502:	1c5a      	adds	r2, r3, #1
    a504:	687b      	ldr	r3, [r7, #4]
    a506:	629a      	str	r2, [r3, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
    a508:	687b      	ldr	r3, [r7, #4]
    a50a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    a50c:	687b      	ldr	r3, [r7, #4]
    a50e:	631a      	str	r2, [r3, #48]	; 0x30
      pcb->lastack = ackno;
    a510:	4b7d      	ldr	r3, [pc, #500]	; (a708 <tcp_process+0x364>)
    a512:	681a      	ldr	r2, [r3, #0]
    a514:	687b      	ldr	r3, [r7, #4]
    a516:	649a      	str	r2, [r3, #72]	; 0x48
      pcb->snd_wnd = tcphdr->wnd;
    a518:	4b82      	ldr	r3, [pc, #520]	; (a724 <tcp_process+0x380>)
    a51a:	681b      	ldr	r3, [r3, #0]
    a51c:	7b9a      	ldrb	r2, [r3, #14]
    a51e:	7bdb      	ldrb	r3, [r3, #15]
    a520:	021b      	lsls	r3, r3, #8
    a522:	4313      	orrs	r3, r2
    a524:	b299      	uxth	r1, r3
    a526:	687b      	ldr	r3, [r7, #4]
    a528:	2260      	movs	r2, #96	; 0x60
    a52a:	5299      	strh	r1, [r3, r2]
      pcb->snd_wnd_max = tcphdr->wnd;
    a52c:	4b7d      	ldr	r3, [pc, #500]	; (a724 <tcp_process+0x380>)
    a52e:	681b      	ldr	r3, [r3, #0]
    a530:	7b9a      	ldrb	r2, [r3, #14]
    a532:	7bdb      	ldrb	r3, [r3, #15]
    a534:	021b      	lsls	r3, r3, #8
    a536:	4313      	orrs	r3, r2
    a538:	b299      	uxth	r1, r3
    a53a:	687b      	ldr	r3, [r7, #4]
    a53c:	2262      	movs	r2, #98	; 0x62
    a53e:	5299      	strh	r1, [r3, r2]
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
    a540:	4b72      	ldr	r3, [pc, #456]	; (a70c <tcp_process+0x368>)
    a542:	681b      	ldr	r3, [r3, #0]
    a544:	1e5a      	subs	r2, r3, #1
    a546:	687b      	ldr	r3, [r7, #4]
    a548:	655a      	str	r2, [r3, #84]	; 0x54
      pcb->state = ESTABLISHED;
    a54a:	687b      	ldr	r3, [r7, #4]
    a54c:	2204      	movs	r2, #4
    a54e:	761a      	strb	r2, [r3, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
    a550:	687b      	ldr	r3, [r7, #4]
    a552:	8eda      	ldrh	r2, [r3, #54]	; 0x36
    a554:	687b      	ldr	r3, [r7, #4]
    a556:	3304      	adds	r3, #4
    a558:	0019      	movs	r1, r3
    a55a:	0010      	movs	r0, r2
    a55c:	4b72      	ldr	r3, [pc, #456]	; (a728 <tcp_process+0x384>)
    a55e:	4798      	blx	r3
    a560:	0003      	movs	r3, r0
    a562:	001a      	movs	r2, r3
    a564:	687b      	ldr	r3, [r7, #4]
    a566:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
    a568:	687b      	ldr	r3, [r7, #4]
    a56a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    a56c:	1c1a      	adds	r2, r3, #0
    a56e:	0092      	lsls	r2, r2, #2
    a570:	18d3      	adds	r3, r2, r3
    a572:	18db      	adds	r3, r3, r3
    a574:	b299      	uxth	r1, r3
    a576:	687b      	ldr	r3, [r7, #4]
    a578:	224e      	movs	r2, #78	; 0x4e
    a57a:	5299      	strh	r1, [r3, r2]

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    a57c:	687b      	ldr	r3, [r7, #4]
    a57e:	224c      	movs	r2, #76	; 0x4c
    a580:	5a9b      	ldrh	r3, [r3, r2]
    a582:	2b01      	cmp	r3, #1
    a584:	d104      	bne.n	a590 <tcp_process+0x1ec>
    a586:	687b      	ldr	r3, [r7, #4]
    a588:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    a58a:	18db      	adds	r3, r3, r3
    a58c:	b29b      	uxth	r3, r3
    a58e:	e001      	b.n	a594 <tcp_process+0x1f0>
    a590:	687b      	ldr	r3, [r7, #4]
    a592:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    a594:	687a      	ldr	r2, [r7, #4]
    a596:	214c      	movs	r1, #76	; 0x4c
    a598:	5253      	strh	r3, [r2, r1]
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
    a59a:	687b      	ldr	r3, [r7, #4]
    a59c:	2268      	movs	r2, #104	; 0x68
    a59e:	5a9b      	ldrh	r3, [r3, r2]
    a5a0:	3b01      	subs	r3, #1
    a5a2:	b299      	uxth	r1, r3
    a5a4:	687b      	ldr	r3, [r7, #4]
    a5a6:	2268      	movs	r2, #104	; 0x68
    a5a8:	5299      	strh	r1, [r3, r2]
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
    a5aa:	687b      	ldr	r3, [r7, #4]
    a5ac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    a5ae:	613b      	str	r3, [r7, #16]
      pcb->unacked = rseg->next;
    a5b0:	693b      	ldr	r3, [r7, #16]
    a5b2:	681a      	ldr	r2, [r3, #0]
    a5b4:	687b      	ldr	r3, [r7, #4]
    a5b6:	671a      	str	r2, [r3, #112]	; 0x70
      tcp_seg_free(rseg);
    a5b8:	693b      	ldr	r3, [r7, #16]
    a5ba:	0018      	movs	r0, r3
    a5bc:	4b5b      	ldr	r3, [pc, #364]	; (a72c <tcp_process+0x388>)
    a5be:	4798      	blx	r3

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    a5c0:	687b      	ldr	r3, [r7, #4]
    a5c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    a5c4:	2b00      	cmp	r3, #0
    a5c6:	d104      	bne.n	a5d2 <tcp_process+0x22e>
        pcb->rtime = -1;
    a5c8:	687b      	ldr	r3, [r7, #4]
    a5ca:	2201      	movs	r2, #1
    a5cc:	4252      	negs	r2, r2
    a5ce:	869a      	strh	r2, [r3, #52]	; 0x34
    a5d0:	e006      	b.n	a5e0 <tcp_process+0x23c>
      else {
        pcb->rtime = 0;
    a5d2:	687b      	ldr	r3, [r7, #4]
    a5d4:	2200      	movs	r2, #0
    a5d6:	869a      	strh	r2, [r3, #52]	; 0x34
        pcb->nrtx = 0;
    a5d8:	687b      	ldr	r3, [r7, #4]
    a5da:	2246      	movs	r2, #70	; 0x46
    a5dc:	2100      	movs	r1, #0
    a5de:	5499      	strb	r1, [r3, r2]
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
    a5e0:	687b      	ldr	r3, [r7, #4]
    a5e2:	2284      	movs	r2, #132	; 0x84
    a5e4:	589b      	ldr	r3, [r3, r2]
    a5e6:	2b00      	cmp	r3, #0
    a5e8:	d00d      	beq.n	a606 <tcp_process+0x262>
    a5ea:	687b      	ldr	r3, [r7, #4]
    a5ec:	2284      	movs	r2, #132	; 0x84
    a5ee:	589d      	ldr	r5, [r3, r2]
    a5f0:	687b      	ldr	r3, [r7, #4]
    a5f2:	691b      	ldr	r3, [r3, #16]
    a5f4:	2216      	movs	r2, #22
    a5f6:	18bc      	adds	r4, r7, r2
    a5f8:	6879      	ldr	r1, [r7, #4]
    a5fa:	2200      	movs	r2, #0
    a5fc:	0018      	movs	r0, r3
    a5fe:	47a8      	blx	r5
    a600:	0003      	movs	r3, r0
    a602:	7023      	strb	r3, [r4, #0]
    a604:	e003      	b.n	a60e <tcp_process+0x26a>
    a606:	2316      	movs	r3, #22
    a608:	18fb      	adds	r3, r7, r3
    a60a:	2200      	movs	r2, #0
    a60c:	701a      	strb	r2, [r3, #0]
      if (err == ERR_ABRT) {
    a60e:	2316      	movs	r3, #22
    a610:	18fb      	adds	r3, r7, r3
    a612:	781b      	ldrb	r3, [r3, #0]
    a614:	b25b      	sxtb	r3, r3
    a616:	330a      	adds	r3, #10
    a618:	d102      	bne.n	a620 <tcp_process+0x27c>
        return ERR_ABRT;
    a61a:	230a      	movs	r3, #10
    a61c:	425b      	negs	r3, r3
    a61e:	e271      	b.n	ab04 <tcp_process+0x760>
      }
      tcp_ack_now(pcb);
    a620:	687b      	ldr	r3, [r7, #4]
    a622:	7f9b      	ldrb	r3, [r3, #30]
    a624:	2202      	movs	r2, #2
    a626:	4313      	orrs	r3, r2
    a628:	b2da      	uxtb	r2, r3
    a62a:	687b      	ldr	r3, [r7, #4]
    a62c:	779a      	strb	r2, [r3, #30]
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
    a62e:	e238      	b.n	aaa2 <tcp_process+0x6fe>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
    a630:	4b34      	ldr	r3, [pc, #208]	; (a704 <tcp_process+0x360>)
    a632:	781b      	ldrb	r3, [r3, #0]
    a634:	001a      	movs	r2, r3
    a636:	2310      	movs	r3, #16
    a638:	4013      	ands	r3, r2
    a63a:	d100      	bne.n	a63e <tcp_process+0x29a>
    a63c:	e231      	b.n	aaa2 <tcp_process+0x6fe>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a63e:	4b32      	ldr	r3, [pc, #200]	; (a708 <tcp_process+0x364>)
    a640:	6818      	ldr	r0, [r3, #0]
    a642:	4b3b      	ldr	r3, [pc, #236]	; (a730 <tcp_process+0x38c>)
    a644:	881b      	ldrh	r3, [r3, #0]
    a646:	001a      	movs	r2, r3
    a648:	4b30      	ldr	r3, [pc, #192]	; (a70c <tcp_process+0x368>)
    a64a:	681b      	ldr	r3, [r3, #0]
    a64c:	18d4      	adds	r4, r2, r3
        tcphdr->dest, tcphdr->src);
    a64e:	4b35      	ldr	r3, [pc, #212]	; (a724 <tcp_process+0x380>)
    a650:	681b      	ldr	r3, [r3, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a652:	789a      	ldrb	r2, [r3, #2]
    a654:	78db      	ldrb	r3, [r3, #3]
    a656:	021b      	lsls	r3, r3, #8
    a658:	4313      	orrs	r3, r2
    a65a:	b29a      	uxth	r2, r3
        tcphdr->dest, tcphdr->src);
    a65c:	4b31      	ldr	r3, [pc, #196]	; (a724 <tcp_process+0x380>)
    a65e:	681b      	ldr	r3, [r3, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a660:	7819      	ldrb	r1, [r3, #0]
    a662:	785b      	ldrb	r3, [r3, #1]
    a664:	021b      	lsls	r3, r3, #8
    a666:	430b      	orrs	r3, r1
    a668:	b29b      	uxth	r3, r3
    a66a:	4d32      	ldr	r5, [pc, #200]	; (a734 <tcp_process+0x390>)
    a66c:	4932      	ldr	r1, [pc, #200]	; (a738 <tcp_process+0x394>)
    a66e:	9301      	str	r3, [sp, #4]
    a670:	9200      	str	r2, [sp, #0]
    a672:	002b      	movs	r3, r5
    a674:	000a      	movs	r2, r1
    a676:	0021      	movs	r1, r4
    a678:	4c30      	ldr	r4, [pc, #192]	; (a73c <tcp_process+0x398>)
    a67a:	47a0      	blx	r4
        tcphdr->dest, tcphdr->src);
    }
    break;
    a67c:	e211      	b.n	aaa2 <tcp_process+0x6fe>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
    a67e:	4b21      	ldr	r3, [pc, #132]	; (a704 <tcp_process+0x360>)
    a680:	781b      	ldrb	r3, [r3, #0]
    a682:	001a      	movs	r2, r3
    a684:	2310      	movs	r3, #16
    a686:	4013      	ands	r3, r2
    a688:	d100      	bne.n	a68c <tcp_process+0x2e8>
    a68a:	e0b2      	b.n	a7f2 <tcp_process+0x44e>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    a68c:	4b1e      	ldr	r3, [pc, #120]	; (a708 <tcp_process+0x364>)
    a68e:	681a      	ldr	r2, [r3, #0]
    a690:	687b      	ldr	r3, [r7, #4]
    a692:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    a694:	1ad3      	subs	r3, r2, r3
    a696:	3b01      	subs	r3, #1
    a698:	2b00      	cmp	r3, #0
    a69a:	da00      	bge.n	a69e <tcp_process+0x2fa>
    a69c:	e089      	b.n	a7b2 <tcp_process+0x40e>
    a69e:	4b1a      	ldr	r3, [pc, #104]	; (a708 <tcp_process+0x364>)
    a6a0:	681a      	ldr	r2, [r3, #0]
    a6a2:	687b      	ldr	r3, [r7, #4]
    a6a4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    a6a6:	1ad3      	subs	r3, r2, r3
    a6a8:	2b00      	cmp	r3, #0
    a6aa:	dd00      	ble.n	a6ae <tcp_process+0x30a>
    a6ac:	e081      	b.n	a7b2 <tcp_process+0x40e>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
    a6ae:	687b      	ldr	r3, [r7, #4]
    a6b0:	2204      	movs	r2, #4
    a6b2:	761a      	strb	r2, [r3, #24]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
    a6b4:	687b      	ldr	r3, [r7, #4]
    a6b6:	695b      	ldr	r3, [r3, #20]
    a6b8:	2b00      	cmp	r3, #0
    a6ba:	d00c      	beq.n	a6d6 <tcp_process+0x332>
    a6bc:	687b      	ldr	r3, [r7, #4]
    a6be:	695d      	ldr	r5, [r3, #20]
    a6c0:	687b      	ldr	r3, [r7, #4]
    a6c2:	691b      	ldr	r3, [r3, #16]
    a6c4:	2216      	movs	r2, #22
    a6c6:	18bc      	adds	r4, r7, r2
    a6c8:	6879      	ldr	r1, [r7, #4]
    a6ca:	2200      	movs	r2, #0
    a6cc:	0018      	movs	r0, r3
    a6ce:	47a8      	blx	r5
    a6d0:	0003      	movs	r3, r0
    a6d2:	7023      	strb	r3, [r4, #0]
    a6d4:	e003      	b.n	a6de <tcp_process+0x33a>
    a6d6:	2316      	movs	r3, #22
    a6d8:	18fb      	adds	r3, r7, r3
    a6da:	22f2      	movs	r2, #242	; 0xf2
    a6dc:	701a      	strb	r2, [r3, #0]
        if (err != ERR_OK) {
    a6de:	2316      	movs	r3, #22
    a6e0:	18fb      	adds	r3, r7, r3
    a6e2:	781b      	ldrb	r3, [r3, #0]
    a6e4:	b25b      	sxtb	r3, r3
    a6e6:	2b00      	cmp	r3, #0
    a6e8:	d02c      	beq.n	a744 <tcp_process+0x3a0>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
    a6ea:	2316      	movs	r3, #22
    a6ec:	18fb      	adds	r3, r7, r3
    a6ee:	781b      	ldrb	r3, [r3, #0]
    a6f0:	b25b      	sxtb	r3, r3
    a6f2:	330a      	adds	r3, #10
    a6f4:	d003      	beq.n	a6fe <tcp_process+0x35a>
            tcp_abort(pcb);
    a6f6:	687b      	ldr	r3, [r7, #4]
    a6f8:	0018      	movs	r0, r3
    a6fa:	4b11      	ldr	r3, [pc, #68]	; (a740 <tcp_process+0x39c>)
    a6fc:	4798      	blx	r3
          }
          return ERR_ABRT;
    a6fe:	230a      	movs	r3, #10
    a700:	425b      	negs	r3, r3
    a702:	e1ff      	b.n	ab04 <tcp_process+0x760>
    a704:	20002c90 	.word	0x20002c90
    a708:	20002c8c 	.word	0x20002c8c
    a70c:	20002c88 	.word	0x20002c88
    a710:	20002c94 	.word	0x20002c94
    a714:	20003ec8 	.word	0x20003ec8
    a718:	0000be19 	.word	0x0000be19
    a71c:	0000fdc0 	.word	0x0000fdc0
    a720:	00005675 	.word	0x00005675
    a724:	20002c80 	.word	0x20002c80
    a728:	00009821 	.word	0x00009821
    a72c:	000093ad 	.word	0x000093ad
    a730:	20002c92 	.word	0x20002c92
    a734:	20002e90 	.word	0x20002e90
    a738:	20002e98 	.word	0x20002e98
    a73c:	0000cc35 	.word	0x0000cc35
    a740:	00008bbd 	.word	0x00008bbd
        }
        old_cwnd = pcb->cwnd;
    a744:	230e      	movs	r3, #14
    a746:	18fb      	adds	r3, r7, r3
    a748:	687a      	ldr	r2, [r7, #4]
    a74a:	214c      	movs	r1, #76	; 0x4c
    a74c:	5a52      	ldrh	r2, [r2, r1]
    a74e:	801a      	strh	r2, [r3, #0]
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
    a750:	687b      	ldr	r3, [r7, #4]
    a752:	0018      	movs	r0, r3
    a754:	4bd5      	ldr	r3, [pc, #852]	; (aaac <tcp_process+0x708>)
    a756:	4798      	blx	r3

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
    a758:	687b      	ldr	r3, [r7, #4]
    a75a:	2264      	movs	r2, #100	; 0x64
    a75c:	5a9b      	ldrh	r3, [r3, r2]
    a75e:	2b00      	cmp	r3, #0
    a760:	d007      	beq.n	a772 <tcp_process+0x3ce>
          pcb->acked--;
    a762:	687b      	ldr	r3, [r7, #4]
    a764:	2264      	movs	r2, #100	; 0x64
    a766:	5a9b      	ldrh	r3, [r3, r2]
    a768:	3b01      	subs	r3, #1
    a76a:	b299      	uxth	r1, r3
    a76c:	687b      	ldr	r3, [r7, #4]
    a76e:	2264      	movs	r2, #100	; 0x64
    a770:	5299      	strh	r1, [r3, r2]
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
    a772:	230e      	movs	r3, #14
    a774:	18fb      	adds	r3, r7, r3
    a776:	881b      	ldrh	r3, [r3, #0]
    a778:	2b01      	cmp	r3, #1
    a77a:	d104      	bne.n	a786 <tcp_process+0x3e2>
    a77c:	687b      	ldr	r3, [r7, #4]
    a77e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    a780:	18db      	adds	r3, r3, r3
    a782:	b29b      	uxth	r3, r3
    a784:	e001      	b.n	a78a <tcp_process+0x3e6>
    a786:	687b      	ldr	r3, [r7, #4]
    a788:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    a78a:	687a      	ldr	r2, [r7, #4]
    a78c:	214c      	movs	r1, #76	; 0x4c
    a78e:	5253      	strh	r3, [r2, r1]

        if (recv_flags & TF_GOT_FIN) {
    a790:	4bc7      	ldr	r3, [pc, #796]	; (aab0 <tcp_process+0x70c>)
    a792:	781b      	ldrb	r3, [r3, #0]
    a794:	001a      	movs	r2, r3
    a796:	2320      	movs	r3, #32
    a798:	4013      	ands	r3, r2
    a79a:	d03e      	beq.n	a81a <tcp_process+0x476>
          tcp_ack_now(pcb);
    a79c:	687b      	ldr	r3, [r7, #4]
    a79e:	7f9b      	ldrb	r3, [r3, #30]
    a7a0:	2202      	movs	r2, #2
    a7a2:	4313      	orrs	r3, r2
    a7a4:	b2da      	uxtb	r2, r3
    a7a6:	687b      	ldr	r3, [r7, #4]
    a7a8:	779a      	strb	r2, [r3, #30]
          pcb->state = CLOSE_WAIT;
    a7aa:	687b      	ldr	r3, [r7, #4]
    a7ac:	2207      	movs	r2, #7
    a7ae:	761a      	strb	r2, [r3, #24]
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    a7b0:	e033      	b.n	a81a <tcp_process+0x476>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a7b2:	4bc0      	ldr	r3, [pc, #768]	; (aab4 <tcp_process+0x710>)
    a7b4:	6818      	ldr	r0, [r3, #0]
    a7b6:	4bc0      	ldr	r3, [pc, #768]	; (aab8 <tcp_process+0x714>)
    a7b8:	881b      	ldrh	r3, [r3, #0]
    a7ba:	001a      	movs	r2, r3
    a7bc:	4bbf      	ldr	r3, [pc, #764]	; (aabc <tcp_process+0x718>)
    a7be:	681b      	ldr	r3, [r3, #0]
    a7c0:	18d4      	adds	r4, r2, r3
                tcphdr->dest, tcphdr->src);
    a7c2:	4bbf      	ldr	r3, [pc, #764]	; (aac0 <tcp_process+0x71c>)
    a7c4:	681b      	ldr	r3, [r3, #0]
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a7c6:	789a      	ldrb	r2, [r3, #2]
    a7c8:	78db      	ldrb	r3, [r3, #3]
    a7ca:	021b      	lsls	r3, r3, #8
    a7cc:	4313      	orrs	r3, r2
    a7ce:	b29a      	uxth	r2, r3
                tcphdr->dest, tcphdr->src);
    a7d0:	4bbb      	ldr	r3, [pc, #748]	; (aac0 <tcp_process+0x71c>)
    a7d2:	681b      	ldr	r3, [r3, #0]
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
    a7d4:	7819      	ldrb	r1, [r3, #0]
    a7d6:	785b      	ldrb	r3, [r3, #1]
    a7d8:	021b      	lsls	r3, r3, #8
    a7da:	430b      	orrs	r3, r1
    a7dc:	b29b      	uxth	r3, r3
    a7de:	4db9      	ldr	r5, [pc, #740]	; (aac4 <tcp_process+0x720>)
    a7e0:	49b9      	ldr	r1, [pc, #740]	; (aac8 <tcp_process+0x724>)
    a7e2:	9301      	str	r3, [sp, #4]
    a7e4:	9200      	str	r2, [sp, #0]
    a7e6:	002b      	movs	r3, r5
    a7e8:	000a      	movs	r2, r1
    a7ea:	0021      	movs	r1, r4
    a7ec:	4cb7      	ldr	r4, [pc, #732]	; (aacc <tcp_process+0x728>)
    a7ee:	47a0      	blx	r4
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    a7f0:	e159      	b.n	aaa6 <tcp_process+0x702>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
    a7f2:	4bb7      	ldr	r3, [pc, #732]	; (aad0 <tcp_process+0x72c>)
    a7f4:	781b      	ldrb	r3, [r3, #0]
    a7f6:	001a      	movs	r2, r3
    a7f8:	2302      	movs	r3, #2
    a7fa:	4013      	ands	r3, r2
    a7fc:	d100      	bne.n	a800 <tcp_process+0x45c>
    a7fe:	e152      	b.n	aaa6 <tcp_process+0x702>
    a800:	687b      	ldr	r3, [r7, #4]
    a802:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    a804:	1e5a      	subs	r2, r3, #1
    a806:	4bad      	ldr	r3, [pc, #692]	; (aabc <tcp_process+0x718>)
    a808:	681b      	ldr	r3, [r3, #0]
    a80a:	429a      	cmp	r2, r3
    a80c:	d000      	beq.n	a810 <tcp_process+0x46c>
    a80e:	e14a      	b.n	aaa6 <tcp_process+0x702>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    a810:	687b      	ldr	r3, [r7, #4]
    a812:	0018      	movs	r0, r3
    a814:	4baf      	ldr	r3, [pc, #700]	; (aad4 <tcp_process+0x730>)
    a816:	4798      	blx	r3
    }
    break;
    a818:	e145      	b.n	aaa6 <tcp_process+0x702>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
    a81a:	46c0      	nop			; (mov r8, r8)
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    a81c:	e143      	b.n	aaa6 <tcp_process+0x702>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    a81e:	687b      	ldr	r3, [r7, #4]
    a820:	0018      	movs	r0, r3
    a822:	4ba2      	ldr	r3, [pc, #648]	; (aaac <tcp_process+0x708>)
    a824:	4798      	blx	r3
    if (recv_flags & TF_GOT_FIN) { /* passive close */
    a826:	4ba2      	ldr	r3, [pc, #648]	; (aab0 <tcp_process+0x70c>)
    a828:	781b      	ldrb	r3, [r3, #0]
    a82a:	001a      	movs	r2, r3
    a82c:	2320      	movs	r3, #32
    a82e:	4013      	ands	r3, r2
    a830:	d100      	bne.n	a834 <tcp_process+0x490>
    a832:	e15d      	b.n	aaf0 <tcp_process+0x74c>
      tcp_ack_now(pcb);
    a834:	687b      	ldr	r3, [r7, #4]
    a836:	7f9b      	ldrb	r3, [r3, #30]
    a838:	2202      	movs	r2, #2
    a83a:	4313      	orrs	r3, r2
    a83c:	b2da      	uxtb	r2, r3
    a83e:	687b      	ldr	r3, [r7, #4]
    a840:	779a      	strb	r2, [r3, #30]
      pcb->state = CLOSE_WAIT;
    a842:	687b      	ldr	r3, [r7, #4]
    a844:	2207      	movs	r2, #7
    a846:	761a      	strb	r2, [r3, #24]
    }
    break;
    a848:	e152      	b.n	aaf0 <tcp_process+0x74c>
  case FIN_WAIT_1:
    tcp_receive(pcb);
    a84a:	687b      	ldr	r3, [r7, #4]
    a84c:	0018      	movs	r0, r3
    a84e:	4b97      	ldr	r3, [pc, #604]	; (aaac <tcp_process+0x708>)
    a850:	4798      	blx	r3
    if (recv_flags & TF_GOT_FIN) {
    a852:	4b97      	ldr	r3, [pc, #604]	; (aab0 <tcp_process+0x70c>)
    a854:	781b      	ldrb	r3, [r3, #0]
    a856:	001a      	movs	r2, r3
    a858:	2320      	movs	r3, #32
    a85a:	4013      	ands	r3, r2
    a85c:	d059      	beq.n	a912 <tcp_process+0x56e>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    a85e:	4b9c      	ldr	r3, [pc, #624]	; (aad0 <tcp_process+0x72c>)
    a860:	781b      	ldrb	r3, [r3, #0]
    a862:	001a      	movs	r2, r3
    a864:	2310      	movs	r3, #16
    a866:	4013      	ands	r3, r2
    a868:	d048      	beq.n	a8fc <tcp_process+0x558>
    a86a:	687b      	ldr	r3, [r7, #4]
    a86c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    a86e:	4b91      	ldr	r3, [pc, #580]	; (aab4 <tcp_process+0x710>)
    a870:	681b      	ldr	r3, [r3, #0]
    a872:	429a      	cmp	r2, r3
    a874:	d142      	bne.n	a8fc <tcp_process+0x558>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
    a876:	687b      	ldr	r3, [r7, #4]
    a878:	7f9b      	ldrb	r3, [r3, #30]
    a87a:	2202      	movs	r2, #2
    a87c:	4313      	orrs	r3, r2
    a87e:	b2da      	uxtb	r2, r3
    a880:	687b      	ldr	r3, [r7, #4]
    a882:	779a      	strb	r2, [r3, #30]
        tcp_pcb_purge(pcb);
    a884:	687b      	ldr	r3, [r7, #4]
    a886:	0018      	movs	r0, r3
    a888:	4b93      	ldr	r3, [pc, #588]	; (aad8 <tcp_process+0x734>)
    a88a:	4798      	blx	r3
        TCP_RMV_ACTIVE(pcb);
    a88c:	4b93      	ldr	r3, [pc, #588]	; (aadc <tcp_process+0x738>)
    a88e:	681a      	ldr	r2, [r3, #0]
    a890:	687b      	ldr	r3, [r7, #4]
    a892:	429a      	cmp	r2, r3
    a894:	d105      	bne.n	a8a2 <tcp_process+0x4fe>
    a896:	4b91      	ldr	r3, [pc, #580]	; (aadc <tcp_process+0x738>)
    a898:	681b      	ldr	r3, [r3, #0]
    a89a:	68da      	ldr	r2, [r3, #12]
    a89c:	4b8f      	ldr	r3, [pc, #572]	; (aadc <tcp_process+0x738>)
    a89e:	601a      	str	r2, [r3, #0]
    a8a0:	e019      	b.n	a8d6 <tcp_process+0x532>
    a8a2:	4b8e      	ldr	r3, [pc, #568]	; (aadc <tcp_process+0x738>)
    a8a4:	681a      	ldr	r2, [r3, #0]
    a8a6:	4b8e      	ldr	r3, [pc, #568]	; (aae0 <tcp_process+0x73c>)
    a8a8:	601a      	str	r2, [r3, #0]
    a8aa:	e010      	b.n	a8ce <tcp_process+0x52a>
    a8ac:	4b8c      	ldr	r3, [pc, #560]	; (aae0 <tcp_process+0x73c>)
    a8ae:	681b      	ldr	r3, [r3, #0]
    a8b0:	68da      	ldr	r2, [r3, #12]
    a8b2:	687b      	ldr	r3, [r7, #4]
    a8b4:	429a      	cmp	r2, r3
    a8b6:	d105      	bne.n	a8c4 <tcp_process+0x520>
    a8b8:	4b89      	ldr	r3, [pc, #548]	; (aae0 <tcp_process+0x73c>)
    a8ba:	681b      	ldr	r3, [r3, #0]
    a8bc:	687a      	ldr	r2, [r7, #4]
    a8be:	68d2      	ldr	r2, [r2, #12]
    a8c0:	60da      	str	r2, [r3, #12]
    a8c2:	e008      	b.n	a8d6 <tcp_process+0x532>
    a8c4:	4b86      	ldr	r3, [pc, #536]	; (aae0 <tcp_process+0x73c>)
    a8c6:	681b      	ldr	r3, [r3, #0]
    a8c8:	68da      	ldr	r2, [r3, #12]
    a8ca:	4b85      	ldr	r3, [pc, #532]	; (aae0 <tcp_process+0x73c>)
    a8cc:	601a      	str	r2, [r3, #0]
    a8ce:	4b84      	ldr	r3, [pc, #528]	; (aae0 <tcp_process+0x73c>)
    a8d0:	681b      	ldr	r3, [r3, #0]
    a8d2:	2b00      	cmp	r3, #0
    a8d4:	d1ea      	bne.n	a8ac <tcp_process+0x508>
    a8d6:	687b      	ldr	r3, [r7, #4]
    a8d8:	2200      	movs	r2, #0
    a8da:	60da      	str	r2, [r3, #12]
    a8dc:	4b81      	ldr	r3, [pc, #516]	; (aae4 <tcp_process+0x740>)
    a8de:	2201      	movs	r2, #1
    a8e0:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
    a8e2:	687b      	ldr	r3, [r7, #4]
    a8e4:	220a      	movs	r2, #10
    a8e6:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
    a8e8:	4b7f      	ldr	r3, [pc, #508]	; (aae8 <tcp_process+0x744>)
    a8ea:	681a      	ldr	r2, [r3, #0]
    a8ec:	687b      	ldr	r3, [r7, #4]
    a8ee:	60da      	str	r2, [r3, #12]
    a8f0:	4b7d      	ldr	r3, [pc, #500]	; (aae8 <tcp_process+0x744>)
    a8f2:	687a      	ldr	r2, [r7, #4]
    a8f4:	601a      	str	r2, [r3, #0]
    a8f6:	4b7d      	ldr	r3, [pc, #500]	; (aaec <tcp_process+0x748>)
    a8f8:	4798      	blx	r3
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    a8fa:	e0fb      	b.n	aaf4 <tcp_process+0x750>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
    a8fc:	687b      	ldr	r3, [r7, #4]
    a8fe:	7f9b      	ldrb	r3, [r3, #30]
    a900:	2202      	movs	r2, #2
    a902:	4313      	orrs	r3, r2
    a904:	b2da      	uxtb	r2, r3
    a906:	687b      	ldr	r3, [r7, #4]
    a908:	779a      	strb	r2, [r3, #30]
        pcb->state = CLOSING;
    a90a:	687b      	ldr	r3, [r7, #4]
    a90c:	2208      	movs	r2, #8
    a90e:	761a      	strb	r2, [r3, #24]
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    a910:	e0f0      	b.n	aaf4 <tcp_process+0x750>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
    a912:	4b6f      	ldr	r3, [pc, #444]	; (aad0 <tcp_process+0x72c>)
    a914:	781b      	ldrb	r3, [r3, #0]
    a916:	001a      	movs	r2, r3
    a918:	2310      	movs	r3, #16
    a91a:	4013      	ands	r3, r2
    a91c:	d100      	bne.n	a920 <tcp_process+0x57c>
    a91e:	e0e9      	b.n	aaf4 <tcp_process+0x750>
    a920:	687b      	ldr	r3, [r7, #4]
    a922:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    a924:	4b63      	ldr	r3, [pc, #396]	; (aab4 <tcp_process+0x710>)
    a926:	681b      	ldr	r3, [r3, #0]
    a928:	429a      	cmp	r2, r3
    a92a:	d000      	beq.n	a92e <tcp_process+0x58a>
    a92c:	e0e2      	b.n	aaf4 <tcp_process+0x750>
      pcb->state = FIN_WAIT_2;
    a92e:	687b      	ldr	r3, [r7, #4]
    a930:	2206      	movs	r2, #6
    a932:	761a      	strb	r2, [r3, #24]
    }
    break;
    a934:	e0de      	b.n	aaf4 <tcp_process+0x750>
  case FIN_WAIT_2:
    tcp_receive(pcb);
    a936:	687b      	ldr	r3, [r7, #4]
    a938:	0018      	movs	r0, r3
    a93a:	4b5c      	ldr	r3, [pc, #368]	; (aaac <tcp_process+0x708>)
    a93c:	4798      	blx	r3
    if (recv_flags & TF_GOT_FIN) {
    a93e:	4b5c      	ldr	r3, [pc, #368]	; (aab0 <tcp_process+0x70c>)
    a940:	781b      	ldrb	r3, [r3, #0]
    a942:	001a      	movs	r2, r3
    a944:	2320      	movs	r3, #32
    a946:	4013      	ands	r3, r2
    a948:	d100      	bne.n	a94c <tcp_process+0x5a8>
    a94a:	e0d5      	b.n	aaf8 <tcp_process+0x754>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
    a94c:	687b      	ldr	r3, [r7, #4]
    a94e:	7f9b      	ldrb	r3, [r3, #30]
    a950:	2202      	movs	r2, #2
    a952:	4313      	orrs	r3, r2
    a954:	b2da      	uxtb	r2, r3
    a956:	687b      	ldr	r3, [r7, #4]
    a958:	779a      	strb	r2, [r3, #30]
      tcp_pcb_purge(pcb);
    a95a:	687b      	ldr	r3, [r7, #4]
    a95c:	0018      	movs	r0, r3
    a95e:	4b5e      	ldr	r3, [pc, #376]	; (aad8 <tcp_process+0x734>)
    a960:	4798      	blx	r3
      TCP_RMV_ACTIVE(pcb);
    a962:	4b5e      	ldr	r3, [pc, #376]	; (aadc <tcp_process+0x738>)
    a964:	681a      	ldr	r2, [r3, #0]
    a966:	687b      	ldr	r3, [r7, #4]
    a968:	429a      	cmp	r2, r3
    a96a:	d105      	bne.n	a978 <tcp_process+0x5d4>
    a96c:	4b5b      	ldr	r3, [pc, #364]	; (aadc <tcp_process+0x738>)
    a96e:	681b      	ldr	r3, [r3, #0]
    a970:	68da      	ldr	r2, [r3, #12]
    a972:	4b5a      	ldr	r3, [pc, #360]	; (aadc <tcp_process+0x738>)
    a974:	601a      	str	r2, [r3, #0]
    a976:	e019      	b.n	a9ac <tcp_process+0x608>
    a978:	4b58      	ldr	r3, [pc, #352]	; (aadc <tcp_process+0x738>)
    a97a:	681a      	ldr	r2, [r3, #0]
    a97c:	4b58      	ldr	r3, [pc, #352]	; (aae0 <tcp_process+0x73c>)
    a97e:	601a      	str	r2, [r3, #0]
    a980:	e010      	b.n	a9a4 <tcp_process+0x600>
    a982:	4b57      	ldr	r3, [pc, #348]	; (aae0 <tcp_process+0x73c>)
    a984:	681b      	ldr	r3, [r3, #0]
    a986:	68da      	ldr	r2, [r3, #12]
    a988:	687b      	ldr	r3, [r7, #4]
    a98a:	429a      	cmp	r2, r3
    a98c:	d105      	bne.n	a99a <tcp_process+0x5f6>
    a98e:	4b54      	ldr	r3, [pc, #336]	; (aae0 <tcp_process+0x73c>)
    a990:	681b      	ldr	r3, [r3, #0]
    a992:	687a      	ldr	r2, [r7, #4]
    a994:	68d2      	ldr	r2, [r2, #12]
    a996:	60da      	str	r2, [r3, #12]
    a998:	e008      	b.n	a9ac <tcp_process+0x608>
    a99a:	4b51      	ldr	r3, [pc, #324]	; (aae0 <tcp_process+0x73c>)
    a99c:	681b      	ldr	r3, [r3, #0]
    a99e:	68da      	ldr	r2, [r3, #12]
    a9a0:	4b4f      	ldr	r3, [pc, #316]	; (aae0 <tcp_process+0x73c>)
    a9a2:	601a      	str	r2, [r3, #0]
    a9a4:	4b4e      	ldr	r3, [pc, #312]	; (aae0 <tcp_process+0x73c>)
    a9a6:	681b      	ldr	r3, [r3, #0]
    a9a8:	2b00      	cmp	r3, #0
    a9aa:	d1ea      	bne.n	a982 <tcp_process+0x5de>
    a9ac:	687b      	ldr	r3, [r7, #4]
    a9ae:	2200      	movs	r2, #0
    a9b0:	60da      	str	r2, [r3, #12]
    a9b2:	4b4c      	ldr	r3, [pc, #304]	; (aae4 <tcp_process+0x740>)
    a9b4:	2201      	movs	r2, #1
    a9b6:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
    a9b8:	687b      	ldr	r3, [r7, #4]
    a9ba:	220a      	movs	r2, #10
    a9bc:	761a      	strb	r2, [r3, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
    a9be:	4b4a      	ldr	r3, [pc, #296]	; (aae8 <tcp_process+0x744>)
    a9c0:	681a      	ldr	r2, [r3, #0]
    a9c2:	687b      	ldr	r3, [r7, #4]
    a9c4:	60da      	str	r2, [r3, #12]
    a9c6:	4b48      	ldr	r3, [pc, #288]	; (aae8 <tcp_process+0x744>)
    a9c8:	687a      	ldr	r2, [r7, #4]
    a9ca:	601a      	str	r2, [r3, #0]
    a9cc:	4b47      	ldr	r3, [pc, #284]	; (aaec <tcp_process+0x748>)
    a9ce:	4798      	blx	r3
    }
    break;
    a9d0:	e092      	b.n	aaf8 <tcp_process+0x754>
  case CLOSING:
    tcp_receive(pcb);
    a9d2:	687b      	ldr	r3, [r7, #4]
    a9d4:	0018      	movs	r0, r3
    a9d6:	4b35      	ldr	r3, [pc, #212]	; (aaac <tcp_process+0x708>)
    a9d8:	4798      	blx	r3
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    a9da:	4b3d      	ldr	r3, [pc, #244]	; (aad0 <tcp_process+0x72c>)
    a9dc:	781b      	ldrb	r3, [r3, #0]
    a9de:	001a      	movs	r2, r3
    a9e0:	2310      	movs	r3, #16
    a9e2:	4013      	ands	r3, r2
    a9e4:	d100      	bne.n	a9e8 <tcp_process+0x644>
    a9e6:	e089      	b.n	aafc <tcp_process+0x758>
    a9e8:	687b      	ldr	r3, [r7, #4]
    a9ea:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    a9ec:	4b31      	ldr	r3, [pc, #196]	; (aab4 <tcp_process+0x710>)
    a9ee:	681b      	ldr	r3, [r3, #0]
    a9f0:	429a      	cmp	r2, r3
    a9f2:	d000      	beq.n	a9f6 <tcp_process+0x652>
    a9f4:	e082      	b.n	aafc <tcp_process+0x758>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
    a9f6:	687b      	ldr	r3, [r7, #4]
    a9f8:	0018      	movs	r0, r3
    a9fa:	4b37      	ldr	r3, [pc, #220]	; (aad8 <tcp_process+0x734>)
    a9fc:	4798      	blx	r3
      TCP_RMV_ACTIVE(pcb);
    a9fe:	4b37      	ldr	r3, [pc, #220]	; (aadc <tcp_process+0x738>)
    aa00:	681a      	ldr	r2, [r3, #0]
    aa02:	687b      	ldr	r3, [r7, #4]
    aa04:	429a      	cmp	r2, r3
    aa06:	d105      	bne.n	aa14 <tcp_process+0x670>
    aa08:	4b34      	ldr	r3, [pc, #208]	; (aadc <tcp_process+0x738>)
    aa0a:	681b      	ldr	r3, [r3, #0]
    aa0c:	68da      	ldr	r2, [r3, #12]
    aa0e:	4b33      	ldr	r3, [pc, #204]	; (aadc <tcp_process+0x738>)
    aa10:	601a      	str	r2, [r3, #0]
    aa12:	e019      	b.n	aa48 <tcp_process+0x6a4>
    aa14:	4b31      	ldr	r3, [pc, #196]	; (aadc <tcp_process+0x738>)
    aa16:	681a      	ldr	r2, [r3, #0]
    aa18:	4b31      	ldr	r3, [pc, #196]	; (aae0 <tcp_process+0x73c>)
    aa1a:	601a      	str	r2, [r3, #0]
    aa1c:	e010      	b.n	aa40 <tcp_process+0x69c>
    aa1e:	4b30      	ldr	r3, [pc, #192]	; (aae0 <tcp_process+0x73c>)
    aa20:	681b      	ldr	r3, [r3, #0]
    aa22:	68da      	ldr	r2, [r3, #12]
    aa24:	687b      	ldr	r3, [r7, #4]
    aa26:	429a      	cmp	r2, r3
    aa28:	d105      	bne.n	aa36 <tcp_process+0x692>
    aa2a:	4b2d      	ldr	r3, [pc, #180]	; (aae0 <tcp_process+0x73c>)
    aa2c:	681b      	ldr	r3, [r3, #0]
    aa2e:	687a      	ldr	r2, [r7, #4]
    aa30:	68d2      	ldr	r2, [r2, #12]
    aa32:	60da      	str	r2, [r3, #12]
    aa34:	e008      	b.n	aa48 <tcp_process+0x6a4>
    aa36:	4b2a      	ldr	r3, [pc, #168]	; (aae0 <tcp_process+0x73c>)
    aa38:	681b      	ldr	r3, [r3, #0]
    aa3a:	68da      	ldr	r2, [r3, #12]
    aa3c:	4b28      	ldr	r3, [pc, #160]	; (aae0 <tcp_process+0x73c>)
    aa3e:	601a      	str	r2, [r3, #0]
    aa40:	4b27      	ldr	r3, [pc, #156]	; (aae0 <tcp_process+0x73c>)
    aa42:	681b      	ldr	r3, [r3, #0]
    aa44:	2b00      	cmp	r3, #0
    aa46:	d1ea      	bne.n	aa1e <tcp_process+0x67a>
    aa48:	687b      	ldr	r3, [r7, #4]
    aa4a:	2200      	movs	r2, #0
    aa4c:	60da      	str	r2, [r3, #12]
    aa4e:	4b25      	ldr	r3, [pc, #148]	; (aae4 <tcp_process+0x740>)
    aa50:	2201      	movs	r2, #1
    aa52:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
    aa54:	687b      	ldr	r3, [r7, #4]
    aa56:	220a      	movs	r2, #10
    aa58:	761a      	strb	r2, [r3, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
    aa5a:	4b23      	ldr	r3, [pc, #140]	; (aae8 <tcp_process+0x744>)
    aa5c:	681a      	ldr	r2, [r3, #0]
    aa5e:	687b      	ldr	r3, [r7, #4]
    aa60:	60da      	str	r2, [r3, #12]
    aa62:	4b21      	ldr	r3, [pc, #132]	; (aae8 <tcp_process+0x744>)
    aa64:	687a      	ldr	r2, [r7, #4]
    aa66:	601a      	str	r2, [r3, #0]
    aa68:	4b20      	ldr	r3, [pc, #128]	; (aaec <tcp_process+0x748>)
    aa6a:	4798      	blx	r3
    }
    break;
    aa6c:	e046      	b.n	aafc <tcp_process+0x758>
  case LAST_ACK:
    tcp_receive(pcb);
    aa6e:	687b      	ldr	r3, [r7, #4]
    aa70:	0018      	movs	r0, r3
    aa72:	4b0e      	ldr	r3, [pc, #56]	; (aaac <tcp_process+0x708>)
    aa74:	4798      	blx	r3
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
    aa76:	4b16      	ldr	r3, [pc, #88]	; (aad0 <tcp_process+0x72c>)
    aa78:	781b      	ldrb	r3, [r3, #0]
    aa7a:	001a      	movs	r2, r3
    aa7c:	2310      	movs	r3, #16
    aa7e:	4013      	ands	r3, r2
    aa80:	d03e      	beq.n	ab00 <tcp_process+0x75c>
    aa82:	687b      	ldr	r3, [r7, #4]
    aa84:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    aa86:	4b0b      	ldr	r3, [pc, #44]	; (aab4 <tcp_process+0x710>)
    aa88:	681b      	ldr	r3, [r3, #0]
    aa8a:	429a      	cmp	r2, r3
    aa8c:	d138      	bne.n	ab00 <tcp_process+0x75c>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    aa8e:	4b08      	ldr	r3, [pc, #32]	; (aab0 <tcp_process+0x70c>)
    aa90:	781b      	ldrb	r3, [r3, #0]
    aa92:	2210      	movs	r2, #16
    aa94:	4313      	orrs	r3, r2
    aa96:	b2da      	uxtb	r2, r3
    aa98:	4b05      	ldr	r3, [pc, #20]	; (aab0 <tcp_process+0x70c>)
    aa9a:	701a      	strb	r2, [r3, #0]
    }
    break;
    aa9c:	e030      	b.n	ab00 <tcp_process+0x75c>
  default:
    break;
    aa9e:	46c0      	nop			; (mov r8, r8)
    aaa0:	e02f      	b.n	ab02 <tcp_process+0x75e>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
    aaa2:	46c0      	nop			; (mov r8, r8)
    aaa4:	e02d      	b.n	ab02 <tcp_process+0x75e>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
    aaa6:	46c0      	nop			; (mov r8, r8)
    aaa8:	e02b      	b.n	ab02 <tcp_process+0x75e>
    aaaa:	46c0      	nop			; (mov r8, r8)
    aaac:	0000ac7d 	.word	0x0000ac7d
    aab0:	20002c94 	.word	0x20002c94
    aab4:	20002c8c 	.word	0x20002c8c
    aab8:	20002c92 	.word	0x20002c92
    aabc:	20002c88 	.word	0x20002c88
    aac0:	20002c80 	.word	0x20002c80
    aac4:	20002e90 	.word	0x20002e90
    aac8:	20002e98 	.word	0x20002e98
    aacc:	0000cc35 	.word	0x0000cc35
    aad0:	20002c90 	.word	0x20002c90
    aad4:	0000cea5 	.word	0x0000cea5
    aad8:	000096c1 	.word	0x000096c1
    aadc:	20003ec4 	.word	0x20003ec4
    aae0:	20003ed0 	.word	0x20003ed0
    aae4:	20003ec0 	.word	0x20003ec0
    aae8:	20003ed8 	.word	0x20003ed8
    aaec:	00007355 	.word	0x00007355
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
    aaf0:	46c0      	nop			; (mov r8, r8)
    aaf2:	e006      	b.n	ab02 <tcp_process+0x75e>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
    aaf4:	46c0      	nop			; (mov r8, r8)
    aaf6:	e004      	b.n	ab02 <tcp_process+0x75e>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
    aaf8:	46c0      	nop			; (mov r8, r8)
    aafa:	e002      	b.n	ab02 <tcp_process+0x75e>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
    aafc:	46c0      	nop			; (mov r8, r8)
    aafe:	e000      	b.n	ab02 <tcp_process+0x75e>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
    ab00:	46c0      	nop			; (mov r8, r8)
  default:
    break;
  }
  return ERR_OK;
    ab02:	2300      	movs	r3, #0
}
    ab04:	0018      	movs	r0, r3
    ab06:	46bd      	mov	sp, r7
    ab08:	b006      	add	sp, #24
    ab0a:	bdb0      	pop	{r4, r5, r7, pc}

0000ab0c <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
    ab0c:	b5b0      	push	{r4, r5, r7, lr}
    ab0e:	b084      	sub	sp, #16
    ab10:	af00      	add	r7, sp, #0
    ab12:	6078      	str	r0, [r7, #4]
    ab14:	6039      	str	r1, [r7, #0]
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    ab16:	687b      	ldr	r3, [r7, #4]
    ab18:	68db      	ldr	r3, [r3, #12]
    ab1a:	7b1a      	ldrb	r2, [r3, #12]
    ab1c:	7b5b      	ldrb	r3, [r3, #13]
    ab1e:	021b      	lsls	r3, r3, #8
    ab20:	4313      	orrs	r3, r2
    ab22:	b29b      	uxth	r3, r3
    ab24:	0018      	movs	r0, r3
    ab26:	4b4f      	ldr	r3, [pc, #316]	; (ac64 <tcp_oos_insert_segment+0x158>)
    ab28:	4798      	blx	r3
    ab2a:	0003      	movs	r3, r0
    ab2c:	001a      	movs	r2, r3
    ab2e:	2301      	movs	r3, #1
    ab30:	4013      	ands	r3, r2
    ab32:	d040      	beq.n	abb6 <tcp_oos_insert_segment+0xaa>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
    ab34:	683b      	ldr	r3, [r7, #0]
    ab36:	0018      	movs	r0, r3
    ab38:	4b4b      	ldr	r3, [pc, #300]	; (ac68 <tcp_oos_insert_segment+0x15c>)
    ab3a:	4798      	blx	r3
    next = NULL;
    ab3c:	2300      	movs	r3, #0
    ab3e:	603b      	str	r3, [r7, #0]
    ab40:	e088      	b.n	ac54 <tcp_oos_insert_segment+0x148>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    ab42:	683b      	ldr	r3, [r7, #0]
    ab44:	68db      	ldr	r3, [r3, #12]
    ab46:	7b1a      	ldrb	r2, [r3, #12]
    ab48:	7b5b      	ldrb	r3, [r3, #13]
    ab4a:	021b      	lsls	r3, r3, #8
    ab4c:	4313      	orrs	r3, r2
    ab4e:	b29b      	uxth	r3, r3
    ab50:	0018      	movs	r0, r3
    ab52:	4b44      	ldr	r3, [pc, #272]	; (ac64 <tcp_oos_insert_segment+0x158>)
    ab54:	4798      	blx	r3
    ab56:	0003      	movs	r3, r0
    ab58:	001a      	movs	r2, r3
    ab5a:	2301      	movs	r3, #1
    ab5c:	4013      	ands	r3, r2
    ab5e:	d021      	beq.n	aba4 <tcp_oos_insert_segment+0x98>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    ab60:	687b      	ldr	r3, [r7, #4]
    ab62:	68dc      	ldr	r4, [r3, #12]
    ab64:	687b      	ldr	r3, [r7, #4]
    ab66:	68db      	ldr	r3, [r3, #12]
    ab68:	7b1a      	ldrb	r2, [r3, #12]
    ab6a:	7b5b      	ldrb	r3, [r3, #13]
    ab6c:	021b      	lsls	r3, r3, #8
    ab6e:	4313      	orrs	r3, r2
    ab70:	b29d      	uxth	r5, r3
    ab72:	2001      	movs	r0, #1
    ab74:	4b3d      	ldr	r3, [pc, #244]	; (ac6c <tcp_oos_insert_segment+0x160>)
    ab76:	4798      	blx	r3
    ab78:	0003      	movs	r3, r0
    ab7a:	432b      	orrs	r3, r5
    ab7c:	b29b      	uxth	r3, r3
    ab7e:	22ff      	movs	r2, #255	; 0xff
    ab80:	401a      	ands	r2, r3
    ab82:	0010      	movs	r0, r2
    ab84:	7b22      	ldrb	r2, [r4, #12]
    ab86:	2100      	movs	r1, #0
    ab88:	400a      	ands	r2, r1
    ab8a:	1c11      	adds	r1, r2, #0
    ab8c:	1c02      	adds	r2, r0, #0
    ab8e:	430a      	orrs	r2, r1
    ab90:	7322      	strb	r2, [r4, #12]
    ab92:	0a1b      	lsrs	r3, r3, #8
    ab94:	b299      	uxth	r1, r3
    ab96:	7b63      	ldrb	r3, [r4, #13]
    ab98:	2200      	movs	r2, #0
    ab9a:	4013      	ands	r3, r2
    ab9c:	1c1a      	adds	r2, r3, #0
    ab9e:	1c0b      	adds	r3, r1, #0
    aba0:	4313      	orrs	r3, r2
    aba2:	7363      	strb	r3, [r4, #13]
      }
      old_seg = next;
    aba4:	683b      	ldr	r3, [r7, #0]
    aba6:	60fb      	str	r3, [r7, #12]
      next = next->next;
    aba8:	683b      	ldr	r3, [r7, #0]
    abaa:	681b      	ldr	r3, [r3, #0]
    abac:	603b      	str	r3, [r7, #0]
      tcp_seg_free(old_seg);
    abae:	68fb      	ldr	r3, [r7, #12]
    abb0:	0018      	movs	r0, r3
    abb2:	4b2f      	ldr	r3, [pc, #188]	; (ac70 <tcp_oos_insert_segment+0x164>)
    abb4:	4798      	blx	r3
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    abb6:	683b      	ldr	r3, [r7, #0]
    abb8:	2b00      	cmp	r3, #0
    abba:	d017      	beq.n	abec <tcp_oos_insert_segment+0xe0>
           TCP_SEQ_GEQ((seqno + cseg->len),
    abbc:	687b      	ldr	r3, [r7, #4]
    abbe:	891b      	ldrh	r3, [r3, #8]
    abc0:	001a      	movs	r2, r3
    abc2:	4b2c      	ldr	r3, [pc, #176]	; (ac74 <tcp_oos_insert_segment+0x168>)
    abc4:	681b      	ldr	r3, [r3, #0]
    abc6:	18d2      	adds	r2, r2, r3
    abc8:	683b      	ldr	r3, [r7, #0]
    abca:	68db      	ldr	r3, [r3, #12]
    abcc:	7919      	ldrb	r1, [r3, #4]
    abce:	7958      	ldrb	r0, [r3, #5]
    abd0:	0200      	lsls	r0, r0, #8
    abd2:	4301      	orrs	r1, r0
    abd4:	7998      	ldrb	r0, [r3, #6]
    abd6:	0400      	lsls	r0, r0, #16
    abd8:	4301      	orrs	r1, r0
    abda:	79db      	ldrb	r3, [r3, #7]
    abdc:	061b      	lsls	r3, r3, #24
    abde:	430b      	orrs	r3, r1
    abe0:	0019      	movs	r1, r3
    abe2:	683b      	ldr	r3, [r7, #0]
    abe4:	891b      	ldrh	r3, [r3, #8]
    abe6:	18cb      	adds	r3, r1, r3
    abe8:	1ad3      	subs	r3, r2, r3
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    abea:	d5aa      	bpl.n	ab42 <tcp_oos_insert_segment+0x36>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    abec:	683b      	ldr	r3, [r7, #0]
    abee:	2b00      	cmp	r3, #0
    abf0:	d030      	beq.n	ac54 <tcp_oos_insert_segment+0x148>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    abf2:	687b      	ldr	r3, [r7, #4]
    abf4:	891b      	ldrh	r3, [r3, #8]
    abf6:	001a      	movs	r2, r3
    abf8:	4b1e      	ldr	r3, [pc, #120]	; (ac74 <tcp_oos_insert_segment+0x168>)
    abfa:	681b      	ldr	r3, [r3, #0]
    abfc:	18d2      	adds	r2, r2, r3
    abfe:	683b      	ldr	r3, [r7, #0]
    ac00:	68db      	ldr	r3, [r3, #12]
    ac02:	7919      	ldrb	r1, [r3, #4]
    ac04:	7958      	ldrb	r0, [r3, #5]
    ac06:	0200      	lsls	r0, r0, #8
    ac08:	4301      	orrs	r1, r0
    ac0a:	7998      	ldrb	r0, [r3, #6]
    ac0c:	0400      	lsls	r0, r0, #16
    ac0e:	4301      	orrs	r1, r0
    ac10:	79db      	ldrb	r3, [r3, #7]
    ac12:	061b      	lsls	r3, r3, #24
    ac14:	430b      	orrs	r3, r1
    ac16:	1ad3      	subs	r3, r2, r3
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    ac18:	2b00      	cmp	r3, #0
    ac1a:	dd1b      	ble.n	ac54 <tcp_oos_insert_segment+0x148>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    ac1c:	683b      	ldr	r3, [r7, #0]
    ac1e:	68db      	ldr	r3, [r3, #12]
    ac20:	791a      	ldrb	r2, [r3, #4]
    ac22:	7959      	ldrb	r1, [r3, #5]
    ac24:	0209      	lsls	r1, r1, #8
    ac26:	430a      	orrs	r2, r1
    ac28:	7999      	ldrb	r1, [r3, #6]
    ac2a:	0409      	lsls	r1, r1, #16
    ac2c:	430a      	orrs	r2, r1
    ac2e:	79db      	ldrb	r3, [r3, #7]
    ac30:	061b      	lsls	r3, r3, #24
    ac32:	4313      	orrs	r3, r2
    ac34:	b29a      	uxth	r2, r3
    ac36:	4b0f      	ldr	r3, [pc, #60]	; (ac74 <tcp_oos_insert_segment+0x168>)
    ac38:	681b      	ldr	r3, [r3, #0]
    ac3a:	b29b      	uxth	r3, r3
    ac3c:	1ad3      	subs	r3, r2, r3
    ac3e:	b29a      	uxth	r2, r3
    ac40:	687b      	ldr	r3, [r7, #4]
    ac42:	811a      	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
    ac44:	687b      	ldr	r3, [r7, #4]
    ac46:	685a      	ldr	r2, [r3, #4]
    ac48:	687b      	ldr	r3, [r7, #4]
    ac4a:	891b      	ldrh	r3, [r3, #8]
    ac4c:	0019      	movs	r1, r3
    ac4e:	0010      	movs	r0, r2
    ac50:	4b09      	ldr	r3, [pc, #36]	; (ac78 <tcp_oos_insert_segment+0x16c>)
    ac52:	4798      	blx	r3
    }
  }
  cseg->next = next;
    ac54:	687b      	ldr	r3, [r7, #4]
    ac56:	683a      	ldr	r2, [r7, #0]
    ac58:	601a      	str	r2, [r3, #0]
}
    ac5a:	46c0      	nop			; (mov r8, r8)
    ac5c:	46bd      	mov	sp, r7
    ac5e:	b004      	add	sp, #16
    ac60:	bdb0      	pop	{r4, r5, r7, pc}
    ac62:	46c0      	nop			; (mov r8, r8)
    ac64:	0000561d 	.word	0x0000561d
    ac68:	0000937d 	.word	0x0000937d
    ac6c:	000055f1 	.word	0x000055f1
    ac70:	000093ad 	.word	0x000093ad
    ac74:	20002c88 	.word	0x20002c88
    ac78:	00008151 	.word	0x00008151

0000ac7c <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
    ac7c:	b5f0      	push	{r4, r5, r6, r7, lr}
    ac7e:	b08d      	sub	sp, #52	; 0x34
    ac80:	af00      	add	r7, sp, #0
    ac82:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
    ac84:	2300      	movs	r3, #0
    ac86:	61bb      	str	r3, [r7, #24]
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    ac88:	4bbe      	ldr	r3, [pc, #760]	; (af84 <tcp_receive+0x308>)
    ac8a:	781b      	ldrb	r3, [r3, #0]
    ac8c:	001a      	movs	r2, r3
    ac8e:	2310      	movs	r3, #16
    ac90:	4013      	ands	r3, r2
    ac92:	d100      	bne.n	ac96 <tcp_receive+0x1a>
    ac94:	e2e7      	b.n	b266 <tcp_receive+0x5ea>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    ac96:	687b      	ldr	r3, [r7, #4]
    ac98:	2260      	movs	r2, #96	; 0x60
    ac9a:	5a9b      	ldrh	r3, [r3, r2]
    ac9c:	001a      	movs	r2, r3
    ac9e:	687b      	ldr	r3, [r7, #4]
    aca0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    aca2:	18d3      	adds	r3, r2, r3
    aca4:	617b      	str	r3, [r7, #20]

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    aca6:	687b      	ldr	r3, [r7, #4]
    aca8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    acaa:	4bb7      	ldr	r3, [pc, #732]	; (af88 <tcp_receive+0x30c>)
    acac:	681b      	ldr	r3, [r3, #0]
    acae:	1ad3      	subs	r3, r2, r3
    acb0:	d41d      	bmi.n	acee <tcp_receive+0x72>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    acb2:	687b      	ldr	r3, [r7, #4]
    acb4:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    acb6:	4bb4      	ldr	r3, [pc, #720]	; (af88 <tcp_receive+0x30c>)
    acb8:	681b      	ldr	r3, [r3, #0]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    acba:	429a      	cmp	r2, r3
    acbc:	d105      	bne.n	acca <tcp_receive+0x4e>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    acbe:	687b      	ldr	r3, [r7, #4]
    acc0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    acc2:	4bb2      	ldr	r3, [pc, #712]	; (af8c <tcp_receive+0x310>)
    acc4:	681b      	ldr	r3, [r3, #0]
    acc6:	1ad3      	subs	r3, r2, r3
    acc8:	d411      	bmi.n	acee <tcp_receive+0x72>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    acca:	687b      	ldr	r3, [r7, #4]
    accc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    acce:	4baf      	ldr	r3, [pc, #700]	; (af8c <tcp_receive+0x310>)
    acd0:	681b      	ldr	r3, [r3, #0]
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    acd2:	429a      	cmp	r2, r3
    acd4:	d14f      	bne.n	ad76 <tcp_receive+0xfa>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    acd6:	4bae      	ldr	r3, [pc, #696]	; (af90 <tcp_receive+0x314>)
    acd8:	681b      	ldr	r3, [r3, #0]
    acda:	7b9a      	ldrb	r2, [r3, #14]
    acdc:	7bdb      	ldrb	r3, [r3, #15]
    acde:	021b      	lsls	r3, r3, #8
    ace0:	4313      	orrs	r3, r2
    ace2:	b29a      	uxth	r2, r3
    ace4:	687b      	ldr	r3, [r7, #4]
    ace6:	2160      	movs	r1, #96	; 0x60
    ace8:	5a5b      	ldrh	r3, [r3, r1]
    acea:	429a      	cmp	r2, r3
    acec:	d943      	bls.n	ad76 <tcp_receive+0xfa>
      pcb->snd_wnd = tcphdr->wnd;
    acee:	4ba8      	ldr	r3, [pc, #672]	; (af90 <tcp_receive+0x314>)
    acf0:	681b      	ldr	r3, [r3, #0]
    acf2:	7b9a      	ldrb	r2, [r3, #14]
    acf4:	7bdb      	ldrb	r3, [r3, #15]
    acf6:	021b      	lsls	r3, r3, #8
    acf8:	4313      	orrs	r3, r2
    acfa:	b299      	uxth	r1, r3
    acfc:	687b      	ldr	r3, [r7, #4]
    acfe:	2260      	movs	r2, #96	; 0x60
    ad00:	5299      	strh	r1, [r3, r2]
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
    ad02:	687b      	ldr	r3, [r7, #4]
    ad04:	2262      	movs	r2, #98	; 0x62
    ad06:	5a9a      	ldrh	r2, [r3, r2]
    ad08:	4ba1      	ldr	r3, [pc, #644]	; (af90 <tcp_receive+0x314>)
    ad0a:	681b      	ldr	r3, [r3, #0]
    ad0c:	7b99      	ldrb	r1, [r3, #14]
    ad0e:	7bdb      	ldrb	r3, [r3, #15]
    ad10:	021b      	lsls	r3, r3, #8
    ad12:	430b      	orrs	r3, r1
    ad14:	b29b      	uxth	r3, r3
    ad16:	429a      	cmp	r2, r3
    ad18:	d209      	bcs.n	ad2e <tcp_receive+0xb2>
        pcb->snd_wnd_max = tcphdr->wnd;
    ad1a:	4b9d      	ldr	r3, [pc, #628]	; (af90 <tcp_receive+0x314>)
    ad1c:	681b      	ldr	r3, [r3, #0]
    ad1e:	7b9a      	ldrb	r2, [r3, #14]
    ad20:	7bdb      	ldrb	r3, [r3, #15]
    ad22:	021b      	lsls	r3, r3, #8
    ad24:	4313      	orrs	r3, r2
    ad26:	b299      	uxth	r1, r3
    ad28:	687b      	ldr	r3, [r7, #4]
    ad2a:	2262      	movs	r2, #98	; 0x62
    ad2c:	5299      	strh	r1, [r3, r2]
      }
      pcb->snd_wl1 = seqno;
    ad2e:	4b96      	ldr	r3, [pc, #600]	; (af88 <tcp_receive+0x30c>)
    ad30:	681a      	ldr	r2, [r3, #0]
    ad32:	687b      	ldr	r3, [r7, #4]
    ad34:	655a      	str	r2, [r3, #84]	; 0x54
      pcb->snd_wl2 = ackno;
    ad36:	4b95      	ldr	r3, [pc, #596]	; (af8c <tcp_receive+0x310>)
    ad38:	681a      	ldr	r2, [r3, #0]
    ad3a:	687b      	ldr	r3, [r7, #4]
    ad3c:	659a      	str	r2, [r3, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
    ad3e:	687b      	ldr	r3, [r7, #4]
    ad40:	2260      	movs	r2, #96	; 0x60
    ad42:	5a9b      	ldrh	r3, [r3, r2]
    ad44:	2b00      	cmp	r3, #0
    ad46:	d10d      	bne.n	ad64 <tcp_receive+0xe8>
        if (pcb->persist_backoff == 0) {
    ad48:	687b      	ldr	r3, [r7, #4]
    ad4a:	2295      	movs	r2, #149	; 0x95
    ad4c:	5c9b      	ldrb	r3, [r3, r2]
    ad4e:	2b00      	cmp	r3, #0
    ad50:	d111      	bne.n	ad76 <tcp_receive+0xfa>
          /* start persist timer */
          pcb->persist_cnt = 0;
    ad52:	687b      	ldr	r3, [r7, #4]
    ad54:	2294      	movs	r2, #148	; 0x94
    ad56:	2100      	movs	r1, #0
    ad58:	5499      	strb	r1, [r3, r2]
          pcb->persist_backoff = 1;
    ad5a:	687b      	ldr	r3, [r7, #4]
    ad5c:	2295      	movs	r2, #149	; 0x95
    ad5e:	2101      	movs	r1, #1
    ad60:	5499      	strb	r1, [r3, r2]
    ad62:	e008      	b.n	ad76 <tcp_receive+0xfa>
        }
      } else if (pcb->persist_backoff > 0) {
    ad64:	687b      	ldr	r3, [r7, #4]
    ad66:	2295      	movs	r2, #149	; 0x95
    ad68:	5c9b      	ldrb	r3, [r3, r2]
    ad6a:	2b00      	cmp	r3, #0
    ad6c:	d003      	beq.n	ad76 <tcp_receive+0xfa>
        /* stop persist timer */
          pcb->persist_backoff = 0;
    ad6e:	687b      	ldr	r3, [r7, #4]
    ad70:	2295      	movs	r2, #149	; 0x95
    ad72:	2100      	movs	r1, #0
    ad74:	5499      	strb	r1, [r3, r2]
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    ad76:	4b85      	ldr	r3, [pc, #532]	; (af8c <tcp_receive+0x310>)
    ad78:	681a      	ldr	r2, [r3, #0]
    ad7a:	687b      	ldr	r3, [r7, #4]
    ad7c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    ad7e:	1ad3      	subs	r3, r2, r3
    ad80:	2b00      	cmp	r3, #0
    ad82:	dc5d      	bgt.n	ae40 <tcp_receive+0x1c4>
      pcb->acked = 0;
    ad84:	687b      	ldr	r3, [r7, #4]
    ad86:	2264      	movs	r2, #100	; 0x64
    ad88:	2100      	movs	r1, #0
    ad8a:	5299      	strh	r1, [r3, r2]
      /* Clause 2 */
      if (tcplen == 0) {
    ad8c:	4b81      	ldr	r3, [pc, #516]	; (af94 <tcp_receive+0x318>)
    ad8e:	881b      	ldrh	r3, [r3, #0]
    ad90:	2b00      	cmp	r3, #0
    ad92:	d14c      	bne.n	ae2e <tcp_receive+0x1b2>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
    ad94:	687b      	ldr	r3, [r7, #4]
    ad96:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    ad98:	687a      	ldr	r2, [r7, #4]
    ad9a:	2160      	movs	r1, #96	; 0x60
    ad9c:	5a52      	ldrh	r2, [r2, r1]
    ad9e:	189a      	adds	r2, r3, r2
    ada0:	697b      	ldr	r3, [r7, #20]
    ada2:	429a      	cmp	r2, r3
    ada4:	d143      	bne.n	ae2e <tcp_receive+0x1b2>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
    ada6:	687b      	ldr	r3, [r7, #4]
    ada8:	2234      	movs	r2, #52	; 0x34
    adaa:	5e9b      	ldrsh	r3, [r3, r2]
    adac:	2b00      	cmp	r3, #0
    adae:	db3e      	blt.n	ae2e <tcp_receive+0x1b2>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
    adb0:	687b      	ldr	r3, [r7, #4]
    adb2:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    adb4:	4b75      	ldr	r3, [pc, #468]	; (af8c <tcp_receive+0x310>)
    adb6:	681b      	ldr	r3, [r3, #0]
    adb8:	429a      	cmp	r2, r3
    adba:	d138      	bne.n	ae2e <tcp_receive+0x1b2>
              found_dupack = 1;
    adbc:	2301      	movs	r3, #1
    adbe:	61bb      	str	r3, [r7, #24]
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    adc0:	687b      	ldr	r3, [r7, #4]
    adc2:	2247      	movs	r2, #71	; 0x47
    adc4:	5c9b      	ldrb	r3, [r3, r2]
    adc6:	3301      	adds	r3, #1
    adc8:	b2da      	uxtb	r2, r3
    adca:	687b      	ldr	r3, [r7, #4]
    adcc:	2147      	movs	r1, #71	; 0x47
    adce:	5c5b      	ldrb	r3, [r3, r1]
    add0:	429a      	cmp	r2, r3
    add2:	d907      	bls.n	ade4 <tcp_receive+0x168>
                ++pcb->dupacks;
    add4:	687b      	ldr	r3, [r7, #4]
    add6:	2247      	movs	r2, #71	; 0x47
    add8:	5c9b      	ldrb	r3, [r3, r2]
    adda:	3301      	adds	r3, #1
    addc:	b2d9      	uxtb	r1, r3
    adde:	687b      	ldr	r3, [r7, #4]
    ade0:	2247      	movs	r2, #71	; 0x47
    ade2:	5499      	strb	r1, [r3, r2]
              }
              if (pcb->dupacks > 3) {
    ade4:	687b      	ldr	r3, [r7, #4]
    ade6:	2247      	movs	r2, #71	; 0x47
    ade8:	5c9b      	ldrb	r3, [r3, r2]
    adea:	2b03      	cmp	r3, #3
    adec:	d916      	bls.n	ae1c <tcp_receive+0x1a0>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    adee:	687b      	ldr	r3, [r7, #4]
    adf0:	224c      	movs	r2, #76	; 0x4c
    adf2:	5a9a      	ldrh	r2, [r3, r2]
    adf4:	687b      	ldr	r3, [r7, #4]
    adf6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    adf8:	18d3      	adds	r3, r2, r3
    adfa:	b29a      	uxth	r2, r3
    adfc:	687b      	ldr	r3, [r7, #4]
    adfe:	214c      	movs	r1, #76	; 0x4c
    ae00:	5a5b      	ldrh	r3, [r3, r1]
    ae02:	429a      	cmp	r2, r3
    ae04:	d913      	bls.n	ae2e <tcp_receive+0x1b2>
                  pcb->cwnd += pcb->mss;
    ae06:	687b      	ldr	r3, [r7, #4]
    ae08:	224c      	movs	r2, #76	; 0x4c
    ae0a:	5a9a      	ldrh	r2, [r3, r2]
    ae0c:	687b      	ldr	r3, [r7, #4]
    ae0e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    ae10:	18d3      	adds	r3, r2, r3
    ae12:	b299      	uxth	r1, r3
    ae14:	687b      	ldr	r3, [r7, #4]
    ae16:	224c      	movs	r2, #76	; 0x4c
    ae18:	5299      	strh	r1, [r3, r2]
    ae1a:	e008      	b.n	ae2e <tcp_receive+0x1b2>
                }
              } else if (pcb->dupacks == 3) {
    ae1c:	687b      	ldr	r3, [r7, #4]
    ae1e:	2247      	movs	r2, #71	; 0x47
    ae20:	5c9b      	ldrb	r3, [r3, r2]
    ae22:	2b03      	cmp	r3, #3
    ae24:	d103      	bne.n	ae2e <tcp_receive+0x1b2>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
    ae26:	687b      	ldr	r3, [r7, #4]
    ae28:	0018      	movs	r0, r3
    ae2a:	4b5b      	ldr	r3, [pc, #364]	; (af98 <tcp_receive+0x31c>)
    ae2c:	4798      	blx	r3
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
    ae2e:	69bb      	ldr	r3, [r7, #24]
    ae30:	2b00      	cmp	r3, #0
    ae32:	d000      	beq.n	ae36 <tcp_receive+0x1ba>
    ae34:	e173      	b.n	b11e <tcp_receive+0x4a2>
        pcb->dupacks = 0;
    ae36:	687b      	ldr	r3, [r7, #4]
    ae38:	2247      	movs	r2, #71	; 0x47
    ae3a:	2100      	movs	r1, #0
    ae3c:	5499      	strb	r1, [r3, r2]
    ae3e:	e16e      	b.n	b11e <tcp_receive+0x4a2>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
    ae40:	4b52      	ldr	r3, [pc, #328]	; (af8c <tcp_receive+0x310>)
    ae42:	681a      	ldr	r2, [r3, #0]
    ae44:	687b      	ldr	r3, [r7, #4]
    ae46:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    ae48:	1ad3      	subs	r3, r2, r3
    ae4a:	3b01      	subs	r3, #1
    ae4c:	2b00      	cmp	r3, #0
    ae4e:	da00      	bge.n	ae52 <tcp_receive+0x1d6>
    ae50:	e120      	b.n	b094 <tcp_receive+0x418>
    ae52:	4b4e      	ldr	r3, [pc, #312]	; (af8c <tcp_receive+0x310>)
    ae54:	681a      	ldr	r2, [r3, #0]
    ae56:	687b      	ldr	r3, [r7, #4]
    ae58:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    ae5a:	1ad3      	subs	r3, r2, r3
    ae5c:	2b00      	cmp	r3, #0
    ae5e:	dd00      	ble.n	ae62 <tcp_receive+0x1e6>
    ae60:	e118      	b.n	b094 <tcp_receive+0x418>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
    ae62:	687b      	ldr	r3, [r7, #4]
    ae64:	7f9b      	ldrb	r3, [r3, #30]
    ae66:	001a      	movs	r2, r3
    ae68:	2304      	movs	r3, #4
    ae6a:	4013      	ands	r3, r2
    ae6c:	d00c      	beq.n	ae88 <tcp_receive+0x20c>
        pcb->flags &= ~TF_INFR;
    ae6e:	687b      	ldr	r3, [r7, #4]
    ae70:	7f9b      	ldrb	r3, [r3, #30]
    ae72:	2204      	movs	r2, #4
    ae74:	4393      	bics	r3, r2
    ae76:	b2da      	uxtb	r2, r3
    ae78:	687b      	ldr	r3, [r7, #4]
    ae7a:	779a      	strb	r2, [r3, #30]
        pcb->cwnd = pcb->ssthresh;
    ae7c:	687b      	ldr	r3, [r7, #4]
    ae7e:	224e      	movs	r2, #78	; 0x4e
    ae80:	5a99      	ldrh	r1, [r3, r2]
    ae82:	687b      	ldr	r3, [r7, #4]
    ae84:	224c      	movs	r2, #76	; 0x4c
    ae86:	5299      	strh	r1, [r3, r2]
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
    ae88:	687b      	ldr	r3, [r7, #4]
    ae8a:	2246      	movs	r2, #70	; 0x46
    ae8c:	2100      	movs	r1, #0
    ae8e:	5499      	strb	r1, [r3, r2]

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    ae90:	687b      	ldr	r3, [r7, #4]
    ae92:	2240      	movs	r2, #64	; 0x40
    ae94:	5e9b      	ldrsh	r3, [r3, r2]
    ae96:	10db      	asrs	r3, r3, #3
    ae98:	b21b      	sxth	r3, r3
    ae9a:	b29a      	uxth	r2, r3
    ae9c:	687b      	ldr	r3, [r7, #4]
    ae9e:	2142      	movs	r1, #66	; 0x42
    aea0:	5e5b      	ldrsh	r3, [r3, r1]
    aea2:	b29b      	uxth	r3, r3
    aea4:	18d3      	adds	r3, r2, r3
    aea6:	b29b      	uxth	r3, r3
    aea8:	b219      	sxth	r1, r3
    aeaa:	687b      	ldr	r3, [r7, #4]
    aeac:	2244      	movs	r2, #68	; 0x44
    aeae:	5299      	strh	r1, [r3, r2]

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
    aeb0:	4b36      	ldr	r3, [pc, #216]	; (af8c <tcp_receive+0x310>)
    aeb2:	681b      	ldr	r3, [r3, #0]
    aeb4:	b29a      	uxth	r2, r3
    aeb6:	687b      	ldr	r3, [r7, #4]
    aeb8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    aeba:	b29b      	uxth	r3, r3
    aebc:	1ad3      	subs	r3, r2, r3
    aebe:	b299      	uxth	r1, r3
    aec0:	687b      	ldr	r3, [r7, #4]
    aec2:	2264      	movs	r2, #100	; 0x64
    aec4:	5299      	strh	r1, [r3, r2]

      pcb->snd_buf += pcb->acked;
    aec6:	687b      	ldr	r3, [r7, #4]
    aec8:	2266      	movs	r2, #102	; 0x66
    aeca:	5a9a      	ldrh	r2, [r3, r2]
    aecc:	687b      	ldr	r3, [r7, #4]
    aece:	2164      	movs	r1, #100	; 0x64
    aed0:	5a5b      	ldrh	r3, [r3, r1]
    aed2:	18d3      	adds	r3, r2, r3
    aed4:	b299      	uxth	r1, r3
    aed6:	687b      	ldr	r3, [r7, #4]
    aed8:	2266      	movs	r2, #102	; 0x66
    aeda:	5299      	strh	r1, [r3, r2]

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
    aedc:	687b      	ldr	r3, [r7, #4]
    aede:	2247      	movs	r2, #71	; 0x47
    aee0:	2100      	movs	r1, #0
    aee2:	5499      	strb	r1, [r3, r2]
      pcb->lastack = ackno;
    aee4:	4b29      	ldr	r3, [pc, #164]	; (af8c <tcp_receive+0x310>)
    aee6:	681a      	ldr	r2, [r3, #0]
    aee8:	687b      	ldr	r3, [r7, #4]
    aeea:	649a      	str	r2, [r3, #72]	; 0x48

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
    aeec:	687b      	ldr	r3, [r7, #4]
    aeee:	7e1b      	ldrb	r3, [r3, #24]
    aef0:	2b03      	cmp	r3, #3
    aef2:	d800      	bhi.n	aef6 <tcp_receive+0x27a>
    aef4:	e08c      	b.n	b010 <tcp_receive+0x394>
        if (pcb->cwnd < pcb->ssthresh) {
    aef6:	687b      	ldr	r3, [r7, #4]
    aef8:	224c      	movs	r2, #76	; 0x4c
    aefa:	5a9a      	ldrh	r2, [r3, r2]
    aefc:	687b      	ldr	r3, [r7, #4]
    aefe:	214e      	movs	r1, #78	; 0x4e
    af00:	5a5b      	ldrh	r3, [r3, r1]
    af02:	429a      	cmp	r2, r3
    af04:	d217      	bcs.n	af36 <tcp_receive+0x2ba>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    af06:	687b      	ldr	r3, [r7, #4]
    af08:	224c      	movs	r2, #76	; 0x4c
    af0a:	5a9a      	ldrh	r2, [r3, r2]
    af0c:	687b      	ldr	r3, [r7, #4]
    af0e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    af10:	18d3      	adds	r3, r2, r3
    af12:	b29a      	uxth	r2, r3
    af14:	687b      	ldr	r3, [r7, #4]
    af16:	214c      	movs	r1, #76	; 0x4c
    af18:	5a5b      	ldrh	r3, [r3, r1]
    af1a:	429a      	cmp	r2, r3
    af1c:	d800      	bhi.n	af20 <tcp_receive+0x2a4>
    af1e:	e077      	b.n	b010 <tcp_receive+0x394>
            pcb->cwnd += pcb->mss;
    af20:	687b      	ldr	r3, [r7, #4]
    af22:	224c      	movs	r2, #76	; 0x4c
    af24:	5a9a      	ldrh	r2, [r3, r2]
    af26:	687b      	ldr	r3, [r7, #4]
    af28:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    af2a:	18d3      	adds	r3, r2, r3
    af2c:	b299      	uxth	r1, r3
    af2e:	687b      	ldr	r3, [r7, #4]
    af30:	224c      	movs	r2, #76	; 0x4c
    af32:	5299      	strh	r1, [r3, r2]
    af34:	e06c      	b.n	b010 <tcp_receive+0x394>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    af36:	687b      	ldr	r3, [r7, #4]
    af38:	224c      	movs	r2, #76	; 0x4c
    af3a:	5a9c      	ldrh	r4, [r3, r2]
    af3c:	687b      	ldr	r3, [r7, #4]
    af3e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    af40:	001a      	movs	r2, r3
    af42:	687b      	ldr	r3, [r7, #4]
    af44:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    af46:	4353      	muls	r3, r2
    af48:	0018      	movs	r0, r3
    af4a:	687b      	ldr	r3, [r7, #4]
    af4c:	224c      	movs	r2, #76	; 0x4c
    af4e:	5a9b      	ldrh	r3, [r3, r2]
    af50:	001a      	movs	r2, r3
    af52:	4b12      	ldr	r3, [pc, #72]	; (af9c <tcp_receive+0x320>)
    af54:	0011      	movs	r1, r2
    af56:	4798      	blx	r3
    af58:	0003      	movs	r3, r0
    af5a:	b29a      	uxth	r2, r3
    af5c:	2312      	movs	r3, #18
    af5e:	18fb      	adds	r3, r7, r3
    af60:	18a2      	adds	r2, r4, r2
    af62:	801a      	strh	r2, [r3, #0]
          if (new_cwnd > pcb->cwnd) {
    af64:	687b      	ldr	r3, [r7, #4]
    af66:	224c      	movs	r2, #76	; 0x4c
    af68:	5a9b      	ldrh	r3, [r3, r2]
    af6a:	2212      	movs	r2, #18
    af6c:	18ba      	adds	r2, r7, r2
    af6e:	8812      	ldrh	r2, [r2, #0]
    af70:	429a      	cmp	r2, r3
    af72:	d94d      	bls.n	b010 <tcp_receive+0x394>
            pcb->cwnd = new_cwnd;
    af74:	687b      	ldr	r3, [r7, #4]
    af76:	2212      	movs	r2, #18
    af78:	18ba      	adds	r2, r7, r2
    af7a:	214c      	movs	r1, #76	; 0x4c
    af7c:	8812      	ldrh	r2, [r2, #0]
    af7e:	525a      	strh	r2, [r3, r1]
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    af80:	e046      	b.n	b010 <tcp_receive+0x394>
    af82:	46c0      	nop			; (mov r8, r8)
    af84:	20002c90 	.word	0x20002c90
    af88:	20002c88 	.word	0x20002c88
    af8c:	20002c8c 	.word	0x20002c8c
    af90:	20002c80 	.word	0x20002c80
    af94:	20002c92 	.word	0x20002c92
    af98:	0000cf61 	.word	0x0000cf61
    af9c:	0000fa01 	.word	0x0000fa01
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
    afa0:	687b      	ldr	r3, [r7, #4]
    afa2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    afa4:	62fb      	str	r3, [r7, #44]	; 0x2c
        pcb->unacked = pcb->unacked->next;
    afa6:	687b      	ldr	r3, [r7, #4]
    afa8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    afaa:	681a      	ldr	r2, [r3, #0]
    afac:	687b      	ldr	r3, [r7, #4]
    afae:	671a      	str	r2, [r3, #112]	; 0x70

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    afb0:	687b      	ldr	r3, [r7, #4]
    afb2:	2264      	movs	r2, #100	; 0x64
    afb4:	5a9b      	ldrh	r3, [r3, r2]
    afb6:	2b00      	cmp	r3, #0
    afb8:	d016      	beq.n	afe8 <tcp_receive+0x36c>
    afba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    afbc:	68db      	ldr	r3, [r3, #12]
    afbe:	7b1a      	ldrb	r2, [r3, #12]
    afc0:	7b5b      	ldrb	r3, [r3, #13]
    afc2:	021b      	lsls	r3, r3, #8
    afc4:	4313      	orrs	r3, r2
    afc6:	b29b      	uxth	r3, r3
    afc8:	0018      	movs	r0, r3
    afca:	4bd6      	ldr	r3, [pc, #856]	; (b324 <tcp_receive+0x6a8>)
    afcc:	4798      	blx	r3
    afce:	0003      	movs	r3, r0
    afd0:	001a      	movs	r2, r3
    afd2:	2301      	movs	r3, #1
    afd4:	4013      	ands	r3, r2
    afd6:	d007      	beq.n	afe8 <tcp_receive+0x36c>
          pcb->acked--;
    afd8:	687b      	ldr	r3, [r7, #4]
    afda:	2264      	movs	r2, #100	; 0x64
    afdc:	5a9b      	ldrh	r3, [r3, r2]
    afde:	3b01      	subs	r3, #1
    afe0:	b299      	uxth	r1, r3
    afe2:	687b      	ldr	r3, [r7, #4]
    afe4:	2264      	movs	r2, #100	; 0x64
    afe6:	5299      	strh	r1, [r3, r2]
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
    afe8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    afea:	685b      	ldr	r3, [r3, #4]
    afec:	0018      	movs	r0, r3
    afee:	4bce      	ldr	r3, [pc, #824]	; (b328 <tcp_receive+0x6ac>)
    aff0:	4798      	blx	r3
    aff2:	0003      	movs	r3, r0
    aff4:	0019      	movs	r1, r3
    aff6:	687b      	ldr	r3, [r7, #4]
    aff8:	2268      	movs	r2, #104	; 0x68
    affa:	5a9a      	ldrh	r2, [r3, r2]
    affc:	b28b      	uxth	r3, r1
    affe:	1ad3      	subs	r3, r2, r3
    b000:	b299      	uxth	r1, r3
    b002:	687b      	ldr	r3, [r7, #4]
    b004:	2268      	movs	r2, #104	; 0x68
    b006:	5299      	strh	r1, [r3, r2]
        tcp_seg_free(next);
    b008:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b00a:	0018      	movs	r0, r3
    b00c:	4bc7      	ldr	r3, [pc, #796]	; (b32c <tcp_receive+0x6b0>)
    b00e:	4798      	blx	r3
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    b010:	687b      	ldr	r3, [r7, #4]
    b012:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    b014:	2b00      	cmp	r3, #0
    b016:	d02d      	beq.n	b074 <tcp_receive+0x3f8>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
    b018:	687b      	ldr	r3, [r7, #4]
    b01a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    b01c:	68db      	ldr	r3, [r3, #12]
    b01e:	791a      	ldrb	r2, [r3, #4]
    b020:	7959      	ldrb	r1, [r3, #5]
    b022:	0209      	lsls	r1, r1, #8
    b024:	430a      	orrs	r2, r1
    b026:	7999      	ldrb	r1, [r3, #6]
    b028:	0409      	lsls	r1, r1, #16
    b02a:	430a      	orrs	r2, r1
    b02c:	79db      	ldrb	r3, [r3, #7]
    b02e:	061b      	lsls	r3, r3, #24
    b030:	4313      	orrs	r3, r2
    b032:	0018      	movs	r0, r3
    b034:	4bbe      	ldr	r3, [pc, #760]	; (b330 <tcp_receive+0x6b4>)
    b036:	4798      	blx	r3
    b038:	0004      	movs	r4, r0
    b03a:	687b      	ldr	r3, [r7, #4]
    b03c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    b03e:	891b      	ldrh	r3, [r3, #8]
    b040:	001d      	movs	r5, r3
    b042:	687b      	ldr	r3, [r7, #4]
    b044:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    b046:	68db      	ldr	r3, [r3, #12]
    b048:	7b1a      	ldrb	r2, [r3, #12]
    b04a:	7b5b      	ldrb	r3, [r3, #13]
    b04c:	021b      	lsls	r3, r3, #8
    b04e:	4313      	orrs	r3, r2
    b050:	b29b      	uxth	r3, r3
    b052:	0018      	movs	r0, r3
    b054:	4bb3      	ldr	r3, [pc, #716]	; (b324 <tcp_receive+0x6a8>)
    b056:	4798      	blx	r3
    b058:	0003      	movs	r3, r0
    b05a:	001a      	movs	r2, r3
    b05c:	2303      	movs	r3, #3
    b05e:	4013      	ands	r3, r2
    b060:	1e5a      	subs	r2, r3, #1
    b062:	4193      	sbcs	r3, r2
    b064:	b2db      	uxtb	r3, r3
    b066:	18eb      	adds	r3, r5, r3
    b068:	18e2      	adds	r2, r4, r3
    b06a:	4bb2      	ldr	r3, [pc, #712]	; (b334 <tcp_receive+0x6b8>)
    b06c:	681b      	ldr	r3, [r3, #0]
    b06e:	1ad3      	subs	r3, r2, r3
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    b070:	2b00      	cmp	r3, #0
    b072:	dd95      	ble.n	afa0 <tcp_receive+0x324>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    b074:	687b      	ldr	r3, [r7, #4]
    b076:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    b078:	2b00      	cmp	r3, #0
    b07a:	d104      	bne.n	b086 <tcp_receive+0x40a>
        pcb->rtime = -1;
    b07c:	687b      	ldr	r3, [r7, #4]
    b07e:	2201      	movs	r2, #1
    b080:	4252      	negs	r2, r2
    b082:	869a      	strh	r2, [r3, #52]	; 0x34
    b084:	e002      	b.n	b08c <tcp_receive+0x410>
      else
        pcb->rtime = 0;
    b086:	687b      	ldr	r3, [r7, #4]
    b088:	2200      	movs	r2, #0
    b08a:	869a      	strh	r2, [r3, #52]	; 0x34

      pcb->polltmr = 0;
    b08c:	687b      	ldr	r3, [r7, #4]
    b08e:	2200      	movs	r2, #0
    b090:	77da      	strb	r2, [r3, #31]
    b092:	e003      	b.n	b09c <tcp_receive+0x420>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
    b094:	687b      	ldr	r3, [r7, #4]
    b096:	2264      	movs	r2, #100	; 0x64
    b098:	2100      	movs	r1, #0
    b09a:	5299      	strh	r1, [r3, r2]
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    b09c:	e03f      	b.n	b11e <tcp_receive+0x4a2>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
    b09e:	687b      	ldr	r3, [r7, #4]
    b0a0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    b0a2:	62fb      	str	r3, [r7, #44]	; 0x2c
      pcb->unsent = pcb->unsent->next;
    b0a4:	687b      	ldr	r3, [r7, #4]
    b0a6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    b0a8:	681a      	ldr	r2, [r3, #0]
    b0aa:	687b      	ldr	r3, [r7, #4]
    b0ac:	66da      	str	r2, [r3, #108]	; 0x6c
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
    b0ae:	687b      	ldr	r3, [r7, #4]
    b0b0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    b0b2:	2b00      	cmp	r3, #0
    b0b4:	d103      	bne.n	b0be <tcp_receive+0x442>
        pcb->unsent_oversize = 0;
    b0b6:	687b      	ldr	r3, [r7, #4]
    b0b8:	226a      	movs	r2, #106	; 0x6a
    b0ba:	2100      	movs	r1, #0
    b0bc:	5299      	strh	r1, [r3, r2]
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    b0be:	687b      	ldr	r3, [r7, #4]
    b0c0:	2264      	movs	r2, #100	; 0x64
    b0c2:	5a9b      	ldrh	r3, [r3, r2]
    b0c4:	2b00      	cmp	r3, #0
    b0c6:	d016      	beq.n	b0f6 <tcp_receive+0x47a>
    b0c8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b0ca:	68db      	ldr	r3, [r3, #12]
    b0cc:	7b1a      	ldrb	r2, [r3, #12]
    b0ce:	7b5b      	ldrb	r3, [r3, #13]
    b0d0:	021b      	lsls	r3, r3, #8
    b0d2:	4313      	orrs	r3, r2
    b0d4:	b29b      	uxth	r3, r3
    b0d6:	0018      	movs	r0, r3
    b0d8:	4b92      	ldr	r3, [pc, #584]	; (b324 <tcp_receive+0x6a8>)
    b0da:	4798      	blx	r3
    b0dc:	0003      	movs	r3, r0
    b0de:	001a      	movs	r2, r3
    b0e0:	2301      	movs	r3, #1
    b0e2:	4013      	ands	r3, r2
    b0e4:	d007      	beq.n	b0f6 <tcp_receive+0x47a>
        pcb->acked--;
    b0e6:	687b      	ldr	r3, [r7, #4]
    b0e8:	2264      	movs	r2, #100	; 0x64
    b0ea:	5a9b      	ldrh	r3, [r3, r2]
    b0ec:	3b01      	subs	r3, #1
    b0ee:	b299      	uxth	r1, r3
    b0f0:	687b      	ldr	r3, [r7, #4]
    b0f2:	2264      	movs	r2, #100	; 0x64
    b0f4:	5299      	strh	r1, [r3, r2]
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
    b0f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b0f8:	685b      	ldr	r3, [r3, #4]
    b0fa:	0018      	movs	r0, r3
    b0fc:	4b8a      	ldr	r3, [pc, #552]	; (b328 <tcp_receive+0x6ac>)
    b0fe:	4798      	blx	r3
    b100:	0003      	movs	r3, r0
    b102:	0019      	movs	r1, r3
    b104:	687b      	ldr	r3, [r7, #4]
    b106:	2268      	movs	r2, #104	; 0x68
    b108:	5a9a      	ldrh	r2, [r3, r2]
    b10a:	b28b      	uxth	r3, r1
    b10c:	1ad3      	subs	r3, r2, r3
    b10e:	b299      	uxth	r1, r3
    b110:	687b      	ldr	r3, [r7, #4]
    b112:	2268      	movs	r2, #104	; 0x68
    b114:	5299      	strh	r1, [r3, r2]
      tcp_seg_free(next);
    b116:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b118:	0018      	movs	r0, r3
    b11a:	4b84      	ldr	r3, [pc, #528]	; (b32c <tcp_receive+0x6b0>)
    b11c:	4798      	blx	r3
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    b11e:	687b      	ldr	r3, [r7, #4]
    b120:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    b122:	2b00      	cmp	r3, #0
    b124:	d033      	beq.n	b18e <tcp_receive+0x512>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    b126:	4b83      	ldr	r3, [pc, #524]	; (b334 <tcp_receive+0x6b8>)
    b128:	681c      	ldr	r4, [r3, #0]
    b12a:	687b      	ldr	r3, [r7, #4]
    b12c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    b12e:	68db      	ldr	r3, [r3, #12]
    b130:	791a      	ldrb	r2, [r3, #4]
    b132:	7959      	ldrb	r1, [r3, #5]
    b134:	0209      	lsls	r1, r1, #8
    b136:	430a      	orrs	r2, r1
    b138:	7999      	ldrb	r1, [r3, #6]
    b13a:	0409      	lsls	r1, r1, #16
    b13c:	430a      	orrs	r2, r1
    b13e:	79db      	ldrb	r3, [r3, #7]
    b140:	061b      	lsls	r3, r3, #24
    b142:	4313      	orrs	r3, r2
    b144:	0018      	movs	r0, r3
    b146:	4b7a      	ldr	r3, [pc, #488]	; (b330 <tcp_receive+0x6b4>)
    b148:	4798      	blx	r3
    b14a:	0005      	movs	r5, r0
    b14c:	687b      	ldr	r3, [r7, #4]
    b14e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    b150:	891b      	ldrh	r3, [r3, #8]
    b152:	001e      	movs	r6, r3
    b154:	687b      	ldr	r3, [r7, #4]
    b156:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    b158:	68db      	ldr	r3, [r3, #12]
    b15a:	7b1a      	ldrb	r2, [r3, #12]
    b15c:	7b5b      	ldrb	r3, [r3, #13]
    b15e:	021b      	lsls	r3, r3, #8
    b160:	4313      	orrs	r3, r2
    b162:	b29b      	uxth	r3, r3
    b164:	0018      	movs	r0, r3
    b166:	4b6f      	ldr	r3, [pc, #444]	; (b324 <tcp_receive+0x6a8>)
    b168:	4798      	blx	r3
    b16a:	0003      	movs	r3, r0
    b16c:	001a      	movs	r2, r3
    b16e:	2303      	movs	r3, #3
    b170:	4013      	ands	r3, r2
    b172:	1e5a      	subs	r2, r3, #1
    b174:	4193      	sbcs	r3, r2
    b176:	b2db      	uxtb	r3, r3
    b178:	18f3      	adds	r3, r6, r3
    b17a:	18eb      	adds	r3, r5, r3
    b17c:	1ae3      	subs	r3, r4, r3
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    b17e:	d406      	bmi.n	b18e <tcp_receive+0x512>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    b180:	4b6c      	ldr	r3, [pc, #432]	; (b334 <tcp_receive+0x6b8>)
    b182:	681a      	ldr	r2, [r3, #0]
    b184:	687b      	ldr	r3, [r7, #4]
    b186:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    b188:	1ad3      	subs	r3, r2, r3
    b18a:	2b00      	cmp	r3, #0
    b18c:	dd87      	ble.n	b09e <tcp_receive+0x422>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    b18e:	687b      	ldr	r3, [r7, #4]
    b190:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    b192:	2b00      	cmp	r3, #0
    b194:	d067      	beq.n	b266 <tcp_receive+0x5ea>
    b196:	687b      	ldr	r3, [r7, #4]
    b198:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    b19a:	4b66      	ldr	r3, [pc, #408]	; (b334 <tcp_receive+0x6b8>)
    b19c:	681b      	ldr	r3, [r3, #0]
    b19e:	1ad3      	subs	r3, r2, r3
    b1a0:	d561      	bpl.n	b266 <tcp_receive+0x5ea>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
    b1a2:	4b65      	ldr	r3, [pc, #404]	; (b338 <tcp_receive+0x6bc>)
    b1a4:	681b      	ldr	r3, [r3, #0]
    b1a6:	b29a      	uxth	r2, r3
    b1a8:	687b      	ldr	r3, [r7, #4]
    b1aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    b1ac:	b29b      	uxth	r3, r3
    b1ae:	1ad3      	subs	r3, r2, r3
    b1b0:	b29a      	uxth	r2, r3
    b1b2:	231e      	movs	r3, #30
    b1b4:	18fb      	adds	r3, r7, r3
    b1b6:	801a      	strh	r2, [r3, #0]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
    b1b8:	231e      	movs	r3, #30
    b1ba:	18fb      	adds	r3, r7, r3
    b1bc:	881a      	ldrh	r2, [r3, #0]
    b1be:	687b      	ldr	r3, [r7, #4]
    b1c0:	2140      	movs	r1, #64	; 0x40
    b1c2:	5e5b      	ldrsh	r3, [r3, r1]
    b1c4:	10db      	asrs	r3, r3, #3
    b1c6:	b21b      	sxth	r3, r3
    b1c8:	b29b      	uxth	r3, r3
    b1ca:	1ad3      	subs	r3, r2, r3
    b1cc:	b29a      	uxth	r2, r3
    b1ce:	231e      	movs	r3, #30
    b1d0:	18fb      	adds	r3, r7, r3
    b1d2:	801a      	strh	r2, [r3, #0]
      pcb->sa += m;
    b1d4:	687b      	ldr	r3, [r7, #4]
    b1d6:	2240      	movs	r2, #64	; 0x40
    b1d8:	5e9b      	ldrsh	r3, [r3, r2]
    b1da:	b29a      	uxth	r2, r3
    b1dc:	231e      	movs	r3, #30
    b1de:	18fb      	adds	r3, r7, r3
    b1e0:	881b      	ldrh	r3, [r3, #0]
    b1e2:	18d3      	adds	r3, r2, r3
    b1e4:	b29b      	uxth	r3, r3
    b1e6:	b219      	sxth	r1, r3
    b1e8:	687b      	ldr	r3, [r7, #4]
    b1ea:	2240      	movs	r2, #64	; 0x40
    b1ec:	5299      	strh	r1, [r3, r2]
      if (m < 0) {
    b1ee:	231e      	movs	r3, #30
    b1f0:	18fb      	adds	r3, r7, r3
    b1f2:	2200      	movs	r2, #0
    b1f4:	5e9b      	ldrsh	r3, [r3, r2]
    b1f6:	2b00      	cmp	r3, #0
    b1f8:	da07      	bge.n	b20a <tcp_receive+0x58e>
        m = -m;
    b1fa:	231e      	movs	r3, #30
    b1fc:	18fb      	adds	r3, r7, r3
    b1fe:	881b      	ldrh	r3, [r3, #0]
    b200:	425b      	negs	r3, r3
    b202:	b29a      	uxth	r2, r3
    b204:	231e      	movs	r3, #30
    b206:	18fb      	adds	r3, r7, r3
    b208:	801a      	strh	r2, [r3, #0]
      }
      m = m - (pcb->sv >> 2);
    b20a:	231e      	movs	r3, #30
    b20c:	18fb      	adds	r3, r7, r3
    b20e:	881a      	ldrh	r2, [r3, #0]
    b210:	687b      	ldr	r3, [r7, #4]
    b212:	2142      	movs	r1, #66	; 0x42
    b214:	5e5b      	ldrsh	r3, [r3, r1]
    b216:	109b      	asrs	r3, r3, #2
    b218:	b21b      	sxth	r3, r3
    b21a:	b29b      	uxth	r3, r3
    b21c:	1ad3      	subs	r3, r2, r3
    b21e:	b29a      	uxth	r2, r3
    b220:	231e      	movs	r3, #30
    b222:	18fb      	adds	r3, r7, r3
    b224:	801a      	strh	r2, [r3, #0]
      pcb->sv += m;
    b226:	687b      	ldr	r3, [r7, #4]
    b228:	2242      	movs	r2, #66	; 0x42
    b22a:	5e9b      	ldrsh	r3, [r3, r2]
    b22c:	b29a      	uxth	r2, r3
    b22e:	231e      	movs	r3, #30
    b230:	18fb      	adds	r3, r7, r3
    b232:	881b      	ldrh	r3, [r3, #0]
    b234:	18d3      	adds	r3, r2, r3
    b236:	b29b      	uxth	r3, r3
    b238:	b219      	sxth	r1, r3
    b23a:	687b      	ldr	r3, [r7, #4]
    b23c:	2242      	movs	r2, #66	; 0x42
    b23e:	5299      	strh	r1, [r3, r2]
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    b240:	687b      	ldr	r3, [r7, #4]
    b242:	2240      	movs	r2, #64	; 0x40
    b244:	5e9b      	ldrsh	r3, [r3, r2]
    b246:	10db      	asrs	r3, r3, #3
    b248:	b21b      	sxth	r3, r3
    b24a:	b29a      	uxth	r2, r3
    b24c:	687b      	ldr	r3, [r7, #4]
    b24e:	2142      	movs	r1, #66	; 0x42
    b250:	5e5b      	ldrsh	r3, [r3, r1]
    b252:	b29b      	uxth	r3, r3
    b254:	18d3      	adds	r3, r2, r3
    b256:	b29b      	uxth	r3, r3
    b258:	b219      	sxth	r1, r3
    b25a:	687b      	ldr	r3, [r7, #4]
    b25c:	2244      	movs	r2, #68	; 0x44
    b25e:	5299      	strh	r1, [r3, r2]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
    b260:	687b      	ldr	r3, [r7, #4]
    b262:	2200      	movs	r2, #0
    b264:	639a      	str	r2, [r3, #56]	; 0x38

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    b266:	4b35      	ldr	r3, [pc, #212]	; (b33c <tcp_receive+0x6c0>)
    b268:	881b      	ldrh	r3, [r3, #0]
    b26a:	2b00      	cmp	r3, #0
    b26c:	d101      	bne.n	b272 <tcp_receive+0x5f6>
    b26e:	f000 fda3 	bl	bdb8 <tcp_receive+0x113c>
    b272:	687b      	ldr	r3, [r7, #4]
    b274:	7e1b      	ldrb	r3, [r3, #24]
    b276:	2b06      	cmp	r3, #6
    b278:	d901      	bls.n	b27e <tcp_receive+0x602>
    b27a:	f000 fd9d 	bl	bdb8 <tcp_receive+0x113c>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
    b27e:	687b      	ldr	r3, [r7, #4]
    b280:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    b282:	4b2f      	ldr	r3, [pc, #188]	; (b340 <tcp_receive+0x6c4>)
    b284:	681b      	ldr	r3, [r3, #0]
    b286:	1ad3      	subs	r3, r2, r3
    b288:	3b01      	subs	r3, #1
    b28a:	2b00      	cmp	r3, #0
    b28c:	da00      	bge.n	b290 <tcp_receive+0x614>
    b28e:	e0a7      	b.n	b3e0 <tcp_receive+0x764>
    b290:	687b      	ldr	r3, [r7, #4]
    b292:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    b294:	4b29      	ldr	r3, [pc, #164]	; (b33c <tcp_receive+0x6c0>)
    b296:	881b      	ldrh	r3, [r3, #0]
    b298:	0019      	movs	r1, r3
    b29a:	4b29      	ldr	r3, [pc, #164]	; (b340 <tcp_receive+0x6c4>)
    b29c:	681b      	ldr	r3, [r3, #0]
    b29e:	18cb      	adds	r3, r1, r3
    b2a0:	1ad3      	subs	r3, r2, r3
    b2a2:	3301      	adds	r3, #1
    b2a4:	2b00      	cmp	r3, #0
    b2a6:	dd00      	ble.n	b2aa <tcp_receive+0x62e>
    b2a8:	e09a      	b.n	b3e0 <tcp_receive+0x764>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
    b2aa:	687b      	ldr	r3, [r7, #4]
    b2ac:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    b2ae:	4b24      	ldr	r3, [pc, #144]	; (b340 <tcp_receive+0x6c4>)
    b2b0:	681b      	ldr	r3, [r3, #0]
    b2b2:	1ad3      	subs	r3, r2, r3
    b2b4:	623b      	str	r3, [r7, #32]
      p = inseg.p;
    b2b6:	4b23      	ldr	r3, [pc, #140]	; (b344 <tcp_receive+0x6c8>)
    b2b8:	685b      	ldr	r3, [r3, #4]
    b2ba:	627b      	str	r3, [r7, #36]	; 0x24
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
    b2bc:	4b21      	ldr	r3, [pc, #132]	; (b344 <tcp_receive+0x6c8>)
    b2be:	685b      	ldr	r3, [r3, #4]
    b2c0:	895b      	ldrh	r3, [r3, #10]
    b2c2:	1e1a      	subs	r2, r3, #0
    b2c4:	6a3b      	ldr	r3, [r7, #32]
    b2c6:	429a      	cmp	r2, r3
    b2c8:	da40      	bge.n	b34c <tcp_receive+0x6d0>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
    b2ca:	4b1e      	ldr	r3, [pc, #120]	; (b344 <tcp_receive+0x6c8>)
    b2cc:	685b      	ldr	r3, [r3, #4]
    b2ce:	8919      	ldrh	r1, [r3, #8]
    b2d0:	6a3b      	ldr	r3, [r7, #32]
    b2d2:	b29a      	uxth	r2, r3
    b2d4:	2310      	movs	r3, #16
    b2d6:	18fb      	adds	r3, r7, r3
    b2d8:	1a8a      	subs	r2, r1, r2
    b2da:	801a      	strh	r2, [r3, #0]
        while (p->len < off) {
    b2dc:	e010      	b.n	b300 <tcp_receive+0x684>
          off -= p->len;
    b2de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    b2e0:	895b      	ldrh	r3, [r3, #10]
    b2e2:	001a      	movs	r2, r3
    b2e4:	6a3b      	ldr	r3, [r7, #32]
    b2e6:	1a9b      	subs	r3, r3, r2
    b2e8:	623b      	str	r3, [r7, #32]
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
    b2ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    b2ec:	2210      	movs	r2, #16
    b2ee:	18ba      	adds	r2, r7, r2
    b2f0:	8812      	ldrh	r2, [r2, #0]
    b2f2:	811a      	strh	r2, [r3, #8]
          p->len = 0;
    b2f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    b2f6:	2200      	movs	r2, #0
    b2f8:	815a      	strh	r2, [r3, #10]
          p = p->next;
    b2fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    b2fc:	681b      	ldr	r3, [r3, #0]
    b2fe:	627b      	str	r3, [r7, #36]	; 0x24
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
    b300:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    b302:	895b      	ldrh	r3, [r3, #10]
    b304:	1e1a      	subs	r2, r3, #0
    b306:	6a3b      	ldr	r3, [r7, #32]
    b308:	429a      	cmp	r2, r3
    b30a:	dbe8      	blt.n	b2de <tcp_receive+0x662>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
    b30c:	6a3b      	ldr	r3, [r7, #32]
    b30e:	b29b      	uxth	r3, r3
    b310:	425b      	negs	r3, r3
    b312:	b29b      	uxth	r3, r3
    b314:	b21a      	sxth	r2, r3
    b316:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    b318:	0011      	movs	r1, r2
    b31a:	0018      	movs	r0, r3
    b31c:	4b0a      	ldr	r3, [pc, #40]	; (b348 <tcp_receive+0x6cc>)
    b31e:	4798      	blx	r3
    b320:	e01f      	b.n	b362 <tcp_receive+0x6e6>
    b322:	46c0      	nop			; (mov r8, r8)
    b324:	0000561d 	.word	0x0000561d
    b328:	00008431 	.word	0x00008431
    b32c:	000093ad 	.word	0x000093ad
    b330:	00005675 	.word	0x00005675
    b334:	20002c8c 	.word	0x20002c8c
    b338:	20003ec8 	.word	0x20003ec8
    b33c:	20002c92 	.word	0x20002c92
    b340:	20002c88 	.word	0x20002c88
    b344:	20002c70 	.word	0x20002c70
    b348:	00008235 	.word	0x00008235
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
    b34c:	4b9d      	ldr	r3, [pc, #628]	; (b5c4 <tcp_receive+0x948>)
    b34e:	685b      	ldr	r3, [r3, #4]
    b350:	6a3a      	ldr	r2, [r7, #32]
    b352:	b292      	uxth	r2, r2
    b354:	4252      	negs	r2, r2
    b356:	b292      	uxth	r2, r2
    b358:	b212      	sxth	r2, r2
    b35a:	0011      	movs	r1, r2
    b35c:	0018      	movs	r0, r3
    b35e:	4b9a      	ldr	r3, [pc, #616]	; (b5c8 <tcp_receive+0x94c>)
    b360:	4798      	blx	r3
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    b362:	4b98      	ldr	r3, [pc, #608]	; (b5c4 <tcp_receive+0x948>)
    b364:	891a      	ldrh	r2, [r3, #8]
    b366:	4b99      	ldr	r3, [pc, #612]	; (b5cc <tcp_receive+0x950>)
    b368:	681b      	ldr	r3, [r3, #0]
    b36a:	b299      	uxth	r1, r3
    b36c:	687b      	ldr	r3, [r7, #4]
    b36e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    b370:	b29b      	uxth	r3, r3
    b372:	1acb      	subs	r3, r1, r3
    b374:	b29b      	uxth	r3, r3
    b376:	18d3      	adds	r3, r2, r3
    b378:	b29a      	uxth	r2, r3
    b37a:	4b92      	ldr	r3, [pc, #584]	; (b5c4 <tcp_receive+0x948>)
    b37c:	811a      	strh	r2, [r3, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    b37e:	4b91      	ldr	r3, [pc, #580]	; (b5c4 <tcp_receive+0x948>)
    b380:	68db      	ldr	r3, [r3, #12]
    b382:	687a      	ldr	r2, [r7, #4]
    b384:	6a91      	ldr	r1, [r2, #40]	; 0x28
    b386:	4a91      	ldr	r2, [pc, #580]	; (b5cc <tcp_receive+0x950>)
    b388:	6011      	str	r1, [r2, #0]
    b38a:	4a90      	ldr	r2, [pc, #576]	; (b5cc <tcp_receive+0x950>)
    b38c:	6812      	ldr	r2, [r2, #0]
    b38e:	21ff      	movs	r1, #255	; 0xff
    b390:	4011      	ands	r1, r2
    b392:	000c      	movs	r4, r1
    b394:	7919      	ldrb	r1, [r3, #4]
    b396:	2000      	movs	r0, #0
    b398:	4001      	ands	r1, r0
    b39a:	1c08      	adds	r0, r1, #0
    b39c:	1c21      	adds	r1, r4, #0
    b39e:	4301      	orrs	r1, r0
    b3a0:	7119      	strb	r1, [r3, #4]
    b3a2:	0a11      	lsrs	r1, r2, #8
    b3a4:	20ff      	movs	r0, #255	; 0xff
    b3a6:	4001      	ands	r1, r0
    b3a8:	000c      	movs	r4, r1
    b3aa:	7959      	ldrb	r1, [r3, #5]
    b3ac:	2000      	movs	r0, #0
    b3ae:	4001      	ands	r1, r0
    b3b0:	1c08      	adds	r0, r1, #0
    b3b2:	1c21      	adds	r1, r4, #0
    b3b4:	4301      	orrs	r1, r0
    b3b6:	7159      	strb	r1, [r3, #5]
    b3b8:	0c11      	lsrs	r1, r2, #16
    b3ba:	20ff      	movs	r0, #255	; 0xff
    b3bc:	4001      	ands	r1, r0
    b3be:	000c      	movs	r4, r1
    b3c0:	7999      	ldrb	r1, [r3, #6]
    b3c2:	2000      	movs	r0, #0
    b3c4:	4001      	ands	r1, r0
    b3c6:	1c08      	adds	r0, r1, #0
    b3c8:	1c21      	adds	r1, r4, #0
    b3ca:	4301      	orrs	r1, r0
    b3cc:	7199      	strb	r1, [r3, #6]
    b3ce:	0e10      	lsrs	r0, r2, #24
    b3d0:	79da      	ldrb	r2, [r3, #7]
    b3d2:	2100      	movs	r1, #0
    b3d4:	400a      	ands	r2, r1
    b3d6:	1c11      	adds	r1, r2, #0
    b3d8:	1c02      	adds	r2, r0, #0
    b3da:	430a      	orrs	r2, r1
    b3dc:	71da      	strb	r2, [r3, #7]
    b3de:	e00c      	b.n	b3fa <tcp_receive+0x77e>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
    b3e0:	4b7a      	ldr	r3, [pc, #488]	; (b5cc <tcp_receive+0x950>)
    b3e2:	681a      	ldr	r2, [r3, #0]
    b3e4:	687b      	ldr	r3, [r7, #4]
    b3e6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    b3e8:	1ad3      	subs	r3, r2, r3
    b3ea:	d506      	bpl.n	b3fa <tcp_receive+0x77e>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
    b3ec:	687b      	ldr	r3, [r7, #4]
    b3ee:	7f9b      	ldrb	r3, [r3, #30]
    b3f0:	2202      	movs	r2, #2
    b3f2:	4313      	orrs	r3, r2
    b3f4:	b2da      	uxtb	r2, r3
    b3f6:	687b      	ldr	r3, [r7, #4]
    b3f8:	779a      	strb	r2, [r3, #30]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    b3fa:	4b74      	ldr	r3, [pc, #464]	; (b5cc <tcp_receive+0x950>)
    b3fc:	681a      	ldr	r2, [r3, #0]
    b3fe:	687b      	ldr	r3, [r7, #4]
    b400:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    b402:	1ad3      	subs	r3, r2, r3
    b404:	d501      	bpl.n	b40a <tcp_receive+0x78e>
    b406:	f000 fcd1 	bl	bdac <tcp_receive+0x1130>
    b40a:	4b70      	ldr	r3, [pc, #448]	; (b5cc <tcp_receive+0x950>)
    b40c:	681a      	ldr	r2, [r3, #0]
    b40e:	687b      	ldr	r3, [r7, #4]
    b410:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    b412:	6879      	ldr	r1, [r7, #4]
    b414:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
    b416:	185b      	adds	r3, r3, r1
    b418:	1ad3      	subs	r3, r2, r3
    b41a:	3301      	adds	r3, #1
    b41c:	2b00      	cmp	r3, #0
    b41e:	dd01      	ble.n	b424 <tcp_receive+0x7a8>
    b420:	f000 fcc4 	bl	bdac <tcp_receive+0x1130>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    b424:	687b      	ldr	r3, [r7, #4]
    b426:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    b428:	4b68      	ldr	r3, [pc, #416]	; (b5cc <tcp_receive+0x950>)
    b42a:	681b      	ldr	r3, [r3, #0]
    b42c:	429a      	cmp	r2, r3
    b42e:	d000      	beq.n	b432 <tcp_receive+0x7b6>
    b430:	e2c8      	b.n	b9c4 <tcp_receive+0xd48>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
    b432:	4b64      	ldr	r3, [pc, #400]	; (b5c4 <tcp_receive+0x948>)
    b434:	891c      	ldrh	r4, [r3, #8]
    b436:	4b63      	ldr	r3, [pc, #396]	; (b5c4 <tcp_receive+0x948>)
    b438:	68db      	ldr	r3, [r3, #12]
    b43a:	7b1a      	ldrb	r2, [r3, #12]
    b43c:	7b5b      	ldrb	r3, [r3, #13]
    b43e:	021b      	lsls	r3, r3, #8
    b440:	4313      	orrs	r3, r2
    b442:	b29b      	uxth	r3, r3
    b444:	0018      	movs	r0, r3
    b446:	4b62      	ldr	r3, [pc, #392]	; (b5d0 <tcp_receive+0x954>)
    b448:	4798      	blx	r3
    b44a:	0003      	movs	r3, r0
    b44c:	001a      	movs	r2, r3
    b44e:	2303      	movs	r3, #3
    b450:	4013      	ands	r3, r2
    b452:	1e5a      	subs	r2, r3, #1
    b454:	4193      	sbcs	r3, r2
    b456:	b2db      	uxtb	r3, r3
    b458:	b29b      	uxth	r3, r3
    b45a:	18e3      	adds	r3, r4, r3
    b45c:	b29a      	uxth	r2, r3
    b45e:	4b5d      	ldr	r3, [pc, #372]	; (b5d4 <tcp_receive+0x958>)
    b460:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
    b462:	687b      	ldr	r3, [r7, #4]
    b464:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    b466:	4b5b      	ldr	r3, [pc, #364]	; (b5d4 <tcp_receive+0x958>)
    b468:	881b      	ldrh	r3, [r3, #0]
    b46a:	429a      	cmp	r2, r3
    b46c:	d300      	bcc.n	b470 <tcp_receive+0x7f4>
    b46e:	e07e      	b.n	b56e <tcp_receive+0x8f2>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    b470:	4b54      	ldr	r3, [pc, #336]	; (b5c4 <tcp_receive+0x948>)
    b472:	68db      	ldr	r3, [r3, #12]
    b474:	7b1a      	ldrb	r2, [r3, #12]
    b476:	7b5b      	ldrb	r3, [r3, #13]
    b478:	021b      	lsls	r3, r3, #8
    b47a:	4313      	orrs	r3, r2
    b47c:	b29b      	uxth	r3, r3
    b47e:	0018      	movs	r0, r3
    b480:	4b53      	ldr	r3, [pc, #332]	; (b5d0 <tcp_receive+0x954>)
    b482:	4798      	blx	r3
    b484:	0003      	movs	r3, r0
    b486:	001a      	movs	r2, r3
    b488:	2301      	movs	r3, #1
    b48a:	4013      	ands	r3, r2
    b48c:	d036      	beq.n	b4fc <tcp_receive+0x880>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
    b48e:	4b4d      	ldr	r3, [pc, #308]	; (b5c4 <tcp_receive+0x948>)
    b490:	68dc      	ldr	r4, [r3, #12]
    b492:	4b4c      	ldr	r3, [pc, #304]	; (b5c4 <tcp_receive+0x948>)
    b494:	68db      	ldr	r3, [r3, #12]
    b496:	7b1a      	ldrb	r2, [r3, #12]
    b498:	7b5b      	ldrb	r3, [r3, #13]
    b49a:	021b      	lsls	r3, r3, #8
    b49c:	4313      	orrs	r3, r2
    b49e:	b29b      	uxth	r3, r3
    b4a0:	b21b      	sxth	r3, r3
    b4a2:	4a4d      	ldr	r2, [pc, #308]	; (b5d8 <tcp_receive+0x95c>)
    b4a4:	4013      	ands	r3, r2
    b4a6:	b21d      	sxth	r5, r3
    b4a8:	4b46      	ldr	r3, [pc, #280]	; (b5c4 <tcp_receive+0x948>)
    b4aa:	68db      	ldr	r3, [r3, #12]
    b4ac:	7b1a      	ldrb	r2, [r3, #12]
    b4ae:	7b5b      	ldrb	r3, [r3, #13]
    b4b0:	021b      	lsls	r3, r3, #8
    b4b2:	4313      	orrs	r3, r2
    b4b4:	b29b      	uxth	r3, r3
    b4b6:	0018      	movs	r0, r3
    b4b8:	4b45      	ldr	r3, [pc, #276]	; (b5d0 <tcp_receive+0x954>)
    b4ba:	4798      	blx	r3
    b4bc:	0003      	movs	r3, r0
    b4be:	001a      	movs	r2, r3
    b4c0:	233e      	movs	r3, #62	; 0x3e
    b4c2:	4013      	ands	r3, r2
    b4c4:	b29b      	uxth	r3, r3
    b4c6:	0018      	movs	r0, r3
    b4c8:	4b44      	ldr	r3, [pc, #272]	; (b5dc <tcp_receive+0x960>)
    b4ca:	4798      	blx	r3
    b4cc:	0003      	movs	r3, r0
    b4ce:	b21b      	sxth	r3, r3
    b4d0:	432b      	orrs	r3, r5
    b4d2:	b21b      	sxth	r3, r3
    b4d4:	b29b      	uxth	r3, r3
    b4d6:	22ff      	movs	r2, #255	; 0xff
    b4d8:	401a      	ands	r2, r3
    b4da:	0010      	movs	r0, r2
    b4dc:	7b22      	ldrb	r2, [r4, #12]
    b4de:	2100      	movs	r1, #0
    b4e0:	400a      	ands	r2, r1
    b4e2:	1c11      	adds	r1, r2, #0
    b4e4:	1c02      	adds	r2, r0, #0
    b4e6:	430a      	orrs	r2, r1
    b4e8:	7322      	strb	r2, [r4, #12]
    b4ea:	0a1b      	lsrs	r3, r3, #8
    b4ec:	b299      	uxth	r1, r3
    b4ee:	7b63      	ldrb	r3, [r4, #13]
    b4f0:	2200      	movs	r2, #0
    b4f2:	4013      	ands	r3, r2
    b4f4:	1c1a      	adds	r2, r3, #0
    b4f6:	1c0b      	adds	r3, r1, #0
    b4f8:	4313      	orrs	r3, r2
    b4fa:	7363      	strb	r3, [r4, #13]
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
    b4fc:	687b      	ldr	r3, [r7, #4]
    b4fe:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    b500:	4b30      	ldr	r3, [pc, #192]	; (b5c4 <tcp_receive+0x948>)
    b502:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    b504:	4b2f      	ldr	r3, [pc, #188]	; (b5c4 <tcp_receive+0x948>)
    b506:	68db      	ldr	r3, [r3, #12]
    b508:	7b1a      	ldrb	r2, [r3, #12]
    b50a:	7b5b      	ldrb	r3, [r3, #13]
    b50c:	021b      	lsls	r3, r3, #8
    b50e:	4313      	orrs	r3, r2
    b510:	b29b      	uxth	r3, r3
    b512:	0018      	movs	r0, r3
    b514:	4b2e      	ldr	r3, [pc, #184]	; (b5d0 <tcp_receive+0x954>)
    b516:	4798      	blx	r3
    b518:	0003      	movs	r3, r0
    b51a:	001a      	movs	r2, r3
    b51c:	2302      	movs	r3, #2
    b51e:	4013      	ands	r3, r2
    b520:	d005      	beq.n	b52e <tcp_receive+0x8b2>
            inseg.len -= 1;
    b522:	4b28      	ldr	r3, [pc, #160]	; (b5c4 <tcp_receive+0x948>)
    b524:	891b      	ldrh	r3, [r3, #8]
    b526:	3b01      	subs	r3, #1
    b528:	b29a      	uxth	r2, r3
    b52a:	4b26      	ldr	r3, [pc, #152]	; (b5c4 <tcp_receive+0x948>)
    b52c:	811a      	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
    b52e:	4b25      	ldr	r3, [pc, #148]	; (b5c4 <tcp_receive+0x948>)
    b530:	685a      	ldr	r2, [r3, #4]
    b532:	4b24      	ldr	r3, [pc, #144]	; (b5c4 <tcp_receive+0x948>)
    b534:	891b      	ldrh	r3, [r3, #8]
    b536:	0019      	movs	r1, r3
    b538:	0010      	movs	r0, r2
    b53a:	4b29      	ldr	r3, [pc, #164]	; (b5e0 <tcp_receive+0x964>)
    b53c:	4798      	blx	r3
          tcplen = TCP_TCPLEN(&inseg);
    b53e:	4b21      	ldr	r3, [pc, #132]	; (b5c4 <tcp_receive+0x948>)
    b540:	891c      	ldrh	r4, [r3, #8]
    b542:	4b20      	ldr	r3, [pc, #128]	; (b5c4 <tcp_receive+0x948>)
    b544:	68db      	ldr	r3, [r3, #12]
    b546:	7b1a      	ldrb	r2, [r3, #12]
    b548:	7b5b      	ldrb	r3, [r3, #13]
    b54a:	021b      	lsls	r3, r3, #8
    b54c:	4313      	orrs	r3, r2
    b54e:	b29b      	uxth	r3, r3
    b550:	0018      	movs	r0, r3
    b552:	4b1f      	ldr	r3, [pc, #124]	; (b5d0 <tcp_receive+0x954>)
    b554:	4798      	blx	r3
    b556:	0003      	movs	r3, r0
    b558:	001a      	movs	r2, r3
    b55a:	2303      	movs	r3, #3
    b55c:	4013      	ands	r3, r2
    b55e:	1e5a      	subs	r2, r3, #1
    b560:	4193      	sbcs	r3, r2
    b562:	b2db      	uxtb	r3, r3
    b564:	b29b      	uxth	r3, r3
    b566:	18e3      	adds	r3, r4, r3
    b568:	b29a      	uxth	r2, r3
    b56a:	4b1a      	ldr	r3, [pc, #104]	; (b5d4 <tcp_receive+0x958>)
    b56c:	801a      	strh	r2, [r3, #0]
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
    b56e:	687b      	ldr	r3, [r7, #4]
    b570:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b572:	2b00      	cmp	r3, #0
    b574:	d100      	bne.n	b578 <tcp_receive+0x8fc>
    b576:	e118      	b.n	b7aa <tcp_receive+0xb2e>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    b578:	4b12      	ldr	r3, [pc, #72]	; (b5c4 <tcp_receive+0x948>)
    b57a:	68db      	ldr	r3, [r3, #12]
    b57c:	7b1a      	ldrb	r2, [r3, #12]
    b57e:	7b5b      	ldrb	r3, [r3, #13]
    b580:	021b      	lsls	r3, r3, #8
    b582:	4313      	orrs	r3, r2
    b584:	b29b      	uxth	r3, r3
    b586:	0018      	movs	r0, r3
    b588:	4b11      	ldr	r3, [pc, #68]	; (b5d0 <tcp_receive+0x954>)
    b58a:	4798      	blx	r3
    b58c:	0003      	movs	r3, r0
    b58e:	001a      	movs	r2, r3
    b590:	2301      	movs	r3, #1
    b592:	4013      	ands	r3, r2
    b594:	d011      	beq.n	b5ba <tcp_receive+0x93e>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
    b596:	e00b      	b.n	b5b0 <tcp_receive+0x934>
              struct tcp_seg *old_ooseq = pcb->ooseq;
    b598:	687b      	ldr	r3, [r7, #4]
    b59a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b59c:	60fb      	str	r3, [r7, #12]
              pcb->ooseq = pcb->ooseq->next;
    b59e:	687b      	ldr	r3, [r7, #4]
    b5a0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b5a2:	681a      	ldr	r2, [r3, #0]
    b5a4:	687b      	ldr	r3, [r7, #4]
    b5a6:	675a      	str	r2, [r3, #116]	; 0x74
              tcp_seg_free(old_ooseq);
    b5a8:	68fb      	ldr	r3, [r7, #12]
    b5aa:	0018      	movs	r0, r3
    b5ac:	4b0d      	ldr	r3, [pc, #52]	; (b5e4 <tcp_receive+0x968>)
    b5ae:	4798      	blx	r3
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
    b5b0:	687b      	ldr	r3, [r7, #4]
    b5b2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b5b4:	2b00      	cmp	r3, #0
    b5b6:	d1ef      	bne.n	b598 <tcp_receive+0x91c>
    b5b8:	e0f7      	b.n	b7aa <tcp_receive+0xb2e>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
    b5ba:	687b      	ldr	r3, [r7, #4]
    b5bc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b5be:	62fb      	str	r3, [r7, #44]	; 0x2c
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    b5c0:	e073      	b.n	b6aa <tcp_receive+0xa2e>
    b5c2:	46c0      	nop			; (mov r8, r8)
    b5c4:	20002c70 	.word	0x20002c70
    b5c8:	00008235 	.word	0x00008235
    b5cc:	20002c88 	.word	0x20002c88
    b5d0:	0000561d 	.word	0x0000561d
    b5d4:	20002c92 	.word	0x20002c92
    b5d8:	ffffc0ff 	.word	0xffffc0ff
    b5dc:	000055f1 	.word	0x000055f1
    b5e0:	00008151 	.word	0x00008151
    b5e4:	000093ad 	.word	0x000093ad
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
    b5e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b5ea:	68db      	ldr	r3, [r3, #12]
    b5ec:	7b1a      	ldrb	r2, [r3, #12]
    b5ee:	7b5b      	ldrb	r3, [r3, #13]
    b5f0:	021b      	lsls	r3, r3, #8
    b5f2:	4313      	orrs	r3, r2
    b5f4:	b29b      	uxth	r3, r3
    b5f6:	0018      	movs	r0, r3
    b5f8:	4bb7      	ldr	r3, [pc, #732]	; (b8d8 <tcp_receive+0xc5c>)
    b5fa:	4798      	blx	r3
    b5fc:	0003      	movs	r3, r0
    b5fe:	001a      	movs	r2, r3
    b600:	2301      	movs	r3, #1
    b602:	4013      	ands	r3, r2
    b604:	d048      	beq.n	b698 <tcp_receive+0xa1c>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    b606:	4bb5      	ldr	r3, [pc, #724]	; (b8dc <tcp_receive+0xc60>)
    b608:	68db      	ldr	r3, [r3, #12]
    b60a:	7b1a      	ldrb	r2, [r3, #12]
    b60c:	7b5b      	ldrb	r3, [r3, #13]
    b60e:	021b      	lsls	r3, r3, #8
    b610:	4313      	orrs	r3, r2
    b612:	b29b      	uxth	r3, r3
    b614:	0018      	movs	r0, r3
    b616:	4bb0      	ldr	r3, [pc, #704]	; (b8d8 <tcp_receive+0xc5c>)
    b618:	4798      	blx	r3
    b61a:	0003      	movs	r3, r0
    b61c:	001a      	movs	r2, r3
    b61e:	2302      	movs	r3, #2
    b620:	4013      	ands	r3, r2
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
    b622:	d139      	bne.n	b698 <tcp_receive+0xa1c>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    b624:	4bad      	ldr	r3, [pc, #692]	; (b8dc <tcp_receive+0xc60>)
    b626:	68dc      	ldr	r4, [r3, #12]
    b628:	4bac      	ldr	r3, [pc, #688]	; (b8dc <tcp_receive+0xc60>)
    b62a:	68db      	ldr	r3, [r3, #12]
    b62c:	7b1a      	ldrb	r2, [r3, #12]
    b62e:	7b5b      	ldrb	r3, [r3, #13]
    b630:	021b      	lsls	r3, r3, #8
    b632:	4313      	orrs	r3, r2
    b634:	b29d      	uxth	r5, r3
    b636:	2001      	movs	r0, #1
    b638:	4ba9      	ldr	r3, [pc, #676]	; (b8e0 <tcp_receive+0xc64>)
    b63a:	4798      	blx	r3
    b63c:	0003      	movs	r3, r0
    b63e:	432b      	orrs	r3, r5
    b640:	b29b      	uxth	r3, r3
    b642:	22ff      	movs	r2, #255	; 0xff
    b644:	401a      	ands	r2, r3
    b646:	0010      	movs	r0, r2
    b648:	7b22      	ldrb	r2, [r4, #12]
    b64a:	2100      	movs	r1, #0
    b64c:	400a      	ands	r2, r1
    b64e:	1c11      	adds	r1, r2, #0
    b650:	1c02      	adds	r2, r0, #0
    b652:	430a      	orrs	r2, r1
    b654:	7322      	strb	r2, [r4, #12]
    b656:	0a1b      	lsrs	r3, r3, #8
    b658:	b299      	uxth	r1, r3
    b65a:	7b63      	ldrb	r3, [r4, #13]
    b65c:	2200      	movs	r2, #0
    b65e:	4013      	ands	r3, r2
    b660:	1c1a      	adds	r2, r3, #0
    b662:	1c0b      	adds	r3, r1, #0
    b664:	4313      	orrs	r3, r2
    b666:	7363      	strb	r3, [r4, #13]
                tcplen = TCP_TCPLEN(&inseg);
    b668:	4b9c      	ldr	r3, [pc, #624]	; (b8dc <tcp_receive+0xc60>)
    b66a:	891c      	ldrh	r4, [r3, #8]
    b66c:	4b9b      	ldr	r3, [pc, #620]	; (b8dc <tcp_receive+0xc60>)
    b66e:	68db      	ldr	r3, [r3, #12]
    b670:	7b1a      	ldrb	r2, [r3, #12]
    b672:	7b5b      	ldrb	r3, [r3, #13]
    b674:	021b      	lsls	r3, r3, #8
    b676:	4313      	orrs	r3, r2
    b678:	b29b      	uxth	r3, r3
    b67a:	0018      	movs	r0, r3
    b67c:	4b96      	ldr	r3, [pc, #600]	; (b8d8 <tcp_receive+0xc5c>)
    b67e:	4798      	blx	r3
    b680:	0003      	movs	r3, r0
    b682:	001a      	movs	r2, r3
    b684:	2303      	movs	r3, #3
    b686:	4013      	ands	r3, r2
    b688:	1e5a      	subs	r2, r3, #1
    b68a:	4193      	sbcs	r3, r2
    b68c:	b2db      	uxtb	r3, r3
    b68e:	b29b      	uxth	r3, r3
    b690:	18e3      	adds	r3, r4, r3
    b692:	b29a      	uxth	r2, r3
    b694:	4b93      	ldr	r3, [pc, #588]	; (b8e4 <tcp_receive+0xc68>)
    b696:	801a      	strh	r2, [r3, #0]
              }
              prev = next;
    b698:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b69a:	62bb      	str	r3, [r7, #40]	; 0x28
              next = next->next;
    b69c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b69e:	681b      	ldr	r3, [r3, #0]
    b6a0:	62fb      	str	r3, [r7, #44]	; 0x2c
              tcp_seg_free(prev);
    b6a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    b6a4:	0018      	movs	r0, r3
    b6a6:	4b90      	ldr	r3, [pc, #576]	; (b8e8 <tcp_receive+0xc6c>)
    b6a8:	4798      	blx	r3
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    b6aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b6ac:	2b00      	cmp	r3, #0
    b6ae:	d018      	beq.n	b6e2 <tcp_receive+0xa66>
                   TCP_SEQ_GEQ(seqno + tcplen,
    b6b0:	4b8c      	ldr	r3, [pc, #560]	; (b8e4 <tcp_receive+0xc68>)
    b6b2:	881b      	ldrh	r3, [r3, #0]
    b6b4:	001a      	movs	r2, r3
    b6b6:	4b8d      	ldr	r3, [pc, #564]	; (b8ec <tcp_receive+0xc70>)
    b6b8:	681b      	ldr	r3, [r3, #0]
    b6ba:	18d2      	adds	r2, r2, r3
    b6bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b6be:	68db      	ldr	r3, [r3, #12]
    b6c0:	7919      	ldrb	r1, [r3, #4]
    b6c2:	7958      	ldrb	r0, [r3, #5]
    b6c4:	0200      	lsls	r0, r0, #8
    b6c6:	4301      	orrs	r1, r0
    b6c8:	7998      	ldrb	r0, [r3, #6]
    b6ca:	0400      	lsls	r0, r0, #16
    b6cc:	4301      	orrs	r1, r0
    b6ce:	79db      	ldrb	r3, [r3, #7]
    b6d0:	061b      	lsls	r3, r3, #24
    b6d2:	430b      	orrs	r3, r1
    b6d4:	0019      	movs	r1, r3
    b6d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b6d8:	891b      	ldrh	r3, [r3, #8]
    b6da:	18cb      	adds	r3, r1, r3
    b6dc:	1ad3      	subs	r3, r2, r3
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    b6de:	d400      	bmi.n	b6e2 <tcp_receive+0xa66>
    b6e0:	e782      	b.n	b5e8 <tcp_receive+0x96c>
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
    b6e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b6e4:	2b00      	cmp	r3, #0
    b6e6:	d05d      	beq.n	b7a4 <tcp_receive+0xb28>
                TCP_SEQ_GT(seqno + tcplen,
    b6e8:	4b7e      	ldr	r3, [pc, #504]	; (b8e4 <tcp_receive+0xc68>)
    b6ea:	881b      	ldrh	r3, [r3, #0]
    b6ec:	001a      	movs	r2, r3
    b6ee:	4b7f      	ldr	r3, [pc, #508]	; (b8ec <tcp_receive+0xc70>)
    b6f0:	681b      	ldr	r3, [r3, #0]
    b6f2:	18d2      	adds	r2, r2, r3
    b6f4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b6f6:	68db      	ldr	r3, [r3, #12]
    b6f8:	7919      	ldrb	r1, [r3, #4]
    b6fa:	7958      	ldrb	r0, [r3, #5]
    b6fc:	0200      	lsls	r0, r0, #8
    b6fe:	4301      	orrs	r1, r0
    b700:	7998      	ldrb	r0, [r3, #6]
    b702:	0400      	lsls	r0, r0, #16
    b704:	4301      	orrs	r1, r0
    b706:	79db      	ldrb	r3, [r3, #7]
    b708:	061b      	lsls	r3, r3, #24
    b70a:	430b      	orrs	r3, r1
    b70c:	1ad3      	subs	r3, r2, r3
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
    b70e:	2b00      	cmp	r3, #0
    b710:	dd48      	ble.n	b7a4 <tcp_receive+0xb28>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    b712:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b714:	68db      	ldr	r3, [r3, #12]
    b716:	791a      	ldrb	r2, [r3, #4]
    b718:	7959      	ldrb	r1, [r3, #5]
    b71a:	0209      	lsls	r1, r1, #8
    b71c:	430a      	orrs	r2, r1
    b71e:	7999      	ldrb	r1, [r3, #6]
    b720:	0409      	lsls	r1, r1, #16
    b722:	430a      	orrs	r2, r1
    b724:	79db      	ldrb	r3, [r3, #7]
    b726:	061b      	lsls	r3, r3, #24
    b728:	4313      	orrs	r3, r2
    b72a:	b29a      	uxth	r2, r3
    b72c:	4b6f      	ldr	r3, [pc, #444]	; (b8ec <tcp_receive+0xc70>)
    b72e:	681b      	ldr	r3, [r3, #0]
    b730:	b29b      	uxth	r3, r3
    b732:	1ad3      	subs	r3, r2, r3
    b734:	b29a      	uxth	r2, r3
    b736:	4b69      	ldr	r3, [pc, #420]	; (b8dc <tcp_receive+0xc60>)
    b738:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    b73a:	4b68      	ldr	r3, [pc, #416]	; (b8dc <tcp_receive+0xc60>)
    b73c:	68db      	ldr	r3, [r3, #12]
    b73e:	7b1a      	ldrb	r2, [r3, #12]
    b740:	7b5b      	ldrb	r3, [r3, #13]
    b742:	021b      	lsls	r3, r3, #8
    b744:	4313      	orrs	r3, r2
    b746:	b29b      	uxth	r3, r3
    b748:	0018      	movs	r0, r3
    b74a:	4b63      	ldr	r3, [pc, #396]	; (b8d8 <tcp_receive+0xc5c>)
    b74c:	4798      	blx	r3
    b74e:	0003      	movs	r3, r0
    b750:	001a      	movs	r2, r3
    b752:	2302      	movs	r3, #2
    b754:	4013      	ands	r3, r2
    b756:	d005      	beq.n	b764 <tcp_receive+0xae8>
                inseg.len -= 1;
    b758:	4b60      	ldr	r3, [pc, #384]	; (b8dc <tcp_receive+0xc60>)
    b75a:	891b      	ldrh	r3, [r3, #8]
    b75c:	3b01      	subs	r3, #1
    b75e:	b29a      	uxth	r2, r3
    b760:	4b5e      	ldr	r3, [pc, #376]	; (b8dc <tcp_receive+0xc60>)
    b762:	811a      	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
    b764:	4b5d      	ldr	r3, [pc, #372]	; (b8dc <tcp_receive+0xc60>)
    b766:	685a      	ldr	r2, [r3, #4]
    b768:	4b5c      	ldr	r3, [pc, #368]	; (b8dc <tcp_receive+0xc60>)
    b76a:	891b      	ldrh	r3, [r3, #8]
    b76c:	0019      	movs	r1, r3
    b76e:	0010      	movs	r0, r2
    b770:	4b5f      	ldr	r3, [pc, #380]	; (b8f0 <tcp_receive+0xc74>)
    b772:	4798      	blx	r3
              tcplen = TCP_TCPLEN(&inseg);
    b774:	4b59      	ldr	r3, [pc, #356]	; (b8dc <tcp_receive+0xc60>)
    b776:	891c      	ldrh	r4, [r3, #8]
    b778:	4b58      	ldr	r3, [pc, #352]	; (b8dc <tcp_receive+0xc60>)
    b77a:	68db      	ldr	r3, [r3, #12]
    b77c:	7b1a      	ldrb	r2, [r3, #12]
    b77e:	7b5b      	ldrb	r3, [r3, #13]
    b780:	021b      	lsls	r3, r3, #8
    b782:	4313      	orrs	r3, r2
    b784:	b29b      	uxth	r3, r3
    b786:	0018      	movs	r0, r3
    b788:	4b53      	ldr	r3, [pc, #332]	; (b8d8 <tcp_receive+0xc5c>)
    b78a:	4798      	blx	r3
    b78c:	0003      	movs	r3, r0
    b78e:	001a      	movs	r2, r3
    b790:	2303      	movs	r3, #3
    b792:	4013      	ands	r3, r2
    b794:	1e5a      	subs	r2, r3, #1
    b796:	4193      	sbcs	r3, r2
    b798:	b2db      	uxtb	r3, r3
    b79a:	b29b      	uxth	r3, r3
    b79c:	18e3      	adds	r3, r4, r3
    b79e:	b29a      	uxth	r2, r3
    b7a0:	4b50      	ldr	r3, [pc, #320]	; (b8e4 <tcp_receive+0xc68>)
    b7a2:	801a      	strh	r2, [r3, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
    b7a4:	687b      	ldr	r3, [r7, #4]
    b7a6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    b7a8:	675a      	str	r2, [r3, #116]	; 0x74
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
    b7aa:	4b4e      	ldr	r3, [pc, #312]	; (b8e4 <tcp_receive+0xc68>)
    b7ac:	881b      	ldrh	r3, [r3, #0]
    b7ae:	001a      	movs	r2, r3
    b7b0:	4b4e      	ldr	r3, [pc, #312]	; (b8ec <tcp_receive+0xc70>)
    b7b2:	681b      	ldr	r3, [r3, #0]
    b7b4:	18d2      	adds	r2, r2, r3
    b7b6:	687b      	ldr	r3, [r7, #4]
    b7b8:	629a      	str	r2, [r3, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
    b7ba:	687b      	ldr	r3, [r7, #4]
    b7bc:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    b7be:	4b49      	ldr	r3, [pc, #292]	; (b8e4 <tcp_receive+0xc68>)
    b7c0:	881b      	ldrh	r3, [r3, #0]
    b7c2:	1ad3      	subs	r3, r2, r3
    b7c4:	b29a      	uxth	r2, r3
    b7c6:	687b      	ldr	r3, [r7, #4]
    b7c8:	859a      	strh	r2, [r3, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
    b7ca:	687b      	ldr	r3, [r7, #4]
    b7cc:	0018      	movs	r0, r3
    b7ce:	4b49      	ldr	r3, [pc, #292]	; (b8f4 <tcp_receive+0xc78>)
    b7d0:	4798      	blx	r3
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
    b7d2:	4b42      	ldr	r3, [pc, #264]	; (b8dc <tcp_receive+0xc60>)
    b7d4:	685b      	ldr	r3, [r3, #4]
    b7d6:	891b      	ldrh	r3, [r3, #8]
    b7d8:	2b00      	cmp	r3, #0
    b7da:	d006      	beq.n	b7ea <tcp_receive+0xb6e>
          recv_data = inseg.p;
    b7dc:	4b3f      	ldr	r3, [pc, #252]	; (b8dc <tcp_receive+0xc60>)
    b7de:	685a      	ldr	r2, [r3, #4]
    b7e0:	4b45      	ldr	r3, [pc, #276]	; (b8f8 <tcp_receive+0xc7c>)
    b7e2:	601a      	str	r2, [r3, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
    b7e4:	4b3d      	ldr	r3, [pc, #244]	; (b8dc <tcp_receive+0xc60>)
    b7e6:	2200      	movs	r2, #0
    b7e8:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    b7ea:	4b3c      	ldr	r3, [pc, #240]	; (b8dc <tcp_receive+0xc60>)
    b7ec:	68db      	ldr	r3, [r3, #12]
    b7ee:	7b1a      	ldrb	r2, [r3, #12]
    b7f0:	7b5b      	ldrb	r3, [r3, #13]
    b7f2:	021b      	lsls	r3, r3, #8
    b7f4:	4313      	orrs	r3, r2
    b7f6:	b29b      	uxth	r3, r3
    b7f8:	0018      	movs	r0, r3
    b7fa:	4b37      	ldr	r3, [pc, #220]	; (b8d8 <tcp_receive+0xc5c>)
    b7fc:	4798      	blx	r3
    b7fe:	0003      	movs	r3, r0
    b800:	001a      	movs	r2, r3
    b802:	2301      	movs	r3, #1
    b804:	4013      	ands	r3, r2
    b806:	d100      	bne.n	b80a <tcp_receive+0xb8e>
    b808:	e0a8      	b.n	b95c <tcp_receive+0xce0>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
    b80a:	4b3c      	ldr	r3, [pc, #240]	; (b8fc <tcp_receive+0xc80>)
    b80c:	781b      	ldrb	r3, [r3, #0]
    b80e:	2220      	movs	r2, #32
    b810:	4313      	orrs	r3, r2
    b812:	b2da      	uxtb	r2, r3
    b814:	4b39      	ldr	r3, [pc, #228]	; (b8fc <tcp_receive+0xc80>)
    b816:	701a      	strb	r2, [r3, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    b818:	e0a0      	b.n	b95c <tcp_receive+0xce0>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
    b81a:	687b      	ldr	r3, [r7, #4]
    b81c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b81e:	60bb      	str	r3, [r7, #8]
          seqno = pcb->ooseq->tcphdr->seqno;
    b820:	687b      	ldr	r3, [r7, #4]
    b822:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b824:	68db      	ldr	r3, [r3, #12]
    b826:	791a      	ldrb	r2, [r3, #4]
    b828:	7959      	ldrb	r1, [r3, #5]
    b82a:	0209      	lsls	r1, r1, #8
    b82c:	430a      	orrs	r2, r1
    b82e:	7999      	ldrb	r1, [r3, #6]
    b830:	0409      	lsls	r1, r1, #16
    b832:	430a      	orrs	r2, r1
    b834:	79db      	ldrb	r3, [r3, #7]
    b836:	061b      	lsls	r3, r3, #24
    b838:	4313      	orrs	r3, r2
    b83a:	001a      	movs	r2, r3
    b83c:	4b2b      	ldr	r3, [pc, #172]	; (b8ec <tcp_receive+0xc70>)
    b83e:	601a      	str	r2, [r3, #0]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
    b840:	68bb      	ldr	r3, [r7, #8]
    b842:	891b      	ldrh	r3, [r3, #8]
    b844:	001c      	movs	r4, r3
    b846:	68bb      	ldr	r3, [r7, #8]
    b848:	68db      	ldr	r3, [r3, #12]
    b84a:	7b1a      	ldrb	r2, [r3, #12]
    b84c:	7b5b      	ldrb	r3, [r3, #13]
    b84e:	021b      	lsls	r3, r3, #8
    b850:	4313      	orrs	r3, r2
    b852:	b29b      	uxth	r3, r3
    b854:	0018      	movs	r0, r3
    b856:	4b20      	ldr	r3, [pc, #128]	; (b8d8 <tcp_receive+0xc5c>)
    b858:	4798      	blx	r3
    b85a:	0003      	movs	r3, r0
    b85c:	001a      	movs	r2, r3
    b85e:	2303      	movs	r3, #3
    b860:	4013      	ands	r3, r2
    b862:	1e5a      	subs	r2, r3, #1
    b864:	4193      	sbcs	r3, r2
    b866:	b2db      	uxtb	r3, r3
    b868:	18e2      	adds	r2, r4, r3
    b86a:	687b      	ldr	r3, [r7, #4]
    b86c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    b86e:	189a      	adds	r2, r3, r2
    b870:	687b      	ldr	r3, [r7, #4]
    b872:	629a      	str	r2, [r3, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    b874:	68bb      	ldr	r3, [r7, #8]
    b876:	891b      	ldrh	r3, [r3, #8]
    b878:	001c      	movs	r4, r3
    b87a:	68bb      	ldr	r3, [r7, #8]
    b87c:	68db      	ldr	r3, [r3, #12]
    b87e:	7b1a      	ldrb	r2, [r3, #12]
    b880:	7b5b      	ldrb	r3, [r3, #13]
    b882:	021b      	lsls	r3, r3, #8
    b884:	4313      	orrs	r3, r2
    b886:	b29b      	uxth	r3, r3
    b888:	0018      	movs	r0, r3
    b88a:	4b13      	ldr	r3, [pc, #76]	; (b8d8 <tcp_receive+0xc5c>)
    b88c:	4798      	blx	r3
    b88e:	0003      	movs	r3, r0
    b890:	001a      	movs	r2, r3
    b892:	2303      	movs	r3, #3
    b894:	4013      	ands	r3, r2
    b896:	1e5a      	subs	r2, r3, #1
    b898:	4193      	sbcs	r3, r2
    b89a:	b2db      	uxtb	r3, r3
    b89c:	18e1      	adds	r1, r4, r3
    b89e:	687b      	ldr	r3, [r7, #4]
    b8a0:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    b8a2:	b28b      	uxth	r3, r1
    b8a4:	1ad3      	subs	r3, r2, r3
    b8a6:	b29a      	uxth	r2, r3
    b8a8:	687b      	ldr	r3, [r7, #4]
    b8aa:	859a      	strh	r2, [r3, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
    b8ac:	687b      	ldr	r3, [r7, #4]
    b8ae:	0018      	movs	r0, r3
    b8b0:	4b10      	ldr	r3, [pc, #64]	; (b8f4 <tcp_receive+0xc78>)
    b8b2:	4798      	blx	r3

          if (cseg->p->tot_len > 0) {
    b8b4:	68bb      	ldr	r3, [r7, #8]
    b8b6:	685b      	ldr	r3, [r3, #4]
    b8b8:	891b      	ldrh	r3, [r3, #8]
    b8ba:	2b00      	cmp	r3, #0
    b8bc:	d029      	beq.n	b912 <tcp_receive+0xc96>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
    b8be:	4b0e      	ldr	r3, [pc, #56]	; (b8f8 <tcp_receive+0xc7c>)
    b8c0:	681b      	ldr	r3, [r3, #0]
    b8c2:	2b00      	cmp	r3, #0
    b8c4:	d01e      	beq.n	b904 <tcp_receive+0xc88>
              pbuf_cat(recv_data, cseg->p);
    b8c6:	4b0c      	ldr	r3, [pc, #48]	; (b8f8 <tcp_receive+0xc7c>)
    b8c8:	681a      	ldr	r2, [r3, #0]
    b8ca:	68bb      	ldr	r3, [r7, #8]
    b8cc:	685b      	ldr	r3, [r3, #4]
    b8ce:	0019      	movs	r1, r3
    b8d0:	0010      	movs	r0, r2
    b8d2:	4b0b      	ldr	r3, [pc, #44]	; (b900 <tcp_receive+0xc84>)
    b8d4:	4798      	blx	r3
    b8d6:	e019      	b.n	b90c <tcp_receive+0xc90>
    b8d8:	0000561d 	.word	0x0000561d
    b8dc:	20002c70 	.word	0x20002c70
    b8e0:	000055f1 	.word	0x000055f1
    b8e4:	20002c92 	.word	0x20002c92
    b8e8:	000093ad 	.word	0x000093ad
    b8ec:	20002c88 	.word	0x20002c88
    b8f0:	00008151 	.word	0x00008151
    b8f4:	00008bdd 	.word	0x00008bdd
    b8f8:	20002c98 	.word	0x20002c98
    b8fc:	20002c94 	.word	0x20002c94
    b900:	00008491 	.word	0x00008491
            } else {
              recv_data = cseg->p;
    b904:	68bb      	ldr	r3, [r7, #8]
    b906:	685a      	ldr	r2, [r3, #4]
    b908:	4b9b      	ldr	r3, [pc, #620]	; (bb78 <tcp_receive+0xefc>)
    b90a:	601a      	str	r2, [r3, #0]
            }
            cseg->p = NULL;
    b90c:	68bb      	ldr	r3, [r7, #8]
    b90e:	2200      	movs	r2, #0
    b910:	605a      	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    b912:	68bb      	ldr	r3, [r7, #8]
    b914:	68db      	ldr	r3, [r3, #12]
    b916:	7b1a      	ldrb	r2, [r3, #12]
    b918:	7b5b      	ldrb	r3, [r3, #13]
    b91a:	021b      	lsls	r3, r3, #8
    b91c:	4313      	orrs	r3, r2
    b91e:	b29b      	uxth	r3, r3
    b920:	0018      	movs	r0, r3
    b922:	4b96      	ldr	r3, [pc, #600]	; (bb7c <tcp_receive+0xf00>)
    b924:	4798      	blx	r3
    b926:	0003      	movs	r3, r0
    b928:	001a      	movs	r2, r3
    b92a:	2301      	movs	r3, #1
    b92c:	4013      	ands	r3, r2
    b92e:	d00d      	beq.n	b94c <tcp_receive+0xcd0>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
    b930:	4b93      	ldr	r3, [pc, #588]	; (bb80 <tcp_receive+0xf04>)
    b932:	781b      	ldrb	r3, [r3, #0]
    b934:	2220      	movs	r2, #32
    b936:	4313      	orrs	r3, r2
    b938:	b2da      	uxtb	r2, r3
    b93a:	4b91      	ldr	r3, [pc, #580]	; (bb80 <tcp_receive+0xf04>)
    b93c:	701a      	strb	r2, [r3, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    b93e:	687b      	ldr	r3, [r7, #4]
    b940:	7e1b      	ldrb	r3, [r3, #24]
    b942:	2b04      	cmp	r3, #4
    b944:	d102      	bne.n	b94c <tcp_receive+0xcd0>
              pcb->state = CLOSE_WAIT;
    b946:	687b      	ldr	r3, [r7, #4]
    b948:	2207      	movs	r2, #7
    b94a:	761a      	strb	r2, [r3, #24]
            } 
          }

          pcb->ooseq = cseg->next;
    b94c:	68bb      	ldr	r3, [r7, #8]
    b94e:	681a      	ldr	r2, [r3, #0]
    b950:	687b      	ldr	r3, [r7, #4]
    b952:	675a      	str	r2, [r3, #116]	; 0x74
          tcp_seg_free(cseg);
    b954:	68bb      	ldr	r3, [r7, #8]
    b956:	0018      	movs	r0, r3
    b958:	4b8a      	ldr	r3, [pc, #552]	; (bb84 <tcp_receive+0xf08>)
    b95a:	4798      	blx	r3
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    b95c:	687b      	ldr	r3, [r7, #4]
    b95e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b960:	2b00      	cmp	r3, #0
    b962:	d012      	beq.n	b98a <tcp_receive+0xd0e>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    b964:	687b      	ldr	r3, [r7, #4]
    b966:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b968:	68db      	ldr	r3, [r3, #12]
    b96a:	791a      	ldrb	r2, [r3, #4]
    b96c:	7959      	ldrb	r1, [r3, #5]
    b96e:	0209      	lsls	r1, r1, #8
    b970:	430a      	orrs	r2, r1
    b972:	7999      	ldrb	r1, [r3, #6]
    b974:	0409      	lsls	r1, r1, #16
    b976:	430a      	orrs	r2, r1
    b978:	79db      	ldrb	r3, [r3, #7]
    b97a:	061b      	lsls	r3, r3, #24
    b97c:	4313      	orrs	r3, r2
    b97e:	1e1a      	subs	r2, r3, #0
    b980:	687b      	ldr	r3, [r7, #4]
    b982:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    b984:	429a      	cmp	r2, r3
    b986:	d100      	bne.n	b98a <tcp_receive+0xd0e>
    b988:	e747      	b.n	b81a <tcp_receive+0xb9e>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
    b98a:	687b      	ldr	r3, [r7, #4]
    b98c:	7f9b      	ldrb	r3, [r3, #30]
    b98e:	001a      	movs	r2, r3
    b990:	2301      	movs	r3, #1
    b992:	4013      	ands	r3, r2
    b994:	d00e      	beq.n	b9b4 <tcp_receive+0xd38>
    b996:	687b      	ldr	r3, [r7, #4]
    b998:	7f9b      	ldrb	r3, [r3, #30]
    b99a:	2201      	movs	r2, #1
    b99c:	4393      	bics	r3, r2
    b99e:	b2da      	uxtb	r2, r3
    b9a0:	687b      	ldr	r3, [r7, #4]
    b9a2:	779a      	strb	r2, [r3, #30]
    b9a4:	687b      	ldr	r3, [r7, #4]
    b9a6:	7f9b      	ldrb	r3, [r3, #30]
    b9a8:	2202      	movs	r2, #2
    b9aa:	4313      	orrs	r3, r2
    b9ac:	b2da      	uxtb	r2, r3
    b9ae:	687b      	ldr	r3, [r7, #4]
    b9b0:	779a      	strb	r2, [r3, #30]
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    b9b2:	e200      	b.n	bdb6 <tcp_receive+0x113a>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
    b9b4:	687b      	ldr	r3, [r7, #4]
    b9b6:	7f9b      	ldrb	r3, [r3, #30]
    b9b8:	2201      	movs	r2, #1
    b9ba:	4313      	orrs	r3, r2
    b9bc:	b2da      	uxtb	r2, r3
    b9be:	687b      	ldr	r3, [r7, #4]
    b9c0:	779a      	strb	r2, [r3, #30]
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    b9c2:	e1f8      	b.n	bdb6 <tcp_receive+0x113a>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
    b9c4:	687b      	ldr	r3, [r7, #4]
    b9c6:	0018      	movs	r0, r3
    b9c8:	4b6f      	ldr	r3, [pc, #444]	; (bb88 <tcp_receive+0xf0c>)
    b9ca:	4798      	blx	r3
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
    b9cc:	687b      	ldr	r3, [r7, #4]
    b9ce:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b9d0:	2b00      	cmp	r3, #0
    b9d2:	d107      	bne.n	b9e4 <tcp_receive+0xd68>
          pcb->ooseq = tcp_seg_copy(&inseg);
    b9d4:	4b6d      	ldr	r3, [pc, #436]	; (bb8c <tcp_receive+0xf10>)
    b9d6:	0018      	movs	r0, r3
    b9d8:	4b6d      	ldr	r3, [pc, #436]	; (bb90 <tcp_receive+0xf14>)
    b9da:	4798      	blx	r3
    b9dc:	0002      	movs	r2, r0
    b9de:	687b      	ldr	r3, [r7, #4]
    b9e0:	675a      	str	r2, [r3, #116]	; 0x74
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    b9e2:	e1e8      	b.n	bdb6 <tcp_receive+0x113a>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
    b9e4:	2300      	movs	r3, #0
    b9e6:	62bb      	str	r3, [r7, #40]	; 0x28
          for(next = pcb->ooseq; next != NULL; next = next->next) {
    b9e8:	687b      	ldr	r3, [r7, #4]
    b9ea:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    b9ec:	62fb      	str	r3, [r7, #44]	; 0x2c
    b9ee:	e1cc      	b.n	bd8a <tcp_receive+0x110e>
            if (seqno == next->tcphdr->seqno) {
    b9f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    b9f2:	68db      	ldr	r3, [r3, #12]
    b9f4:	791a      	ldrb	r2, [r3, #4]
    b9f6:	7959      	ldrb	r1, [r3, #5]
    b9f8:	0209      	lsls	r1, r1, #8
    b9fa:	430a      	orrs	r2, r1
    b9fc:	7999      	ldrb	r1, [r3, #6]
    b9fe:	0409      	lsls	r1, r1, #16
    ba00:	430a      	orrs	r2, r1
    ba02:	79db      	ldrb	r3, [r3, #7]
    ba04:	061b      	lsls	r3, r3, #24
    ba06:	4313      	orrs	r3, r2
    ba08:	1e1a      	subs	r2, r3, #0
    ba0a:	4b62      	ldr	r3, [pc, #392]	; (bb94 <tcp_receive+0xf18>)
    ba0c:	681b      	ldr	r3, [r3, #0]
    ba0e:	429a      	cmp	r2, r3
    ba10:	d121      	bne.n	ba56 <tcp_receive+0xdda>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
    ba12:	4b5e      	ldr	r3, [pc, #376]	; (bb8c <tcp_receive+0xf10>)
    ba14:	891a      	ldrh	r2, [r3, #8]
    ba16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    ba18:	891b      	ldrh	r3, [r3, #8]
    ba1a:	429a      	cmp	r2, r3
    ba1c:	d800      	bhi.n	ba20 <tcp_receive+0xda4>
    ba1e:	e1b9      	b.n	bd94 <tcp_receive+0x1118>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
    ba20:	4b5a      	ldr	r3, [pc, #360]	; (bb8c <tcp_receive+0xf10>)
    ba22:	0018      	movs	r0, r3
    ba24:	4b5a      	ldr	r3, [pc, #360]	; (bb90 <tcp_receive+0xf14>)
    ba26:	4798      	blx	r3
    ba28:	0003      	movs	r3, r0
    ba2a:	60bb      	str	r3, [r7, #8]
                if (cseg != NULL) {
    ba2c:	68bb      	ldr	r3, [r7, #8]
    ba2e:	2b00      	cmp	r3, #0
    ba30:	d100      	bne.n	ba34 <tcp_receive+0xdb8>
    ba32:	e1b1      	b.n	bd98 <tcp_receive+0x111c>
                  if (prev != NULL) {
    ba34:	6abb      	ldr	r3, [r7, #40]	; 0x28
    ba36:	2b00      	cmp	r3, #0
    ba38:	d003      	beq.n	ba42 <tcp_receive+0xdc6>
                    prev->next = cseg;
    ba3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    ba3c:	68ba      	ldr	r2, [r7, #8]
    ba3e:	601a      	str	r2, [r3, #0]
    ba40:	e002      	b.n	ba48 <tcp_receive+0xdcc>
                  } else {
                    pcb->ooseq = cseg;
    ba42:	687b      	ldr	r3, [r7, #4]
    ba44:	68ba      	ldr	r2, [r7, #8]
    ba46:	675a      	str	r2, [r3, #116]	; 0x74
                  }
                  tcp_oos_insert_segment(cseg, next);
    ba48:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    ba4a:	68bb      	ldr	r3, [r7, #8]
    ba4c:	0011      	movs	r1, r2
    ba4e:	0018      	movs	r0, r3
    ba50:	4b51      	ldr	r3, [pc, #324]	; (bb98 <tcp_receive+0xf1c>)
    ba52:	4798      	blx	r3
                }
                break;
    ba54:	e1a0      	b.n	bd98 <tcp_receive+0x111c>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
    ba56:	6abb      	ldr	r3, [r7, #40]	; 0x28
    ba58:	2b00      	cmp	r3, #0
    ba5a:	d124      	bne.n	baa6 <tcp_receive+0xe2a>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    ba5c:	4b4d      	ldr	r3, [pc, #308]	; (bb94 <tcp_receive+0xf18>)
    ba5e:	681a      	ldr	r2, [r3, #0]
    ba60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    ba62:	68db      	ldr	r3, [r3, #12]
    ba64:	7919      	ldrb	r1, [r3, #4]
    ba66:	7958      	ldrb	r0, [r3, #5]
    ba68:	0200      	lsls	r0, r0, #8
    ba6a:	4301      	orrs	r1, r0
    ba6c:	7998      	ldrb	r0, [r3, #6]
    ba6e:	0400      	lsls	r0, r0, #16
    ba70:	4301      	orrs	r1, r0
    ba72:	79db      	ldrb	r3, [r3, #7]
    ba74:	061b      	lsls	r3, r3, #24
    ba76:	430b      	orrs	r3, r1
    ba78:	1ad3      	subs	r3, r2, r3
    ba7a:	d400      	bmi.n	ba7e <tcp_receive+0xe02>
    ba7c:	e090      	b.n	bba0 <tcp_receive+0xf24>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
    ba7e:	4b43      	ldr	r3, [pc, #268]	; (bb8c <tcp_receive+0xf10>)
    ba80:	0018      	movs	r0, r3
    ba82:	4b43      	ldr	r3, [pc, #268]	; (bb90 <tcp_receive+0xf14>)
    ba84:	4798      	blx	r3
    ba86:	0003      	movs	r3, r0
    ba88:	60bb      	str	r3, [r7, #8]
                  if (cseg != NULL) {
    ba8a:	68bb      	ldr	r3, [r7, #8]
    ba8c:	2b00      	cmp	r3, #0
    ba8e:	d100      	bne.n	ba92 <tcp_receive+0xe16>
    ba90:	e184      	b.n	bd9c <tcp_receive+0x1120>
                    pcb->ooseq = cseg;
    ba92:	687b      	ldr	r3, [r7, #4]
    ba94:	68ba      	ldr	r2, [r7, #8]
    ba96:	675a      	str	r2, [r3, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
    ba98:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    ba9a:	68bb      	ldr	r3, [r7, #8]
    ba9c:	0011      	movs	r1, r2
    ba9e:	0018      	movs	r0, r3
    baa0:	4b3d      	ldr	r3, [pc, #244]	; (bb98 <tcp_receive+0xf1c>)
    baa2:	4798      	blx	r3
                  }
                  break;
    baa4:	e17a      	b.n	bd9c <tcp_receive+0x1120>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
    baa6:	4b3b      	ldr	r3, [pc, #236]	; (bb94 <tcp_receive+0xf18>)
    baa8:	681a      	ldr	r2, [r3, #0]
    baaa:	6abb      	ldr	r3, [r7, #40]	; 0x28
    baac:	68db      	ldr	r3, [r3, #12]
    baae:	7919      	ldrb	r1, [r3, #4]
    bab0:	7958      	ldrb	r0, [r3, #5]
    bab2:	0200      	lsls	r0, r0, #8
    bab4:	4301      	orrs	r1, r0
    bab6:	7998      	ldrb	r0, [r3, #6]
    bab8:	0400      	lsls	r0, r0, #16
    baba:	4301      	orrs	r1, r0
    babc:	79db      	ldrb	r3, [r3, #7]
    babe:	061b      	lsls	r3, r3, #24
    bac0:	430b      	orrs	r3, r1
    bac2:	1ad3      	subs	r3, r2, r3
    bac4:	3b01      	subs	r3, #1
    bac6:	2b00      	cmp	r3, #0
    bac8:	db6a      	blt.n	bba0 <tcp_receive+0xf24>
    baca:	4b32      	ldr	r3, [pc, #200]	; (bb94 <tcp_receive+0xf18>)
    bacc:	681a      	ldr	r2, [r3, #0]
    bace:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bad0:	68db      	ldr	r3, [r3, #12]
    bad2:	7919      	ldrb	r1, [r3, #4]
    bad4:	7958      	ldrb	r0, [r3, #5]
    bad6:	0200      	lsls	r0, r0, #8
    bad8:	4301      	orrs	r1, r0
    bada:	7998      	ldrb	r0, [r3, #6]
    badc:	0400      	lsls	r0, r0, #16
    bade:	4301      	orrs	r1, r0
    bae0:	79db      	ldrb	r3, [r3, #7]
    bae2:	061b      	lsls	r3, r3, #24
    bae4:	430b      	orrs	r3, r1
    bae6:	1ad3      	subs	r3, r2, r3
    bae8:	3301      	adds	r3, #1
    baea:	2b00      	cmp	r3, #0
    baec:	dc58      	bgt.n	bba0 <tcp_receive+0xf24>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
    baee:	4b27      	ldr	r3, [pc, #156]	; (bb8c <tcp_receive+0xf10>)
    baf0:	0018      	movs	r0, r3
    baf2:	4b27      	ldr	r3, [pc, #156]	; (bb90 <tcp_receive+0xf14>)
    baf4:	4798      	blx	r3
    baf6:	0003      	movs	r3, r0
    baf8:	60bb      	str	r3, [r7, #8]
                  if (cseg != NULL) {
    bafa:	68bb      	ldr	r3, [r7, #8]
    bafc:	2b00      	cmp	r3, #0
    bafe:	d100      	bne.n	bb02 <tcp_receive+0xe86>
    bb00:	e14e      	b.n	bda0 <tcp_receive+0x1124>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    bb02:	6abb      	ldr	r3, [r7, #40]	; 0x28
    bb04:	68db      	ldr	r3, [r3, #12]
    bb06:	791a      	ldrb	r2, [r3, #4]
    bb08:	7959      	ldrb	r1, [r3, #5]
    bb0a:	0209      	lsls	r1, r1, #8
    bb0c:	430a      	orrs	r2, r1
    bb0e:	7999      	ldrb	r1, [r3, #6]
    bb10:	0409      	lsls	r1, r1, #16
    bb12:	430a      	orrs	r2, r1
    bb14:	79db      	ldrb	r3, [r3, #7]
    bb16:	061b      	lsls	r3, r3, #24
    bb18:	4313      	orrs	r3, r2
    bb1a:	001a      	movs	r2, r3
    bb1c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    bb1e:	891b      	ldrh	r3, [r3, #8]
    bb20:	18d2      	adds	r2, r2, r3
    bb22:	4b1c      	ldr	r3, [pc, #112]	; (bb94 <tcp_receive+0xf18>)
    bb24:	681b      	ldr	r3, [r3, #0]
    bb26:	1ad3      	subs	r3, r2, r3
    bb28:	2b00      	cmp	r3, #0
    bb2a:	dd1b      	ble.n	bb64 <tcp_receive+0xee8>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    bb2c:	4b19      	ldr	r3, [pc, #100]	; (bb94 <tcp_receive+0xf18>)
    bb2e:	681b      	ldr	r3, [r3, #0]
    bb30:	b29a      	uxth	r2, r3
    bb32:	6abb      	ldr	r3, [r7, #40]	; 0x28
    bb34:	68db      	ldr	r3, [r3, #12]
    bb36:	7919      	ldrb	r1, [r3, #4]
    bb38:	7958      	ldrb	r0, [r3, #5]
    bb3a:	0200      	lsls	r0, r0, #8
    bb3c:	4301      	orrs	r1, r0
    bb3e:	7998      	ldrb	r0, [r3, #6]
    bb40:	0400      	lsls	r0, r0, #16
    bb42:	4301      	orrs	r1, r0
    bb44:	79db      	ldrb	r3, [r3, #7]
    bb46:	061b      	lsls	r3, r3, #24
    bb48:	430b      	orrs	r3, r1
    bb4a:	b29b      	uxth	r3, r3
    bb4c:	1ad3      	subs	r3, r2, r3
    bb4e:	b29a      	uxth	r2, r3
    bb50:	6abb      	ldr	r3, [r7, #40]	; 0x28
    bb52:	811a      	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
    bb54:	6abb      	ldr	r3, [r7, #40]	; 0x28
    bb56:	685a      	ldr	r2, [r3, #4]
    bb58:	6abb      	ldr	r3, [r7, #40]	; 0x28
    bb5a:	891b      	ldrh	r3, [r3, #8]
    bb5c:	0019      	movs	r1, r3
    bb5e:	0010      	movs	r0, r2
    bb60:	4b0e      	ldr	r3, [pc, #56]	; (bb9c <tcp_receive+0xf20>)
    bb62:	4798      	blx	r3
                    }
                    prev->next = cseg;
    bb64:	6abb      	ldr	r3, [r7, #40]	; 0x28
    bb66:	68ba      	ldr	r2, [r7, #8]
    bb68:	601a      	str	r2, [r3, #0]
                    tcp_oos_insert_segment(cseg, next);
    bb6a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    bb6c:	68bb      	ldr	r3, [r7, #8]
    bb6e:	0011      	movs	r1, r2
    bb70:	0018      	movs	r0, r3
    bb72:	4b09      	ldr	r3, [pc, #36]	; (bb98 <tcp_receive+0xf1c>)
    bb74:	4798      	blx	r3
                  }
                  break;
    bb76:	e113      	b.n	bda0 <tcp_receive+0x1124>
    bb78:	20002c98 	.word	0x20002c98
    bb7c:	0000561d 	.word	0x0000561d
    bb80:	20002c94 	.word	0x20002c94
    bb84:	000093ad 	.word	0x000093ad
    bb88:	0000c629 	.word	0x0000c629
    bb8c:	20002c70 	.word	0x20002c70
    bb90:	000093e9 	.word	0x000093e9
    bb94:	20002c88 	.word	0x20002c88
    bb98:	0000ab0d 	.word	0x0000ab0d
    bb9c:	00008151 	.word	0x00008151
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
    bba0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bba2:	681b      	ldr	r3, [r3, #0]
    bba4:	2b00      	cmp	r3, #0
    bba6:	d000      	beq.n	bbaa <tcp_receive+0xf2e>
    bba8:	e0ea      	b.n	bd80 <tcp_receive+0x1104>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    bbaa:	4b92      	ldr	r3, [pc, #584]	; (bdf4 <tcp_receive+0x1178>)
    bbac:	681a      	ldr	r2, [r3, #0]
    bbae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bbb0:	68db      	ldr	r3, [r3, #12]
    bbb2:	7919      	ldrb	r1, [r3, #4]
    bbb4:	7958      	ldrb	r0, [r3, #5]
    bbb6:	0200      	lsls	r0, r0, #8
    bbb8:	4301      	orrs	r1, r0
    bbba:	7998      	ldrb	r0, [r3, #6]
    bbbc:	0400      	lsls	r0, r0, #16
    bbbe:	4301      	orrs	r1, r0
    bbc0:	79db      	ldrb	r3, [r3, #7]
    bbc2:	061b      	lsls	r3, r3, #24
    bbc4:	430b      	orrs	r3, r1
    bbc6:	1ad3      	subs	r3, r2, r3
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
    bbc8:	2b00      	cmp	r3, #0
    bbca:	dc00      	bgt.n	bbce <tcp_receive+0xf52>
    bbcc:	e0d8      	b.n	bd80 <tcp_receive+0x1104>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    bbce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bbd0:	68db      	ldr	r3, [r3, #12]
    bbd2:	7b1a      	ldrb	r2, [r3, #12]
    bbd4:	7b5b      	ldrb	r3, [r3, #13]
    bbd6:	021b      	lsls	r3, r3, #8
    bbd8:	4313      	orrs	r3, r2
    bbda:	b29b      	uxth	r3, r3
    bbdc:	0018      	movs	r0, r3
    bbde:	4b86      	ldr	r3, [pc, #536]	; (bdf8 <tcp_receive+0x117c>)
    bbe0:	4798      	blx	r3
    bbe2:	0003      	movs	r3, r0
    bbe4:	001a      	movs	r2, r3
    bbe6:	2301      	movs	r3, #1
    bbe8:	4013      	ands	r3, r2
    bbea:	d000      	beq.n	bbee <tcp_receive+0xf72>
    bbec:	e0da      	b.n	bda4 <tcp_receive+0x1128>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
    bbee:	4b83      	ldr	r3, [pc, #524]	; (bdfc <tcp_receive+0x1180>)
    bbf0:	0018      	movs	r0, r3
    bbf2:	4b83      	ldr	r3, [pc, #524]	; (be00 <tcp_receive+0x1184>)
    bbf4:	4798      	blx	r3
    bbf6:	0002      	movs	r2, r0
    bbf8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bbfa:	601a      	str	r2, [r3, #0]
                if (next->next != NULL) {
    bbfc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bbfe:	681b      	ldr	r3, [r3, #0]
    bc00:	2b00      	cmp	r3, #0
    bc02:	d100      	bne.n	bc06 <tcp_receive+0xf8a>
    bc04:	e0d0      	b.n	bda8 <tcp_receive+0x112c>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    bc06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bc08:	68db      	ldr	r3, [r3, #12]
    bc0a:	791a      	ldrb	r2, [r3, #4]
    bc0c:	7959      	ldrb	r1, [r3, #5]
    bc0e:	0209      	lsls	r1, r1, #8
    bc10:	430a      	orrs	r2, r1
    bc12:	7999      	ldrb	r1, [r3, #6]
    bc14:	0409      	lsls	r1, r1, #16
    bc16:	430a      	orrs	r2, r1
    bc18:	79db      	ldrb	r3, [r3, #7]
    bc1a:	061b      	lsls	r3, r3, #24
    bc1c:	4313      	orrs	r3, r2
    bc1e:	001a      	movs	r2, r3
    bc20:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bc22:	891b      	ldrh	r3, [r3, #8]
    bc24:	18d2      	adds	r2, r2, r3
    bc26:	4b73      	ldr	r3, [pc, #460]	; (bdf4 <tcp_receive+0x1178>)
    bc28:	681b      	ldr	r3, [r3, #0]
    bc2a:	1ad3      	subs	r3, r2, r3
    bc2c:	2b00      	cmp	r3, #0
    bc2e:	dd1b      	ble.n	bc68 <tcp_receive+0xfec>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
    bc30:	4b70      	ldr	r3, [pc, #448]	; (bdf4 <tcp_receive+0x1178>)
    bc32:	681b      	ldr	r3, [r3, #0]
    bc34:	b29a      	uxth	r2, r3
    bc36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bc38:	68db      	ldr	r3, [r3, #12]
    bc3a:	7919      	ldrb	r1, [r3, #4]
    bc3c:	7958      	ldrb	r0, [r3, #5]
    bc3e:	0200      	lsls	r0, r0, #8
    bc40:	4301      	orrs	r1, r0
    bc42:	7998      	ldrb	r0, [r3, #6]
    bc44:	0400      	lsls	r0, r0, #16
    bc46:	4301      	orrs	r1, r0
    bc48:	79db      	ldrb	r3, [r3, #7]
    bc4a:	061b      	lsls	r3, r3, #24
    bc4c:	430b      	orrs	r3, r1
    bc4e:	b29b      	uxth	r3, r3
    bc50:	1ad3      	subs	r3, r2, r3
    bc52:	b29a      	uxth	r2, r3
    bc54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bc56:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
    bc58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bc5a:	685a      	ldr	r2, [r3, #4]
    bc5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bc5e:	891b      	ldrh	r3, [r3, #8]
    bc60:	0019      	movs	r1, r3
    bc62:	0010      	movs	r0, r2
    bc64:	4b67      	ldr	r3, [pc, #412]	; (be04 <tcp_receive+0x1188>)
    bc66:	4798      	blx	r3
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    bc68:	4b67      	ldr	r3, [pc, #412]	; (be08 <tcp_receive+0x118c>)
    bc6a:	881b      	ldrh	r3, [r3, #0]
    bc6c:	001a      	movs	r2, r3
    bc6e:	4b61      	ldr	r3, [pc, #388]	; (bdf4 <tcp_receive+0x1178>)
    bc70:	681b      	ldr	r3, [r3, #0]
    bc72:	18d2      	adds	r2, r2, r3
    bc74:	687b      	ldr	r3, [r7, #4]
    bc76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    bc78:	6879      	ldr	r1, [r7, #4]
    bc7a:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
    bc7c:	185b      	adds	r3, r3, r1
    bc7e:	429a      	cmp	r2, r3
    bc80:	d800      	bhi.n	bc84 <tcp_receive+0x1008>
    bc82:	e091      	b.n	bda8 <tcp_receive+0x112c>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    bc84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bc86:	681b      	ldr	r3, [r3, #0]
    bc88:	68db      	ldr	r3, [r3, #12]
    bc8a:	7b1a      	ldrb	r2, [r3, #12]
    bc8c:	7b5b      	ldrb	r3, [r3, #13]
    bc8e:	021b      	lsls	r3, r3, #8
    bc90:	4313      	orrs	r3, r2
    bc92:	b29b      	uxth	r3, r3
    bc94:	0018      	movs	r0, r3
    bc96:	4b58      	ldr	r3, [pc, #352]	; (bdf8 <tcp_receive+0x117c>)
    bc98:	4798      	blx	r3
    bc9a:	0003      	movs	r3, r0
    bc9c:	001a      	movs	r2, r3
    bc9e:	2301      	movs	r3, #1
    bca0:	4013      	ands	r3, r2
    bca2:	d039      	beq.n	bd18 <tcp_receive+0x109c>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
    bca4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bca6:	681b      	ldr	r3, [r3, #0]
    bca8:	68dc      	ldr	r4, [r3, #12]
    bcaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bcac:	681b      	ldr	r3, [r3, #0]
    bcae:	68db      	ldr	r3, [r3, #12]
    bcb0:	7b1a      	ldrb	r2, [r3, #12]
    bcb2:	7b5b      	ldrb	r3, [r3, #13]
    bcb4:	021b      	lsls	r3, r3, #8
    bcb6:	4313      	orrs	r3, r2
    bcb8:	b29b      	uxth	r3, r3
    bcba:	b21b      	sxth	r3, r3
    bcbc:	4a53      	ldr	r2, [pc, #332]	; (be0c <tcp_receive+0x1190>)
    bcbe:	4013      	ands	r3, r2
    bcc0:	b21d      	sxth	r5, r3
    bcc2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bcc4:	681b      	ldr	r3, [r3, #0]
    bcc6:	68db      	ldr	r3, [r3, #12]
    bcc8:	7b1a      	ldrb	r2, [r3, #12]
    bcca:	7b5b      	ldrb	r3, [r3, #13]
    bccc:	021b      	lsls	r3, r3, #8
    bcce:	4313      	orrs	r3, r2
    bcd0:	b29b      	uxth	r3, r3
    bcd2:	0018      	movs	r0, r3
    bcd4:	4b48      	ldr	r3, [pc, #288]	; (bdf8 <tcp_receive+0x117c>)
    bcd6:	4798      	blx	r3
    bcd8:	0003      	movs	r3, r0
    bcda:	001a      	movs	r2, r3
    bcdc:	233e      	movs	r3, #62	; 0x3e
    bcde:	4013      	ands	r3, r2
    bce0:	b29b      	uxth	r3, r3
    bce2:	0018      	movs	r0, r3
    bce4:	4b4a      	ldr	r3, [pc, #296]	; (be10 <tcp_receive+0x1194>)
    bce6:	4798      	blx	r3
    bce8:	0003      	movs	r3, r0
    bcea:	b21b      	sxth	r3, r3
    bcec:	432b      	orrs	r3, r5
    bcee:	b21b      	sxth	r3, r3
    bcf0:	b29b      	uxth	r3, r3
    bcf2:	22ff      	movs	r2, #255	; 0xff
    bcf4:	401a      	ands	r2, r3
    bcf6:	0010      	movs	r0, r2
    bcf8:	7b22      	ldrb	r2, [r4, #12]
    bcfa:	2100      	movs	r1, #0
    bcfc:	400a      	ands	r2, r1
    bcfe:	1c11      	adds	r1, r2, #0
    bd00:	1c02      	adds	r2, r0, #0
    bd02:	430a      	orrs	r2, r1
    bd04:	7322      	strb	r2, [r4, #12]
    bd06:	0a1b      	lsrs	r3, r3, #8
    bd08:	b299      	uxth	r1, r3
    bd0a:	7b63      	ldrb	r3, [r4, #13]
    bd0c:	2200      	movs	r2, #0
    bd0e:	4013      	ands	r3, r2
    bd10:	1c1a      	adds	r2, r3, #0
    bd12:	1c0b      	adds	r3, r1, #0
    bd14:	4313      	orrs	r3, r2
    bd16:	7363      	strb	r3, [r4, #13]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    bd18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd1a:	681a      	ldr	r2, [r3, #0]
    bd1c:	687b      	ldr	r3, [r7, #4]
    bd1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    bd20:	b299      	uxth	r1, r3
    bd22:	687b      	ldr	r3, [r7, #4]
    bd24:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    bd26:	18cb      	adds	r3, r1, r3
    bd28:	b299      	uxth	r1, r3
    bd2a:	4b32      	ldr	r3, [pc, #200]	; (bdf4 <tcp_receive+0x1178>)
    bd2c:	681b      	ldr	r3, [r3, #0]
    bd2e:	b29b      	uxth	r3, r3
    bd30:	1acb      	subs	r3, r1, r3
    bd32:	b29b      	uxth	r3, r3
    bd34:	8113      	strh	r3, [r2, #8]
                    pbuf_realloc(next->next->p, next->next->len);
    bd36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd38:	681b      	ldr	r3, [r3, #0]
    bd3a:	685a      	ldr	r2, [r3, #4]
    bd3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd3e:	681b      	ldr	r3, [r3, #0]
    bd40:	891b      	ldrh	r3, [r3, #8]
    bd42:	0019      	movs	r1, r3
    bd44:	0010      	movs	r0, r2
    bd46:	4b2f      	ldr	r3, [pc, #188]	; (be04 <tcp_receive+0x1188>)
    bd48:	4798      	blx	r3
                    tcplen = TCP_TCPLEN(next->next);
    bd4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd4c:	681b      	ldr	r3, [r3, #0]
    bd4e:	891c      	ldrh	r4, [r3, #8]
    bd50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd52:	681b      	ldr	r3, [r3, #0]
    bd54:	68db      	ldr	r3, [r3, #12]
    bd56:	7b1a      	ldrb	r2, [r3, #12]
    bd58:	7b5b      	ldrb	r3, [r3, #13]
    bd5a:	021b      	lsls	r3, r3, #8
    bd5c:	4313      	orrs	r3, r2
    bd5e:	b29b      	uxth	r3, r3
    bd60:	0018      	movs	r0, r3
    bd62:	4b25      	ldr	r3, [pc, #148]	; (bdf8 <tcp_receive+0x117c>)
    bd64:	4798      	blx	r3
    bd66:	0003      	movs	r3, r0
    bd68:	001a      	movs	r2, r3
    bd6a:	2303      	movs	r3, #3
    bd6c:	4013      	ands	r3, r2
    bd6e:	1e5a      	subs	r2, r3, #1
    bd70:	4193      	sbcs	r3, r2
    bd72:	b2db      	uxtb	r3, r3
    bd74:	b29b      	uxth	r3, r3
    bd76:	18e3      	adds	r3, r4, r3
    bd78:	b29a      	uxth	r2, r3
    bd7a:	4b23      	ldr	r3, [pc, #140]	; (be08 <tcp_receive+0x118c>)
    bd7c:	801a      	strh	r2, [r3, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
    bd7e:	e013      	b.n	bda8 <tcp_receive+0x112c>
              }
            }
            prev = next;
    bd80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd82:	62bb      	str	r3, [r7, #40]	; 0x28
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
    bd84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd86:	681b      	ldr	r3, [r3, #0]
    bd88:	62fb      	str	r3, [r7, #44]	; 0x2c
    bd8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    bd8c:	2b00      	cmp	r3, #0
    bd8e:	d000      	beq.n	bd92 <tcp_receive+0x1116>
    bd90:	e62e      	b.n	b9f0 <tcp_receive+0xd74>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    bd92:	e010      	b.n	bdb6 <tcp_receive+0x113a>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
    bd94:	46c0      	nop			; (mov r8, r8)
    bd96:	e00e      	b.n	bdb6 <tcp_receive+0x113a>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
    bd98:	46c0      	nop			; (mov r8, r8)
    bd9a:	e00c      	b.n	bdb6 <tcp_receive+0x113a>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
    bd9c:	46c0      	nop			; (mov r8, r8)
    bd9e:	e00a      	b.n	bdb6 <tcp_receive+0x113a>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
    bda0:	46c0      	nop			; (mov r8, r8)
    bda2:	e008      	b.n	bdb6 <tcp_receive+0x113a>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
    bda4:	46c0      	nop			; (mov r8, r8)
    bda6:	e006      	b.n	bdb6 <tcp_receive+0x113a>
                    tcplen = TCP_TCPLEN(next->next);
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
    bda8:	46c0      	nop			; (mov r8, r8)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    bdaa:	e004      	b.n	bdb6 <tcp_receive+0x113a>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
    bdac:	687b      	ldr	r3, [r7, #4]
    bdae:	0018      	movs	r0, r3
    bdb0:	4b18      	ldr	r3, [pc, #96]	; (be14 <tcp_receive+0x1198>)
    bdb2:	4798      	blx	r3
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    bdb4:	e019      	b.n	bdea <tcp_receive+0x116e>
    bdb6:	e018      	b.n	bdea <tcp_receive+0x116e>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
    bdb8:	4b0e      	ldr	r3, [pc, #56]	; (bdf4 <tcp_receive+0x1178>)
    bdba:	681a      	ldr	r2, [r3, #0]
    bdbc:	687b      	ldr	r3, [r7, #4]
    bdbe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    bdc0:	1ad3      	subs	r3, r2, r3
    bdc2:	d40a      	bmi.n	bdda <tcp_receive+0x115e>
    bdc4:	4b0b      	ldr	r3, [pc, #44]	; (bdf4 <tcp_receive+0x1178>)
    bdc6:	681a      	ldr	r2, [r3, #0]
    bdc8:	687b      	ldr	r3, [r7, #4]
    bdca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    bdcc:	6879      	ldr	r1, [r7, #4]
    bdce:	8d89      	ldrh	r1, [r1, #44]	; 0x2c
    bdd0:	185b      	adds	r3, r3, r1
    bdd2:	1ad3      	subs	r3, r2, r3
    bdd4:	3301      	adds	r3, #1
    bdd6:	2b00      	cmp	r3, #0
    bdd8:	dd07      	ble.n	bdea <tcp_receive+0x116e>
      tcp_ack_now(pcb);
    bdda:	687b      	ldr	r3, [r7, #4]
    bddc:	7f9b      	ldrb	r3, [r3, #30]
    bdde:	2202      	movs	r2, #2
    bde0:	4313      	orrs	r3, r2
    bde2:	b2da      	uxtb	r2, r3
    bde4:	687b      	ldr	r3, [r7, #4]
    bde6:	779a      	strb	r2, [r3, #30]
    }
  }
}
    bde8:	e7ff      	b.n	bdea <tcp_receive+0x116e>
    bdea:	46c0      	nop			; (mov r8, r8)
    bdec:	46bd      	mov	sp, r7
    bdee:	b00d      	add	sp, #52	; 0x34
    bdf0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bdf2:	46c0      	nop			; (mov r8, r8)
    bdf4:	20002c88 	.word	0x20002c88
    bdf8:	0000561d 	.word	0x0000561d
    bdfc:	20002c70 	.word	0x20002c70
    be00:	000093e9 	.word	0x000093e9
    be04:	00008151 	.word	0x00008151
    be08:	20002c92 	.word	0x20002c92
    be0c:	ffffc0ff 	.word	0xffffc0ff
    be10:	000055f1 	.word	0x000055f1
    be14:	0000c629 	.word	0x0000c629

0000be18 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
    be18:	b580      	push	{r7, lr}
    be1a:	b086      	sub	sp, #24
    be1c:	af00      	add	r7, sp, #0
    be1e:	6078      	str	r0, [r7, #4]
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
    be20:	4b59      	ldr	r3, [pc, #356]	; (bf88 <tcp_parseopt+0x170>)
    be22:	681b      	ldr	r3, [r3, #0]
    be24:	3314      	adds	r3, #20
    be26:	613b      	str	r3, [r7, #16]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    be28:	4b57      	ldr	r3, [pc, #348]	; (bf88 <tcp_parseopt+0x170>)
    be2a:	681b      	ldr	r3, [r3, #0]
    be2c:	7b1a      	ldrb	r2, [r3, #12]
    be2e:	7b5b      	ldrb	r3, [r3, #13]
    be30:	021b      	lsls	r3, r3, #8
    be32:	4313      	orrs	r3, r2
    be34:	b29b      	uxth	r3, r3
    be36:	0018      	movs	r0, r3
    be38:	4b54      	ldr	r3, [pc, #336]	; (bf8c <tcp_parseopt+0x174>)
    be3a:	4798      	blx	r3
    be3c:	0003      	movs	r3, r0
    be3e:	0b1b      	lsrs	r3, r3, #12
    be40:	b29b      	uxth	r3, r3
    be42:	2b05      	cmp	r3, #5
    be44:	d800      	bhi.n	be48 <tcp_parseopt+0x30>
    be46:	e09c      	b.n	bf82 <tcp_parseopt+0x16a>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    be48:	4b4f      	ldr	r3, [pc, #316]	; (bf88 <tcp_parseopt+0x170>)
    be4a:	681b      	ldr	r3, [r3, #0]
    be4c:	7b1a      	ldrb	r2, [r3, #12]
    be4e:	7b5b      	ldrb	r3, [r3, #13]
    be50:	021b      	lsls	r3, r3, #8
    be52:	4313      	orrs	r3, r2
    be54:	b29b      	uxth	r3, r3
    be56:	0018      	movs	r0, r3
    be58:	4b4c      	ldr	r3, [pc, #304]	; (bf8c <tcp_parseopt+0x174>)
    be5a:	4798      	blx	r3
    be5c:	0003      	movs	r3, r0
    be5e:	0b1b      	lsrs	r3, r3, #12
    be60:	b29b      	uxth	r3, r3
    be62:	3b05      	subs	r3, #5
    be64:	b29a      	uxth	r2, r3
    be66:	230e      	movs	r3, #14
    be68:	18fb      	adds	r3, r7, r3
    be6a:	0092      	lsls	r2, r2, #2
    be6c:	801a      	strh	r2, [r3, #0]
    for (c = 0; c < max_c; ) {
    be6e:	2316      	movs	r3, #22
    be70:	18fb      	adds	r3, r7, r3
    be72:	2200      	movs	r2, #0
    be74:	801a      	strh	r2, [r3, #0]
    be76:	e075      	b.n	bf64 <tcp_parseopt+0x14c>
      opt = opts[c];
    be78:	2316      	movs	r3, #22
    be7a:	18fb      	adds	r3, r7, r3
    be7c:	881b      	ldrh	r3, [r3, #0]
    be7e:	693a      	ldr	r2, [r7, #16]
    be80:	18d2      	adds	r2, r2, r3
    be82:	230d      	movs	r3, #13
    be84:	18fb      	adds	r3, r7, r3
    be86:	7812      	ldrb	r2, [r2, #0]
    be88:	701a      	strb	r2, [r3, #0]
      switch (opt) {
    be8a:	230d      	movs	r3, #13
    be8c:	18fb      	adds	r3, r7, r3
    be8e:	781b      	ldrb	r3, [r3, #0]
    be90:	2b01      	cmp	r3, #1
    be92:	d005      	beq.n	bea0 <tcp_parseopt+0x88>
    be94:	2b02      	cmp	r3, #2
    be96:	d00b      	beq.n	beb0 <tcp_parseopt+0x98>
    be98:	2b00      	cmp	r3, #0
    be9a:	d100      	bne.n	be9e <tcp_parseopt+0x86>
    be9c:	e06c      	b.n	bf78 <tcp_parseopt+0x160>
    be9e:	e049      	b.n	bf34 <tcp_parseopt+0x11c>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
    bea0:	2316      	movs	r3, #22
    bea2:	18fb      	adds	r3, r7, r3
    bea4:	2216      	movs	r2, #22
    bea6:	18ba      	adds	r2, r7, r2
    bea8:	8812      	ldrh	r2, [r2, #0]
    beaa:	3201      	adds	r2, #1
    beac:	801a      	strh	r2, [r3, #0]
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
    beae:	e059      	b.n	bf64 <tcp_parseopt+0x14c>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    beb0:	2316      	movs	r3, #22
    beb2:	18fb      	adds	r3, r7, r3
    beb4:	881b      	ldrh	r3, [r3, #0]
    beb6:	3301      	adds	r3, #1
    beb8:	693a      	ldr	r2, [r7, #16]
    beba:	18d3      	adds	r3, r2, r3
    bebc:	781b      	ldrb	r3, [r3, #0]
    bebe:	2b04      	cmp	r3, #4
    bec0:	d15c      	bne.n	bf7c <tcp_parseopt+0x164>
    bec2:	2316      	movs	r3, #22
    bec4:	18fb      	adds	r3, r7, r3
    bec6:	881b      	ldrh	r3, [r3, #0]
    bec8:	1d1a      	adds	r2, r3, #4
    beca:	230e      	movs	r3, #14
    becc:	18fb      	adds	r3, r7, r3
    bece:	881b      	ldrh	r3, [r3, #0]
    bed0:	429a      	cmp	r2, r3
    bed2:	dc53      	bgt.n	bf7c <tcp_parseopt+0x164>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
    bed4:	2316      	movs	r3, #22
    bed6:	18fb      	adds	r3, r7, r3
    bed8:	881b      	ldrh	r3, [r3, #0]
    beda:	3302      	adds	r3, #2
    bedc:	693a      	ldr	r2, [r7, #16]
    bede:	18d3      	adds	r3, r2, r3
    bee0:	781b      	ldrb	r3, [r3, #0]
    bee2:	021b      	lsls	r3, r3, #8
    bee4:	b21a      	sxth	r2, r3
    bee6:	2316      	movs	r3, #22
    bee8:	18fb      	adds	r3, r7, r3
    beea:	881b      	ldrh	r3, [r3, #0]
    beec:	3303      	adds	r3, #3
    beee:	6939      	ldr	r1, [r7, #16]
    bef0:	18cb      	adds	r3, r1, r3
    bef2:	781b      	ldrb	r3, [r3, #0]
    bef4:	b21b      	sxth	r3, r3
    bef6:	4313      	orrs	r3, r2
    bef8:	b21a      	sxth	r2, r3
    befa:	230a      	movs	r3, #10
    befc:	18fb      	adds	r3, r7, r3
    befe:	801a      	strh	r2, [r3, #0]
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    bf00:	230a      	movs	r3, #10
    bf02:	18fb      	adds	r3, r7, r3
    bf04:	881b      	ldrh	r3, [r3, #0]
    bf06:	4a22      	ldr	r2, [pc, #136]	; (bf90 <tcp_parseopt+0x178>)
    bf08:	4293      	cmp	r3, r2
    bf0a:	d808      	bhi.n	bf1e <tcp_parseopt+0x106>
    bf0c:	230a      	movs	r3, #10
    bf0e:	18fb      	adds	r3, r7, r3
    bf10:	881b      	ldrh	r3, [r3, #0]
    bf12:	2b00      	cmp	r3, #0
    bf14:	d003      	beq.n	bf1e <tcp_parseopt+0x106>
    bf16:	230a      	movs	r3, #10
    bf18:	18fb      	adds	r3, r7, r3
    bf1a:	881a      	ldrh	r2, [r3, #0]
    bf1c:	e000      	b.n	bf20 <tcp_parseopt+0x108>
    bf1e:	4a1c      	ldr	r2, [pc, #112]	; (bf90 <tcp_parseopt+0x178>)
    bf20:	687b      	ldr	r3, [r7, #4]
    bf22:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Advance to next option */
        c += 0x04;
    bf24:	2316      	movs	r3, #22
    bf26:	18fb      	adds	r3, r7, r3
    bf28:	2216      	movs	r2, #22
    bf2a:	18ba      	adds	r2, r7, r2
    bf2c:	8812      	ldrh	r2, [r2, #0]
    bf2e:	3204      	adds	r2, #4
    bf30:	801a      	strh	r2, [r3, #0]
        break;
    bf32:	e017      	b.n	bf64 <tcp_parseopt+0x14c>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
    bf34:	2316      	movs	r3, #22
    bf36:	18fb      	adds	r3, r7, r3
    bf38:	881b      	ldrh	r3, [r3, #0]
    bf3a:	3301      	adds	r3, #1
    bf3c:	693a      	ldr	r2, [r7, #16]
    bf3e:	18d3      	adds	r3, r2, r3
    bf40:	781b      	ldrb	r3, [r3, #0]
    bf42:	2b00      	cmp	r3, #0
    bf44:	d01c      	beq.n	bf80 <tcp_parseopt+0x168>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
    bf46:	2316      	movs	r3, #22
    bf48:	18fb      	adds	r3, r7, r3
    bf4a:	881b      	ldrh	r3, [r3, #0]
    bf4c:	3301      	adds	r3, #1
    bf4e:	693a      	ldr	r2, [r7, #16]
    bf50:	18d3      	adds	r3, r2, r3
    bf52:	781b      	ldrb	r3, [r3, #0]
    bf54:	b299      	uxth	r1, r3
    bf56:	2316      	movs	r3, #22
    bf58:	18fb      	adds	r3, r7, r3
    bf5a:	2216      	movs	r2, #22
    bf5c:	18ba      	adds	r2, r7, r2
    bf5e:	8812      	ldrh	r2, [r2, #0]
    bf60:	188a      	adds	r2, r1, r2
    bf62:	801a      	strh	r2, [r3, #0]
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
    bf64:	2316      	movs	r3, #22
    bf66:	18fa      	adds	r2, r7, r3
    bf68:	230e      	movs	r3, #14
    bf6a:	18fb      	adds	r3, r7, r3
    bf6c:	8812      	ldrh	r2, [r2, #0]
    bf6e:	881b      	ldrh	r3, [r3, #0]
    bf70:	429a      	cmp	r2, r3
    bf72:	d200      	bcs.n	bf76 <tcp_parseopt+0x15e>
    bf74:	e780      	b.n	be78 <tcp_parseopt+0x60>
    bf76:	e004      	b.n	bf82 <tcp_parseopt+0x16a>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
    bf78:	46c0      	nop			; (mov r8, r8)
    bf7a:	e002      	b.n	bf82 <tcp_parseopt+0x16a>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
    bf7c:	46c0      	nop			; (mov r8, r8)
    bf7e:	e000      	b.n	bf82 <tcp_parseopt+0x16a>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
    bf80:	46c0      	nop			; (mov r8, r8)
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
    bf82:	46bd      	mov	sp, r7
    bf84:	b006      	add	sp, #24
    bf86:	bd80      	pop	{r7, pc}
    bf88:	20002c80 	.word	0x20002c80
    bf8c:	0000561d 	.word	0x0000561d
    bf90:	000005b4 	.word	0x000005b4

0000bf94 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
    bf94:	b590      	push	{r4, r7, lr}
    bf96:	b087      	sub	sp, #28
    bf98:	af00      	add	r7, sp, #0
    bf9a:	60f8      	str	r0, [r7, #12]
    bf9c:	0008      	movs	r0, r1
    bf9e:	0011      	movs	r1, r2
    bfa0:	607b      	str	r3, [r7, #4]
    bfa2:	230a      	movs	r3, #10
    bfa4:	18fb      	adds	r3, r7, r3
    bfa6:	1c02      	adds	r2, r0, #0
    bfa8:	801a      	strh	r2, [r3, #0]
    bfaa:	2308      	movs	r3, #8
    bfac:	18fb      	adds	r3, r7, r3
    bfae:	1c0a      	adds	r2, r1, #0
    bfb0:	801a      	strh	r2, [r3, #0]
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
    bfb2:	230a      	movs	r3, #10
    bfb4:	18fa      	adds	r2, r7, r3
    bfb6:	2308      	movs	r3, #8
    bfb8:	18fb      	adds	r3, r7, r3
    bfba:	8812      	ldrh	r2, [r2, #0]
    bfbc:	881b      	ldrh	r3, [r3, #0]
    bfbe:	18d3      	adds	r3, r2, r3
    bfc0:	b29b      	uxth	r3, r3
    bfc2:	3314      	adds	r3, #20
    bfc4:	b29b      	uxth	r3, r3
    bfc6:	2200      	movs	r2, #0
    bfc8:	0019      	movs	r1, r3
    bfca:	2001      	movs	r0, #1
    bfcc:	4b79      	ldr	r3, [pc, #484]	; (c1b4 <tcp_output_alloc_header+0x220>)
    bfce:	4798      	blx	r3
    bfd0:	0003      	movs	r3, r0
    bfd2:	617b      	str	r3, [r7, #20]
  if (p != NULL) {
    bfd4:	697b      	ldr	r3, [r7, #20]
    bfd6:	2b00      	cmp	r3, #0
    bfd8:	d100      	bne.n	bfdc <tcp_output_alloc_header+0x48>
    bfda:	e0e5      	b.n	c1a8 <tcp_output_alloc_header+0x214>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    bfdc:	697b      	ldr	r3, [r7, #20]
    bfde:	685b      	ldr	r3, [r3, #4]
    bfe0:	613b      	str	r3, [r7, #16]
    tcphdr->src = htons(pcb->local_port);
    bfe2:	68fb      	ldr	r3, [r7, #12]
    bfe4:	8b5b      	ldrh	r3, [r3, #26]
    bfe6:	0018      	movs	r0, r3
    bfe8:	4b73      	ldr	r3, [pc, #460]	; (c1b8 <tcp_output_alloc_header+0x224>)
    bfea:	4798      	blx	r3
    bfec:	0003      	movs	r3, r0
    bfee:	001a      	movs	r2, r3
    bff0:	693b      	ldr	r3, [r7, #16]
    bff2:	21ff      	movs	r1, #255	; 0xff
    bff4:	4011      	ands	r1, r2
    bff6:	000c      	movs	r4, r1
    bff8:	7819      	ldrb	r1, [r3, #0]
    bffa:	2000      	movs	r0, #0
    bffc:	4001      	ands	r1, r0
    bffe:	1c08      	adds	r0, r1, #0
    c000:	1c21      	adds	r1, r4, #0
    c002:	4301      	orrs	r1, r0
    c004:	7019      	strb	r1, [r3, #0]
    c006:	0a12      	lsrs	r2, r2, #8
    c008:	b290      	uxth	r0, r2
    c00a:	785a      	ldrb	r2, [r3, #1]
    c00c:	2100      	movs	r1, #0
    c00e:	400a      	ands	r2, r1
    c010:	1c11      	adds	r1, r2, #0
    c012:	1c02      	adds	r2, r0, #0
    c014:	430a      	orrs	r2, r1
    c016:	705a      	strb	r2, [r3, #1]
    tcphdr->dest = htons(pcb->remote_port);
    c018:	68fb      	ldr	r3, [r7, #12]
    c01a:	8b9b      	ldrh	r3, [r3, #28]
    c01c:	0018      	movs	r0, r3
    c01e:	4b66      	ldr	r3, [pc, #408]	; (c1b8 <tcp_output_alloc_header+0x224>)
    c020:	4798      	blx	r3
    c022:	0003      	movs	r3, r0
    c024:	001a      	movs	r2, r3
    c026:	693b      	ldr	r3, [r7, #16]
    c028:	21ff      	movs	r1, #255	; 0xff
    c02a:	4011      	ands	r1, r2
    c02c:	000c      	movs	r4, r1
    c02e:	7899      	ldrb	r1, [r3, #2]
    c030:	2000      	movs	r0, #0
    c032:	4001      	ands	r1, r0
    c034:	1c08      	adds	r0, r1, #0
    c036:	1c21      	adds	r1, r4, #0
    c038:	4301      	orrs	r1, r0
    c03a:	7099      	strb	r1, [r3, #2]
    c03c:	0a12      	lsrs	r2, r2, #8
    c03e:	b290      	uxth	r0, r2
    c040:	78da      	ldrb	r2, [r3, #3]
    c042:	2100      	movs	r1, #0
    c044:	400a      	ands	r2, r1
    c046:	1c11      	adds	r1, r2, #0
    c048:	1c02      	adds	r2, r0, #0
    c04a:	430a      	orrs	r2, r1
    c04c:	70da      	strb	r2, [r3, #3]
    tcphdr->seqno = seqno_be;
    c04e:	693b      	ldr	r3, [r7, #16]
    c050:	1d3a      	adds	r2, r7, #4
    c052:	7810      	ldrb	r0, [r2, #0]
    c054:	791a      	ldrb	r2, [r3, #4]
    c056:	2100      	movs	r1, #0
    c058:	400a      	ands	r2, r1
    c05a:	1c11      	adds	r1, r2, #0
    c05c:	1c02      	adds	r2, r0, #0
    c05e:	430a      	orrs	r2, r1
    c060:	711a      	strb	r2, [r3, #4]
    c062:	1d7a      	adds	r2, r7, #5
    c064:	7810      	ldrb	r0, [r2, #0]
    c066:	795a      	ldrb	r2, [r3, #5]
    c068:	2100      	movs	r1, #0
    c06a:	400a      	ands	r2, r1
    c06c:	1c11      	adds	r1, r2, #0
    c06e:	1c02      	adds	r2, r0, #0
    c070:	430a      	orrs	r2, r1
    c072:	715a      	strb	r2, [r3, #5]
    c074:	1dba      	adds	r2, r7, #6
    c076:	7810      	ldrb	r0, [r2, #0]
    c078:	799a      	ldrb	r2, [r3, #6]
    c07a:	2100      	movs	r1, #0
    c07c:	400a      	ands	r2, r1
    c07e:	1c11      	adds	r1, r2, #0
    c080:	1c02      	adds	r2, r0, #0
    c082:	430a      	orrs	r2, r1
    c084:	719a      	strb	r2, [r3, #6]
    c086:	1dfa      	adds	r2, r7, #7
    c088:	7810      	ldrb	r0, [r2, #0]
    c08a:	79da      	ldrb	r2, [r3, #7]
    c08c:	2100      	movs	r1, #0
    c08e:	400a      	ands	r2, r1
    c090:	1c11      	adds	r1, r2, #0
    c092:	1c02      	adds	r2, r0, #0
    c094:	430a      	orrs	r2, r1
    c096:	71da      	strb	r2, [r3, #7]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    c098:	68fb      	ldr	r3, [r7, #12]
    c09a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    c09c:	0018      	movs	r0, r3
    c09e:	4b47      	ldr	r3, [pc, #284]	; (c1bc <tcp_output_alloc_header+0x228>)
    c0a0:	4798      	blx	r3
    c0a2:	0002      	movs	r2, r0
    c0a4:	693b      	ldr	r3, [r7, #16]
    c0a6:	21ff      	movs	r1, #255	; 0xff
    c0a8:	4011      	ands	r1, r2
    c0aa:	000c      	movs	r4, r1
    c0ac:	7a19      	ldrb	r1, [r3, #8]
    c0ae:	2000      	movs	r0, #0
    c0b0:	4001      	ands	r1, r0
    c0b2:	1c08      	adds	r0, r1, #0
    c0b4:	1c21      	adds	r1, r4, #0
    c0b6:	4301      	orrs	r1, r0
    c0b8:	7219      	strb	r1, [r3, #8]
    c0ba:	0a11      	lsrs	r1, r2, #8
    c0bc:	20ff      	movs	r0, #255	; 0xff
    c0be:	4001      	ands	r1, r0
    c0c0:	000c      	movs	r4, r1
    c0c2:	7a59      	ldrb	r1, [r3, #9]
    c0c4:	2000      	movs	r0, #0
    c0c6:	4001      	ands	r1, r0
    c0c8:	1c08      	adds	r0, r1, #0
    c0ca:	1c21      	adds	r1, r4, #0
    c0cc:	4301      	orrs	r1, r0
    c0ce:	7259      	strb	r1, [r3, #9]
    c0d0:	0c11      	lsrs	r1, r2, #16
    c0d2:	20ff      	movs	r0, #255	; 0xff
    c0d4:	4001      	ands	r1, r0
    c0d6:	000c      	movs	r4, r1
    c0d8:	7a99      	ldrb	r1, [r3, #10]
    c0da:	2000      	movs	r0, #0
    c0dc:	4001      	ands	r1, r0
    c0de:	1c08      	adds	r0, r1, #0
    c0e0:	1c21      	adds	r1, r4, #0
    c0e2:	4301      	orrs	r1, r0
    c0e4:	7299      	strb	r1, [r3, #10]
    c0e6:	0e10      	lsrs	r0, r2, #24
    c0e8:	7ada      	ldrb	r2, [r3, #11]
    c0ea:	2100      	movs	r1, #0
    c0ec:	400a      	ands	r2, r1
    c0ee:	1c11      	adds	r1, r2, #0
    c0f0:	1c02      	adds	r2, r0, #0
    c0f2:	430a      	orrs	r2, r1
    c0f4:	72da      	strb	r2, [r3, #11]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    c0f6:	230a      	movs	r3, #10
    c0f8:	18fb      	adds	r3, r7, r3
    c0fa:	881b      	ldrh	r3, [r3, #0]
    c0fc:	089b      	lsrs	r3, r3, #2
    c0fe:	b29b      	uxth	r3, r3
    c100:	3305      	adds	r3, #5
    c102:	b29b      	uxth	r3, r3
    c104:	031b      	lsls	r3, r3, #12
    c106:	b29b      	uxth	r3, r3
    c108:	2210      	movs	r2, #16
    c10a:	4313      	orrs	r3, r2
    c10c:	b29b      	uxth	r3, r3
    c10e:	0018      	movs	r0, r3
    c110:	4b29      	ldr	r3, [pc, #164]	; (c1b8 <tcp_output_alloc_header+0x224>)
    c112:	4798      	blx	r3
    c114:	0003      	movs	r3, r0
    c116:	001a      	movs	r2, r3
    c118:	693b      	ldr	r3, [r7, #16]
    c11a:	21ff      	movs	r1, #255	; 0xff
    c11c:	4011      	ands	r1, r2
    c11e:	000c      	movs	r4, r1
    c120:	7b19      	ldrb	r1, [r3, #12]
    c122:	2000      	movs	r0, #0
    c124:	4001      	ands	r1, r0
    c126:	1c08      	adds	r0, r1, #0
    c128:	1c21      	adds	r1, r4, #0
    c12a:	4301      	orrs	r1, r0
    c12c:	7319      	strb	r1, [r3, #12]
    c12e:	0a12      	lsrs	r2, r2, #8
    c130:	b290      	uxth	r0, r2
    c132:	7b5a      	ldrb	r2, [r3, #13]
    c134:	2100      	movs	r1, #0
    c136:	400a      	ands	r2, r1
    c138:	1c11      	adds	r1, r2, #0
    c13a:	1c02      	adds	r2, r0, #0
    c13c:	430a      	orrs	r2, r1
    c13e:	735a      	strb	r2, [r3, #13]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    c140:	68fb      	ldr	r3, [r7, #12]
    c142:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    c144:	0018      	movs	r0, r3
    c146:	4b1c      	ldr	r3, [pc, #112]	; (c1b8 <tcp_output_alloc_header+0x224>)
    c148:	4798      	blx	r3
    c14a:	0003      	movs	r3, r0
    c14c:	001a      	movs	r2, r3
    c14e:	693b      	ldr	r3, [r7, #16]
    c150:	21ff      	movs	r1, #255	; 0xff
    c152:	4011      	ands	r1, r2
    c154:	000c      	movs	r4, r1
    c156:	7b99      	ldrb	r1, [r3, #14]
    c158:	2000      	movs	r0, #0
    c15a:	4001      	ands	r1, r0
    c15c:	1c08      	adds	r0, r1, #0
    c15e:	1c21      	adds	r1, r4, #0
    c160:	4301      	orrs	r1, r0
    c162:	7399      	strb	r1, [r3, #14]
    c164:	0a12      	lsrs	r2, r2, #8
    c166:	b290      	uxth	r0, r2
    c168:	7bda      	ldrb	r2, [r3, #15]
    c16a:	2100      	movs	r1, #0
    c16c:	400a      	ands	r2, r1
    c16e:	1c11      	adds	r1, r2, #0
    c170:	1c02      	adds	r2, r0, #0
    c172:	430a      	orrs	r2, r1
    c174:	73da      	strb	r2, [r3, #15]
    tcphdr->chksum = 0;
    c176:	693b      	ldr	r3, [r7, #16]
    c178:	7c1a      	ldrb	r2, [r3, #16]
    c17a:	2100      	movs	r1, #0
    c17c:	400a      	ands	r2, r1
    c17e:	741a      	strb	r2, [r3, #16]
    c180:	7c5a      	ldrb	r2, [r3, #17]
    c182:	2100      	movs	r1, #0
    c184:	400a      	ands	r2, r1
    c186:	745a      	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
    c188:	693b      	ldr	r3, [r7, #16]
    c18a:	7c9a      	ldrb	r2, [r3, #18]
    c18c:	2100      	movs	r1, #0
    c18e:	400a      	ands	r2, r1
    c190:	749a      	strb	r2, [r3, #18]
    c192:	7cda      	ldrb	r2, [r3, #19]
    c194:	2100      	movs	r1, #0
    c196:	400a      	ands	r2, r1
    c198:	74da      	strb	r2, [r3, #19]

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    c19a:	68fb      	ldr	r3, [r7, #12]
    c19c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    c19e:	68fa      	ldr	r2, [r7, #12]
    c1a0:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
    c1a2:	189a      	adds	r2, r3, r2
    c1a4:	68fb      	ldr	r3, [r7, #12]
    c1a6:	631a      	str	r2, [r3, #48]	; 0x30
  }
  return p;
    c1a8:	697b      	ldr	r3, [r7, #20]
}
    c1aa:	0018      	movs	r0, r3
    c1ac:	46bd      	mov	sp, r7
    c1ae:	b007      	add	sp, #28
    c1b0:	bd90      	pop	{r4, r7, pc}
    c1b2:	46c0      	nop			; (mov r8, r8)
    c1b4:	00007e19 	.word	0x00007e19
    c1b8:	000055f1 	.word	0x000055f1
    c1bc:	00005641 	.word	0x00005641

0000c1c0 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
    c1c0:	b5b0      	push	{r4, r5, r7, lr}
    c1c2:	b084      	sub	sp, #16
    c1c4:	af00      	add	r7, sp, #0
    c1c6:	6078      	str	r0, [r7, #4]
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    c1c8:	687b      	ldr	r3, [r7, #4]
    c1ca:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c1cc:	2b00      	cmp	r3, #0
    c1ce:	d044      	beq.n	c25a <tcp_send_fin+0x9a>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
    c1d0:	687b      	ldr	r3, [r7, #4]
    c1d2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c1d4:	60fb      	str	r3, [r7, #12]
    c1d6:	e002      	b.n	c1de <tcp_send_fin+0x1e>
         last_unsent = last_unsent->next);
    c1d8:	68fb      	ldr	r3, [r7, #12]
    c1da:	681b      	ldr	r3, [r3, #0]
    c1dc:	60fb      	str	r3, [r7, #12]
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
    c1de:	68fb      	ldr	r3, [r7, #12]
    c1e0:	681b      	ldr	r3, [r3, #0]
    c1e2:	2b00      	cmp	r3, #0
    c1e4:	d1f8      	bne.n	c1d8 <tcp_send_fin+0x18>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
    c1e6:	68fb      	ldr	r3, [r7, #12]
    c1e8:	68db      	ldr	r3, [r3, #12]
    c1ea:	7b1a      	ldrb	r2, [r3, #12]
    c1ec:	7b5b      	ldrb	r3, [r3, #13]
    c1ee:	021b      	lsls	r3, r3, #8
    c1f0:	4313      	orrs	r3, r2
    c1f2:	b29b      	uxth	r3, r3
    c1f4:	0018      	movs	r0, r3
    c1f6:	4b1e      	ldr	r3, [pc, #120]	; (c270 <tcp_send_fin+0xb0>)
    c1f8:	4798      	blx	r3
    c1fa:	0003      	movs	r3, r0
    c1fc:	001a      	movs	r2, r3
    c1fe:	2307      	movs	r3, #7
    c200:	4013      	ands	r3, r2
    c202:	d12a      	bne.n	c25a <tcp_send_fin+0x9a>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
    c204:	68fb      	ldr	r3, [r7, #12]
    c206:	68dc      	ldr	r4, [r3, #12]
    c208:	68fb      	ldr	r3, [r7, #12]
    c20a:	68db      	ldr	r3, [r3, #12]
    c20c:	7b1a      	ldrb	r2, [r3, #12]
    c20e:	7b5b      	ldrb	r3, [r3, #13]
    c210:	021b      	lsls	r3, r3, #8
    c212:	4313      	orrs	r3, r2
    c214:	b29d      	uxth	r5, r3
    c216:	2001      	movs	r0, #1
    c218:	4b16      	ldr	r3, [pc, #88]	; (c274 <tcp_send_fin+0xb4>)
    c21a:	4798      	blx	r3
    c21c:	0003      	movs	r3, r0
    c21e:	432b      	orrs	r3, r5
    c220:	b29b      	uxth	r3, r3
    c222:	22ff      	movs	r2, #255	; 0xff
    c224:	401a      	ands	r2, r3
    c226:	0010      	movs	r0, r2
    c228:	7b22      	ldrb	r2, [r4, #12]
    c22a:	2100      	movs	r1, #0
    c22c:	400a      	ands	r2, r1
    c22e:	1c11      	adds	r1, r2, #0
    c230:	1c02      	adds	r2, r0, #0
    c232:	430a      	orrs	r2, r1
    c234:	7322      	strb	r2, [r4, #12]
    c236:	0a1b      	lsrs	r3, r3, #8
    c238:	b299      	uxth	r1, r3
    c23a:	7b63      	ldrb	r3, [r4, #13]
    c23c:	2200      	movs	r2, #0
    c23e:	4013      	ands	r3, r2
    c240:	1c1a      	adds	r2, r3, #0
    c242:	1c0b      	adds	r3, r1, #0
    c244:	4313      	orrs	r3, r2
    c246:	7363      	strb	r3, [r4, #13]
      pcb->flags |= TF_FIN;
    c248:	687b      	ldr	r3, [r7, #4]
    c24a:	7f9b      	ldrb	r3, [r3, #30]
    c24c:	2220      	movs	r2, #32
    c24e:	4313      	orrs	r3, r2
    c250:	b2da      	uxtb	r2, r3
    c252:	687b      	ldr	r3, [r7, #4]
    c254:	779a      	strb	r2, [r3, #30]
      return ERR_OK;
    c256:	2300      	movs	r3, #0
    c258:	e005      	b.n	c266 <tcp_send_fin+0xa6>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
    c25a:	687b      	ldr	r3, [r7, #4]
    c25c:	2101      	movs	r1, #1
    c25e:	0018      	movs	r0, r3
    c260:	4b05      	ldr	r3, [pc, #20]	; (c278 <tcp_send_fin+0xb8>)
    c262:	4798      	blx	r3
    c264:	0003      	movs	r3, r0
}
    c266:	0018      	movs	r0, r3
    c268:	46bd      	mov	sp, r7
    c26a:	b004      	add	sp, #16
    c26c:	bdb0      	pop	{r4, r5, r7, pc}
    c26e:	46c0      	nop			; (mov r8, r8)
    c270:	0000561d 	.word	0x0000561d
    c274:	000055f1 	.word	0x000055f1
    c278:	0000c471 	.word	0x0000c471

0000c27c <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
    c27c:	b590      	push	{r4, r7, lr}
    c27e:	b087      	sub	sp, #28
    c280:	af00      	add	r7, sp, #0
    c282:	60f8      	str	r0, [r7, #12]
    c284:	60b9      	str	r1, [r7, #8]
    c286:	603b      	str	r3, [r7, #0]
    c288:	1dfb      	adds	r3, r7, #7
    c28a:	701a      	strb	r2, [r3, #0]
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
    c28c:	2328      	movs	r3, #40	; 0x28
    c28e:	18fb      	adds	r3, r7, r3
    c290:	781b      	ldrb	r3, [r3, #0]
    c292:	2201      	movs	r2, #1
    c294:	4013      	ands	r3, r2
    c296:	d001      	beq.n	c29c <tcp_create_segment+0x20>
    c298:	2204      	movs	r2, #4
    c29a:	e000      	b.n	c29e <tcp_create_segment+0x22>
    c29c:	2200      	movs	r2, #0
    c29e:	2328      	movs	r3, #40	; 0x28
    c2a0:	18fb      	adds	r3, r7, r3
    c2a2:	781b      	ldrb	r3, [r3, #0]
    c2a4:	2102      	movs	r1, #2
    c2a6:	400b      	ands	r3, r1
    c2a8:	d001      	beq.n	c2ae <tcp_create_segment+0x32>
    c2aa:	230c      	movs	r3, #12
    c2ac:	e000      	b.n	c2b0 <tcp_create_segment+0x34>
    c2ae:	2300      	movs	r3, #0
    c2b0:	2117      	movs	r1, #23
    c2b2:	1879      	adds	r1, r7, r1
    c2b4:	18d3      	adds	r3, r2, r3
    c2b6:	700b      	strb	r3, [r1, #0]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    c2b8:	2003      	movs	r0, #3
    c2ba:	4b67      	ldr	r3, [pc, #412]	; (c458 <tcp_create_segment+0x1dc>)
    c2bc:	4798      	blx	r3
    c2be:	0003      	movs	r3, r0
    c2c0:	613b      	str	r3, [r7, #16]
    c2c2:	693b      	ldr	r3, [r7, #16]
    c2c4:	2b00      	cmp	r3, #0
    c2c6:	d105      	bne.n	c2d4 <tcp_create_segment+0x58>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    c2c8:	68bb      	ldr	r3, [r7, #8]
    c2ca:	0018      	movs	r0, r3
    c2cc:	4b63      	ldr	r3, [pc, #396]	; (c45c <tcp_create_segment+0x1e0>)
    c2ce:	4798      	blx	r3
    return NULL;
    c2d0:	2300      	movs	r3, #0
    c2d2:	e0bd      	b.n	c450 <tcp_create_segment+0x1d4>
  }
  seg->flags = optflags;
    c2d4:	693b      	ldr	r3, [r7, #16]
    c2d6:	2228      	movs	r2, #40	; 0x28
    c2d8:	18ba      	adds	r2, r7, r2
    c2da:	7812      	ldrb	r2, [r2, #0]
    c2dc:	729a      	strb	r2, [r3, #10]
  seg->next = NULL;
    c2de:	693b      	ldr	r3, [r7, #16]
    c2e0:	2200      	movs	r2, #0
    c2e2:	601a      	str	r2, [r3, #0]
  seg->p = p;
    c2e4:	693b      	ldr	r3, [r7, #16]
    c2e6:	68ba      	ldr	r2, [r7, #8]
    c2e8:	605a      	str	r2, [r3, #4]
  seg->len = p->tot_len - optlen;
    c2ea:	68bb      	ldr	r3, [r7, #8]
    c2ec:	891a      	ldrh	r2, [r3, #8]
    c2ee:	2317      	movs	r3, #23
    c2f0:	18fb      	adds	r3, r7, r3
    c2f2:	781b      	ldrb	r3, [r3, #0]
    c2f4:	b29b      	uxth	r3, r3
    c2f6:	1ad3      	subs	r3, r2, r3
    c2f8:	b29a      	uxth	r2, r3
    c2fa:	693b      	ldr	r3, [r7, #16]
    c2fc:	811a      	strh	r2, [r3, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    c2fe:	68bb      	ldr	r3, [r7, #8]
    c300:	2114      	movs	r1, #20
    c302:	0018      	movs	r0, r3
    c304:	4b56      	ldr	r3, [pc, #344]	; (c460 <tcp_create_segment+0x1e4>)
    c306:	4798      	blx	r3
    c308:	1e03      	subs	r3, r0, #0
    c30a:	d005      	beq.n	c318 <tcp_create_segment+0x9c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    c30c:	693b      	ldr	r3, [r7, #16]
    c30e:	0018      	movs	r0, r3
    c310:	4b54      	ldr	r3, [pc, #336]	; (c464 <tcp_create_segment+0x1e8>)
    c312:	4798      	blx	r3
    return NULL;
    c314:	2300      	movs	r3, #0
    c316:	e09b      	b.n	c450 <tcp_create_segment+0x1d4>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
    c318:	693b      	ldr	r3, [r7, #16]
    c31a:	685b      	ldr	r3, [r3, #4]
    c31c:	685a      	ldr	r2, [r3, #4]
    c31e:	693b      	ldr	r3, [r7, #16]
    c320:	60da      	str	r2, [r3, #12]
  seg->tcphdr->src = htons(pcb->local_port);
    c322:	693b      	ldr	r3, [r7, #16]
    c324:	68dc      	ldr	r4, [r3, #12]
    c326:	68fb      	ldr	r3, [r7, #12]
    c328:	8b5b      	ldrh	r3, [r3, #26]
    c32a:	0018      	movs	r0, r3
    c32c:	4b4e      	ldr	r3, [pc, #312]	; (c468 <tcp_create_segment+0x1ec>)
    c32e:	4798      	blx	r3
    c330:	0003      	movs	r3, r0
    c332:	22ff      	movs	r2, #255	; 0xff
    c334:	401a      	ands	r2, r3
    c336:	0010      	movs	r0, r2
    c338:	7822      	ldrb	r2, [r4, #0]
    c33a:	2100      	movs	r1, #0
    c33c:	400a      	ands	r2, r1
    c33e:	1c11      	adds	r1, r2, #0
    c340:	1c02      	adds	r2, r0, #0
    c342:	430a      	orrs	r2, r1
    c344:	7022      	strb	r2, [r4, #0]
    c346:	0a1b      	lsrs	r3, r3, #8
    c348:	b299      	uxth	r1, r3
    c34a:	7863      	ldrb	r3, [r4, #1]
    c34c:	2200      	movs	r2, #0
    c34e:	4013      	ands	r3, r2
    c350:	1c1a      	adds	r2, r3, #0
    c352:	1c0b      	adds	r3, r1, #0
    c354:	4313      	orrs	r3, r2
    c356:	7063      	strb	r3, [r4, #1]
  seg->tcphdr->dest = htons(pcb->remote_port);
    c358:	693b      	ldr	r3, [r7, #16]
    c35a:	68dc      	ldr	r4, [r3, #12]
    c35c:	68fb      	ldr	r3, [r7, #12]
    c35e:	8b9b      	ldrh	r3, [r3, #28]
    c360:	0018      	movs	r0, r3
    c362:	4b41      	ldr	r3, [pc, #260]	; (c468 <tcp_create_segment+0x1ec>)
    c364:	4798      	blx	r3
    c366:	0003      	movs	r3, r0
    c368:	22ff      	movs	r2, #255	; 0xff
    c36a:	401a      	ands	r2, r3
    c36c:	0010      	movs	r0, r2
    c36e:	78a2      	ldrb	r2, [r4, #2]
    c370:	2100      	movs	r1, #0
    c372:	400a      	ands	r2, r1
    c374:	1c11      	adds	r1, r2, #0
    c376:	1c02      	adds	r2, r0, #0
    c378:	430a      	orrs	r2, r1
    c37a:	70a2      	strb	r2, [r4, #2]
    c37c:	0a1b      	lsrs	r3, r3, #8
    c37e:	b299      	uxth	r1, r3
    c380:	78e3      	ldrb	r3, [r4, #3]
    c382:	2200      	movs	r2, #0
    c384:	4013      	ands	r3, r2
    c386:	1c1a      	adds	r2, r3, #0
    c388:	1c0b      	adds	r3, r1, #0
    c38a:	4313      	orrs	r3, r2
    c38c:	70e3      	strb	r3, [r4, #3]
  seg->tcphdr->seqno = htonl(seqno);
    c38e:	693b      	ldr	r3, [r7, #16]
    c390:	68dc      	ldr	r4, [r3, #12]
    c392:	683b      	ldr	r3, [r7, #0]
    c394:	0018      	movs	r0, r3
    c396:	4b35      	ldr	r3, [pc, #212]	; (c46c <tcp_create_segment+0x1f0>)
    c398:	4798      	blx	r3
    c39a:	0003      	movs	r3, r0
    c39c:	22ff      	movs	r2, #255	; 0xff
    c39e:	401a      	ands	r2, r3
    c3a0:	0010      	movs	r0, r2
    c3a2:	7922      	ldrb	r2, [r4, #4]
    c3a4:	2100      	movs	r1, #0
    c3a6:	400a      	ands	r2, r1
    c3a8:	1c11      	adds	r1, r2, #0
    c3aa:	1c02      	adds	r2, r0, #0
    c3ac:	430a      	orrs	r2, r1
    c3ae:	7122      	strb	r2, [r4, #4]
    c3b0:	0a1a      	lsrs	r2, r3, #8
    c3b2:	21ff      	movs	r1, #255	; 0xff
    c3b4:	400a      	ands	r2, r1
    c3b6:	0010      	movs	r0, r2
    c3b8:	7962      	ldrb	r2, [r4, #5]
    c3ba:	2100      	movs	r1, #0
    c3bc:	400a      	ands	r2, r1
    c3be:	1c11      	adds	r1, r2, #0
    c3c0:	1c02      	adds	r2, r0, #0
    c3c2:	430a      	orrs	r2, r1
    c3c4:	7162      	strb	r2, [r4, #5]
    c3c6:	0c1a      	lsrs	r2, r3, #16
    c3c8:	21ff      	movs	r1, #255	; 0xff
    c3ca:	400a      	ands	r2, r1
    c3cc:	0010      	movs	r0, r2
    c3ce:	79a2      	ldrb	r2, [r4, #6]
    c3d0:	2100      	movs	r1, #0
    c3d2:	400a      	ands	r2, r1
    c3d4:	1c11      	adds	r1, r2, #0
    c3d6:	1c02      	adds	r2, r0, #0
    c3d8:	430a      	orrs	r2, r1
    c3da:	71a2      	strb	r2, [r4, #6]
    c3dc:	0e19      	lsrs	r1, r3, #24
    c3de:	79e3      	ldrb	r3, [r4, #7]
    c3e0:	2200      	movs	r2, #0
    c3e2:	4013      	ands	r3, r2
    c3e4:	1c1a      	adds	r2, r3, #0
    c3e6:	1c0b      	adds	r3, r1, #0
    c3e8:	4313      	orrs	r3, r2
    c3ea:	71e3      	strb	r3, [r4, #7]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
    c3ec:	693b      	ldr	r3, [r7, #16]
    c3ee:	68dc      	ldr	r4, [r3, #12]
    c3f0:	2317      	movs	r3, #23
    c3f2:	18fb      	adds	r3, r7, r3
    c3f4:	781b      	ldrb	r3, [r3, #0]
    c3f6:	089b      	lsrs	r3, r3, #2
    c3f8:	b2db      	uxtb	r3, r3
    c3fa:	3305      	adds	r3, #5
    c3fc:	031b      	lsls	r3, r3, #12
    c3fe:	b21a      	sxth	r2, r3
    c400:	1dfb      	adds	r3, r7, #7
    c402:	781b      	ldrb	r3, [r3, #0]
    c404:	b21b      	sxth	r3, r3
    c406:	4313      	orrs	r3, r2
    c408:	b21b      	sxth	r3, r3
    c40a:	b29b      	uxth	r3, r3
    c40c:	0018      	movs	r0, r3
    c40e:	4b16      	ldr	r3, [pc, #88]	; (c468 <tcp_create_segment+0x1ec>)
    c410:	4798      	blx	r3
    c412:	0003      	movs	r3, r0
    c414:	22ff      	movs	r2, #255	; 0xff
    c416:	401a      	ands	r2, r3
    c418:	0010      	movs	r0, r2
    c41a:	7b22      	ldrb	r2, [r4, #12]
    c41c:	2100      	movs	r1, #0
    c41e:	400a      	ands	r2, r1
    c420:	1c11      	adds	r1, r2, #0
    c422:	1c02      	adds	r2, r0, #0
    c424:	430a      	orrs	r2, r1
    c426:	7322      	strb	r2, [r4, #12]
    c428:	0a1b      	lsrs	r3, r3, #8
    c42a:	b299      	uxth	r1, r3
    c42c:	7b63      	ldrb	r3, [r4, #13]
    c42e:	2200      	movs	r2, #0
    c430:	4013      	ands	r3, r2
    c432:	1c1a      	adds	r2, r3, #0
    c434:	1c0b      	adds	r3, r1, #0
    c436:	4313      	orrs	r3, r2
    c438:	7363      	strb	r3, [r4, #13]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
    c43a:	693b      	ldr	r3, [r7, #16]
    c43c:	68db      	ldr	r3, [r3, #12]
    c43e:	7c9a      	ldrb	r2, [r3, #18]
    c440:	2100      	movs	r1, #0
    c442:	400a      	ands	r2, r1
    c444:	749a      	strb	r2, [r3, #18]
    c446:	7cda      	ldrb	r2, [r3, #19]
    c448:	2100      	movs	r1, #0
    c44a:	400a      	ands	r2, r1
    c44c:	74da      	strb	r2, [r3, #19]
  return seg;
    c44e:	693b      	ldr	r3, [r7, #16]
} 
    c450:	0018      	movs	r0, r3
    c452:	46bd      	mov	sp, r7
    c454:	b007      	add	sp, #28
    c456:	bd90      	pop	{r4, r7, pc}
    c458:	00007af1 	.word	0x00007af1
    c45c:	00008349 	.word	0x00008349
    c460:	00008235 	.word	0x00008235
    c464:	000093ad 	.word	0x000093ad
    c468:	000055f1 	.word	0x000055f1
    c46c:	00005641 	.word	0x00005641

0000c470 <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
    c470:	b590      	push	{r4, r7, lr}
    c472:	b08b      	sub	sp, #44	; 0x2c
    c474:	af02      	add	r7, sp, #8
    c476:	6078      	str	r0, [r7, #4]
    c478:	000a      	movs	r2, r1
    c47a:	1cfb      	adds	r3, r7, #3
    c47c:	701a      	strb	r2, [r3, #0]
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
    c47e:	231f      	movs	r3, #31
    c480:	18fb      	adds	r3, r7, r3
    c482:	2200      	movs	r2, #0
    c484:	701a      	strb	r2, [r3, #0]
  u8_t optlen = 0;
    c486:	2317      	movs	r3, #23
    c488:	18fb      	adds	r3, r7, r3
    c48a:	2200      	movs	r2, #0
    c48c:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
    c48e:	687b      	ldr	r3, [r7, #4]
    c490:	2268      	movs	r2, #104	; 0x68
    c492:	5a9b      	ldrh	r3, [r3, r2]
    c494:	2b07      	cmp	r3, #7
    c496:	d805      	bhi.n	c4a4 <tcp_enqueue_flags+0x34>
    c498:	687b      	ldr	r3, [r7, #4]
    c49a:	2268      	movs	r2, #104	; 0x68
    c49c:	5a9b      	ldrh	r3, [r3, r2]
    c49e:	4a5e      	ldr	r2, [pc, #376]	; (c618 <tcp_enqueue_flags+0x1a8>)
    c4a0:	4293      	cmp	r3, r2
    c4a2:	d90a      	bls.n	c4ba <tcp_enqueue_flags+0x4a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    c4a4:	687b      	ldr	r3, [r7, #4]
    c4a6:	7f9b      	ldrb	r3, [r3, #30]
    c4a8:	2280      	movs	r2, #128	; 0x80
    c4aa:	4252      	negs	r2, r2
    c4ac:	4313      	orrs	r3, r2
    c4ae:	b2da      	uxtb	r2, r3
    c4b0:	687b      	ldr	r3, [r7, #4]
    c4b2:	779a      	strb	r2, [r3, #30]
    return ERR_MEM;
    c4b4:	2301      	movs	r3, #1
    c4b6:	425b      	negs	r3, r3
    c4b8:	e0aa      	b.n	c610 <tcp_enqueue_flags+0x1a0>
  }

  if (flags & TCP_SYN) {
    c4ba:	1cfb      	adds	r3, r7, #3
    c4bc:	781b      	ldrb	r3, [r3, #0]
    c4be:	2202      	movs	r2, #2
    c4c0:	4013      	ands	r3, r2
    c4c2:	d003      	beq.n	c4cc <tcp_enqueue_flags+0x5c>
    optflags = TF_SEG_OPTS_MSS;
    c4c4:	231f      	movs	r3, #31
    c4c6:	18fb      	adds	r3, r7, r3
    c4c8:	2201      	movs	r2, #1
    c4ca:	701a      	strb	r2, [r3, #0]
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
    c4cc:	231f      	movs	r3, #31
    c4ce:	18fb      	adds	r3, r7, r3
    c4d0:	781b      	ldrb	r3, [r3, #0]
    c4d2:	2201      	movs	r2, #1
    c4d4:	4013      	ands	r3, r2
    c4d6:	d001      	beq.n	c4dc <tcp_enqueue_flags+0x6c>
    c4d8:	2204      	movs	r2, #4
    c4da:	e000      	b.n	c4de <tcp_enqueue_flags+0x6e>
    c4dc:	2200      	movs	r2, #0
    c4de:	231f      	movs	r3, #31
    c4e0:	18fb      	adds	r3, r7, r3
    c4e2:	781b      	ldrb	r3, [r3, #0]
    c4e4:	2102      	movs	r1, #2
    c4e6:	400b      	ands	r3, r1
    c4e8:	d001      	beq.n	c4ee <tcp_enqueue_flags+0x7e>
    c4ea:	230c      	movs	r3, #12
    c4ec:	e000      	b.n	c4f0 <tcp_enqueue_flags+0x80>
    c4ee:	2300      	movs	r3, #0
    c4f0:	2117      	movs	r1, #23
    c4f2:	1879      	adds	r1, r7, r1
    c4f4:	18d3      	adds	r3, r2, r3
    c4f6:	700b      	strb	r3, [r1, #0]

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    c4f8:	687b      	ldr	r3, [r7, #4]
    c4fa:	2266      	movs	r2, #102	; 0x66
    c4fc:	5a9b      	ldrh	r3, [r3, r2]
    c4fe:	2b00      	cmp	r3, #0
    c500:	d102      	bne.n	c508 <tcp_enqueue_flags+0x98>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
    c502:	2301      	movs	r3, #1
    c504:	425b      	negs	r3, r3
    c506:	e083      	b.n	c610 <tcp_enqueue_flags+0x1a0>
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    c508:	2317      	movs	r3, #23
    c50a:	18fb      	adds	r3, r7, r3
    c50c:	781b      	ldrb	r3, [r3, #0]
    c50e:	b29b      	uxth	r3, r3
    c510:	2200      	movs	r2, #0
    c512:	0019      	movs	r1, r3
    c514:	2000      	movs	r0, #0
    c516:	4b41      	ldr	r3, [pc, #260]	; (c61c <tcp_enqueue_flags+0x1ac>)
    c518:	4798      	blx	r3
    c51a:	0003      	movs	r3, r0
    c51c:	613b      	str	r3, [r7, #16]
    c51e:	693b      	ldr	r3, [r7, #16]
    c520:	2b00      	cmp	r3, #0
    c522:	d10a      	bne.n	c53a <tcp_enqueue_flags+0xca>
    pcb->flags |= TF_NAGLEMEMERR;
    c524:	687b      	ldr	r3, [r7, #4]
    c526:	7f9b      	ldrb	r3, [r3, #30]
    c528:	2280      	movs	r2, #128	; 0x80
    c52a:	4252      	negs	r2, r2
    c52c:	4313      	orrs	r3, r2
    c52e:	b2da      	uxtb	r2, r3
    c530:	687b      	ldr	r3, [r7, #4]
    c532:	779a      	strb	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
    c534:	2301      	movs	r3, #1
    c536:	425b      	negs	r3, r3
    c538:	e06a      	b.n	c610 <tcp_enqueue_flags+0x1a0>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    c53a:	687b      	ldr	r3, [r7, #4]
    c53c:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
    c53e:	1cfb      	adds	r3, r7, #3
    c540:	781a      	ldrb	r2, [r3, #0]
    c542:	6939      	ldr	r1, [r7, #16]
    c544:	6878      	ldr	r0, [r7, #4]
    c546:	231f      	movs	r3, #31
    c548:	18fb      	adds	r3, r7, r3
    c54a:	781b      	ldrb	r3, [r3, #0]
    c54c:	9300      	str	r3, [sp, #0]
    c54e:	0023      	movs	r3, r4
    c550:	4c33      	ldr	r4, [pc, #204]	; (c620 <tcp_enqueue_flags+0x1b0>)
    c552:	47a0      	blx	r4
    c554:	0003      	movs	r3, r0
    c556:	60fb      	str	r3, [r7, #12]
    c558:	68fb      	ldr	r3, [r7, #12]
    c55a:	2b00      	cmp	r3, #0
    c55c:	d10a      	bne.n	c574 <tcp_enqueue_flags+0x104>
    pcb->flags |= TF_NAGLEMEMERR;
    c55e:	687b      	ldr	r3, [r7, #4]
    c560:	7f9b      	ldrb	r3, [r3, #30]
    c562:	2280      	movs	r2, #128	; 0x80
    c564:	4252      	negs	r2, r2
    c566:	4313      	orrs	r3, r2
    c568:	b2da      	uxtb	r2, r3
    c56a:	687b      	ldr	r3, [r7, #4]
    c56c:	779a      	strb	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
    c56e:	2301      	movs	r3, #1
    c570:	425b      	negs	r3, r3
    c572:	e04d      	b.n	c610 <tcp_enqueue_flags+0x1a0>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
    c574:	687b      	ldr	r3, [r7, #4]
    c576:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c578:	2b00      	cmp	r3, #0
    c57a:	d103      	bne.n	c584 <tcp_enqueue_flags+0x114>
    pcb->unsent = seg;
    c57c:	687b      	ldr	r3, [r7, #4]
    c57e:	68fa      	ldr	r2, [r7, #12]
    c580:	66da      	str	r2, [r3, #108]	; 0x6c
    c582:	e00d      	b.n	c5a0 <tcp_enqueue_flags+0x130>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    c584:	687b      	ldr	r3, [r7, #4]
    c586:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c588:	61bb      	str	r3, [r7, #24]
    c58a:	e002      	b.n	c592 <tcp_enqueue_flags+0x122>
    c58c:	69bb      	ldr	r3, [r7, #24]
    c58e:	681b      	ldr	r3, [r3, #0]
    c590:	61bb      	str	r3, [r7, #24]
    c592:	69bb      	ldr	r3, [r7, #24]
    c594:	681b      	ldr	r3, [r3, #0]
    c596:	2b00      	cmp	r3, #0
    c598:	d1f8      	bne.n	c58c <tcp_enqueue_flags+0x11c>
    useg->next = seg;
    c59a:	69bb      	ldr	r3, [r7, #24]
    c59c:	68fa      	ldr	r2, [r7, #12]
    c59e:	601a      	str	r2, [r3, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
    c5a0:	687b      	ldr	r3, [r7, #4]
    c5a2:	226a      	movs	r2, #106	; 0x6a
    c5a4:	2100      	movs	r1, #0
    c5a6:	5299      	strh	r1, [r3, r2]
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    c5a8:	1cfb      	adds	r3, r7, #3
    c5aa:	781b      	ldrb	r3, [r3, #0]
    c5ac:	2202      	movs	r2, #2
    c5ae:	4013      	ands	r3, r2
    c5b0:	d104      	bne.n	c5bc <tcp_enqueue_flags+0x14c>
    c5b2:	1cfb      	adds	r3, r7, #3
    c5b4:	781b      	ldrb	r3, [r3, #0]
    c5b6:	2201      	movs	r2, #1
    c5b8:	4013      	ands	r3, r2
    c5ba:	d00c      	beq.n	c5d6 <tcp_enqueue_flags+0x166>
    pcb->snd_lbb++;
    c5bc:	687b      	ldr	r3, [r7, #4]
    c5be:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    c5c0:	1c5a      	adds	r2, r3, #1
    c5c2:	687b      	ldr	r3, [r7, #4]
    c5c4:	65da      	str	r2, [r3, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
    c5c6:	687b      	ldr	r3, [r7, #4]
    c5c8:	2266      	movs	r2, #102	; 0x66
    c5ca:	5a9b      	ldrh	r3, [r3, r2]
    c5cc:	3b01      	subs	r3, #1
    c5ce:	b299      	uxth	r1, r3
    c5d0:	687b      	ldr	r3, [r7, #4]
    c5d2:	2266      	movs	r2, #102	; 0x66
    c5d4:	5299      	strh	r1, [r3, r2]
  }
  if (flags & TCP_FIN) {
    c5d6:	1cfb      	adds	r3, r7, #3
    c5d8:	781b      	ldrb	r3, [r3, #0]
    c5da:	2201      	movs	r2, #1
    c5dc:	4013      	ands	r3, r2
    c5de:	d006      	beq.n	c5ee <tcp_enqueue_flags+0x17e>
    pcb->flags |= TF_FIN;
    c5e0:	687b      	ldr	r3, [r7, #4]
    c5e2:	7f9b      	ldrb	r3, [r3, #30]
    c5e4:	2220      	movs	r2, #32
    c5e6:	4313      	orrs	r3, r2
    c5e8:	b2da      	uxtb	r2, r3
    c5ea:	687b      	ldr	r3, [r7, #4]
    c5ec:	779a      	strb	r2, [r3, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
    c5ee:	68fb      	ldr	r3, [r7, #12]
    c5f0:	685b      	ldr	r3, [r3, #4]
    c5f2:	0018      	movs	r0, r3
    c5f4:	4b0b      	ldr	r3, [pc, #44]	; (c624 <tcp_enqueue_flags+0x1b4>)
    c5f6:	4798      	blx	r3
    c5f8:	0003      	movs	r3, r0
    c5fa:	0019      	movs	r1, r3
    c5fc:	687b      	ldr	r3, [r7, #4]
    c5fe:	2268      	movs	r2, #104	; 0x68
    c600:	5a9a      	ldrh	r2, [r3, r2]
    c602:	b28b      	uxth	r3, r1
    c604:	18d3      	adds	r3, r2, r3
    c606:	b299      	uxth	r1, r3
    c608:	687b      	ldr	r3, [r7, #4]
    c60a:	2268      	movs	r2, #104	; 0x68
    c60c:	5299      	strh	r1, [r3, r2]
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
    c60e:	2300      	movs	r3, #0
}
    c610:	0018      	movs	r0, r3
    c612:	46bd      	mov	sp, r7
    c614:	b009      	add	sp, #36	; 0x24
    c616:	bd90      	pop	{r4, r7, pc}
    c618:	0000fffc 	.word	0x0000fffc
    c61c:	00007e19 	.word	0x00007e19
    c620:	0000c27d 	.word	0x0000c27d
    c624:	00008431 	.word	0x00008431

0000c628 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
    c628:	b5b0      	push	{r4, r5, r7, lr}
    c62a:	b088      	sub	sp, #32
    c62c:	af02      	add	r7, sp, #8
    c62e:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
    c630:	2317      	movs	r3, #23
    c632:	18fb      	adds	r3, r7, r3
    c634:	2200      	movs	r2, #0
    c636:	701a      	strb	r2, [r3, #0]
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
    c638:	2317      	movs	r3, #23
    c63a:	18fb      	adds	r3, r7, r3
    c63c:	781b      	ldrb	r3, [r3, #0]
    c63e:	b29c      	uxth	r4, r3
    c640:	687b      	ldr	r3, [r7, #4]
    c642:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    c644:	0018      	movs	r0, r3
    c646:	4b19      	ldr	r3, [pc, #100]	; (c6ac <tcp_send_empty_ack+0x84>)
    c648:	4798      	blx	r3
    c64a:	0003      	movs	r3, r0
    c64c:	6878      	ldr	r0, [r7, #4]
    c64e:	2200      	movs	r2, #0
    c650:	0021      	movs	r1, r4
    c652:	4c17      	ldr	r4, [pc, #92]	; (c6b0 <tcp_send_empty_ack+0x88>)
    c654:	47a0      	blx	r4
    c656:	0003      	movs	r3, r0
    c658:	613b      	str	r3, [r7, #16]
  if (p == NULL) {
    c65a:	693b      	ldr	r3, [r7, #16]
    c65c:	2b00      	cmp	r3, #0
    c65e:	d102      	bne.n	c666 <tcp_send_empty_ack+0x3e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
    c660:	2302      	movs	r3, #2
    c662:	425b      	negs	r3, r3
    c664:	e01d      	b.n	c6a2 <tcp_send_empty_ack+0x7a>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    c666:	693b      	ldr	r3, [r7, #16]
    c668:	685b      	ldr	r3, [r3, #4]
    c66a:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    c66c:	687b      	ldr	r3, [r7, #4]
    c66e:	7f9b      	ldrb	r3, [r3, #30]
    c670:	2203      	movs	r2, #3
    c672:	4393      	bics	r3, r2
    c674:	b2da      	uxtb	r2, r3
    c676:	687b      	ldr	r3, [r7, #4]
    c678:	779a      	strb	r2, [r3, #30]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
    c67a:	6879      	ldr	r1, [r7, #4]
    c67c:	687b      	ldr	r3, [r7, #4]
    c67e:	1d1c      	adds	r4, r3, #4
    c680:	687b      	ldr	r3, [r7, #4]
    c682:	7a9d      	ldrb	r5, [r3, #10]
    c684:	687b      	ldr	r3, [r7, #4]
    c686:	7a5b      	ldrb	r3, [r3, #9]
    c688:	6938      	ldr	r0, [r7, #16]
    c68a:	2206      	movs	r2, #6
    c68c:	9201      	str	r2, [sp, #4]
    c68e:	9300      	str	r3, [sp, #0]
    c690:	002b      	movs	r3, r5
    c692:	0022      	movs	r2, r4
    c694:	4c07      	ldr	r4, [pc, #28]	; (c6b4 <tcp_send_empty_ack+0x8c>)
    c696:	47a0      	blx	r4
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
    c698:	693b      	ldr	r3, [r7, #16]
    c69a:	0018      	movs	r0, r3
    c69c:	4b06      	ldr	r3, [pc, #24]	; (c6b8 <tcp_send_empty_ack+0x90>)
    c69e:	4798      	blx	r3

  return ERR_OK;
    c6a0:	2300      	movs	r3, #0
}
    c6a2:	0018      	movs	r0, r3
    c6a4:	46bd      	mov	sp, r7
    c6a6:	b006      	add	sp, #24
    c6a8:	bdb0      	pop	{r4, r5, r7, pc}
    c6aa:	46c0      	nop			; (mov r8, r8)
    c6ac:	00005641 	.word	0x00005641
    c6b0:	0000bf95 	.word	0x0000bf95
    c6b4:	0000620d 	.word	0x0000620d
    c6b8:	00008349 	.word	0x00008349

0000c6bc <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
    c6bc:	b5b0      	push	{r4, r5, r7, lr}
    c6be:	b088      	sub	sp, #32
    c6c0:	af00      	add	r7, sp, #0
    c6c2:	6078      	str	r0, [r7, #4]

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    c6c4:	4bc6      	ldr	r3, [pc, #792]	; (c9e0 <tcp_output+0x324>)
    c6c6:	681a      	ldr	r2, [r3, #0]
    c6c8:	687b      	ldr	r3, [r7, #4]
    c6ca:	429a      	cmp	r2, r3
    c6cc:	d101      	bne.n	c6d2 <tcp_output+0x16>
    return ERR_OK;
    c6ce:	2300      	movs	r3, #0
    c6d0:	e1a5      	b.n	ca1e <tcp_output+0x362>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
    c6d2:	687b      	ldr	r3, [r7, #4]
    c6d4:	224c      	movs	r2, #76	; 0x4c
    c6d6:	5a99      	ldrh	r1, [r3, r2]
    c6d8:	687b      	ldr	r3, [r7, #4]
    c6da:	2260      	movs	r2, #96	; 0x60
    c6dc:	5a9b      	ldrh	r3, [r3, r2]
    c6de:	1c18      	adds	r0, r3, #0
    c6e0:	b28a      	uxth	r2, r1
    c6e2:	b283      	uxth	r3, r0
    c6e4:	429a      	cmp	r2, r3
    c6e6:	d900      	bls.n	c6ea <tcp_output+0x2e>
    c6e8:	1c01      	adds	r1, r0, #0
    c6ea:	b28b      	uxth	r3, r1
    c6ec:	613b      	str	r3, [r7, #16]

  seg = pcb->unsent;
    c6ee:	687b      	ldr	r3, [r7, #4]
    c6f0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c6f2:	61fb      	str	r3, [r7, #28]
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
    c6f4:	687b      	ldr	r3, [r7, #4]
    c6f6:	7f9b      	ldrb	r3, [r3, #30]
    c6f8:	001a      	movs	r2, r3
    c6fa:	2302      	movs	r3, #2
    c6fc:	4013      	ands	r3, r2
    c6fe:	d021      	beq.n	c744 <tcp_output+0x88>
    c700:	69fb      	ldr	r3, [r7, #28]
    c702:	2b00      	cmp	r3, #0
    c704:	d018      	beq.n	c738 <tcp_output+0x7c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    c706:	69fb      	ldr	r3, [r7, #28]
    c708:	68db      	ldr	r3, [r3, #12]
    c70a:	791a      	ldrb	r2, [r3, #4]
    c70c:	7959      	ldrb	r1, [r3, #5]
    c70e:	0209      	lsls	r1, r1, #8
    c710:	430a      	orrs	r2, r1
    c712:	7999      	ldrb	r1, [r3, #6]
    c714:	0409      	lsls	r1, r1, #16
    c716:	430a      	orrs	r2, r1
    c718:	79db      	ldrb	r3, [r3, #7]
    c71a:	061b      	lsls	r3, r3, #24
    c71c:	4313      	orrs	r3, r2
    c71e:	0018      	movs	r0, r3
    c720:	4bb0      	ldr	r3, [pc, #704]	; (c9e4 <tcp_output+0x328>)
    c722:	4798      	blx	r3
    c724:	0002      	movs	r2, r0
    c726:	687b      	ldr	r3, [r7, #4]
    c728:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    c72a:	1ad3      	subs	r3, r2, r3
    c72c:	69fa      	ldr	r2, [r7, #28]
    c72e:	8912      	ldrh	r2, [r2, #8]
    c730:	189a      	adds	r2, r3, r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
    c732:	693b      	ldr	r3, [r7, #16]
    c734:	429a      	cmp	r2, r3
    c736:	d905      	bls.n	c744 <tcp_output+0x88>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
    c738:	687b      	ldr	r3, [r7, #4]
    c73a:	0018      	movs	r0, r3
    c73c:	4baa      	ldr	r3, [pc, #680]	; (c9e8 <tcp_output+0x32c>)
    c73e:	4798      	blx	r3
    c740:	0003      	movs	r3, r0
    c742:	e16c      	b.n	ca1e <tcp_output+0x362>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
    c744:	687b      	ldr	r3, [r7, #4]
    c746:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    c748:	61bb      	str	r3, [r7, #24]
  if (useg != NULL) {
    c74a:	69bb      	ldr	r3, [r7, #24]
    c74c:	2b00      	cmp	r3, #0
    c74e:	d100      	bne.n	c752 <tcp_output+0x96>
    c750:	e128      	b.n	c9a4 <tcp_output+0x2e8>
    for (; useg->next != NULL; useg = useg->next);
    c752:	e002      	b.n	c75a <tcp_output+0x9e>
    c754:	69bb      	ldr	r3, [r7, #24]
    c756:	681b      	ldr	r3, [r3, #0]
    c758:	61bb      	str	r3, [r7, #24]
    c75a:	69bb      	ldr	r3, [r7, #24]
    c75c:	681b      	ldr	r3, [r3, #0]
    c75e:	2b00      	cmp	r3, #0
    c760:	d1f8      	bne.n	c754 <tcp_output+0x98>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c762:	e11f      	b.n	c9a4 <tcp_output+0x2e8>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
    c764:	687b      	ldr	r3, [r7, #4]
    c766:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    c768:	2b00      	cmp	r3, #0
    c76a:	d01f      	beq.n	c7ac <tcp_output+0xf0>
    c76c:	687b      	ldr	r3, [r7, #4]
    c76e:	7f9b      	ldrb	r3, [r3, #30]
    c770:	001a      	movs	r2, r3
    c772:	2344      	movs	r3, #68	; 0x44
    c774:	4013      	ands	r3, r2
    c776:	d119      	bne.n	c7ac <tcp_output+0xf0>
    c778:	687b      	ldr	r3, [r7, #4]
    c77a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c77c:	2b00      	cmp	r3, #0
    c77e:	d00b      	beq.n	c798 <tcp_output+0xdc>
    c780:	687b      	ldr	r3, [r7, #4]
    c782:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c784:	681b      	ldr	r3, [r3, #0]
    c786:	2b00      	cmp	r3, #0
    c788:	d110      	bne.n	c7ac <tcp_output+0xf0>
    c78a:	687b      	ldr	r3, [r7, #4]
    c78c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c78e:	891a      	ldrh	r2, [r3, #8]
    c790:	687b      	ldr	r3, [r7, #4]
    c792:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    c794:	429a      	cmp	r2, r3
    c796:	d209      	bcs.n	c7ac <tcp_output+0xf0>
    c798:	687b      	ldr	r3, [r7, #4]
    c79a:	2266      	movs	r2, #102	; 0x66
    c79c:	5a9b      	ldrh	r3, [r3, r2]
    c79e:	2b00      	cmp	r3, #0
    c7a0:	d004      	beq.n	c7ac <tcp_output+0xf0>
    c7a2:	687b      	ldr	r3, [r7, #4]
    c7a4:	2268      	movs	r2, #104	; 0x68
    c7a6:	5a9b      	ldrh	r3, [r3, r2]
    c7a8:	2b07      	cmp	r3, #7
    c7aa:	d901      	bls.n	c7b0 <tcp_output+0xf4>
    c7ac:	2301      	movs	r3, #1
    c7ae:	e000      	b.n	c7b2 <tcp_output+0xf6>
    c7b0:	2300      	movs	r3, #0
    c7b2:	2b00      	cmp	r3, #0
    c7b4:	d106      	bne.n	c7c4 <tcp_output+0x108>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
    c7b6:	687b      	ldr	r3, [r7, #4]
    c7b8:	7f9b      	ldrb	r3, [r3, #30]
    c7ba:	001a      	movs	r2, r3
    c7bc:	23a0      	movs	r3, #160	; 0xa0
    c7be:	4013      	ands	r3, r2
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
    c7c0:	d100      	bne.n	c7c4 <tcp_output+0x108>
    c7c2:	e11b      	b.n	c9fc <tcp_output+0x340>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
    c7c4:	69fb      	ldr	r3, [r7, #28]
    c7c6:	681a      	ldr	r2, [r3, #0]
    c7c8:	687b      	ldr	r3, [r7, #4]
    c7ca:	66da      	str	r2, [r3, #108]	; 0x6c

    if (pcb->state != SYN_SENT) {
    c7cc:	687b      	ldr	r3, [r7, #4]
    c7ce:	7e1b      	ldrb	r3, [r3, #24]
    c7d0:	2b02      	cmp	r3, #2
    c7d2:	d028      	beq.n	c826 <tcp_output+0x16a>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
    c7d4:	69fb      	ldr	r3, [r7, #28]
    c7d6:	68dc      	ldr	r4, [r3, #12]
    c7d8:	69fb      	ldr	r3, [r7, #28]
    c7da:	68db      	ldr	r3, [r3, #12]
    c7dc:	7b1a      	ldrb	r2, [r3, #12]
    c7de:	7b5b      	ldrb	r3, [r3, #13]
    c7e0:	021b      	lsls	r3, r3, #8
    c7e2:	4313      	orrs	r3, r2
    c7e4:	b29d      	uxth	r5, r3
    c7e6:	2010      	movs	r0, #16
    c7e8:	4b80      	ldr	r3, [pc, #512]	; (c9ec <tcp_output+0x330>)
    c7ea:	4798      	blx	r3
    c7ec:	0003      	movs	r3, r0
    c7ee:	432b      	orrs	r3, r5
    c7f0:	b29b      	uxth	r3, r3
    c7f2:	22ff      	movs	r2, #255	; 0xff
    c7f4:	401a      	ands	r2, r3
    c7f6:	0010      	movs	r0, r2
    c7f8:	7b22      	ldrb	r2, [r4, #12]
    c7fa:	2100      	movs	r1, #0
    c7fc:	400a      	ands	r2, r1
    c7fe:	1c11      	adds	r1, r2, #0
    c800:	1c02      	adds	r2, r0, #0
    c802:	430a      	orrs	r2, r1
    c804:	7322      	strb	r2, [r4, #12]
    c806:	0a1b      	lsrs	r3, r3, #8
    c808:	b299      	uxth	r1, r3
    c80a:	7b63      	ldrb	r3, [r4, #13]
    c80c:	2200      	movs	r2, #0
    c80e:	4013      	ands	r3, r2
    c810:	1c1a      	adds	r2, r3, #0
    c812:	1c0b      	adds	r3, r1, #0
    c814:	4313      	orrs	r3, r2
    c816:	7363      	strb	r3, [r4, #13]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    c818:	687b      	ldr	r3, [r7, #4]
    c81a:	7f9b      	ldrb	r3, [r3, #30]
    c81c:	2203      	movs	r2, #3
    c81e:	4393      	bics	r3, r2
    c820:	b2da      	uxtb	r2, r3
    c822:	687b      	ldr	r3, [r7, #4]
    c824:	779a      	strb	r2, [r3, #30]
    }

    tcp_output_segment(seg, pcb);
    c826:	687a      	ldr	r2, [r7, #4]
    c828:	69fb      	ldr	r3, [r7, #28]
    c82a:	0011      	movs	r1, r2
    c82c:	0018      	movs	r0, r3
    c82e:	4b70      	ldr	r3, [pc, #448]	; (c9f0 <tcp_output+0x334>)
    c830:	4798      	blx	r3
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    c832:	69fb      	ldr	r3, [r7, #28]
    c834:	68db      	ldr	r3, [r3, #12]
    c836:	791a      	ldrb	r2, [r3, #4]
    c838:	7959      	ldrb	r1, [r3, #5]
    c83a:	0209      	lsls	r1, r1, #8
    c83c:	430a      	orrs	r2, r1
    c83e:	7999      	ldrb	r1, [r3, #6]
    c840:	0409      	lsls	r1, r1, #16
    c842:	430a      	orrs	r2, r1
    c844:	79db      	ldrb	r3, [r3, #7]
    c846:	061b      	lsls	r3, r3, #24
    c848:	4313      	orrs	r3, r2
    c84a:	0018      	movs	r0, r3
    c84c:	4b65      	ldr	r3, [pc, #404]	; (c9e4 <tcp_output+0x328>)
    c84e:	4798      	blx	r3
    c850:	0004      	movs	r4, r0
    c852:	69fb      	ldr	r3, [r7, #28]
    c854:	891b      	ldrh	r3, [r3, #8]
    c856:	001d      	movs	r5, r3
    c858:	69fb      	ldr	r3, [r7, #28]
    c85a:	68db      	ldr	r3, [r3, #12]
    c85c:	7b1a      	ldrb	r2, [r3, #12]
    c85e:	7b5b      	ldrb	r3, [r3, #13]
    c860:	021b      	lsls	r3, r3, #8
    c862:	4313      	orrs	r3, r2
    c864:	b29b      	uxth	r3, r3
    c866:	0018      	movs	r0, r3
    c868:	4b62      	ldr	r3, [pc, #392]	; (c9f4 <tcp_output+0x338>)
    c86a:	4798      	blx	r3
    c86c:	0003      	movs	r3, r0
    c86e:	001a      	movs	r2, r3
    c870:	2303      	movs	r3, #3
    c872:	4013      	ands	r3, r2
    c874:	1e5a      	subs	r2, r3, #1
    c876:	4193      	sbcs	r3, r2
    c878:	b2db      	uxtb	r3, r3
    c87a:	18eb      	adds	r3, r5, r3
    c87c:	18e3      	adds	r3, r4, r3
    c87e:	60fb      	str	r3, [r7, #12]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
    c880:	687b      	ldr	r3, [r7, #4]
    c882:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    c884:	68fb      	ldr	r3, [r7, #12]
    c886:	1ad3      	subs	r3, r2, r3
    c888:	d502      	bpl.n	c890 <tcp_output+0x1d4>
      pcb->snd_nxt = snd_nxt;
    c88a:	687b      	ldr	r3, [r7, #4]
    c88c:	68fa      	ldr	r2, [r7, #12]
    c88e:	651a      	str	r2, [r3, #80]	; 0x50
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
    c890:	69fb      	ldr	r3, [r7, #28]
    c892:	891b      	ldrh	r3, [r3, #8]
    c894:	001c      	movs	r4, r3
    c896:	69fb      	ldr	r3, [r7, #28]
    c898:	68db      	ldr	r3, [r3, #12]
    c89a:	7b1a      	ldrb	r2, [r3, #12]
    c89c:	7b5b      	ldrb	r3, [r3, #13]
    c89e:	021b      	lsls	r3, r3, #8
    c8a0:	4313      	orrs	r3, r2
    c8a2:	b29b      	uxth	r3, r3
    c8a4:	0018      	movs	r0, r3
    c8a6:	4b53      	ldr	r3, [pc, #332]	; (c9f4 <tcp_output+0x338>)
    c8a8:	4798      	blx	r3
    c8aa:	0003      	movs	r3, r0
    c8ac:	001a      	movs	r2, r3
    c8ae:	2303      	movs	r3, #3
    c8b0:	4013      	ands	r3, r2
    c8b2:	1e5a      	subs	r2, r3, #1
    c8b4:	4193      	sbcs	r3, r2
    c8b6:	b2db      	uxtb	r3, r3
    c8b8:	18e3      	adds	r3, r4, r3
    c8ba:	2b00      	cmp	r3, #0
    c8bc:	dd6b      	ble.n	c996 <tcp_output+0x2da>
      seg->next = NULL;
    c8be:	69fb      	ldr	r3, [r7, #28]
    c8c0:	2200      	movs	r2, #0
    c8c2:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
    c8c4:	687b      	ldr	r3, [r7, #4]
    c8c6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    c8c8:	2b00      	cmp	r3, #0
    c8ca:	d105      	bne.n	c8d8 <tcp_output+0x21c>
        pcb->unacked = seg;
    c8cc:	687b      	ldr	r3, [r7, #4]
    c8ce:	69fa      	ldr	r2, [r7, #28]
    c8d0:	671a      	str	r2, [r3, #112]	; 0x70
        useg = seg;
    c8d2:	69fb      	ldr	r3, [r7, #28]
    c8d4:	61bb      	str	r3, [r7, #24]
    c8d6:	e062      	b.n	c99e <tcp_output+0x2e2>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
    c8d8:	69fb      	ldr	r3, [r7, #28]
    c8da:	68db      	ldr	r3, [r3, #12]
    c8dc:	791a      	ldrb	r2, [r3, #4]
    c8de:	7959      	ldrb	r1, [r3, #5]
    c8e0:	0209      	lsls	r1, r1, #8
    c8e2:	430a      	orrs	r2, r1
    c8e4:	7999      	ldrb	r1, [r3, #6]
    c8e6:	0409      	lsls	r1, r1, #16
    c8e8:	430a      	orrs	r2, r1
    c8ea:	79db      	ldrb	r3, [r3, #7]
    c8ec:	061b      	lsls	r3, r3, #24
    c8ee:	4313      	orrs	r3, r2
    c8f0:	0018      	movs	r0, r3
    c8f2:	4b3c      	ldr	r3, [pc, #240]	; (c9e4 <tcp_output+0x328>)
    c8f4:	4798      	blx	r3
    c8f6:	0004      	movs	r4, r0
    c8f8:	69bb      	ldr	r3, [r7, #24]
    c8fa:	68db      	ldr	r3, [r3, #12]
    c8fc:	791a      	ldrb	r2, [r3, #4]
    c8fe:	7959      	ldrb	r1, [r3, #5]
    c900:	0209      	lsls	r1, r1, #8
    c902:	430a      	orrs	r2, r1
    c904:	7999      	ldrb	r1, [r3, #6]
    c906:	0409      	lsls	r1, r1, #16
    c908:	430a      	orrs	r2, r1
    c90a:	79db      	ldrb	r3, [r3, #7]
    c90c:	061b      	lsls	r3, r3, #24
    c90e:	4313      	orrs	r3, r2
    c910:	0018      	movs	r0, r3
    c912:	4b34      	ldr	r3, [pc, #208]	; (c9e4 <tcp_output+0x328>)
    c914:	4798      	blx	r3
    c916:	0003      	movs	r3, r0
    c918:	1ae3      	subs	r3, r4, r3
    c91a:	d535      	bpl.n	c988 <tcp_output+0x2cc>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
    c91c:	687b      	ldr	r3, [r7, #4]
    c91e:	3370      	adds	r3, #112	; 0x70
    c920:	617b      	str	r3, [r7, #20]
          while (*cur_seg &&
    c922:	e002      	b.n	c92a <tcp_output+0x26e>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
    c924:	697b      	ldr	r3, [r7, #20]
    c926:	681b      	ldr	r3, [r3, #0]
    c928:	617b      	str	r3, [r7, #20]
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
    c92a:	697b      	ldr	r3, [r7, #20]
    c92c:	681b      	ldr	r3, [r3, #0]
    c92e:	2b00      	cmp	r3, #0
    c930:	d022      	beq.n	c978 <tcp_output+0x2bc>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    c932:	697b      	ldr	r3, [r7, #20]
    c934:	681b      	ldr	r3, [r3, #0]
    c936:	68db      	ldr	r3, [r3, #12]
    c938:	791a      	ldrb	r2, [r3, #4]
    c93a:	7959      	ldrb	r1, [r3, #5]
    c93c:	0209      	lsls	r1, r1, #8
    c93e:	430a      	orrs	r2, r1
    c940:	7999      	ldrb	r1, [r3, #6]
    c942:	0409      	lsls	r1, r1, #16
    c944:	430a      	orrs	r2, r1
    c946:	79db      	ldrb	r3, [r3, #7]
    c948:	061b      	lsls	r3, r3, #24
    c94a:	4313      	orrs	r3, r2
    c94c:	0018      	movs	r0, r3
    c94e:	4b25      	ldr	r3, [pc, #148]	; (c9e4 <tcp_output+0x328>)
    c950:	4798      	blx	r3
    c952:	0004      	movs	r4, r0
    c954:	69fb      	ldr	r3, [r7, #28]
    c956:	68db      	ldr	r3, [r3, #12]
    c958:	791a      	ldrb	r2, [r3, #4]
    c95a:	7959      	ldrb	r1, [r3, #5]
    c95c:	0209      	lsls	r1, r1, #8
    c95e:	430a      	orrs	r2, r1
    c960:	7999      	ldrb	r1, [r3, #6]
    c962:	0409      	lsls	r1, r1, #16
    c964:	430a      	orrs	r2, r1
    c966:	79db      	ldrb	r3, [r3, #7]
    c968:	061b      	lsls	r3, r3, #24
    c96a:	4313      	orrs	r3, r2
    c96c:	0018      	movs	r0, r3
    c96e:	4b1d      	ldr	r3, [pc, #116]	; (c9e4 <tcp_output+0x328>)
    c970:	4798      	blx	r3
    c972:	0003      	movs	r3, r0
    c974:	1ae3      	subs	r3, r4, r3
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
    c976:	d4d5      	bmi.n	c924 <tcp_output+0x268>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
    c978:	697b      	ldr	r3, [r7, #20]
    c97a:	681a      	ldr	r2, [r3, #0]
    c97c:	69fb      	ldr	r3, [r7, #28]
    c97e:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
    c980:	697b      	ldr	r3, [r7, #20]
    c982:	69fa      	ldr	r2, [r7, #28]
    c984:	601a      	str	r2, [r3, #0]
    c986:	e00a      	b.n	c99e <tcp_output+0x2e2>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
    c988:	69bb      	ldr	r3, [r7, #24]
    c98a:	69fa      	ldr	r2, [r7, #28]
    c98c:	601a      	str	r2, [r3, #0]
          useg = useg->next;
    c98e:	69bb      	ldr	r3, [r7, #24]
    c990:	681b      	ldr	r3, [r3, #0]
    c992:	61bb      	str	r3, [r7, #24]
    c994:	e003      	b.n	c99e <tcp_output+0x2e2>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    c996:	69fb      	ldr	r3, [r7, #28]
    c998:	0018      	movs	r0, r3
    c99a:	4b17      	ldr	r3, [pc, #92]	; (c9f8 <tcp_output+0x33c>)
    c99c:	4798      	blx	r3
    }
    seg = pcb->unsent;
    c99e:	687b      	ldr	r3, [r7, #4]
    c9a0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    c9a2:	61fb      	str	r3, [r7, #28]
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c9a4:	69fb      	ldr	r3, [r7, #28]
    c9a6:	2b00      	cmp	r3, #0
    c9a8:	d029      	beq.n	c9fe <tcp_output+0x342>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    c9aa:	69fb      	ldr	r3, [r7, #28]
    c9ac:	68db      	ldr	r3, [r3, #12]
    c9ae:	791a      	ldrb	r2, [r3, #4]
    c9b0:	7959      	ldrb	r1, [r3, #5]
    c9b2:	0209      	lsls	r1, r1, #8
    c9b4:	430a      	orrs	r2, r1
    c9b6:	7999      	ldrb	r1, [r3, #6]
    c9b8:	0409      	lsls	r1, r1, #16
    c9ba:	430a      	orrs	r2, r1
    c9bc:	79db      	ldrb	r3, [r3, #7]
    c9be:	061b      	lsls	r3, r3, #24
    c9c0:	4313      	orrs	r3, r2
    c9c2:	0018      	movs	r0, r3
    c9c4:	4b07      	ldr	r3, [pc, #28]	; (c9e4 <tcp_output+0x328>)
    c9c6:	4798      	blx	r3
    c9c8:	0002      	movs	r2, r0
    c9ca:	687b      	ldr	r3, [r7, #4]
    c9cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    c9ce:	1ad3      	subs	r3, r2, r3
    c9d0:	69fa      	ldr	r2, [r7, #28]
    c9d2:	8912      	ldrh	r2, [r2, #8]
    c9d4:	189a      	adds	r2, r3, r2
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
    c9d6:	693b      	ldr	r3, [r7, #16]
    c9d8:	429a      	cmp	r2, r3
    c9da:	d800      	bhi.n	c9de <tcp_output+0x322>
    c9dc:	e6c2      	b.n	c764 <tcp_output+0xa8>
    c9de:	e00e      	b.n	c9fe <tcp_output+0x342>
    c9e0:	20003edc 	.word	0x20003edc
    c9e4:	00005675 	.word	0x00005675
    c9e8:	0000c629 	.word	0x0000c629
    c9ec:	000055f1 	.word	0x000055f1
    c9f0:	0000ca29 	.word	0x0000ca29
    c9f4:	0000561d 	.word	0x0000561d
    c9f8:	000093ad 	.word	0x000093ad
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
    c9fc:	46c0      	nop			; (mov r8, r8)
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    c9fe:	687b      	ldr	r3, [r7, #4]
    ca00:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    ca02:	2b00      	cmp	r3, #0
    ca04:	d103      	bne.n	ca0e <tcp_output+0x352>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
    ca06:	687b      	ldr	r3, [r7, #4]
    ca08:	226a      	movs	r2, #106	; 0x6a
    ca0a:	2100      	movs	r1, #0
    ca0c:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
    ca0e:	687b      	ldr	r3, [r7, #4]
    ca10:	7f9b      	ldrb	r3, [r3, #30]
    ca12:	227f      	movs	r2, #127	; 0x7f
    ca14:	4013      	ands	r3, r2
    ca16:	b2da      	uxtb	r2, r3
    ca18:	687b      	ldr	r3, [r7, #4]
    ca1a:	779a      	strb	r2, [r3, #30]
  return ERR_OK;
    ca1c:	2300      	movs	r3, #0
}
    ca1e:	0018      	movs	r0, r3
    ca20:	46bd      	mov	sp, r7
    ca22:	b008      	add	sp, #32
    ca24:	bdb0      	pop	{r4, r5, r7, pc}
    ca26:	46c0      	nop			; (mov r8, r8)

0000ca28 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
    ca28:	b5b0      	push	{r4, r5, r7, lr}
    ca2a:	b088      	sub	sp, #32
    ca2c:	af02      	add	r7, sp, #8
    ca2e:	6078      	str	r0, [r7, #4]
    ca30:	6039      	str	r1, [r7, #0]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
    ca32:	687b      	ldr	r3, [r7, #4]
    ca34:	68dc      	ldr	r4, [r3, #12]
    ca36:	683b      	ldr	r3, [r7, #0]
    ca38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    ca3a:	0018      	movs	r0, r3
    ca3c:	4b75      	ldr	r3, [pc, #468]	; (cc14 <tcp_output_segment+0x1ec>)
    ca3e:	4798      	blx	r3
    ca40:	0003      	movs	r3, r0
    ca42:	22ff      	movs	r2, #255	; 0xff
    ca44:	401a      	ands	r2, r3
    ca46:	0010      	movs	r0, r2
    ca48:	7a22      	ldrb	r2, [r4, #8]
    ca4a:	2100      	movs	r1, #0
    ca4c:	400a      	ands	r2, r1
    ca4e:	1c11      	adds	r1, r2, #0
    ca50:	1c02      	adds	r2, r0, #0
    ca52:	430a      	orrs	r2, r1
    ca54:	7222      	strb	r2, [r4, #8]
    ca56:	0a1a      	lsrs	r2, r3, #8
    ca58:	21ff      	movs	r1, #255	; 0xff
    ca5a:	400a      	ands	r2, r1
    ca5c:	0010      	movs	r0, r2
    ca5e:	7a62      	ldrb	r2, [r4, #9]
    ca60:	2100      	movs	r1, #0
    ca62:	400a      	ands	r2, r1
    ca64:	1c11      	adds	r1, r2, #0
    ca66:	1c02      	adds	r2, r0, #0
    ca68:	430a      	orrs	r2, r1
    ca6a:	7262      	strb	r2, [r4, #9]
    ca6c:	0c1a      	lsrs	r2, r3, #16
    ca6e:	21ff      	movs	r1, #255	; 0xff
    ca70:	400a      	ands	r2, r1
    ca72:	0010      	movs	r0, r2
    ca74:	7aa2      	ldrb	r2, [r4, #10]
    ca76:	2100      	movs	r1, #0
    ca78:	400a      	ands	r2, r1
    ca7a:	1c11      	adds	r1, r2, #0
    ca7c:	1c02      	adds	r2, r0, #0
    ca7e:	430a      	orrs	r2, r1
    ca80:	72a2      	strb	r2, [r4, #10]
    ca82:	0e19      	lsrs	r1, r3, #24
    ca84:	7ae3      	ldrb	r3, [r4, #11]
    ca86:	2200      	movs	r2, #0
    ca88:	4013      	ands	r3, r2
    ca8a:	1c1a      	adds	r2, r3, #0
    ca8c:	1c0b      	adds	r3, r1, #0
    ca8e:	4313      	orrs	r3, r2
    ca90:	72e3      	strb	r3, [r4, #11]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    ca92:	687b      	ldr	r3, [r7, #4]
    ca94:	68dc      	ldr	r4, [r3, #12]
    ca96:	683b      	ldr	r3, [r7, #0]
    ca98:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    ca9a:	0018      	movs	r0, r3
    ca9c:	4b5e      	ldr	r3, [pc, #376]	; (cc18 <tcp_output_segment+0x1f0>)
    ca9e:	4798      	blx	r3
    caa0:	0003      	movs	r3, r0
    caa2:	22ff      	movs	r2, #255	; 0xff
    caa4:	401a      	ands	r2, r3
    caa6:	0010      	movs	r0, r2
    caa8:	7ba2      	ldrb	r2, [r4, #14]
    caaa:	2100      	movs	r1, #0
    caac:	400a      	ands	r2, r1
    caae:	1c11      	adds	r1, r2, #0
    cab0:	1c02      	adds	r2, r0, #0
    cab2:	430a      	orrs	r2, r1
    cab4:	73a2      	strb	r2, [r4, #14]
    cab6:	0a1b      	lsrs	r3, r3, #8
    cab8:	b299      	uxth	r1, r3
    caba:	7be3      	ldrb	r3, [r4, #15]
    cabc:	2200      	movs	r2, #0
    cabe:	4013      	ands	r3, r2
    cac0:	1c1a      	adds	r2, r3, #0
    cac2:	1c0b      	adds	r3, r1, #0
    cac4:	4313      	orrs	r3, r2
    cac6:	73e3      	strb	r3, [r4, #15]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
    cac8:	683b      	ldr	r3, [r7, #0]
    caca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    cacc:	683a      	ldr	r2, [r7, #0]
    cace:	8dd2      	ldrh	r2, [r2, #46]	; 0x2e
    cad0:	189a      	adds	r2, r3, r2
    cad2:	683b      	ldr	r3, [r7, #0]
    cad4:	631a      	str	r2, [r3, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
    cad6:	687b      	ldr	r3, [r7, #4]
    cad8:	68db      	ldr	r3, [r3, #12]
    cada:	3314      	adds	r3, #20
    cadc:	617b      	str	r3, [r7, #20]
  if (seg->flags & TF_SEG_OPTS_MSS) {
    cade:	687b      	ldr	r3, [r7, #4]
    cae0:	7a9b      	ldrb	r3, [r3, #10]
    cae2:	001a      	movs	r2, r3
    cae4:	2301      	movs	r3, #1
    cae6:	4013      	ands	r3, r2
    cae8:	d019      	beq.n	cb1e <tcp_output_segment+0xf6>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
    caea:	683b      	ldr	r3, [r7, #0]
    caec:	3304      	adds	r3, #4
    caee:	2212      	movs	r2, #18
    caf0:	18bc      	adds	r4, r7, r2
    caf2:	4a4a      	ldr	r2, [pc, #296]	; (cc1c <tcp_output_segment+0x1f4>)
    caf4:	0019      	movs	r1, r3
    caf6:	0010      	movs	r0, r2
    caf8:	4b49      	ldr	r3, [pc, #292]	; (cc20 <tcp_output_segment+0x1f8>)
    cafa:	4798      	blx	r3
    cafc:	0003      	movs	r3, r0
    cafe:	8023      	strh	r3, [r4, #0]
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
    cb00:	2312      	movs	r3, #18
    cb02:	18fb      	adds	r3, r7, r3
    cb04:	881b      	ldrh	r3, [r3, #0]
    cb06:	2281      	movs	r2, #129	; 0x81
    cb08:	0492      	lsls	r2, r2, #18
    cb0a:	4313      	orrs	r3, r2
    cb0c:	0018      	movs	r0, r3
    cb0e:	4b41      	ldr	r3, [pc, #260]	; (cc14 <tcp_output_segment+0x1ec>)
    cb10:	4798      	blx	r3
    cb12:	0002      	movs	r2, r0
    cb14:	697b      	ldr	r3, [r7, #20]
    cb16:	601a      	str	r2, [r3, #0]
    opts += 1;
    cb18:	697b      	ldr	r3, [r7, #20]
    cb1a:	3304      	adds	r3, #4
    cb1c:	617b      	str	r3, [r7, #20]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
    cb1e:	683b      	ldr	r3, [r7, #0]
    cb20:	2234      	movs	r2, #52	; 0x34
    cb22:	5e9b      	ldrsh	r3, [r3, r2]
    cb24:	3301      	adds	r3, #1
    cb26:	d102      	bne.n	cb2e <tcp_output_segment+0x106>
    pcb->rtime = 0;
    cb28:	683b      	ldr	r3, [r7, #0]
    cb2a:	2200      	movs	r2, #0
    cb2c:	869a      	strh	r2, [r3, #52]	; 0x34
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    cb2e:	683b      	ldr	r3, [r7, #0]
    cb30:	2b00      	cmp	r3, #0
    cb32:	d003      	beq.n	cb3c <tcp_output_segment+0x114>
    cb34:	683b      	ldr	r3, [r7, #0]
    cb36:	681b      	ldr	r3, [r3, #0]
    cb38:	2b00      	cmp	r3, #0
    cb3a:	d10d      	bne.n	cb58 <tcp_output_segment+0x130>
    netif = ip_route(&(pcb->remote_ip));
    cb3c:	683b      	ldr	r3, [r7, #0]
    cb3e:	3304      	adds	r3, #4
    cb40:	0018      	movs	r0, r3
    cb42:	4b38      	ldr	r3, [pc, #224]	; (cc24 <tcp_output_segment+0x1fc>)
    cb44:	4798      	blx	r3
    cb46:	0003      	movs	r3, r0
    cb48:	60fb      	str	r3, [r7, #12]
    if (netif == NULL) {
    cb4a:	68fb      	ldr	r3, [r7, #12]
    cb4c:	2b00      	cmp	r3, #0
    cb4e:	d05d      	beq.n	cc0c <tcp_output_segment+0x1e4>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
    cb50:	68fb      	ldr	r3, [r7, #12]
    cb52:	685a      	ldr	r2, [r3, #4]
    cb54:	683b      	ldr	r3, [r7, #0]
    cb56:	601a      	str	r2, [r3, #0]
  }

  if (pcb->rttest == 0) {
    cb58:	683b      	ldr	r3, [r7, #0]
    cb5a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    cb5c:	2b00      	cmp	r3, #0
    cb5e:	d115      	bne.n	cb8c <tcp_output_segment+0x164>
    pcb->rttest = tcp_ticks;
    cb60:	4b31      	ldr	r3, [pc, #196]	; (cc28 <tcp_output_segment+0x200>)
    cb62:	681a      	ldr	r2, [r3, #0]
    cb64:	683b      	ldr	r3, [r7, #0]
    cb66:	639a      	str	r2, [r3, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
    cb68:	687b      	ldr	r3, [r7, #4]
    cb6a:	68db      	ldr	r3, [r3, #12]
    cb6c:	791a      	ldrb	r2, [r3, #4]
    cb6e:	7959      	ldrb	r1, [r3, #5]
    cb70:	0209      	lsls	r1, r1, #8
    cb72:	430a      	orrs	r2, r1
    cb74:	7999      	ldrb	r1, [r3, #6]
    cb76:	0409      	lsls	r1, r1, #16
    cb78:	430a      	orrs	r2, r1
    cb7a:	79db      	ldrb	r3, [r3, #7]
    cb7c:	061b      	lsls	r3, r3, #24
    cb7e:	4313      	orrs	r3, r2
    cb80:	0018      	movs	r0, r3
    cb82:	4b2a      	ldr	r3, [pc, #168]	; (cc2c <tcp_output_segment+0x204>)
    cb84:	4798      	blx	r3
    cb86:	0002      	movs	r2, r0
    cb88:	683b      	ldr	r3, [r7, #0]
    cb8a:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
    cb8c:	687b      	ldr	r3, [r7, #4]
    cb8e:	68db      	ldr	r3, [r3, #12]
    cb90:	001a      	movs	r2, r3
    cb92:	687b      	ldr	r3, [r7, #4]
    cb94:	685b      	ldr	r3, [r3, #4]
    cb96:	685b      	ldr	r3, [r3, #4]
    cb98:	1ad2      	subs	r2, r2, r3
    cb9a:	230a      	movs	r3, #10
    cb9c:	18fb      	adds	r3, r7, r3
    cb9e:	801a      	strh	r2, [r3, #0]

  seg->p->len -= len;
    cba0:	687b      	ldr	r3, [r7, #4]
    cba2:	685a      	ldr	r2, [r3, #4]
    cba4:	687b      	ldr	r3, [r7, #4]
    cba6:	685b      	ldr	r3, [r3, #4]
    cba8:	8959      	ldrh	r1, [r3, #10]
    cbaa:	230a      	movs	r3, #10
    cbac:	18fb      	adds	r3, r7, r3
    cbae:	881b      	ldrh	r3, [r3, #0]
    cbb0:	1acb      	subs	r3, r1, r3
    cbb2:	b29b      	uxth	r3, r3
    cbb4:	8153      	strh	r3, [r2, #10]
  seg->p->tot_len -= len;
    cbb6:	687b      	ldr	r3, [r7, #4]
    cbb8:	685a      	ldr	r2, [r3, #4]
    cbba:	687b      	ldr	r3, [r7, #4]
    cbbc:	685b      	ldr	r3, [r3, #4]
    cbbe:	8919      	ldrh	r1, [r3, #8]
    cbc0:	230a      	movs	r3, #10
    cbc2:	18fb      	adds	r3, r7, r3
    cbc4:	881b      	ldrh	r3, [r3, #0]
    cbc6:	1acb      	subs	r3, r1, r3
    cbc8:	b29b      	uxth	r3, r3
    cbca:	8113      	strh	r3, [r2, #8]

  seg->p->payload = seg->tcphdr;
    cbcc:	687b      	ldr	r3, [r7, #4]
    cbce:	685b      	ldr	r3, [r3, #4]
    cbd0:	687a      	ldr	r2, [r7, #4]
    cbd2:	68d2      	ldr	r2, [r2, #12]
    cbd4:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
    cbd6:	687b      	ldr	r3, [r7, #4]
    cbd8:	68db      	ldr	r3, [r3, #12]
    cbda:	7c1a      	ldrb	r2, [r3, #16]
    cbdc:	2100      	movs	r1, #0
    cbde:	400a      	ands	r2, r1
    cbe0:	741a      	strb	r2, [r3, #16]
    cbe2:	7c5a      	ldrb	r2, [r3, #17]
    cbe4:	2100      	movs	r1, #0
    cbe6:	400a      	ands	r2, r1
    cbe8:	745a      	strb	r2, [r3, #17]

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
    cbea:	687b      	ldr	r3, [r7, #4]
    cbec:	6858      	ldr	r0, [r3, #4]
    cbee:	6839      	ldr	r1, [r7, #0]
    cbf0:	683b      	ldr	r3, [r7, #0]
    cbf2:	1d1c      	adds	r4, r3, #4
    cbf4:	683b      	ldr	r3, [r7, #0]
    cbf6:	7a9d      	ldrb	r5, [r3, #10]
    cbf8:	683b      	ldr	r3, [r7, #0]
    cbfa:	7a5b      	ldrb	r3, [r3, #9]
    cbfc:	2206      	movs	r2, #6
    cbfe:	9201      	str	r2, [sp, #4]
    cc00:	9300      	str	r3, [sp, #0]
    cc02:	002b      	movs	r3, r5
    cc04:	0022      	movs	r2, r4
    cc06:	4c0a      	ldr	r4, [pc, #40]	; (cc30 <tcp_output_segment+0x208>)
    cc08:	47a0      	blx	r4
    cc0a:	e000      	b.n	cc0e <tcp_output_segment+0x1e6>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
    cc0c:	46c0      	nop			; (mov r8, r8)
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
    cc0e:	46bd      	mov	sp, r7
    cc10:	b006      	add	sp, #24
    cc12:	bdb0      	pop	{r4, r5, r7, pc}
    cc14:	00005641 	.word	0x00005641
    cc18:	000055f1 	.word	0x000055f1
    cc1c:	000005b4 	.word	0x000005b4
    cc20:	00009821 	.word	0x00009821
    cc24:	00005c89 	.word	0x00005c89
    cc28:	20003ec8 	.word	0x20003ec8
    cc2c:	00005675 	.word	0x00005675
    cc30:	0000620d 	.word	0x0000620d

0000cc34 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
    cc34:	b590      	push	{r4, r7, lr}
    cc36:	b089      	sub	sp, #36	; 0x24
    cc38:	af02      	add	r7, sp, #8
    cc3a:	60f8      	str	r0, [r7, #12]
    cc3c:	60b9      	str	r1, [r7, #8]
    cc3e:	607a      	str	r2, [r7, #4]
    cc40:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    cc42:	2200      	movs	r2, #0
    cc44:	2114      	movs	r1, #20
    cc46:	2001      	movs	r0, #1
    cc48:	4b76      	ldr	r3, [pc, #472]	; (ce24 <tcp_rst+0x1f0>)
    cc4a:	4798      	blx	r3
    cc4c:	0003      	movs	r3, r0
    cc4e:	617b      	str	r3, [r7, #20]
  if (p == NULL) {
    cc50:	697b      	ldr	r3, [r7, #20]
    cc52:	2b00      	cmp	r3, #0
    cc54:	d100      	bne.n	cc58 <tcp_rst+0x24>
    cc56:	e0e0      	b.n	ce1a <tcp_rst+0x1e6>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
    cc58:	697b      	ldr	r3, [r7, #20]
    cc5a:	685b      	ldr	r3, [r3, #4]
    cc5c:	613b      	str	r3, [r7, #16]
  tcphdr->src = htons(local_port);
    cc5e:	2328      	movs	r3, #40	; 0x28
    cc60:	18fb      	adds	r3, r7, r3
    cc62:	881b      	ldrh	r3, [r3, #0]
    cc64:	0018      	movs	r0, r3
    cc66:	4b70      	ldr	r3, [pc, #448]	; (ce28 <tcp_rst+0x1f4>)
    cc68:	4798      	blx	r3
    cc6a:	0003      	movs	r3, r0
    cc6c:	001a      	movs	r2, r3
    cc6e:	693b      	ldr	r3, [r7, #16]
    cc70:	21ff      	movs	r1, #255	; 0xff
    cc72:	4011      	ands	r1, r2
    cc74:	000c      	movs	r4, r1
    cc76:	7819      	ldrb	r1, [r3, #0]
    cc78:	2000      	movs	r0, #0
    cc7a:	4001      	ands	r1, r0
    cc7c:	1c08      	adds	r0, r1, #0
    cc7e:	1c21      	adds	r1, r4, #0
    cc80:	4301      	orrs	r1, r0
    cc82:	7019      	strb	r1, [r3, #0]
    cc84:	0a12      	lsrs	r2, r2, #8
    cc86:	b290      	uxth	r0, r2
    cc88:	785a      	ldrb	r2, [r3, #1]
    cc8a:	2100      	movs	r1, #0
    cc8c:	400a      	ands	r2, r1
    cc8e:	1c11      	adds	r1, r2, #0
    cc90:	1c02      	adds	r2, r0, #0
    cc92:	430a      	orrs	r2, r1
    cc94:	705a      	strb	r2, [r3, #1]
  tcphdr->dest = htons(remote_port);
    cc96:	232c      	movs	r3, #44	; 0x2c
    cc98:	18fb      	adds	r3, r7, r3
    cc9a:	881b      	ldrh	r3, [r3, #0]
    cc9c:	0018      	movs	r0, r3
    cc9e:	4b62      	ldr	r3, [pc, #392]	; (ce28 <tcp_rst+0x1f4>)
    cca0:	4798      	blx	r3
    cca2:	0003      	movs	r3, r0
    cca4:	001a      	movs	r2, r3
    cca6:	693b      	ldr	r3, [r7, #16]
    cca8:	21ff      	movs	r1, #255	; 0xff
    ccaa:	4011      	ands	r1, r2
    ccac:	000c      	movs	r4, r1
    ccae:	7899      	ldrb	r1, [r3, #2]
    ccb0:	2000      	movs	r0, #0
    ccb2:	4001      	ands	r1, r0
    ccb4:	1c08      	adds	r0, r1, #0
    ccb6:	1c21      	adds	r1, r4, #0
    ccb8:	4301      	orrs	r1, r0
    ccba:	7099      	strb	r1, [r3, #2]
    ccbc:	0a12      	lsrs	r2, r2, #8
    ccbe:	b290      	uxth	r0, r2
    ccc0:	78da      	ldrb	r2, [r3, #3]
    ccc2:	2100      	movs	r1, #0
    ccc4:	400a      	ands	r2, r1
    ccc6:	1c11      	adds	r1, r2, #0
    ccc8:	1c02      	adds	r2, r0, #0
    ccca:	430a      	orrs	r2, r1
    cccc:	70da      	strb	r2, [r3, #3]
  tcphdr->seqno = htonl(seqno);
    ccce:	68fb      	ldr	r3, [r7, #12]
    ccd0:	0018      	movs	r0, r3
    ccd2:	4b56      	ldr	r3, [pc, #344]	; (ce2c <tcp_rst+0x1f8>)
    ccd4:	4798      	blx	r3
    ccd6:	0002      	movs	r2, r0
    ccd8:	693b      	ldr	r3, [r7, #16]
    ccda:	21ff      	movs	r1, #255	; 0xff
    ccdc:	4011      	ands	r1, r2
    ccde:	000c      	movs	r4, r1
    cce0:	7919      	ldrb	r1, [r3, #4]
    cce2:	2000      	movs	r0, #0
    cce4:	4001      	ands	r1, r0
    cce6:	1c08      	adds	r0, r1, #0
    cce8:	1c21      	adds	r1, r4, #0
    ccea:	4301      	orrs	r1, r0
    ccec:	7119      	strb	r1, [r3, #4]
    ccee:	0a11      	lsrs	r1, r2, #8
    ccf0:	20ff      	movs	r0, #255	; 0xff
    ccf2:	4001      	ands	r1, r0
    ccf4:	000c      	movs	r4, r1
    ccf6:	7959      	ldrb	r1, [r3, #5]
    ccf8:	2000      	movs	r0, #0
    ccfa:	4001      	ands	r1, r0
    ccfc:	1c08      	adds	r0, r1, #0
    ccfe:	1c21      	adds	r1, r4, #0
    cd00:	4301      	orrs	r1, r0
    cd02:	7159      	strb	r1, [r3, #5]
    cd04:	0c11      	lsrs	r1, r2, #16
    cd06:	20ff      	movs	r0, #255	; 0xff
    cd08:	4001      	ands	r1, r0
    cd0a:	000c      	movs	r4, r1
    cd0c:	7999      	ldrb	r1, [r3, #6]
    cd0e:	2000      	movs	r0, #0
    cd10:	4001      	ands	r1, r0
    cd12:	1c08      	adds	r0, r1, #0
    cd14:	1c21      	adds	r1, r4, #0
    cd16:	4301      	orrs	r1, r0
    cd18:	7199      	strb	r1, [r3, #6]
    cd1a:	0e10      	lsrs	r0, r2, #24
    cd1c:	79da      	ldrb	r2, [r3, #7]
    cd1e:	2100      	movs	r1, #0
    cd20:	400a      	ands	r2, r1
    cd22:	1c11      	adds	r1, r2, #0
    cd24:	1c02      	adds	r2, r0, #0
    cd26:	430a      	orrs	r2, r1
    cd28:	71da      	strb	r2, [r3, #7]
  tcphdr->ackno = htonl(ackno);
    cd2a:	68bb      	ldr	r3, [r7, #8]
    cd2c:	0018      	movs	r0, r3
    cd2e:	4b3f      	ldr	r3, [pc, #252]	; (ce2c <tcp_rst+0x1f8>)
    cd30:	4798      	blx	r3
    cd32:	0002      	movs	r2, r0
    cd34:	693b      	ldr	r3, [r7, #16]
    cd36:	21ff      	movs	r1, #255	; 0xff
    cd38:	4011      	ands	r1, r2
    cd3a:	000c      	movs	r4, r1
    cd3c:	7a19      	ldrb	r1, [r3, #8]
    cd3e:	2000      	movs	r0, #0
    cd40:	4001      	ands	r1, r0
    cd42:	1c08      	adds	r0, r1, #0
    cd44:	1c21      	adds	r1, r4, #0
    cd46:	4301      	orrs	r1, r0
    cd48:	7219      	strb	r1, [r3, #8]
    cd4a:	0a11      	lsrs	r1, r2, #8
    cd4c:	20ff      	movs	r0, #255	; 0xff
    cd4e:	4001      	ands	r1, r0
    cd50:	000c      	movs	r4, r1
    cd52:	7a59      	ldrb	r1, [r3, #9]
    cd54:	2000      	movs	r0, #0
    cd56:	4001      	ands	r1, r0
    cd58:	1c08      	adds	r0, r1, #0
    cd5a:	1c21      	adds	r1, r4, #0
    cd5c:	4301      	orrs	r1, r0
    cd5e:	7259      	strb	r1, [r3, #9]
    cd60:	0c11      	lsrs	r1, r2, #16
    cd62:	20ff      	movs	r0, #255	; 0xff
    cd64:	4001      	ands	r1, r0
    cd66:	000c      	movs	r4, r1
    cd68:	7a99      	ldrb	r1, [r3, #10]
    cd6a:	2000      	movs	r0, #0
    cd6c:	4001      	ands	r1, r0
    cd6e:	1c08      	adds	r0, r1, #0
    cd70:	1c21      	adds	r1, r4, #0
    cd72:	4301      	orrs	r1, r0
    cd74:	7299      	strb	r1, [r3, #10]
    cd76:	0e10      	lsrs	r0, r2, #24
    cd78:	7ada      	ldrb	r2, [r3, #11]
    cd7a:	2100      	movs	r1, #0
    cd7c:	400a      	ands	r2, r1
    cd7e:	1c11      	adds	r1, r2, #0
    cd80:	1c02      	adds	r2, r0, #0
    cd82:	430a      	orrs	r2, r1
    cd84:	72da      	strb	r2, [r3, #11]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
    cd86:	4b2a      	ldr	r3, [pc, #168]	; (ce30 <tcp_rst+0x1fc>)
    cd88:	0018      	movs	r0, r3
    cd8a:	4b27      	ldr	r3, [pc, #156]	; (ce28 <tcp_rst+0x1f4>)
    cd8c:	4798      	blx	r3
    cd8e:	0003      	movs	r3, r0
    cd90:	001a      	movs	r2, r3
    cd92:	693b      	ldr	r3, [r7, #16]
    cd94:	21ff      	movs	r1, #255	; 0xff
    cd96:	4011      	ands	r1, r2
    cd98:	000c      	movs	r4, r1
    cd9a:	7b19      	ldrb	r1, [r3, #12]
    cd9c:	2000      	movs	r0, #0
    cd9e:	4001      	ands	r1, r0
    cda0:	1c08      	adds	r0, r1, #0
    cda2:	1c21      	adds	r1, r4, #0
    cda4:	4301      	orrs	r1, r0
    cda6:	7319      	strb	r1, [r3, #12]
    cda8:	0a12      	lsrs	r2, r2, #8
    cdaa:	b290      	uxth	r0, r2
    cdac:	7b5a      	ldrb	r2, [r3, #13]
    cdae:	2100      	movs	r1, #0
    cdb0:	400a      	ands	r2, r1
    cdb2:	1c11      	adds	r1, r2, #0
    cdb4:	1c02      	adds	r2, r0, #0
    cdb6:	430a      	orrs	r2, r1
    cdb8:	735a      	strb	r2, [r3, #13]
  tcphdr->wnd = PP_HTONS(TCP_WND);
    cdba:	693b      	ldr	r3, [r7, #16]
    cdbc:	7b9a      	ldrb	r2, [r3, #14]
    cdbe:	2100      	movs	r1, #0
    cdc0:	400a      	ands	r2, r1
    cdc2:	1c11      	adds	r1, r2, #0
    cdc4:	220b      	movs	r2, #11
    cdc6:	430a      	orrs	r2, r1
    cdc8:	739a      	strb	r2, [r3, #14]
    cdca:	7bda      	ldrb	r2, [r3, #15]
    cdcc:	2100      	movs	r1, #0
    cdce:	400a      	ands	r2, r1
    cdd0:	1c11      	adds	r1, r2, #0
    cdd2:	2268      	movs	r2, #104	; 0x68
    cdd4:	430a      	orrs	r2, r1
    cdd6:	73da      	strb	r2, [r3, #15]
  tcphdr->chksum = 0;
    cdd8:	693b      	ldr	r3, [r7, #16]
    cdda:	7c1a      	ldrb	r2, [r3, #16]
    cddc:	2100      	movs	r1, #0
    cdde:	400a      	ands	r2, r1
    cde0:	741a      	strb	r2, [r3, #16]
    cde2:	7c5a      	ldrb	r2, [r3, #17]
    cde4:	2100      	movs	r1, #0
    cde6:	400a      	ands	r2, r1
    cde8:	745a      	strb	r2, [r3, #17]
  tcphdr->urgp = 0;
    cdea:	693b      	ldr	r3, [r7, #16]
    cdec:	7c9a      	ldrb	r2, [r3, #18]
    cdee:	2100      	movs	r1, #0
    cdf0:	400a      	ands	r2, r1
    cdf2:	749a      	strb	r2, [r3, #18]
    cdf4:	7cda      	ldrb	r2, [r3, #19]
    cdf6:	2100      	movs	r1, #0
    cdf8:	400a      	ands	r2, r1
    cdfa:	74da      	strb	r2, [r3, #19]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
    cdfc:	683a      	ldr	r2, [r7, #0]
    cdfe:	6879      	ldr	r1, [r7, #4]
    ce00:	6978      	ldr	r0, [r7, #20]
    ce02:	2306      	movs	r3, #6
    ce04:	9301      	str	r3, [sp, #4]
    ce06:	2300      	movs	r3, #0
    ce08:	9300      	str	r3, [sp, #0]
    ce0a:	23ff      	movs	r3, #255	; 0xff
    ce0c:	4c09      	ldr	r4, [pc, #36]	; (ce34 <tcp_rst+0x200>)
    ce0e:	47a0      	blx	r4
  pbuf_free(p);
    ce10:	697b      	ldr	r3, [r7, #20]
    ce12:	0018      	movs	r0, r3
    ce14:	4b08      	ldr	r3, [pc, #32]	; (ce38 <tcp_rst+0x204>)
    ce16:	4798      	blx	r3
    ce18:	e000      	b.n	ce1c <tcp_rst+0x1e8>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
    ce1a:	46c0      	nop			; (mov r8, r8)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
    ce1c:	46bd      	mov	sp, r7
    ce1e:	b007      	add	sp, #28
    ce20:	bd90      	pop	{r4, r7, pc}
    ce22:	46c0      	nop			; (mov r8, r8)
    ce24:	00007e19 	.word	0x00007e19
    ce28:	000055f1 	.word	0x000055f1
    ce2c:	00005641 	.word	0x00005641
    ce30:	00005014 	.word	0x00005014
    ce34:	0000620d 	.word	0x0000620d
    ce38:	00008349 	.word	0x00008349

0000ce3c <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
    ce3c:	b580      	push	{r7, lr}
    ce3e:	b084      	sub	sp, #16
    ce40:	af00      	add	r7, sp, #0
    ce42:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    ce44:	687b      	ldr	r3, [r7, #4]
    ce46:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    ce48:	2b00      	cmp	r3, #0
    ce4a:	d025      	beq.n	ce98 <tcp_rexmit_rto+0x5c>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
    ce4c:	687b      	ldr	r3, [r7, #4]
    ce4e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    ce50:	60fb      	str	r3, [r7, #12]
    ce52:	e002      	b.n	ce5a <tcp_rexmit_rto+0x1e>
    ce54:	68fb      	ldr	r3, [r7, #12]
    ce56:	681b      	ldr	r3, [r3, #0]
    ce58:	60fb      	str	r3, [r7, #12]
    ce5a:	68fb      	ldr	r3, [r7, #12]
    ce5c:	681b      	ldr	r3, [r3, #0]
    ce5e:	2b00      	cmp	r3, #0
    ce60:	d1f8      	bne.n	ce54 <tcp_rexmit_rto+0x18>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
    ce62:	687b      	ldr	r3, [r7, #4]
    ce64:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    ce66:	68fb      	ldr	r3, [r7, #12]
    ce68:	601a      	str	r2, [r3, #0]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
    ce6a:	687b      	ldr	r3, [r7, #4]
    ce6c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    ce6e:	687b      	ldr	r3, [r7, #4]
    ce70:	66da      	str	r2, [r3, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
    ce72:	687b      	ldr	r3, [r7, #4]
    ce74:	2200      	movs	r2, #0
    ce76:	671a      	str	r2, [r3, #112]	; 0x70
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
    ce78:	687b      	ldr	r3, [r7, #4]
    ce7a:	2246      	movs	r2, #70	; 0x46
    ce7c:	5c9b      	ldrb	r3, [r3, r2]
    ce7e:	3301      	adds	r3, #1
    ce80:	b2d9      	uxtb	r1, r3
    ce82:	687b      	ldr	r3, [r7, #4]
    ce84:	2246      	movs	r2, #70	; 0x46
    ce86:	5499      	strb	r1, [r3, r2]

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
    ce88:	687b      	ldr	r3, [r7, #4]
    ce8a:	2200      	movs	r2, #0
    ce8c:	639a      	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
    ce8e:	687b      	ldr	r3, [r7, #4]
    ce90:	0018      	movs	r0, r3
    ce92:	4b03      	ldr	r3, [pc, #12]	; (cea0 <tcp_rexmit_rto+0x64>)
    ce94:	4798      	blx	r3
    ce96:	e000      	b.n	ce9a <tcp_rexmit_rto+0x5e>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
    ce98:	46c0      	nop			; (mov r8, r8)
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
    ce9a:	46bd      	mov	sp, r7
    ce9c:	b004      	add	sp, #16
    ce9e:	bd80      	pop	{r7, pc}
    cea0:	0000c6bd 	.word	0x0000c6bd

0000cea4 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
    cea4:	b590      	push	{r4, r7, lr}
    cea6:	b085      	sub	sp, #20
    cea8:	af00      	add	r7, sp, #0
    ceaa:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    ceac:	687b      	ldr	r3, [r7, #4]
    ceae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    ceb0:	2b00      	cmp	r3, #0
    ceb2:	d04f      	beq.n	cf54 <tcp_rexmit+0xb0>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
    ceb4:	687b      	ldr	r3, [r7, #4]
    ceb6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    ceb8:	60bb      	str	r3, [r7, #8]
  pcb->unacked = seg->next;
    ceba:	68bb      	ldr	r3, [r7, #8]
    cebc:	681a      	ldr	r2, [r3, #0]
    cebe:	687b      	ldr	r3, [r7, #4]
    cec0:	671a      	str	r2, [r3, #112]	; 0x70

  cur_seg = &(pcb->unsent);
    cec2:	687b      	ldr	r3, [r7, #4]
    cec4:	336c      	adds	r3, #108	; 0x6c
    cec6:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
    cec8:	e002      	b.n	ced0 <tcp_rexmit+0x2c>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
    ceca:	68fb      	ldr	r3, [r7, #12]
    cecc:	681b      	ldr	r3, [r3, #0]
    cece:	60fb      	str	r3, [r7, #12]
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    ced0:	68fb      	ldr	r3, [r7, #12]
    ced2:	681b      	ldr	r3, [r3, #0]
    ced4:	2b00      	cmp	r3, #0
    ced6:	d022      	beq.n	cf1e <tcp_rexmit+0x7a>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    ced8:	68fb      	ldr	r3, [r7, #12]
    ceda:	681b      	ldr	r3, [r3, #0]
    cedc:	68db      	ldr	r3, [r3, #12]
    cede:	791a      	ldrb	r2, [r3, #4]
    cee0:	7959      	ldrb	r1, [r3, #5]
    cee2:	0209      	lsls	r1, r1, #8
    cee4:	430a      	orrs	r2, r1
    cee6:	7999      	ldrb	r1, [r3, #6]
    cee8:	0409      	lsls	r1, r1, #16
    ceea:	430a      	orrs	r2, r1
    ceec:	79db      	ldrb	r3, [r3, #7]
    ceee:	061b      	lsls	r3, r3, #24
    cef0:	4313      	orrs	r3, r2
    cef2:	0018      	movs	r0, r3
    cef4:	4b19      	ldr	r3, [pc, #100]	; (cf5c <tcp_rexmit+0xb8>)
    cef6:	4798      	blx	r3
    cef8:	0004      	movs	r4, r0
    cefa:	68bb      	ldr	r3, [r7, #8]
    cefc:	68db      	ldr	r3, [r3, #12]
    cefe:	791a      	ldrb	r2, [r3, #4]
    cf00:	7959      	ldrb	r1, [r3, #5]
    cf02:	0209      	lsls	r1, r1, #8
    cf04:	430a      	orrs	r2, r1
    cf06:	7999      	ldrb	r1, [r3, #6]
    cf08:	0409      	lsls	r1, r1, #16
    cf0a:	430a      	orrs	r2, r1
    cf0c:	79db      	ldrb	r3, [r3, #7]
    cf0e:	061b      	lsls	r3, r3, #24
    cf10:	4313      	orrs	r3, r2
    cf12:	0018      	movs	r0, r3
    cf14:	4b11      	ldr	r3, [pc, #68]	; (cf5c <tcp_rexmit+0xb8>)
    cf16:	4798      	blx	r3
    cf18:	0003      	movs	r3, r0
    cf1a:	1ae3      	subs	r3, r4, r3
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    cf1c:	d4d5      	bmi.n	ceca <tcp_rexmit+0x26>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
    cf1e:	68fb      	ldr	r3, [r7, #12]
    cf20:	681a      	ldr	r2, [r3, #0]
    cf22:	68bb      	ldr	r3, [r7, #8]
    cf24:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
    cf26:	68fb      	ldr	r3, [r7, #12]
    cf28:	68ba      	ldr	r2, [r7, #8]
    cf2a:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    cf2c:	68bb      	ldr	r3, [r7, #8]
    cf2e:	681b      	ldr	r3, [r3, #0]
    cf30:	2b00      	cmp	r3, #0
    cf32:	d103      	bne.n	cf3c <tcp_rexmit+0x98>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
    cf34:	687b      	ldr	r3, [r7, #4]
    cf36:	226a      	movs	r2, #106	; 0x6a
    cf38:	2100      	movs	r1, #0
    cf3a:	5299      	strh	r1, [r3, r2]
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
    cf3c:	687b      	ldr	r3, [r7, #4]
    cf3e:	2246      	movs	r2, #70	; 0x46
    cf40:	5c9b      	ldrb	r3, [r3, r2]
    cf42:	3301      	adds	r3, #1
    cf44:	b2d9      	uxtb	r1, r3
    cf46:	687b      	ldr	r3, [r7, #4]
    cf48:	2246      	movs	r2, #70	; 0x46
    cf4a:	5499      	strb	r1, [r3, r2]

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
    cf4c:	687b      	ldr	r3, [r7, #4]
    cf4e:	2200      	movs	r2, #0
    cf50:	639a      	str	r2, [r3, #56]	; 0x38
    cf52:	e000      	b.n	cf56 <tcp_rexmit+0xb2>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
    cf54:	46c0      	nop			; (mov r8, r8)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
    cf56:	46bd      	mov	sp, r7
    cf58:	b005      	add	sp, #20
    cf5a:	bd90      	pop	{r4, r7, pc}
    cf5c:	00005675 	.word	0x00005675

0000cf60 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
    cf60:	b580      	push	{r7, lr}
    cf62:	b082      	sub	sp, #8
    cf64:	af00      	add	r7, sp, #0
    cf66:	6078      	str	r0, [r7, #4]
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    cf68:	687b      	ldr	r3, [r7, #4]
    cf6a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    cf6c:	2b00      	cmp	r3, #0
    cf6e:	d048      	beq.n	d002 <tcp_rexmit_fast+0xa2>
    cf70:	687b      	ldr	r3, [r7, #4]
    cf72:	7f9b      	ldrb	r3, [r3, #30]
    cf74:	001a      	movs	r2, r3
    cf76:	2304      	movs	r3, #4
    cf78:	4013      	ands	r3, r2
    cf7a:	d142      	bne.n	d002 <tcp_rexmit_fast+0xa2>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
    cf7c:	687b      	ldr	r3, [r7, #4]
    cf7e:	0018      	movs	r0, r3
    cf80:	4b22      	ldr	r3, [pc, #136]	; (d00c <tcp_rexmit_fast+0xac>)
    cf82:	4798      	blx	r3

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
    cf84:	687b      	ldr	r3, [r7, #4]
    cf86:	224c      	movs	r2, #76	; 0x4c
    cf88:	5a9a      	ldrh	r2, [r3, r2]
    cf8a:	687b      	ldr	r3, [r7, #4]
    cf8c:	2160      	movs	r1, #96	; 0x60
    cf8e:	5a5b      	ldrh	r3, [r3, r1]
    cf90:	429a      	cmp	r2, r3
    cf92:	d908      	bls.n	cfa6 <tcp_rexmit_fast+0x46>
      pcb->ssthresh = pcb->snd_wnd / 2;
    cf94:	687b      	ldr	r3, [r7, #4]
    cf96:	2260      	movs	r2, #96	; 0x60
    cf98:	5a9b      	ldrh	r3, [r3, r2]
    cf9a:	085b      	lsrs	r3, r3, #1
    cf9c:	b299      	uxth	r1, r3
    cf9e:	687b      	ldr	r3, [r7, #4]
    cfa0:	224e      	movs	r2, #78	; 0x4e
    cfa2:	5299      	strh	r1, [r3, r2]
    cfa4:	e007      	b.n	cfb6 <tcp_rexmit_fast+0x56>
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    cfa6:	687b      	ldr	r3, [r7, #4]
    cfa8:	224c      	movs	r2, #76	; 0x4c
    cfaa:	5a9b      	ldrh	r3, [r3, r2]
    cfac:	085b      	lsrs	r3, r3, #1
    cfae:	b299      	uxth	r1, r3
    cfb0:	687b      	ldr	r3, [r7, #4]
    cfb2:	224e      	movs	r2, #78	; 0x4e
    cfb4:	5299      	strh	r1, [r3, r2]
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
    cfb6:	687b      	ldr	r3, [r7, #4]
    cfb8:	224e      	movs	r2, #78	; 0x4e
    cfba:	5a9b      	ldrh	r3, [r3, r2]
    cfbc:	001a      	movs	r2, r3
    cfbe:	687b      	ldr	r3, [r7, #4]
    cfc0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    cfc2:	005b      	lsls	r3, r3, #1
    cfc4:	429a      	cmp	r2, r3
    cfc6:	da06      	bge.n	cfd6 <tcp_rexmit_fast+0x76>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    cfc8:	687b      	ldr	r3, [r7, #4]
    cfca:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    cfcc:	18db      	adds	r3, r3, r3
    cfce:	b299      	uxth	r1, r3
    cfd0:	687b      	ldr	r3, [r7, #4]
    cfd2:	224e      	movs	r2, #78	; 0x4e
    cfd4:	5299      	strh	r1, [r3, r2]
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    cfd6:	687b      	ldr	r3, [r7, #4]
    cfd8:	224e      	movs	r2, #78	; 0x4e
    cfda:	5a9a      	ldrh	r2, [r3, r2]
    cfdc:	687b      	ldr	r3, [r7, #4]
    cfde:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    cfe0:	1c19      	adds	r1, r3, #0
    cfe2:	1c0b      	adds	r3, r1, #0
    cfe4:	18db      	adds	r3, r3, r3
    cfe6:	185b      	adds	r3, r3, r1
    cfe8:	b29b      	uxth	r3, r3
    cfea:	18d3      	adds	r3, r2, r3
    cfec:	b299      	uxth	r1, r3
    cfee:	687b      	ldr	r3, [r7, #4]
    cff0:	224c      	movs	r2, #76	; 0x4c
    cff2:	5299      	strh	r1, [r3, r2]
    pcb->flags |= TF_INFR;
    cff4:	687b      	ldr	r3, [r7, #4]
    cff6:	7f9b      	ldrb	r3, [r3, #30]
    cff8:	2204      	movs	r2, #4
    cffa:	4313      	orrs	r3, r2
    cffc:	b2da      	uxtb	r2, r3
    cffe:	687b      	ldr	r3, [r7, #4]
    d000:	779a      	strb	r2, [r3, #30]
  } 
}
    d002:	46c0      	nop			; (mov r8, r8)
    d004:	46bd      	mov	sp, r7
    d006:	b002      	add	sp, #8
    d008:	bd80      	pop	{r7, pc}
    d00a:	46c0      	nop			; (mov r8, r8)
    d00c:	0000cea5 	.word	0x0000cea5

0000d010 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
    d010:	b590      	push	{r4, r7, lr}
    d012:	b087      	sub	sp, #28
    d014:	af02      	add	r7, sp, #8
    d016:	6078      	str	r0, [r7, #4]
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    d018:	687b      	ldr	r3, [r7, #4]
    d01a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    d01c:	3b01      	subs	r3, #1
    d01e:	0018      	movs	r0, r3
    d020:	4b12      	ldr	r3, [pc, #72]	; (d06c <tcp_keepalive+0x5c>)
    d022:	4798      	blx	r3
    d024:	0003      	movs	r3, r0
    d026:	6878      	ldr	r0, [r7, #4]
    d028:	2200      	movs	r2, #0
    d02a:	2100      	movs	r1, #0
    d02c:	4c10      	ldr	r4, [pc, #64]	; (d070 <tcp_keepalive+0x60>)
    d02e:	47a0      	blx	r4
    d030:	0003      	movs	r3, r0
    d032:	60fb      	str	r3, [r7, #12]
  if(p == NULL) {
    d034:	68fb      	ldr	r3, [r7, #12]
    d036:	2b00      	cmp	r3, #0
    d038:	d014      	beq.n	d064 <tcp_keepalive+0x54>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    d03a:	68fb      	ldr	r3, [r7, #12]
    d03c:	685b      	ldr	r3, [r3, #4]
    d03e:	60bb      	str	r3, [r7, #8]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    d040:	6879      	ldr	r1, [r7, #4]
    d042:	687b      	ldr	r3, [r7, #4]
    d044:	1d1a      	adds	r2, r3, #4
    d046:	687b      	ldr	r3, [r7, #4]
    d048:	7a9c      	ldrb	r4, [r3, #10]
    d04a:	68f8      	ldr	r0, [r7, #12]
    d04c:	2306      	movs	r3, #6
    d04e:	9301      	str	r3, [sp, #4]
    d050:	2300      	movs	r3, #0
    d052:	9300      	str	r3, [sp, #0]
    d054:	0023      	movs	r3, r4
    d056:	4c07      	ldr	r4, [pc, #28]	; (d074 <tcp_keepalive+0x64>)
    d058:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    d05a:	68fb      	ldr	r3, [r7, #12]
    d05c:	0018      	movs	r0, r3
    d05e:	4b06      	ldr	r3, [pc, #24]	; (d078 <tcp_keepalive+0x68>)
    d060:	4798      	blx	r3
    d062:	e000      	b.n	d066 <tcp_keepalive+0x56>
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
    d064:	46c0      	nop			; (mov r8, r8)

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    d066:	46bd      	mov	sp, r7
    d068:	b005      	add	sp, #20
    d06a:	bd90      	pop	{r4, r7, pc}
    d06c:	00005641 	.word	0x00005641
    d070:	0000bf95 	.word	0x0000bf95
    d074:	0000620d 	.word	0x0000620d
    d078:	00008349 	.word	0x00008349

0000d07c <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    d07c:	b590      	push	{r4, r7, lr}
    d07e:	b08b      	sub	sp, #44	; 0x2c
    d080:	af02      	add	r7, sp, #8
    d082:	6078      	str	r0, [r7, #4]
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
    d084:	687b      	ldr	r3, [r7, #4]
    d086:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    d088:	61fb      	str	r3, [r7, #28]

  if(seg == NULL) {
    d08a:	69fb      	ldr	r3, [r7, #28]
    d08c:	2b00      	cmp	r3, #0
    d08e:	d102      	bne.n	d096 <tcp_zero_window_probe+0x1a>
    seg = pcb->unsent;
    d090:	687b      	ldr	r3, [r7, #4]
    d092:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    d094:	61fb      	str	r3, [r7, #28]
  }
  if(seg == NULL) {
    d096:	69fb      	ldr	r3, [r7, #28]
    d098:	2b00      	cmp	r3, #0
    d09a:	d100      	bne.n	d09e <tcp_zero_window_probe+0x22>
    d09c:	e08d      	b.n	d1ba <tcp_zero_window_probe+0x13e>
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    d09e:	69fb      	ldr	r3, [r7, #28]
    d0a0:	68db      	ldr	r3, [r3, #12]
    d0a2:	7b1a      	ldrb	r2, [r3, #12]
    d0a4:	7b5b      	ldrb	r3, [r3, #13]
    d0a6:	021b      	lsls	r3, r3, #8
    d0a8:	4313      	orrs	r3, r2
    d0aa:	b29b      	uxth	r3, r3
    d0ac:	0018      	movs	r0, r3
    d0ae:	4b46      	ldr	r3, [pc, #280]	; (d1c8 <tcp_zero_window_probe+0x14c>)
    d0b0:	4798      	blx	r3
    d0b2:	0003      	movs	r3, r0
    d0b4:	001a      	movs	r2, r3
    d0b6:	2301      	movs	r3, #1
    d0b8:	4013      	ands	r3, r2
    d0ba:	d005      	beq.n	d0c8 <tcp_zero_window_probe+0x4c>
    d0bc:	69fb      	ldr	r3, [r7, #28]
    d0be:	891b      	ldrh	r3, [r3, #8]
    d0c0:	2b00      	cmp	r3, #0
    d0c2:	d101      	bne.n	d0c8 <tcp_zero_window_probe+0x4c>
    d0c4:	2201      	movs	r2, #1
    d0c6:	e000      	b.n	d0ca <tcp_zero_window_probe+0x4e>
    d0c8:	2200      	movs	r2, #0
    d0ca:	231b      	movs	r3, #27
    d0cc:	18fb      	adds	r3, r7, r3
    d0ce:	701a      	strb	r2, [r3, #0]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
    d0d0:	231b      	movs	r3, #27
    d0d2:	18fb      	adds	r3, r7, r3
    d0d4:	781b      	ldrb	r3, [r3, #0]
    d0d6:	425a      	negs	r2, r3
    d0d8:	4153      	adcs	r3, r2
    d0da:	b2da      	uxtb	r2, r3
    d0dc:	2318      	movs	r3, #24
    d0de:	18fb      	adds	r3, r7, r3
    d0e0:	801a      	strh	r2, [r3, #0]

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    d0e2:	69fb      	ldr	r3, [r7, #28]
    d0e4:	68db      	ldr	r3, [r3, #12]
    d0e6:	791a      	ldrb	r2, [r3, #4]
    d0e8:	7959      	ldrb	r1, [r3, #5]
    d0ea:	0209      	lsls	r1, r1, #8
    d0ec:	430a      	orrs	r2, r1
    d0ee:	7999      	ldrb	r1, [r3, #6]
    d0f0:	0409      	lsls	r1, r1, #16
    d0f2:	430a      	orrs	r2, r1
    d0f4:	79db      	ldrb	r3, [r3, #7]
    d0f6:	061b      	lsls	r3, r3, #24
    d0f8:	4313      	orrs	r3, r2
    d0fa:	0019      	movs	r1, r3
    d0fc:	2318      	movs	r3, #24
    d0fe:	18fb      	adds	r3, r7, r3
    d100:	881a      	ldrh	r2, [r3, #0]
    d102:	6878      	ldr	r0, [r7, #4]
    d104:	000b      	movs	r3, r1
    d106:	2100      	movs	r1, #0
    d108:	4c30      	ldr	r4, [pc, #192]	; (d1cc <tcp_zero_window_probe+0x150>)
    d10a:	47a0      	blx	r4
    d10c:	0003      	movs	r3, r0
    d10e:	617b      	str	r3, [r7, #20]
  if(p == NULL) {
    d110:	697b      	ldr	r3, [r7, #20]
    d112:	2b00      	cmp	r3, #0
    d114:	d053      	beq.n	d1be <tcp_zero_window_probe+0x142>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    d116:	697b      	ldr	r3, [r7, #20]
    d118:	685b      	ldr	r3, [r3, #4]
    d11a:	613b      	str	r3, [r7, #16]

  if (is_fin) {
    d11c:	231b      	movs	r3, #27
    d11e:	18fb      	adds	r3, r7, r3
    d120:	781b      	ldrb	r3, [r3, #0]
    d122:	2b00      	cmp	r3, #0
    d124:	d026      	beq.n	d174 <tcp_zero_window_probe+0xf8>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    d126:	693b      	ldr	r3, [r7, #16]
    d128:	7b1a      	ldrb	r2, [r3, #12]
    d12a:	7b5b      	ldrb	r3, [r3, #13]
    d12c:	021b      	lsls	r3, r3, #8
    d12e:	4313      	orrs	r3, r2
    d130:	b29b      	uxth	r3, r3
    d132:	b21b      	sxth	r3, r3
    d134:	4a26      	ldr	r2, [pc, #152]	; (d1d0 <tcp_zero_window_probe+0x154>)
    d136:	4013      	ands	r3, r2
    d138:	b21c      	sxth	r4, r3
    d13a:	2011      	movs	r0, #17
    d13c:	4b25      	ldr	r3, [pc, #148]	; (d1d4 <tcp_zero_window_probe+0x158>)
    d13e:	4798      	blx	r3
    d140:	0003      	movs	r3, r0
    d142:	b21b      	sxth	r3, r3
    d144:	4323      	orrs	r3, r4
    d146:	b21b      	sxth	r3, r3
    d148:	b29a      	uxth	r2, r3
    d14a:	693b      	ldr	r3, [r7, #16]
    d14c:	21ff      	movs	r1, #255	; 0xff
    d14e:	4011      	ands	r1, r2
    d150:	000c      	movs	r4, r1
    d152:	7b19      	ldrb	r1, [r3, #12]
    d154:	2000      	movs	r0, #0
    d156:	4001      	ands	r1, r0
    d158:	1c08      	adds	r0, r1, #0
    d15a:	1c21      	adds	r1, r4, #0
    d15c:	4301      	orrs	r1, r0
    d15e:	7319      	strb	r1, [r3, #12]
    d160:	0a12      	lsrs	r2, r2, #8
    d162:	b290      	uxth	r0, r2
    d164:	7b5a      	ldrb	r2, [r3, #13]
    d166:	2100      	movs	r1, #0
    d168:	400a      	ands	r2, r1
    d16a:	1c11      	adds	r1, r2, #0
    d16c:	1c02      	adds	r2, r0, #0
    d16e:	430a      	orrs	r2, r1
    d170:	735a      	strb	r2, [r3, #13]
    d172:	e010      	b.n	d196 <tcp_zero_window_probe+0x11a>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    d174:	697b      	ldr	r3, [r7, #20]
    d176:	685b      	ldr	r3, [r3, #4]
    d178:	3314      	adds	r3, #20
    d17a:	60fb      	str	r3, [r7, #12]
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    d17c:	69fb      	ldr	r3, [r7, #28]
    d17e:	6858      	ldr	r0, [r3, #4]
    d180:	69fb      	ldr	r3, [r7, #28]
    d182:	685b      	ldr	r3, [r3, #4]
    d184:	891a      	ldrh	r2, [r3, #8]
    d186:	69fb      	ldr	r3, [r7, #28]
    d188:	891b      	ldrh	r3, [r3, #8]
    d18a:	1ad3      	subs	r3, r2, r3
    d18c:	b29b      	uxth	r3, r3
    d18e:	68f9      	ldr	r1, [r7, #12]
    d190:	2201      	movs	r2, #1
    d192:	4c11      	ldr	r4, [pc, #68]	; (d1d8 <tcp_zero_window_probe+0x15c>)
    d194:	47a0      	blx	r4
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    d196:	6879      	ldr	r1, [r7, #4]
    d198:	687b      	ldr	r3, [r7, #4]
    d19a:	1d1a      	adds	r2, r3, #4
    d19c:	687b      	ldr	r3, [r7, #4]
    d19e:	7a9c      	ldrb	r4, [r3, #10]
    d1a0:	6978      	ldr	r0, [r7, #20]
    d1a2:	2306      	movs	r3, #6
    d1a4:	9301      	str	r3, [sp, #4]
    d1a6:	2300      	movs	r3, #0
    d1a8:	9300      	str	r3, [sp, #0]
    d1aa:	0023      	movs	r3, r4
    d1ac:	4c0b      	ldr	r4, [pc, #44]	; (d1dc <tcp_zero_window_probe+0x160>)
    d1ae:	47a0      	blx	r4
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    d1b0:	697b      	ldr	r3, [r7, #20]
    d1b2:	0018      	movs	r0, r3
    d1b4:	4b0a      	ldr	r3, [pc, #40]	; (d1e0 <tcp_zero_window_probe+0x164>)
    d1b6:	4798      	blx	r3
    d1b8:	e002      	b.n	d1c0 <tcp_zero_window_probe+0x144>

  if(seg == NULL) {
    seg = pcb->unsent;
  }
  if(seg == NULL) {
    return;
    d1ba:	46c0      	nop			; (mov r8, r8)
    d1bc:	e000      	b.n	d1c0 <tcp_zero_window_probe+0x144>
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
    d1be:	46c0      	nop			; (mov r8, r8)
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    d1c0:	46bd      	mov	sp, r7
    d1c2:	b009      	add	sp, #36	; 0x24
    d1c4:	bd90      	pop	{r4, r7, pc}
    d1c6:	46c0      	nop			; (mov r8, r8)
    d1c8:	0000561d 	.word	0x0000561d
    d1cc:	0000bf95 	.word	0x0000bf95
    d1d0:	ffffc0ff 	.word	0xffffc0ff
    d1d4:	000055f1 	.word	0x000055f1
    d1d8:	00008689 	.word	0x00008689
    d1dc:	0000620d 	.word	0x0000620d
    d1e0:	00008349 	.word	0x00008349

0000d1e4 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
    d1e4:	b580      	push	{r7, lr}
    d1e6:	af00      	add	r7, sp, #0
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
    d1e8:	46c0      	nop			; (mov r8, r8)
    d1ea:	46bd      	mov	sp, r7
    d1ec:	bd80      	pop	{r7, pc}
    d1ee:	46c0      	nop			; (mov r8, r8)

0000d1f0 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
    d1f0:	b580      	push	{r7, lr}
    d1f2:	b082      	sub	sp, #8
    d1f4:	af00      	add	r7, sp, #0
  u16_t n = 0;
    d1f6:	1dbb      	adds	r3, r7, #6
    d1f8:	2200      	movs	r2, #0
    d1fa:	801a      	strh	r2, [r3, #0]
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    d1fc:	4b16      	ldr	r3, [pc, #88]	; (d258 <udp_new_port+0x68>)
    d1fe:	881b      	ldrh	r3, [r3, #0]
    d200:	1c5a      	adds	r2, r3, #1
    d202:	b291      	uxth	r1, r2
    d204:	4a14      	ldr	r2, [pc, #80]	; (d258 <udp_new_port+0x68>)
    d206:	8011      	strh	r1, [r2, #0]
    d208:	4a14      	ldr	r2, [pc, #80]	; (d25c <udp_new_port+0x6c>)
    d20a:	4293      	cmp	r3, r2
    d20c:	d102      	bne.n	d214 <udp_new_port+0x24>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
    d20e:	4b12      	ldr	r3, [pc, #72]	; (d258 <udp_new_port+0x68>)
    d210:	4a13      	ldr	r2, [pc, #76]	; (d260 <udp_new_port+0x70>)
    d212:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d214:	4b13      	ldr	r3, [pc, #76]	; (d264 <udp_new_port+0x74>)
    d216:	681b      	ldr	r3, [r3, #0]
    d218:	603b      	str	r3, [r7, #0]
    d21a:	e014      	b.n	d246 <udp_new_port+0x56>
    if (pcb->local_port == udp_port) {
    d21c:	683b      	ldr	r3, [r7, #0]
    d21e:	8a5a      	ldrh	r2, [r3, #18]
    d220:	4b0d      	ldr	r3, [pc, #52]	; (d258 <udp_new_port+0x68>)
    d222:	881b      	ldrh	r3, [r3, #0]
    d224:	429a      	cmp	r2, r3
    d226:	d10b      	bne.n	d240 <udp_new_port+0x50>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
    d228:	1dbb      	adds	r3, r7, #6
    d22a:	1dba      	adds	r2, r7, #6
    d22c:	8812      	ldrh	r2, [r2, #0]
    d22e:	3201      	adds	r2, #1
    d230:	801a      	strh	r2, [r3, #0]
    d232:	1dbb      	adds	r3, r7, #6
    d234:	881b      	ldrh	r3, [r3, #0]
    d236:	4a0c      	ldr	r2, [pc, #48]	; (d268 <udp_new_port+0x78>)
    d238:	4293      	cmp	r3, r2
    d23a:	d9df      	bls.n	d1fc <udp_new_port+0xc>
        return 0;
    d23c:	2300      	movs	r3, #0
    d23e:	e007      	b.n	d250 <udp_new_port+0x60>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d240:	683b      	ldr	r3, [r7, #0]
    d242:	68db      	ldr	r3, [r3, #12]
    d244:	603b      	str	r3, [r7, #0]
    d246:	683b      	ldr	r3, [r7, #0]
    d248:	2b00      	cmp	r3, #0
    d24a:	d1e7      	bne.n	d21c <udp_new_port+0x2c>
        return 0;
      }
      goto again;
    }
  }
  return udp_port;
    d24c:	4b02      	ldr	r3, [pc, #8]	; (d258 <udp_new_port+0x68>)
    d24e:	881b      	ldrh	r3, [r3, #0]
  if (ipcb != NULL) {
    return 0;
  }
  return udp_port;
#endif
}
    d250:	0018      	movs	r0, r3
    d252:	46bd      	mov	sp, r7
    d254:	b002      	add	sp, #8
    d256:	bd80      	pop	{r7, pc}
    d258:	20000010 	.word	0x20000010
    d25c:	0000ffff 	.word	0x0000ffff
    d260:	ffffc000 	.word	0xffffc000
    d264:	20003ee0 	.word	0x20003ee0
    d268:	00003fff 	.word	0x00003fff

0000d26c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
    d26c:	b5b0      	push	{r4, r5, r7, lr}
    d26e:	b08c      	sub	sp, #48	; 0x30
    d270:	af02      	add	r7, sp, #8
    d272:	6078      	str	r0, [r7, #4]
    d274:	6039      	str	r1, [r7, #0]

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = (struct ip_hdr *)p->payload;
    d276:	687b      	ldr	r3, [r7, #4]
    d278:	685b      	ldr	r3, [r3, #4]
    d27a:	617b      	str	r3, [r7, #20]

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
    d27c:	687b      	ldr	r3, [r7, #4]
    d27e:	891b      	ldrh	r3, [r3, #8]
    d280:	001a      	movs	r2, r3
    d282:	697b      	ldr	r3, [r7, #20]
    d284:	781b      	ldrb	r3, [r3, #0]
    d286:	0019      	movs	r1, r3
    d288:	230f      	movs	r3, #15
    d28a:	400b      	ands	r3, r1
    d28c:	3302      	adds	r3, #2
    d28e:	009b      	lsls	r3, r3, #2
    d290:	429a      	cmp	r2, r3
    d292:	db11      	blt.n	d2b8 <udp_input+0x4c>
    d294:	697b      	ldr	r3, [r7, #20]
    d296:	781b      	ldrb	r3, [r3, #0]
    d298:	b29b      	uxth	r3, r3
    d29a:	220f      	movs	r2, #15
    d29c:	4013      	ands	r3, r2
    d29e:	b29b      	uxth	r3, r3
    d2a0:	009b      	lsls	r3, r3, #2
    d2a2:	b29b      	uxth	r3, r3
    d2a4:	425b      	negs	r3, r3
    d2a6:	b29b      	uxth	r3, r3
    d2a8:	b21a      	sxth	r2, r3
    d2aa:	687b      	ldr	r3, [r7, #4]
    d2ac:	0011      	movs	r1, r2
    d2ae:	0018      	movs	r0, r3
    d2b0:	4b89      	ldr	r3, [pc, #548]	; (d4d8 <udp_input+0x26c>)
    d2b2:	4798      	blx	r3
    d2b4:	1e03      	subs	r3, r0, #0
    d2b6:	d004      	beq.n	d2c2 <udp_input+0x56>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
    d2b8:	687b      	ldr	r3, [r7, #4]
    d2ba:	0018      	movs	r0, r3
    d2bc:	4b87      	ldr	r3, [pc, #540]	; (d4dc <udp_input+0x270>)
    d2be:	4798      	blx	r3
    goto end;
    d2c0:	e105      	b.n	d4ce <udp_input+0x262>
  }

  udphdr = (struct udp_hdr *)p->payload;
    d2c2:	687b      	ldr	r3, [r7, #4]
    d2c4:	685b      	ldr	r3, [r3, #4]
    d2c6:	613b      	str	r3, [r7, #16]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
    d2c8:	4b85      	ldr	r3, [pc, #532]	; (d4e0 <udp_input+0x274>)
    d2ca:	681b      	ldr	r3, [r3, #0]
    d2cc:	220f      	movs	r2, #15
    d2ce:	18bc      	adds	r4, r7, r2
    d2d0:	683a      	ldr	r2, [r7, #0]
    d2d2:	0011      	movs	r1, r2
    d2d4:	0018      	movs	r0, r3
    d2d6:	4b83      	ldr	r3, [pc, #524]	; (d4e4 <udp_input+0x278>)
    d2d8:	4798      	blx	r3
    d2da:	0003      	movs	r3, r0
    d2dc:	7023      	strb	r3, [r4, #0]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
    d2de:	693b      	ldr	r3, [r7, #16]
    d2e0:	781a      	ldrb	r2, [r3, #0]
    d2e2:	785b      	ldrb	r3, [r3, #1]
    d2e4:	021b      	lsls	r3, r3, #8
    d2e6:	4313      	orrs	r3, r2
    d2e8:	b29b      	uxth	r3, r3
    d2ea:	220c      	movs	r2, #12
    d2ec:	18bc      	adds	r4, r7, r2
    d2ee:	0018      	movs	r0, r3
    d2f0:	4b7d      	ldr	r3, [pc, #500]	; (d4e8 <udp_input+0x27c>)
    d2f2:	4798      	blx	r3
    d2f4:	0003      	movs	r3, r0
    d2f6:	8023      	strh	r3, [r4, #0]
  dest = ntohs(udphdr->dest);
    d2f8:	693b      	ldr	r3, [r7, #16]
    d2fa:	789a      	ldrb	r2, [r3, #2]
    d2fc:	78db      	ldrb	r3, [r3, #3]
    d2fe:	021b      	lsls	r3, r3, #8
    d300:	4313      	orrs	r3, r2
    d302:	b29b      	uxth	r3, r3
    d304:	220a      	movs	r2, #10
    d306:	18bc      	adds	r4, r7, r2
    d308:	0018      	movs	r0, r3
    d30a:	4b77      	ldr	r3, [pc, #476]	; (d4e8 <udp_input+0x27c>)
    d30c:	4798      	blx	r3
    d30e:	0003      	movs	r3, r0
    d310:	8023      	strh	r3, [r4, #0]
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    d312:	2300      	movs	r3, #0
    d314:	623b      	str	r3, [r7, #32]
    local_match = 0;
    d316:	231b      	movs	r3, #27
    d318:	18fb      	adds	r3, r7, r3
    d31a:	2200      	movs	r2, #0
    d31c:	701a      	strb	r2, [r3, #0]
    uncon_pcb = NULL;
    d31e:	2300      	movs	r3, #0
    d320:	61fb      	str	r3, [r7, #28]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d322:	4b72      	ldr	r3, [pc, #456]	; (d4ec <udp_input+0x280>)
    d324:	681b      	ldr	r3, [r3, #0]
    d326:	627b      	str	r3, [r7, #36]	; 0x24
    d328:	e06e      	b.n	d408 <udp_input+0x19c>
      local_match = 0;
    d32a:	231b      	movs	r3, #27
    d32c:	18fb      	adds	r3, r7, r3
    d32e:	2200      	movs	r2, #0
    d330:	701a      	strb	r2, [r3, #0]
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
    d332:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d334:	8a5b      	ldrh	r3, [r3, #18]
    d336:	220a      	movs	r2, #10
    d338:	18ba      	adds	r2, r7, r2
    d33a:	8812      	ldrh	r2, [r2, #0]
    d33c:	429a      	cmp	r2, r3
    d33e:	d135      	bne.n	d3ac <udp_input+0x140>
        if (
    d340:	230f      	movs	r3, #15
    d342:	18fb      	adds	r3, r7, r3
    d344:	781b      	ldrb	r3, [r3, #0]
    d346:	2b00      	cmp	r3, #0
    d348:	d106      	bne.n	d358 <udp_input+0xec>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    d34a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d34c:	2b00      	cmp	r3, #0
    d34e:	d01e      	beq.n	d38e <udp_input+0x122>
    d350:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d352:	681b      	ldr	r3, [r3, #0]
    d354:	2b00      	cmp	r3, #0
    d356:	d01a      	beq.n	d38e <udp_input+0x122>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
    d358:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d35a:	681a      	ldr	r2, [r3, #0]
    d35c:	4b60      	ldr	r3, [pc, #384]	; (d4e0 <udp_input+0x274>)
    d35e:	681b      	ldr	r3, [r3, #0]
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
    d360:	429a      	cmp	r2, r3
    d362:	d014      	beq.n	d38e <udp_input+0x122>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
    d364:	230f      	movs	r3, #15
    d366:	18fb      	adds	r3, r7, r3
    d368:	781b      	ldrb	r3, [r3, #0]
    d36a:	2b00      	cmp	r3, #0
    d36c:	d01e      	beq.n	d3ac <udp_input+0x140>
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
    d36e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
    d370:	2b00      	cmp	r3, #0
    d372:	d00c      	beq.n	d38e <udp_input+0x122>
             (ip_addr_isany(&pcb->local_ip) ||
    d374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d376:	681b      	ldr	r3, [r3, #0]
    d378:	2b00      	cmp	r3, #0
    d37a:	d008      	beq.n	d38e <udp_input+0x122>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
    d37c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d37e:	681a      	ldr	r2, [r3, #0]
    d380:	4b57      	ldr	r3, [pc, #348]	; (d4e0 <udp_input+0x274>)
    d382:	681b      	ldr	r3, [r3, #0]
    d384:	405a      	eors	r2, r3
    d386:	683b      	ldr	r3, [r7, #0]
    d388:	689b      	ldr	r3, [r3, #8]
    d38a:	4013      	ands	r3, r2
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
    d38c:	d10e      	bne.n	d3ac <udp_input+0x140>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
    d38e:	231b      	movs	r3, #27
    d390:	18fb      	adds	r3, r7, r3
    d392:	2201      	movs	r2, #1
    d394:	701a      	strb	r2, [r3, #0]
          if ((uncon_pcb == NULL) && 
    d396:	69fb      	ldr	r3, [r7, #28]
    d398:	2b00      	cmp	r3, #0
    d39a:	d107      	bne.n	d3ac <udp_input+0x140>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
    d39c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d39e:	7c1b      	ldrb	r3, [r3, #16]
    d3a0:	001a      	movs	r2, r3
    d3a2:	2304      	movs	r3, #4
    d3a4:	4013      	ands	r3, r2
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
    d3a6:	d101      	bne.n	d3ac <udp_input+0x140>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
    d3a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3aa:	61fb      	str	r3, [r7, #28]
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    d3ac:	231b      	movs	r3, #27
    d3ae:	18fb      	adds	r3, r7, r3
    d3b0:	781b      	ldrb	r3, [r3, #0]
    d3b2:	2b00      	cmp	r3, #0
    d3b4:	d023      	beq.n	d3fe <udp_input+0x192>
          (pcb->remote_port == src) &&
    d3b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3b8:	8a9b      	ldrh	r3, [r3, #20]
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
    d3ba:	220c      	movs	r2, #12
    d3bc:	18ba      	adds	r2, r7, r2
    d3be:	8812      	ldrh	r2, [r2, #0]
    d3c0:	429a      	cmp	r2, r3
    d3c2:	d11c      	bne.n	d3fe <udp_input+0x192>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
    d3c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3c6:	3304      	adds	r3, #4
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
    d3c8:	2b00      	cmp	r3, #0
    d3ca:	d009      	beq.n	d3e0 <udp_input+0x174>
          (ip_addr_isany(&pcb->remote_ip) ||
    d3cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3ce:	685b      	ldr	r3, [r3, #4]
    d3d0:	2b00      	cmp	r3, #0
    d3d2:	d005      	beq.n	d3e0 <udp_input+0x174>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
    d3d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3d6:	685a      	ldr	r2, [r3, #4]
    d3d8:	4b45      	ldr	r3, [pc, #276]	; (d4f0 <udp_input+0x284>)
    d3da:	681b      	ldr	r3, [r3, #0]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
    d3dc:	429a      	cmp	r2, r3
    d3de:	d10e      	bne.n	d3fe <udp_input+0x192>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
    d3e0:	6a3b      	ldr	r3, [r7, #32]
    d3e2:	2b00      	cmp	r3, #0
    d3e4:	d014      	beq.n	d410 <udp_input+0x1a4>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
    d3e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3e8:	68da      	ldr	r2, [r3, #12]
    d3ea:	6a3b      	ldr	r3, [r7, #32]
    d3ec:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
    d3ee:	4b3f      	ldr	r3, [pc, #252]	; (d4ec <udp_input+0x280>)
    d3f0:	681a      	ldr	r2, [r3, #0]
    d3f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d3f4:	60da      	str	r2, [r3, #12]
          udp_pcbs = pcb;
    d3f6:	4b3d      	ldr	r3, [pc, #244]	; (d4ec <udp_input+0x280>)
    d3f8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    d3fa:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
    d3fc:	e008      	b.n	d410 <udp_input+0x1a4>
      }
      prev = pcb;
    d3fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d400:	623b      	str	r3, [r7, #32]
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    d402:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d404:	68db      	ldr	r3, [r3, #12]
    d406:	627b      	str	r3, [r7, #36]	; 0x24
    d408:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d40a:	2b00      	cmp	r3, #0
    d40c:	d18d      	bne.n	d32a <udp_input+0xbe>
    d40e:	e000      	b.n	d412 <udp_input+0x1a6>
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
    d410:	46c0      	nop			; (mov r8, r8)
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
    d412:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d414:	2b00      	cmp	r3, #0
    d416:	d101      	bne.n	d41c <udp_input+0x1b0>
      pcb = uncon_pcb;
    d418:	69fb      	ldr	r3, [r7, #28]
    d41a:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
    d41c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d41e:	2b00      	cmp	r3, #0
    d420:	d105      	bne.n	d42e <udp_input+0x1c2>
    d422:	683b      	ldr	r3, [r7, #0]
    d424:	685a      	ldr	r2, [r3, #4]
    d426:	4b2e      	ldr	r3, [pc, #184]	; (d4e0 <udp_input+0x274>)
    d428:	681b      	ldr	r3, [r3, #0]
    d42a:	429a      	cmp	r2, r3
    d42c:	d14b      	bne.n	d4c6 <udp_input+0x25a>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
    d42e:	2308      	movs	r3, #8
    d430:	425a      	negs	r2, r3
    d432:	687b      	ldr	r3, [r7, #4]
    d434:	0011      	movs	r1, r2
    d436:	0018      	movs	r0, r3
    d438:	4b27      	ldr	r3, [pc, #156]	; (d4d8 <udp_input+0x26c>)
    d43a:	4798      	blx	r3
    d43c:	1e03      	subs	r3, r0, #0
    d43e:	d004      	beq.n	d44a <udp_input+0x1de>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
    d440:	687b      	ldr	r3, [r7, #4]
    d442:	0018      	movs	r0, r3
    d444:	4b25      	ldr	r3, [pc, #148]	; (d4dc <udp_input+0x270>)
    d446:	4798      	blx	r3
      goto end;
    d448:	e041      	b.n	d4ce <udp_input+0x262>
    }
    if (pcb != NULL) {
    d44a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d44c:	2b00      	cmp	r3, #0
    d44e:	d016      	beq.n	d47e <udp_input+0x212>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
    d450:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d452:	699b      	ldr	r3, [r3, #24]
    d454:	2b00      	cmp	r3, #0
    d456:	d00d      	beq.n	d474 <udp_input+0x208>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
    d458:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d45a:	699c      	ldr	r4, [r3, #24]
    d45c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    d45e:	69d8      	ldr	r0, [r3, #28]
    d460:	4d23      	ldr	r5, [pc, #140]	; (d4f0 <udp_input+0x284>)
    d462:	687a      	ldr	r2, [r7, #4]
    d464:	6a79      	ldr	r1, [r7, #36]	; 0x24
    d466:	230c      	movs	r3, #12
    d468:	18fb      	adds	r3, r7, r3
    d46a:	881b      	ldrh	r3, [r3, #0]
    d46c:	9300      	str	r3, [sp, #0]
    d46e:	002b      	movs	r3, r5
    d470:	47a0      	blx	r4
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
    d472:	e02c      	b.n	d4ce <udp_input+0x262>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
    d474:	687b      	ldr	r3, [r7, #4]
    d476:	0018      	movs	r0, r3
    d478:	4b18      	ldr	r3, [pc, #96]	; (d4dc <udp_input+0x270>)
    d47a:	4798      	blx	r3
        goto end;
    d47c:	e027      	b.n	d4ce <udp_input+0x262>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
    d47e:	230f      	movs	r3, #15
    d480:	18fb      	adds	r3, r7, r3
    d482:	781b      	ldrb	r3, [r3, #0]
    d484:	2b00      	cmp	r3, #0
    d486:	d119      	bne.n	d4bc <udp_input+0x250>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
    d488:	4b15      	ldr	r3, [pc, #84]	; (d4e0 <udp_input+0x274>)
    d48a:	681b      	ldr	r3, [r3, #0]
    d48c:	22f0      	movs	r2, #240	; 0xf0
    d48e:	4013      	ands	r3, r2
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
    d490:	2be0      	cmp	r3, #224	; 0xe0
    d492:	d013      	beq.n	d4bc <udp_input+0x250>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
    d494:	697b      	ldr	r3, [r7, #20]
    d496:	781b      	ldrb	r3, [r3, #0]
    d498:	001a      	movs	r2, r3
    d49a:	230f      	movs	r3, #15
    d49c:	4013      	ands	r3, r2
    d49e:	3302      	adds	r3, #2
    d4a0:	b29b      	uxth	r3, r3
    d4a2:	009b      	lsls	r3, r3, #2
    d4a4:	b29b      	uxth	r3, r3
    d4a6:	b21a      	sxth	r2, r3
    d4a8:	687b      	ldr	r3, [r7, #4]
    d4aa:	0011      	movs	r1, r2
    d4ac:	0018      	movs	r0, r3
    d4ae:	4b0a      	ldr	r3, [pc, #40]	; (d4d8 <udp_input+0x26c>)
    d4b0:	4798      	blx	r3
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
    d4b2:	687b      	ldr	r3, [r7, #4]
    d4b4:	2103      	movs	r1, #3
    d4b6:	0018      	movs	r0, r3
    d4b8:	4b0e      	ldr	r3, [pc, #56]	; (d4f4 <udp_input+0x288>)
    d4ba:	4798      	blx	r3
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    d4bc:	687b      	ldr	r3, [r7, #4]
    d4be:	0018      	movs	r0, r3
    d4c0:	4b06      	ldr	r3, [pc, #24]	; (d4dc <udp_input+0x270>)
    d4c2:	4798      	blx	r3
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
    d4c4:	e003      	b.n	d4ce <udp_input+0x262>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
    d4c6:	687b      	ldr	r3, [r7, #4]
    d4c8:	0018      	movs	r0, r3
    d4ca:	4b04      	ldr	r3, [pc, #16]	; (d4dc <udp_input+0x270>)
    d4cc:	4798      	blx	r3
  }
end:
  PERF_STOP("udp_input");
}
    d4ce:	46c0      	nop			; (mov r8, r8)
    d4d0:	46bd      	mov	sp, r7
    d4d2:	b00a      	add	sp, #40	; 0x28
    d4d4:	bdb0      	pop	{r4, r5, r7, pc}
    d4d6:	46c0      	nop			; (mov r8, r8)
    d4d8:	00008235 	.word	0x00008235
    d4dc:	00008349 	.word	0x00008349
    d4e0:	20002e98 	.word	0x20002e98
    d4e4:	0000626d 	.word	0x0000626d
    d4e8:	0000561d 	.word	0x0000561d
    d4ec:	20003ee0 	.word	0x20003ee0
    d4f0:	20002e90 	.word	0x20002e90
    d4f4:	0000596d 	.word	0x0000596d

0000d4f8 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
    d4f8:	b590      	push	{r4, r7, lr}
    d4fa:	b089      	sub	sp, #36	; 0x24
    d4fc:	af02      	add	r7, sp, #8
    d4fe:	60f8      	str	r0, [r7, #12]
    d500:	60b9      	str	r1, [r7, #8]
    d502:	607a      	str	r2, [r7, #4]
    d504:	001a      	movs	r2, r3
    d506:	1cbb      	adds	r3, r7, #2
    d508:	801a      	strh	r2, [r3, #0]

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
    d50a:	687b      	ldr	r3, [r7, #4]
    d50c:	0018      	movs	r0, r3
    d50e:	4b0c      	ldr	r3, [pc, #48]	; (d540 <udp_sendto+0x48>)
    d510:	4798      	blx	r3
    d512:	0003      	movs	r3, r0
    d514:	617b      	str	r3, [r7, #20]
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    d516:	697b      	ldr	r3, [r7, #20]
    d518:	2b00      	cmp	r3, #0
    d51a:	d102      	bne.n	d522 <udp_sendto+0x2a>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
    d51c:	2304      	movs	r3, #4
    d51e:	425b      	negs	r3, r3
    d520:	e00a      	b.n	d538 <udp_sendto+0x40>
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
    d522:	1cbb      	adds	r3, r7, #2
    d524:	881c      	ldrh	r4, [r3, #0]
    d526:	687a      	ldr	r2, [r7, #4]
    d528:	68b9      	ldr	r1, [r7, #8]
    d52a:	68f8      	ldr	r0, [r7, #12]
    d52c:	697b      	ldr	r3, [r7, #20]
    d52e:	9300      	str	r3, [sp, #0]
    d530:	0023      	movs	r3, r4
    d532:	4c04      	ldr	r4, [pc, #16]	; (d544 <udp_sendto+0x4c>)
    d534:	47a0      	blx	r4
    d536:	0003      	movs	r3, r0
#endif /* LWIP_CHECKSUM_ON_COPY */
}
    d538:	0018      	movs	r0, r3
    d53a:	46bd      	mov	sp, r7
    d53c:	b007      	add	sp, #28
    d53e:	bd90      	pop	{r4, r7, pc}
    d540:	00005c89 	.word	0x00005c89
    d544:	0000d549 	.word	0x0000d549

0000d548 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
    d548:	b5f0      	push	{r4, r5, r6, r7, lr}
    d54a:	b08d      	sub	sp, #52	; 0x34
    d54c:	af04      	add	r7, sp, #16
    d54e:	60f8      	str	r0, [r7, #12]
    d550:	60b9      	str	r1, [r7, #8]
    d552:	607a      	str	r2, [r7, #4]
    d554:	001a      	movs	r2, r3
    d556:	1cbb      	adds	r3, r7, #2
    d558:	801a      	strh	r2, [r3, #0]
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
    d55a:	68fb      	ldr	r3, [r7, #12]
    d55c:	8a5b      	ldrh	r3, [r3, #18]
    d55e:	2b00      	cmp	r3, #0
    d560:	d115      	bne.n	d58e <udp_sendto_if+0x46>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
    d562:	68f9      	ldr	r1, [r7, #12]
    d564:	68fb      	ldr	r3, [r7, #12]
    d566:	8a5a      	ldrh	r2, [r3, #18]
    d568:	2317      	movs	r3, #23
    d56a:	18fc      	adds	r4, r7, r3
    d56c:	68fb      	ldr	r3, [r7, #12]
    d56e:	0018      	movs	r0, r3
    d570:	4b69      	ldr	r3, [pc, #420]	; (d718 <udp_sendto_if+0x1d0>)
    d572:	4798      	blx	r3
    d574:	0003      	movs	r3, r0
    d576:	7023      	strb	r3, [r4, #0]
    if (err != ERR_OK) {
    d578:	2317      	movs	r3, #23
    d57a:	18fb      	adds	r3, r7, r3
    d57c:	781b      	ldrb	r3, [r3, #0]
    d57e:	b25b      	sxtb	r3, r3
    d580:	2b00      	cmp	r3, #0
    d582:	d004      	beq.n	d58e <udp_sendto_if+0x46>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
    d584:	2317      	movs	r3, #23
    d586:	18fb      	adds	r3, r7, r3
    d588:	781b      	ldrb	r3, [r3, #0]
    d58a:	b25b      	sxtb	r3, r3
    d58c:	e0bf      	b.n	d70e <udp_sendto_if+0x1c6>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
    d58e:	68bb      	ldr	r3, [r7, #8]
    d590:	2108      	movs	r1, #8
    d592:	0018      	movs	r0, r3
    d594:	4b61      	ldr	r3, [pc, #388]	; (d71c <udp_sendto_if+0x1d4>)
    d596:	4798      	blx	r3
    d598:	1e03      	subs	r3, r0, #0
    d59a:	d017      	beq.n	d5cc <udp_sendto_if+0x84>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    d59c:	2200      	movs	r2, #0
    d59e:	2108      	movs	r1, #8
    d5a0:	2001      	movs	r0, #1
    d5a2:	4b5f      	ldr	r3, [pc, #380]	; (d720 <udp_sendto_if+0x1d8>)
    d5a4:	4798      	blx	r3
    d5a6:	0003      	movs	r3, r0
    d5a8:	61bb      	str	r3, [r7, #24]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
    d5aa:	69bb      	ldr	r3, [r7, #24]
    d5ac:	2b00      	cmp	r3, #0
    d5ae:	d102      	bne.n	d5b6 <udp_sendto_if+0x6e>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    d5b0:	2301      	movs	r3, #1
    d5b2:	425b      	negs	r3, r3
    d5b4:	e0ab      	b.n	d70e <udp_sendto_if+0x1c6>
    }
    if (p->tot_len != 0) {
    d5b6:	68bb      	ldr	r3, [r7, #8]
    d5b8:	891b      	ldrh	r3, [r3, #8]
    d5ba:	2b00      	cmp	r3, #0
    d5bc:	d008      	beq.n	d5d0 <udp_sendto_if+0x88>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
    d5be:	68ba      	ldr	r2, [r7, #8]
    d5c0:	69bb      	ldr	r3, [r7, #24]
    d5c2:	0011      	movs	r1, r2
    d5c4:	0018      	movs	r0, r3
    d5c6:	4b57      	ldr	r3, [pc, #348]	; (d724 <udp_sendto_if+0x1dc>)
    d5c8:	4798      	blx	r3
    d5ca:	e001      	b.n	d5d0 <udp_sendto_if+0x88>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    d5cc:	68bb      	ldr	r3, [r7, #8]
    d5ce:	61bb      	str	r3, [r7, #24]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
    d5d0:	69bb      	ldr	r3, [r7, #24]
    d5d2:	685b      	ldr	r3, [r3, #4]
    d5d4:	613b      	str	r3, [r7, #16]
  udphdr->src = htons(pcb->local_port);
    d5d6:	68fb      	ldr	r3, [r7, #12]
    d5d8:	8a5b      	ldrh	r3, [r3, #18]
    d5da:	0018      	movs	r0, r3
    d5dc:	4b52      	ldr	r3, [pc, #328]	; (d728 <udp_sendto_if+0x1e0>)
    d5de:	4798      	blx	r3
    d5e0:	0003      	movs	r3, r0
    d5e2:	001a      	movs	r2, r3
    d5e4:	693b      	ldr	r3, [r7, #16]
    d5e6:	21ff      	movs	r1, #255	; 0xff
    d5e8:	4011      	ands	r1, r2
    d5ea:	000c      	movs	r4, r1
    d5ec:	7819      	ldrb	r1, [r3, #0]
    d5ee:	2000      	movs	r0, #0
    d5f0:	4001      	ands	r1, r0
    d5f2:	1c08      	adds	r0, r1, #0
    d5f4:	1c21      	adds	r1, r4, #0
    d5f6:	4301      	orrs	r1, r0
    d5f8:	7019      	strb	r1, [r3, #0]
    d5fa:	0a12      	lsrs	r2, r2, #8
    d5fc:	b290      	uxth	r0, r2
    d5fe:	785a      	ldrb	r2, [r3, #1]
    d600:	2100      	movs	r1, #0
    d602:	400a      	ands	r2, r1
    d604:	1c11      	adds	r1, r2, #0
    d606:	1c02      	adds	r2, r0, #0
    d608:	430a      	orrs	r2, r1
    d60a:	705a      	strb	r2, [r3, #1]
  udphdr->dest = htons(dst_port);
    d60c:	1cbb      	adds	r3, r7, #2
    d60e:	881b      	ldrh	r3, [r3, #0]
    d610:	0018      	movs	r0, r3
    d612:	4b45      	ldr	r3, [pc, #276]	; (d728 <udp_sendto_if+0x1e0>)
    d614:	4798      	blx	r3
    d616:	0003      	movs	r3, r0
    d618:	001a      	movs	r2, r3
    d61a:	693b      	ldr	r3, [r7, #16]
    d61c:	21ff      	movs	r1, #255	; 0xff
    d61e:	4011      	ands	r1, r2
    d620:	000c      	movs	r4, r1
    d622:	7899      	ldrb	r1, [r3, #2]
    d624:	2000      	movs	r0, #0
    d626:	4001      	ands	r1, r0
    d628:	1c08      	adds	r0, r1, #0
    d62a:	1c21      	adds	r1, r4, #0
    d62c:	4301      	orrs	r1, r0
    d62e:	7099      	strb	r1, [r3, #2]
    d630:	0a12      	lsrs	r2, r2, #8
    d632:	b290      	uxth	r0, r2
    d634:	78da      	ldrb	r2, [r3, #3]
    d636:	2100      	movs	r1, #0
    d638:	400a      	ands	r2, r1
    d63a:	1c11      	adds	r1, r2, #0
    d63c:	1c02      	adds	r2, r0, #0
    d63e:	430a      	orrs	r2, r1
    d640:	70da      	strb	r2, [r3, #3]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
    d642:	693b      	ldr	r3, [r7, #16]
    d644:	799a      	ldrb	r2, [r3, #6]
    d646:	2100      	movs	r1, #0
    d648:	400a      	ands	r2, r1
    d64a:	719a      	strb	r2, [r3, #6]
    d64c:	79da      	ldrb	r2, [r3, #7]
    d64e:	2100      	movs	r1, #0
    d650:	400a      	ands	r2, r1
    d652:	71da      	strb	r2, [r3, #7]
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
    d654:	68fb      	ldr	r3, [r7, #12]
    d656:	2b00      	cmp	r3, #0
    d658:	d003      	beq.n	d662 <udp_sendto_if+0x11a>
    d65a:	68fb      	ldr	r3, [r7, #12]
    d65c:	681b      	ldr	r3, [r3, #0]
    d65e:	2b00      	cmp	r3, #0
    d660:	d103      	bne.n	d66a <udp_sendto_if+0x122>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
    d662:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    d664:	3304      	adds	r3, #4
    d666:	61fb      	str	r3, [r7, #28]
    d668:	e014      	b.n	d694 <udp_sendto_if+0x14c>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
    d66a:	68fb      	ldr	r3, [r7, #12]
    d66c:	681a      	ldr	r2, [r3, #0]
    d66e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    d670:	685b      	ldr	r3, [r3, #4]
    d672:	429a      	cmp	r2, r3
    d674:	d00c      	beq.n	d690 <udp_sendto_if+0x148>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
    d676:	69ba      	ldr	r2, [r7, #24]
    d678:	68bb      	ldr	r3, [r7, #8]
    d67a:	429a      	cmp	r2, r3
    d67c:	d005      	beq.n	d68a <udp_sendto_if+0x142>
        /* free the header pbuf */
        pbuf_free(q);
    d67e:	69bb      	ldr	r3, [r7, #24]
    d680:	0018      	movs	r0, r3
    d682:	4b2a      	ldr	r3, [pc, #168]	; (d72c <udp_sendto_if+0x1e4>)
    d684:	4798      	blx	r3
        q = NULL;
    d686:	2300      	movs	r3, #0
    d688:	61bb      	str	r3, [r7, #24]
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
    d68a:	2306      	movs	r3, #6
    d68c:	425b      	negs	r3, r3
    d68e:	e03e      	b.n	d70e <udp_sendto_if+0x1c6>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
    d690:	68fb      	ldr	r3, [r7, #12]
    d692:	61fb      	str	r3, [r7, #28]
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
    d694:	69bb      	ldr	r3, [r7, #24]
    d696:	891b      	ldrh	r3, [r3, #8]
    d698:	0018      	movs	r0, r3
    d69a:	4b23      	ldr	r3, [pc, #140]	; (d728 <udp_sendto_if+0x1e0>)
    d69c:	4798      	blx	r3
    d69e:	0003      	movs	r3, r0
    d6a0:	001a      	movs	r2, r3
    d6a2:	693b      	ldr	r3, [r7, #16]
    d6a4:	21ff      	movs	r1, #255	; 0xff
    d6a6:	4011      	ands	r1, r2
    d6a8:	000c      	movs	r4, r1
    d6aa:	7919      	ldrb	r1, [r3, #4]
    d6ac:	2000      	movs	r0, #0
    d6ae:	4001      	ands	r1, r0
    d6b0:	1c08      	adds	r0, r1, #0
    d6b2:	1c21      	adds	r1, r4, #0
    d6b4:	4301      	orrs	r1, r0
    d6b6:	7119      	strb	r1, [r3, #4]
    d6b8:	0a12      	lsrs	r2, r2, #8
    d6ba:	b290      	uxth	r0, r2
    d6bc:	795a      	ldrb	r2, [r3, #5]
    d6be:	2100      	movs	r1, #0
    d6c0:	400a      	ands	r2, r1
    d6c2:	1c11      	adds	r1, r2, #0
    d6c4:	1c02      	adds	r2, r0, #0
    d6c6:	430a      	orrs	r2, r1
    d6c8:	715a      	strb	r2, [r3, #5]
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
    d6ca:	68fb      	ldr	r3, [r7, #12]
    d6cc:	7a9e      	ldrb	r6, [r3, #10]
    d6ce:	68fb      	ldr	r3, [r7, #12]
    d6d0:	7a5b      	ldrb	r3, [r3, #9]
    d6d2:	2217      	movs	r2, #23
    d6d4:	18bc      	adds	r4, r7, r2
    d6d6:	687d      	ldr	r5, [r7, #4]
    d6d8:	69f9      	ldr	r1, [r7, #28]
    d6da:	69b8      	ldr	r0, [r7, #24]
    d6dc:	6bba      	ldr	r2, [r7, #56]	; 0x38
    d6de:	9202      	str	r2, [sp, #8]
    d6e0:	2211      	movs	r2, #17
    d6e2:	9201      	str	r2, [sp, #4]
    d6e4:	9300      	str	r3, [sp, #0]
    d6e6:	0033      	movs	r3, r6
    d6e8:	002a      	movs	r2, r5
    d6ea:	4d11      	ldr	r5, [pc, #68]	; (d730 <udp_sendto_if+0x1e8>)
    d6ec:	47a8      	blx	r5
    d6ee:	0003      	movs	r3, r0
    d6f0:	7023      	strb	r3, [r4, #0]
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
    d6f2:	69ba      	ldr	r2, [r7, #24]
    d6f4:	68bb      	ldr	r3, [r7, #8]
    d6f6:	429a      	cmp	r2, r3
    d6f8:	d005      	beq.n	d706 <udp_sendto_if+0x1be>
    /* free the header pbuf */
    pbuf_free(q);
    d6fa:	69bb      	ldr	r3, [r7, #24]
    d6fc:	0018      	movs	r0, r3
    d6fe:	4b0b      	ldr	r3, [pc, #44]	; (d72c <udp_sendto_if+0x1e4>)
    d700:	4798      	blx	r3
    q = NULL;
    d702:	2300      	movs	r3, #0
    d704:	61bb      	str	r3, [r7, #24]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
    d706:	2317      	movs	r3, #23
    d708:	18fb      	adds	r3, r7, r3
    d70a:	781b      	ldrb	r3, [r3, #0]
    d70c:	b25b      	sxtb	r3, r3
}
    d70e:	0018      	movs	r0, r3
    d710:	46bd      	mov	sp, r7
    d712:	b009      	add	sp, #36	; 0x24
    d714:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d716:	46c0      	nop			; (mov r8, r8)
    d718:	0000d735 	.word	0x0000d735
    d71c:	00008235 	.word	0x00008235
    d720:	00007e19 	.word	0x00007e19
    d724:	000084ed 	.word	0x000084ed
    d728:	000055f1 	.word	0x000055f1
    d72c:	00008349 	.word	0x00008349
    d730:	00005f81 	.word	0x00005f81

0000d734 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
    d734:	b590      	push	{r4, r7, lr}
    d736:	b087      	sub	sp, #28
    d738:	af00      	add	r7, sp, #0
    d73a:	60f8      	str	r0, [r7, #12]
    d73c:	60b9      	str	r1, [r7, #8]
    d73e:	1dbb      	adds	r3, r7, #6
    d740:	801a      	strh	r2, [r3, #0]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
    d742:	2313      	movs	r3, #19
    d744:	18fb      	adds	r3, r7, r3
    d746:	2200      	movs	r2, #0
    d748:	701a      	strb	r2, [r3, #0]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d74a:	4b2f      	ldr	r3, [pc, #188]	; (d808 <udp_bind+0xd4>)
    d74c:	681b      	ldr	r3, [r3, #0]
    d74e:	617b      	str	r3, [r7, #20]
    d750:	e028      	b.n	d7a4 <udp_bind+0x70>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
    d752:	68fa      	ldr	r2, [r7, #12]
    d754:	697b      	ldr	r3, [r7, #20]
    d756:	429a      	cmp	r2, r3
    d758:	d104      	bne.n	d764 <udp_bind+0x30>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
    d75a:	2313      	movs	r3, #19
    d75c:	18fb      	adds	r3, r7, r3
    d75e:	2201      	movs	r2, #1
    d760:	701a      	strb	r2, [r3, #0]
    d762:	e01c      	b.n	d79e <udp_bind+0x6a>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    d764:	697b      	ldr	r3, [r7, #20]
    d766:	8a5b      	ldrh	r3, [r3, #18]
    d768:	1dba      	adds	r2, r7, #6
    d76a:	8812      	ldrh	r2, [r2, #0]
    d76c:	429a      	cmp	r2, r3
    d76e:	d116      	bne.n	d79e <udp_bind+0x6a>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
    d770:	697b      	ldr	r3, [r7, #20]
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
    d772:	2b00      	cmp	r3, #0
    d774:	d010      	beq.n	d798 <udp_bind+0x64>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
    d776:	697b      	ldr	r3, [r7, #20]
    d778:	681b      	ldr	r3, [r3, #0]
    d77a:	2b00      	cmp	r3, #0
    d77c:	d00c      	beq.n	d798 <udp_bind+0x64>
    d77e:	68bb      	ldr	r3, [r7, #8]
    d780:	2b00      	cmp	r3, #0
    d782:	d009      	beq.n	d798 <udp_bind+0x64>
           ip_addr_isany(ipaddr) ||
    d784:	68bb      	ldr	r3, [r7, #8]
    d786:	681b      	ldr	r3, [r3, #0]
    d788:	2b00      	cmp	r3, #0
    d78a:	d005      	beq.n	d798 <udp_bind+0x64>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
    d78c:	697b      	ldr	r3, [r7, #20]
    d78e:	681a      	ldr	r2, [r3, #0]
    d790:	68bb      	ldr	r3, [r7, #8]
    d792:	681b      	ldr	r3, [r3, #0]
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
    d794:	429a      	cmp	r2, r3
    d796:	d102      	bne.n	d79e <udp_bind+0x6a>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
    d798:	2308      	movs	r3, #8
    d79a:	425b      	negs	r3, r3
    d79c:	e02f      	b.n	d7fe <udp_bind+0xca>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    d79e:	697b      	ldr	r3, [r7, #20]
    d7a0:	68db      	ldr	r3, [r3, #12]
    d7a2:	617b      	str	r3, [r7, #20]
    d7a4:	697b      	ldr	r3, [r7, #20]
    d7a6:	2b00      	cmp	r3, #0
    d7a8:	d1d3      	bne.n	d752 <udp_bind+0x1e>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
    d7aa:	68bb      	ldr	r3, [r7, #8]
    d7ac:	2b00      	cmp	r3, #0
    d7ae:	d002      	beq.n	d7b6 <udp_bind+0x82>
    d7b0:	68bb      	ldr	r3, [r7, #8]
    d7b2:	681a      	ldr	r2, [r3, #0]
    d7b4:	e000      	b.n	d7b8 <udp_bind+0x84>
    d7b6:	2200      	movs	r2, #0
    d7b8:	68fb      	ldr	r3, [r7, #12]
    d7ba:	601a      	str	r2, [r3, #0]

  /* no port specified? */
  if (port == 0) {
    d7bc:	1dbb      	adds	r3, r7, #6
    d7be:	881b      	ldrh	r3, [r3, #0]
    d7c0:	2b00      	cmp	r3, #0
    d7c2:	d10b      	bne.n	d7dc <udp_bind+0xa8>
    port = udp_new_port();
    d7c4:	1dbc      	adds	r4, r7, #6
    d7c6:	4b11      	ldr	r3, [pc, #68]	; (d80c <udp_bind+0xd8>)
    d7c8:	4798      	blx	r3
    d7ca:	0003      	movs	r3, r0
    d7cc:	8023      	strh	r3, [r4, #0]
    if (port == 0) {
    d7ce:	1dbb      	adds	r3, r7, #6
    d7d0:	881b      	ldrh	r3, [r3, #0]
    d7d2:	2b00      	cmp	r3, #0
    d7d4:	d102      	bne.n	d7dc <udp_bind+0xa8>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    d7d6:	2308      	movs	r3, #8
    d7d8:	425b      	negs	r3, r3
    d7da:	e010      	b.n	d7fe <udp_bind+0xca>
    }
  }
  pcb->local_port = port;
    d7dc:	68fb      	ldr	r3, [r7, #12]
    d7de:	1dba      	adds	r2, r7, #6
    d7e0:	8812      	ldrh	r2, [r2, #0]
    d7e2:	825a      	strh	r2, [r3, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
    d7e4:	2313      	movs	r3, #19
    d7e6:	18fb      	adds	r3, r7, r3
    d7e8:	781b      	ldrb	r3, [r3, #0]
    d7ea:	2b00      	cmp	r3, #0
    d7ec:	d106      	bne.n	d7fc <udp_bind+0xc8>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
    d7ee:	4b06      	ldr	r3, [pc, #24]	; (d808 <udp_bind+0xd4>)
    d7f0:	681a      	ldr	r2, [r3, #0]
    d7f2:	68fb      	ldr	r3, [r7, #12]
    d7f4:	60da      	str	r2, [r3, #12]
    udp_pcbs = pcb;
    d7f6:	4b04      	ldr	r3, [pc, #16]	; (d808 <udp_bind+0xd4>)
    d7f8:	68fa      	ldr	r2, [r7, #12]
    d7fa:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
    d7fc:	2300      	movs	r3, #0
}
    d7fe:	0018      	movs	r0, r3
    d800:	46bd      	mov	sp, r7
    d802:	b007      	add	sp, #28
    d804:	bd90      	pop	{r4, r7, pc}
    d806:	46c0      	nop			; (mov r8, r8)
    d808:	20003ee0 	.word	0x20003ee0
    d80c:	0000d1f1 	.word	0x0000d1f1

0000d810 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
    d810:	b580      	push	{r7, lr}
    d812:	b084      	sub	sp, #16
    d814:	af00      	add	r7, sp, #0
    d816:	60f8      	str	r0, [r7, #12]
    d818:	60b9      	str	r1, [r7, #8]
    d81a:	607a      	str	r2, [r7, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
    d81c:	68fb      	ldr	r3, [r7, #12]
    d81e:	68ba      	ldr	r2, [r7, #8]
    d820:	619a      	str	r2, [r3, #24]
  pcb->recv_arg = recv_arg;
    d822:	68fb      	ldr	r3, [r7, #12]
    d824:	687a      	ldr	r2, [r7, #4]
    d826:	61da      	str	r2, [r3, #28]
}
    d828:	46c0      	nop			; (mov r8, r8)
    d82a:	46bd      	mov	sp, r7
    d82c:	b004      	add	sp, #16
    d82e:	bd80      	pop	{r7, pc}

0000d830 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
    d830:	b580      	push	{r7, lr}
    d832:	b082      	sub	sp, #8
    d834:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
    d836:	2000      	movs	r0, #0
    d838:	4b0a      	ldr	r3, [pc, #40]	; (d864 <udp_new+0x34>)
    d83a:	4798      	blx	r3
    d83c:	0003      	movs	r3, r0
    d83e:	607b      	str	r3, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
    d840:	687b      	ldr	r3, [r7, #4]
    d842:	2b00      	cmp	r3, #0
    d844:	d008      	beq.n	d858 <udp_new+0x28>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
    d846:	687b      	ldr	r3, [r7, #4]
    d848:	2220      	movs	r2, #32
    d84a:	2100      	movs	r1, #0
    d84c:	0018      	movs	r0, r3
    d84e:	4b06      	ldr	r3, [pc, #24]	; (d868 <udp_new+0x38>)
    d850:	4798      	blx	r3
    pcb->ttl = UDP_TTL;
    d852:	687b      	ldr	r3, [r7, #4]
    d854:	22ff      	movs	r2, #255	; 0xff
    d856:	729a      	strb	r2, [r3, #10]
  }
  return pcb;
    d858:	687b      	ldr	r3, [r7, #4]
}
    d85a:	0018      	movs	r0, r3
    d85c:	46bd      	mov	sp, r7
    d85e:	b002      	add	sp, #8
    d860:	bd80      	pop	{r7, pc}
    d862:	46c0      	nop			; (mov r8, r8)
    d864:	00007af1 	.word	0x00007af1
    d868:	0000fc55 	.word	0x0000fc55

0000d86c <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
    d86c:	b580      	push	{r7, lr}
    d86e:	b082      	sub	sp, #8
    d870:	af00      	add	r7, sp, #0
    d872:	6078      	str	r0, [r7, #4]
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    d874:	4914      	ldr	r1, [pc, #80]	; (d8c8 <etharp_free_entry+0x5c>)
    d876:	687a      	ldr	r2, [r7, #4]
    d878:	0013      	movs	r3, r2
    d87a:	009b      	lsls	r3, r3, #2
    d87c:	189b      	adds	r3, r3, r2
    d87e:	009b      	lsls	r3, r3, #2
    d880:	585b      	ldr	r3, [r3, r1]
    d882:	2b00      	cmp	r3, #0
    d884:	d011      	beq.n	d8aa <etharp_free_entry+0x3e>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    d886:	4910      	ldr	r1, [pc, #64]	; (d8c8 <etharp_free_entry+0x5c>)
    d888:	687a      	ldr	r2, [r7, #4]
    d88a:	0013      	movs	r3, r2
    d88c:	009b      	lsls	r3, r3, #2
    d88e:	189b      	adds	r3, r3, r2
    d890:	009b      	lsls	r3, r3, #2
    d892:	585b      	ldr	r3, [r3, r1]
    d894:	0018      	movs	r0, r3
    d896:	4b0d      	ldr	r3, [pc, #52]	; (d8cc <etharp_free_entry+0x60>)
    d898:	4798      	blx	r3
    arp_table[i].q = NULL;
    d89a:	490b      	ldr	r1, [pc, #44]	; (d8c8 <etharp_free_entry+0x5c>)
    d89c:	687a      	ldr	r2, [r7, #4]
    d89e:	0013      	movs	r3, r2
    d8a0:	009b      	lsls	r3, r3, #2
    d8a2:	189b      	adds	r3, r3, r2
    d8a4:	009b      	lsls	r3, r3, #2
    d8a6:	2200      	movs	r2, #0
    d8a8:	505a      	str	r2, [r3, r1]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
    d8aa:	4907      	ldr	r1, [pc, #28]	; (d8c8 <etharp_free_entry+0x5c>)
    d8ac:	687a      	ldr	r2, [r7, #4]
    d8ae:	0013      	movs	r3, r2
    d8b0:	009b      	lsls	r3, r3, #2
    d8b2:	189b      	adds	r3, r3, r2
    d8b4:	009b      	lsls	r3, r3, #2
    d8b6:	18cb      	adds	r3, r1, r3
    d8b8:	3312      	adds	r3, #18
    d8ba:	2200      	movs	r2, #0
    d8bc:	701a      	strb	r2, [r3, #0]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
    d8be:	46c0      	nop			; (mov r8, r8)
    d8c0:	46bd      	mov	sp, r7
    d8c2:	b002      	add	sp, #8
    d8c4:	bd80      	pop	{r7, pc}
    d8c6:	46c0      	nop			; (mov r8, r8)
    d8c8:	20002c9c 	.word	0x20002c9c
    d8cc:	00008349 	.word	0x00008349

0000d8d0 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
    d8d0:	b580      	push	{r7, lr}
    d8d2:	b082      	sub	sp, #8
    d8d4:	af00      	add	r7, sp, #0
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    d8d6:	1dfb      	adds	r3, r7, #7
    d8d8:	2200      	movs	r2, #0
    d8da:	701a      	strb	r2, [r3, #0]
    d8dc:	e06a      	b.n	d9b4 <etharp_tmr+0xe4>
    u8_t state = arp_table[i].state;
    d8de:	1dfb      	adds	r3, r7, #7
    d8e0:	781a      	ldrb	r2, [r3, #0]
    d8e2:	1db9      	adds	r1, r7, #6
    d8e4:	4837      	ldr	r0, [pc, #220]	; (d9c4 <etharp_tmr+0xf4>)
    d8e6:	0013      	movs	r3, r2
    d8e8:	009b      	lsls	r3, r3, #2
    d8ea:	189b      	adds	r3, r3, r2
    d8ec:	009b      	lsls	r3, r3, #2
    d8ee:	18c3      	adds	r3, r0, r3
    d8f0:	3312      	adds	r3, #18
    d8f2:	781b      	ldrb	r3, [r3, #0]
    d8f4:	700b      	strb	r3, [r1, #0]
    if (state != ETHARP_STATE_EMPTY
    d8f6:	1dbb      	adds	r3, r7, #6
    d8f8:	781b      	ldrb	r3, [r3, #0]
    d8fa:	2b00      	cmp	r3, #0
    d8fc:	d055      	beq.n	d9aa <etharp_tmr+0xda>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
    d8fe:	1dfb      	adds	r3, r7, #7
    d900:	781a      	ldrb	r2, [r3, #0]
    d902:	4930      	ldr	r1, [pc, #192]	; (d9c4 <etharp_tmr+0xf4>)
    d904:	0013      	movs	r3, r2
    d906:	009b      	lsls	r3, r3, #2
    d908:	189b      	adds	r3, r3, r2
    d90a:	009b      	lsls	r3, r3, #2
    d90c:	18cb      	adds	r3, r1, r3
    d90e:	3313      	adds	r3, #19
    d910:	781b      	ldrb	r3, [r3, #0]
    d912:	3301      	adds	r3, #1
    d914:	b2d8      	uxtb	r0, r3
    d916:	492b      	ldr	r1, [pc, #172]	; (d9c4 <etharp_tmr+0xf4>)
    d918:	0013      	movs	r3, r2
    d91a:	009b      	lsls	r3, r3, #2
    d91c:	189b      	adds	r3, r3, r2
    d91e:	009b      	lsls	r3, r3, #2
    d920:	18cb      	adds	r3, r1, r3
    d922:	3313      	adds	r3, #19
    d924:	1c02      	adds	r2, r0, #0
    d926:	701a      	strb	r2, [r3, #0]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    d928:	1dfb      	adds	r3, r7, #7
    d92a:	781a      	ldrb	r2, [r3, #0]
    d92c:	4925      	ldr	r1, [pc, #148]	; (d9c4 <etharp_tmr+0xf4>)
    d92e:	0013      	movs	r3, r2
    d930:	009b      	lsls	r3, r3, #2
    d932:	189b      	adds	r3, r3, r2
    d934:	009b      	lsls	r3, r3, #2
    d936:	18cb      	adds	r3, r1, r3
    d938:	3313      	adds	r3, #19
    d93a:	781b      	ldrb	r3, [r3, #0]
    d93c:	2bef      	cmp	r3, #239	; 0xef
    d93e:	d817      	bhi.n	d970 <etharp_tmr+0xa0>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
    d940:	1dfb      	adds	r3, r7, #7
    d942:	781a      	ldrb	r2, [r3, #0]
    d944:	491f      	ldr	r1, [pc, #124]	; (d9c4 <etharp_tmr+0xf4>)
    d946:	0013      	movs	r3, r2
    d948:	009b      	lsls	r3, r3, #2
    d94a:	189b      	adds	r3, r3, r2
    d94c:	009b      	lsls	r3, r3, #2
    d94e:	18cb      	adds	r3, r1, r3
    d950:	3312      	adds	r3, #18
    d952:	781b      	ldrb	r3, [r3, #0]
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
    d954:	2b01      	cmp	r3, #1
    d956:	d111      	bne.n	d97c <etharp_tmr+0xac>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
    d958:	1dfb      	adds	r3, r7, #7
    d95a:	781a      	ldrb	r2, [r3, #0]
    d95c:	4919      	ldr	r1, [pc, #100]	; (d9c4 <etharp_tmr+0xf4>)
    d95e:	0013      	movs	r3, r2
    d960:	009b      	lsls	r3, r3, #2
    d962:	189b      	adds	r3, r3, r2
    d964:	009b      	lsls	r3, r3, #2
    d966:	18cb      	adds	r3, r1, r3
    d968:	3313      	adds	r3, #19
    d96a:	781b      	ldrb	r3, [r3, #0]
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
    d96c:	2b01      	cmp	r3, #1
    d96e:	d905      	bls.n	d97c <etharp_tmr+0xac>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
    d970:	1dfb      	adds	r3, r7, #7
    d972:	781b      	ldrb	r3, [r3, #0]
    d974:	0018      	movs	r0, r3
    d976:	4b14      	ldr	r3, [pc, #80]	; (d9c8 <etharp_tmr+0xf8>)
    d978:	4798      	blx	r3
    d97a:	e016      	b.n	d9aa <etharp_tmr+0xda>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
    d97c:	1dfb      	adds	r3, r7, #7
    d97e:	781a      	ldrb	r2, [r3, #0]
    d980:	4910      	ldr	r1, [pc, #64]	; (d9c4 <etharp_tmr+0xf4>)
    d982:	0013      	movs	r3, r2
    d984:	009b      	lsls	r3, r3, #2
    d986:	189b      	adds	r3, r3, r2
    d988:	009b      	lsls	r3, r3, #2
    d98a:	18cb      	adds	r3, r1, r3
    d98c:	3312      	adds	r3, #18
    d98e:	781b      	ldrb	r3, [r3, #0]
    d990:	2b03      	cmp	r3, #3
    d992:	d10a      	bne.n	d9aa <etharp_tmr+0xda>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
    d994:	1dfb      	adds	r3, r7, #7
    d996:	781a      	ldrb	r2, [r3, #0]
    d998:	490a      	ldr	r1, [pc, #40]	; (d9c4 <etharp_tmr+0xf4>)
    d99a:	0013      	movs	r3, r2
    d99c:	009b      	lsls	r3, r3, #2
    d99e:	189b      	adds	r3, r3, r2
    d9a0:	009b      	lsls	r3, r3, #2
    d9a2:	18cb      	adds	r3, r1, r3
    d9a4:	3312      	adds	r3, #18
    d9a6:	2202      	movs	r2, #2
    d9a8:	701a      	strb	r2, [r3, #0]
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    d9aa:	1dfb      	adds	r3, r7, #7
    d9ac:	1dfa      	adds	r2, r7, #7
    d9ae:	7812      	ldrb	r2, [r2, #0]
    d9b0:	3201      	adds	r2, #1
    d9b2:	701a      	strb	r2, [r3, #0]
    d9b4:	1dfb      	adds	r3, r7, #7
    d9b6:	781b      	ldrb	r3, [r3, #0]
    d9b8:	2b09      	cmp	r3, #9
    d9ba:	d990      	bls.n	d8de <etharp_tmr+0xe>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
    d9bc:	46c0      	nop			; (mov r8, r8)
    d9be:	46bd      	mov	sp, r7
    d9c0:	b002      	add	sp, #8
    d9c2:	bd80      	pop	{r7, pc}
    d9c4:	20002c9c 	.word	0x20002c9c
    d9c8:	0000d86d 	.word	0x0000d86d

0000d9cc <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
    d9cc:	b580      	push	{r7, lr}
    d9ce:	b086      	sub	sp, #24
    d9d0:	af00      	add	r7, sp, #0
    d9d2:	6078      	str	r0, [r7, #4]
    d9d4:	000a      	movs	r2, r1
    d9d6:	1cfb      	adds	r3, r7, #3
    d9d8:	701a      	strb	r2, [r3, #0]
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
    d9da:	2317      	movs	r3, #23
    d9dc:	18fb      	adds	r3, r7, r3
    d9de:	220a      	movs	r2, #10
    d9e0:	701a      	strb	r2, [r3, #0]
    d9e2:	2316      	movs	r3, #22
    d9e4:	18fb      	adds	r3, r7, r3
    d9e6:	220a      	movs	r2, #10
    d9e8:	701a      	strb	r2, [r3, #0]
  s8_t empty = ARP_TABLE_SIZE;
    d9ea:	2315      	movs	r3, #21
    d9ec:	18fb      	adds	r3, r7, r3
    d9ee:	220a      	movs	r2, #10
    d9f0:	701a      	strb	r2, [r3, #0]
  u8_t i = 0, age_pending = 0, age_stable = 0;
    d9f2:	2314      	movs	r3, #20
    d9f4:	18fb      	adds	r3, r7, r3
    d9f6:	2200      	movs	r2, #0
    d9f8:	701a      	strb	r2, [r3, #0]
    d9fa:	2313      	movs	r3, #19
    d9fc:	18fb      	adds	r3, r7, r3
    d9fe:	2200      	movs	r2, #0
    da00:	701a      	strb	r2, [r3, #0]
    da02:	2312      	movs	r3, #18
    da04:	18fb      	adds	r3, r7, r3
    da06:	2200      	movs	r2, #0
    da08:	701a      	strb	r2, [r3, #0]
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
    da0a:	2311      	movs	r3, #17
    da0c:	18fb      	adds	r3, r7, r3
    da0e:	220a      	movs	r2, #10
    da10:	701a      	strb	r2, [r3, #0]
  /* its age */
  u8_t age_queue = 0;
    da12:	2310      	movs	r3, #16
    da14:	18fb      	adds	r3, r7, r3
    da16:	2200      	movs	r2, #0
    da18:	701a      	strb	r2, [r3, #0]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    da1a:	2314      	movs	r3, #20
    da1c:	18fb      	adds	r3, r7, r3
    da1e:	2200      	movs	r2, #0
    da20:	701a      	strb	r2, [r3, #0]
    da22:	e0c6      	b.n	dbb2 <etharp_find_entry+0x1e6>
    u8_t state = arp_table[i].state;
    da24:	2314      	movs	r3, #20
    da26:	18fb      	adds	r3, r7, r3
    da28:	781a      	ldrb	r2, [r3, #0]
    da2a:	230f      	movs	r3, #15
    da2c:	18f9      	adds	r1, r7, r3
    da2e:	489e      	ldr	r0, [pc, #632]	; (dca8 <etharp_find_entry+0x2dc>)
    da30:	0013      	movs	r3, r2
    da32:	009b      	lsls	r3, r3, #2
    da34:	189b      	adds	r3, r3, r2
    da36:	009b      	lsls	r3, r3, #2
    da38:	18c3      	adds	r3, r0, r3
    da3a:	3312      	adds	r3, #18
    da3c:	781b      	ldrb	r3, [r3, #0]
    da3e:	700b      	strb	r3, [r1, #0]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
    da40:	2315      	movs	r3, #21
    da42:	18fb      	adds	r3, r7, r3
    da44:	781b      	ldrb	r3, [r3, #0]
    da46:	b25b      	sxtb	r3, r3
    da48:	2b0a      	cmp	r3, #10
    da4a:	d10b      	bne.n	da64 <etharp_find_entry+0x98>
    da4c:	230f      	movs	r3, #15
    da4e:	18fb      	adds	r3, r7, r3
    da50:	781b      	ldrb	r3, [r3, #0]
    da52:	2b00      	cmp	r3, #0
    da54:	d106      	bne.n	da64 <etharp_find_entry+0x98>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    da56:	2315      	movs	r3, #21
    da58:	18fb      	adds	r3, r7, r3
    da5a:	2214      	movs	r2, #20
    da5c:	18ba      	adds	r2, r7, r2
    da5e:	7812      	ldrb	r2, [r2, #0]
    da60:	701a      	strb	r2, [r3, #0]
    da62:	e09f      	b.n	dba4 <etharp_find_entry+0x1d8>
    } else if (state != ETHARP_STATE_EMPTY) {
    da64:	230f      	movs	r3, #15
    da66:	18fb      	adds	r3, r7, r3
    da68:	781b      	ldrb	r3, [r3, #0]
    da6a:	2b00      	cmp	r3, #0
    da6c:	d100      	bne.n	da70 <etharp_find_entry+0xa4>
    da6e:	e099      	b.n	dba4 <etharp_find_entry+0x1d8>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
    da70:	687b      	ldr	r3, [r7, #4]
    da72:	2b00      	cmp	r3, #0
    da74:	d013      	beq.n	da9e <etharp_find_entry+0xd2>
    da76:	687b      	ldr	r3, [r7, #4]
    da78:	6819      	ldr	r1, [r3, #0]
    da7a:	2314      	movs	r3, #20
    da7c:	18fb      	adds	r3, r7, r3
    da7e:	781a      	ldrb	r2, [r3, #0]
    da80:	4889      	ldr	r0, [pc, #548]	; (dca8 <etharp_find_entry+0x2dc>)
    da82:	0013      	movs	r3, r2
    da84:	009b      	lsls	r3, r3, #2
    da86:	189b      	adds	r3, r3, r2
    da88:	009b      	lsls	r3, r3, #2
    da8a:	18c3      	adds	r3, r0, r3
    da8c:	3304      	adds	r3, #4
    da8e:	681b      	ldr	r3, [r3, #0]
    da90:	4299      	cmp	r1, r3
    da92:	d104      	bne.n	da9e <etharp_find_entry+0xd2>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
    da94:	2314      	movs	r3, #20
    da96:	18fb      	adds	r3, r7, r3
    da98:	781b      	ldrb	r3, [r3, #0]
    da9a:	b25b      	sxtb	r3, r3
    da9c:	e0ff      	b.n	dc9e <etharp_find_entry+0x2d2>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
    da9e:	230f      	movs	r3, #15
    daa0:	18fb      	adds	r3, r7, r3
    daa2:	781b      	ldrb	r3, [r3, #0]
    daa4:	2b01      	cmp	r3, #1
    daa6:	d154      	bne.n	db52 <etharp_find_entry+0x186>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
    daa8:	2314      	movs	r3, #20
    daaa:	18fb      	adds	r3, r7, r3
    daac:	781a      	ldrb	r2, [r3, #0]
    daae:	497e      	ldr	r1, [pc, #504]	; (dca8 <etharp_find_entry+0x2dc>)
    dab0:	0013      	movs	r3, r2
    dab2:	009b      	lsls	r3, r3, #2
    dab4:	189b      	adds	r3, r3, r2
    dab6:	009b      	lsls	r3, r3, #2
    dab8:	585b      	ldr	r3, [r3, r1]
    daba:	2b00      	cmp	r3, #0
    dabc:	d024      	beq.n	db08 <etharp_find_entry+0x13c>
          if (arp_table[i].ctime >= age_queue) {
    dabe:	2314      	movs	r3, #20
    dac0:	18fb      	adds	r3, r7, r3
    dac2:	781a      	ldrb	r2, [r3, #0]
    dac4:	4978      	ldr	r1, [pc, #480]	; (dca8 <etharp_find_entry+0x2dc>)
    dac6:	0013      	movs	r3, r2
    dac8:	009b      	lsls	r3, r3, #2
    daca:	189b      	adds	r3, r3, r2
    dacc:	009b      	lsls	r3, r3, #2
    dace:	18cb      	adds	r3, r1, r3
    dad0:	3313      	adds	r3, #19
    dad2:	781b      	ldrb	r3, [r3, #0]
    dad4:	2210      	movs	r2, #16
    dad6:	18ba      	adds	r2, r7, r2
    dad8:	7812      	ldrb	r2, [r2, #0]
    dada:	429a      	cmp	r2, r3
    dadc:	d862      	bhi.n	dba4 <etharp_find_entry+0x1d8>
            old_queue = i;
    dade:	2311      	movs	r3, #17
    dae0:	18fb      	adds	r3, r7, r3
    dae2:	2214      	movs	r2, #20
    dae4:	18ba      	adds	r2, r7, r2
    dae6:	7812      	ldrb	r2, [r2, #0]
    dae8:	701a      	strb	r2, [r3, #0]
            age_queue = arp_table[i].ctime;
    daea:	2314      	movs	r3, #20
    daec:	18fb      	adds	r3, r7, r3
    daee:	781a      	ldrb	r2, [r3, #0]
    daf0:	2310      	movs	r3, #16
    daf2:	18f9      	adds	r1, r7, r3
    daf4:	486c      	ldr	r0, [pc, #432]	; (dca8 <etharp_find_entry+0x2dc>)
    daf6:	0013      	movs	r3, r2
    daf8:	009b      	lsls	r3, r3, #2
    dafa:	189b      	adds	r3, r3, r2
    dafc:	009b      	lsls	r3, r3, #2
    dafe:	18c3      	adds	r3, r0, r3
    db00:	3313      	adds	r3, #19
    db02:	781b      	ldrb	r3, [r3, #0]
    db04:	700b      	strb	r3, [r1, #0]
    db06:	e04d      	b.n	dba4 <etharp_find_entry+0x1d8>
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
    db08:	2314      	movs	r3, #20
    db0a:	18fb      	adds	r3, r7, r3
    db0c:	781a      	ldrb	r2, [r3, #0]
    db0e:	4966      	ldr	r1, [pc, #408]	; (dca8 <etharp_find_entry+0x2dc>)
    db10:	0013      	movs	r3, r2
    db12:	009b      	lsls	r3, r3, #2
    db14:	189b      	adds	r3, r3, r2
    db16:	009b      	lsls	r3, r3, #2
    db18:	18cb      	adds	r3, r1, r3
    db1a:	3313      	adds	r3, #19
    db1c:	781b      	ldrb	r3, [r3, #0]
    db1e:	2213      	movs	r2, #19
    db20:	18ba      	adds	r2, r7, r2
    db22:	7812      	ldrb	r2, [r2, #0]
    db24:	429a      	cmp	r2, r3
    db26:	d83d      	bhi.n	dba4 <etharp_find_entry+0x1d8>
            old_pending = i;
    db28:	2317      	movs	r3, #23
    db2a:	18fb      	adds	r3, r7, r3
    db2c:	2214      	movs	r2, #20
    db2e:	18ba      	adds	r2, r7, r2
    db30:	7812      	ldrb	r2, [r2, #0]
    db32:	701a      	strb	r2, [r3, #0]
            age_pending = arp_table[i].ctime;
    db34:	2314      	movs	r3, #20
    db36:	18fb      	adds	r3, r7, r3
    db38:	781a      	ldrb	r2, [r3, #0]
    db3a:	2313      	movs	r3, #19
    db3c:	18f9      	adds	r1, r7, r3
    db3e:	485a      	ldr	r0, [pc, #360]	; (dca8 <etharp_find_entry+0x2dc>)
    db40:	0013      	movs	r3, r2
    db42:	009b      	lsls	r3, r3, #2
    db44:	189b      	adds	r3, r3, r2
    db46:	009b      	lsls	r3, r3, #2
    db48:	18c3      	adds	r3, r0, r3
    db4a:	3313      	adds	r3, #19
    db4c:	781b      	ldrb	r3, [r3, #0]
    db4e:	700b      	strb	r3, [r1, #0]
    db50:	e028      	b.n	dba4 <etharp_find_entry+0x1d8>
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
    db52:	230f      	movs	r3, #15
    db54:	18fb      	adds	r3, r7, r3
    db56:	781b      	ldrb	r3, [r3, #0]
    db58:	2b01      	cmp	r3, #1
    db5a:	d923      	bls.n	dba4 <etharp_find_entry+0x1d8>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
    db5c:	2314      	movs	r3, #20
    db5e:	18fb      	adds	r3, r7, r3
    db60:	781a      	ldrb	r2, [r3, #0]
    db62:	4951      	ldr	r1, [pc, #324]	; (dca8 <etharp_find_entry+0x2dc>)
    db64:	0013      	movs	r3, r2
    db66:	009b      	lsls	r3, r3, #2
    db68:	189b      	adds	r3, r3, r2
    db6a:	009b      	lsls	r3, r3, #2
    db6c:	18cb      	adds	r3, r1, r3
    db6e:	3313      	adds	r3, #19
    db70:	781b      	ldrb	r3, [r3, #0]
    db72:	2212      	movs	r2, #18
    db74:	18ba      	adds	r2, r7, r2
    db76:	7812      	ldrb	r2, [r2, #0]
    db78:	429a      	cmp	r2, r3
    db7a:	d813      	bhi.n	dba4 <etharp_find_entry+0x1d8>
            old_stable = i;
    db7c:	2316      	movs	r3, #22
    db7e:	18fb      	adds	r3, r7, r3
    db80:	2214      	movs	r2, #20
    db82:	18ba      	adds	r2, r7, r2
    db84:	7812      	ldrb	r2, [r2, #0]
    db86:	701a      	strb	r2, [r3, #0]
            age_stable = arp_table[i].ctime;
    db88:	2314      	movs	r3, #20
    db8a:	18fb      	adds	r3, r7, r3
    db8c:	781a      	ldrb	r2, [r3, #0]
    db8e:	2312      	movs	r3, #18
    db90:	18f9      	adds	r1, r7, r3
    db92:	4845      	ldr	r0, [pc, #276]	; (dca8 <etharp_find_entry+0x2dc>)
    db94:	0013      	movs	r3, r2
    db96:	009b      	lsls	r3, r3, #2
    db98:	189b      	adds	r3, r3, r2
    db9a:	009b      	lsls	r3, r3, #2
    db9c:	18c3      	adds	r3, r0, r3
    db9e:	3313      	adds	r3, #19
    dba0:	781b      	ldrb	r3, [r3, #0]
    dba2:	700b      	strb	r3, [r1, #0]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    dba4:	2314      	movs	r3, #20
    dba6:	18fb      	adds	r3, r7, r3
    dba8:	2214      	movs	r2, #20
    dbaa:	18ba      	adds	r2, r7, r2
    dbac:	7812      	ldrb	r2, [r2, #0]
    dbae:	3201      	adds	r2, #1
    dbb0:	701a      	strb	r2, [r3, #0]
    dbb2:	2314      	movs	r3, #20
    dbb4:	18fb      	adds	r3, r7, r3
    dbb6:	781b      	ldrb	r3, [r3, #0]
    dbb8:	2b09      	cmp	r3, #9
    dbba:	d800      	bhi.n	dbbe <etharp_find_entry+0x1f2>
    dbbc:	e732      	b.n	da24 <etharp_find_entry+0x58>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
    dbbe:	1cfb      	adds	r3, r7, #3
    dbc0:	781b      	ldrb	r3, [r3, #0]
    dbc2:	2202      	movs	r2, #2
    dbc4:	4013      	ands	r3, r2
    dbc6:	d10a      	bne.n	dbde <etharp_find_entry+0x212>
    dbc8:	2315      	movs	r3, #21
    dbca:	18fb      	adds	r3, r7, r3
    dbcc:	781b      	ldrb	r3, [r3, #0]
    dbce:	b25b      	sxtb	r3, r3
    dbd0:	2b0a      	cmp	r3, #10
    dbd2:	d107      	bne.n	dbe4 <etharp_find_entry+0x218>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    dbd4:	1cfb      	adds	r3, r7, #3
    dbd6:	781b      	ldrb	r3, [r3, #0]
    dbd8:	2201      	movs	r2, #1
    dbda:	4013      	ands	r3, r2
    dbdc:	d102      	bne.n	dbe4 <etharp_find_entry+0x218>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
    dbde:	2301      	movs	r3, #1
    dbe0:	425b      	negs	r3, r3
    dbe2:	e05c      	b.n	dc9e <etharp_find_entry+0x2d2>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    dbe4:	2315      	movs	r3, #21
    dbe6:	18fb      	adds	r3, r7, r3
    dbe8:	781b      	ldrb	r3, [r3, #0]
    dbea:	b25b      	sxtb	r3, r3
    dbec:	2b09      	cmp	r3, #9
    dbee:	dc06      	bgt.n	dbfe <etharp_find_entry+0x232>
    i = empty;
    dbf0:	2314      	movs	r3, #20
    dbf2:	18fb      	adds	r3, r7, r3
    dbf4:	2215      	movs	r2, #21
    dbf6:	18ba      	adds	r2, r7, r2
    dbf8:	7812      	ldrb	r2, [r2, #0]
    dbfa:	701a      	strb	r2, [r3, #0]
    dbfc:	e02f      	b.n	dc5e <etharp_find_entry+0x292>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
    dbfe:	2316      	movs	r3, #22
    dc00:	18fb      	adds	r3, r7, r3
    dc02:	781b      	ldrb	r3, [r3, #0]
    dc04:	b25b      	sxtb	r3, r3
    dc06:	2b09      	cmp	r3, #9
    dc08:	dc06      	bgt.n	dc18 <etharp_find_entry+0x24c>
      /* recycle oldest stable*/
      i = old_stable;
    dc0a:	2314      	movs	r3, #20
    dc0c:	18fb      	adds	r3, r7, r3
    dc0e:	2216      	movs	r2, #22
    dc10:	18ba      	adds	r2, r7, r2
    dc12:	7812      	ldrb	r2, [r2, #0]
    dc14:	701a      	strb	r2, [r3, #0]
    dc16:	e01c      	b.n	dc52 <etharp_find_entry+0x286>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
    dc18:	2317      	movs	r3, #23
    dc1a:	18fb      	adds	r3, r7, r3
    dc1c:	781b      	ldrb	r3, [r3, #0]
    dc1e:	b25b      	sxtb	r3, r3
    dc20:	2b09      	cmp	r3, #9
    dc22:	dc06      	bgt.n	dc32 <etharp_find_entry+0x266>
      /* recycle oldest pending */
      i = old_pending;
    dc24:	2314      	movs	r3, #20
    dc26:	18fb      	adds	r3, r7, r3
    dc28:	2217      	movs	r2, #23
    dc2a:	18ba      	adds	r2, r7, r2
    dc2c:	7812      	ldrb	r2, [r2, #0]
    dc2e:	701a      	strb	r2, [r3, #0]
    dc30:	e00f      	b.n	dc52 <etharp_find_entry+0x286>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
    dc32:	2311      	movs	r3, #17
    dc34:	18fb      	adds	r3, r7, r3
    dc36:	781b      	ldrb	r3, [r3, #0]
    dc38:	b25b      	sxtb	r3, r3
    dc3a:	2b09      	cmp	r3, #9
    dc3c:	dc06      	bgt.n	dc4c <etharp_find_entry+0x280>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
    dc3e:	2314      	movs	r3, #20
    dc40:	18fb      	adds	r3, r7, r3
    dc42:	2211      	movs	r2, #17
    dc44:	18ba      	adds	r2, r7, r2
    dc46:	7812      	ldrb	r2, [r2, #0]
    dc48:	701a      	strb	r2, [r3, #0]
    dc4a:	e002      	b.n	dc52 <etharp_find_entry+0x286>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    dc4c:	2301      	movs	r3, #1
    dc4e:	425b      	negs	r3, r3
    dc50:	e025      	b.n	dc9e <etharp_find_entry+0x2d2>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
    dc52:	2314      	movs	r3, #20
    dc54:	18fb      	adds	r3, r7, r3
    dc56:	781b      	ldrb	r3, [r3, #0]
    dc58:	0018      	movs	r0, r3
    dc5a:	4b14      	ldr	r3, [pc, #80]	; (dcac <etharp_find_entry+0x2e0>)
    dc5c:	4798      	blx	r3
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
    dc5e:	687b      	ldr	r3, [r7, #4]
    dc60:	2b00      	cmp	r3, #0
    dc62:	d00c      	beq.n	dc7e <etharp_find_entry+0x2b2>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
    dc64:	2314      	movs	r3, #20
    dc66:	18fb      	adds	r3, r7, r3
    dc68:	781a      	ldrb	r2, [r3, #0]
    dc6a:	687b      	ldr	r3, [r7, #4]
    dc6c:	6819      	ldr	r1, [r3, #0]
    dc6e:	480e      	ldr	r0, [pc, #56]	; (dca8 <etharp_find_entry+0x2dc>)
    dc70:	0013      	movs	r3, r2
    dc72:	009b      	lsls	r3, r3, #2
    dc74:	189b      	adds	r3, r3, r2
    dc76:	009b      	lsls	r3, r3, #2
    dc78:	18c3      	adds	r3, r0, r3
    dc7a:	3304      	adds	r3, #4
    dc7c:	6019      	str	r1, [r3, #0]
  }
  arp_table[i].ctime = 0;
    dc7e:	2314      	movs	r3, #20
    dc80:	18fb      	adds	r3, r7, r3
    dc82:	781a      	ldrb	r2, [r3, #0]
    dc84:	4908      	ldr	r1, [pc, #32]	; (dca8 <etharp_find_entry+0x2dc>)
    dc86:	0013      	movs	r3, r2
    dc88:	009b      	lsls	r3, r3, #2
    dc8a:	189b      	adds	r3, r3, r2
    dc8c:	009b      	lsls	r3, r3, #2
    dc8e:	18cb      	adds	r3, r1, r3
    dc90:	3313      	adds	r3, #19
    dc92:	2200      	movs	r2, #0
    dc94:	701a      	strb	r2, [r3, #0]
  return (err_t)i;
    dc96:	2314      	movs	r3, #20
    dc98:	18fb      	adds	r3, r7, r3
    dc9a:	781b      	ldrb	r3, [r3, #0]
    dc9c:	b25b      	sxtb	r3, r3
}
    dc9e:	0018      	movs	r0, r3
    dca0:	46bd      	mov	sp, r7
    dca2:	b006      	add	sp, #24
    dca4:	bd80      	pop	{r7, pc}
    dca6:	46c0      	nop			; (mov r8, r8)
    dca8:	20002c9c 	.word	0x20002c9c
    dcac:	0000d86d 	.word	0x0000d86d

0000dcb0 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
    dcb0:	b580      	push	{r7, lr}
    dcb2:	b086      	sub	sp, #24
    dcb4:	af00      	add	r7, sp, #0
    dcb6:	60f8      	str	r0, [r7, #12]
    dcb8:	60b9      	str	r1, [r7, #8]
    dcba:	607a      	str	r2, [r7, #4]
    dcbc:	603b      	str	r3, [r7, #0]
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
    dcbe:	68bb      	ldr	r3, [r7, #8]
    dcc0:	685b      	ldr	r3, [r3, #4]
    dcc2:	617b      	str	r3, [r7, #20]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
    dcc4:	697b      	ldr	r3, [r7, #20]
    dcc6:	6839      	ldr	r1, [r7, #0]
    dcc8:	2206      	movs	r2, #6
    dcca:	0018      	movs	r0, r3
    dccc:	4b0f      	ldr	r3, [pc, #60]	; (dd0c <etharp_send_ip+0x5c>)
    dcce:	4798      	blx	r3
  ETHADDR16_COPY(&ethhdr->src, src);
    dcd0:	697b      	ldr	r3, [r7, #20]
    dcd2:	3306      	adds	r3, #6
    dcd4:	6879      	ldr	r1, [r7, #4]
    dcd6:	2206      	movs	r2, #6
    dcd8:	0018      	movs	r0, r3
    dcda:	4b0c      	ldr	r3, [pc, #48]	; (dd0c <etharp_send_ip+0x5c>)
    dcdc:	4798      	blx	r3
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
    dcde:	697b      	ldr	r3, [r7, #20]
    dce0:	7b1a      	ldrb	r2, [r3, #12]
    dce2:	2100      	movs	r1, #0
    dce4:	400a      	ands	r2, r1
    dce6:	1c11      	adds	r1, r2, #0
    dce8:	2208      	movs	r2, #8
    dcea:	430a      	orrs	r2, r1
    dcec:	731a      	strb	r2, [r3, #12]
    dcee:	7b5a      	ldrb	r2, [r3, #13]
    dcf0:	2100      	movs	r1, #0
    dcf2:	400a      	ands	r2, r1
    dcf4:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
    dcf6:	68fb      	ldr	r3, [r7, #12]
    dcf8:	699b      	ldr	r3, [r3, #24]
    dcfa:	68b9      	ldr	r1, [r7, #8]
    dcfc:	68fa      	ldr	r2, [r7, #12]
    dcfe:	0010      	movs	r0, r2
    dd00:	4798      	blx	r3
    dd02:	0003      	movs	r3, r0
}
    dd04:	0018      	movs	r0, r3
    dd06:	46bd      	mov	sp, r7
    dd08:	b006      	add	sp, #24
    dd0a:	bd80      	pop	{r7, pc}
    dd0c:	0000fc43 	.word	0x0000fc43

0000dd10 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
    dd10:	b590      	push	{r4, r7, lr}
    dd12:	b087      	sub	sp, #28
    dd14:	af00      	add	r7, sp, #0
    dd16:	60f8      	str	r0, [r7, #12]
    dd18:	60b9      	str	r1, [r7, #8]
    dd1a:	607a      	str	r2, [r7, #4]
    dd1c:	001a      	movs	r2, r3
    dd1e:	1cfb      	adds	r3, r7, #3
    dd20:	701a      	strb	r2, [r3, #0]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
    dd22:	68bb      	ldr	r3, [r7, #8]
    dd24:	2b00      	cmp	r3, #0
    dd26:	d012      	beq.n	dd4e <etharp_update_arp_entry+0x3e>
    dd28:	68bb      	ldr	r3, [r7, #8]
    dd2a:	681b      	ldr	r3, [r3, #0]
    dd2c:	2b00      	cmp	r3, #0
    dd2e:	d00e      	beq.n	dd4e <etharp_update_arp_entry+0x3e>
      ip_addr_isbroadcast(ipaddr, netif) ||
    dd30:	68bb      	ldr	r3, [r7, #8]
    dd32:	681b      	ldr	r3, [r3, #0]
    dd34:	68fa      	ldr	r2, [r7, #12]
    dd36:	0011      	movs	r1, r2
    dd38:	0018      	movs	r0, r3
    dd3a:	4b47      	ldr	r3, [pc, #284]	; (de58 <etharp_update_arp_entry+0x148>)
    dd3c:	4798      	blx	r3
    dd3e:	1e03      	subs	r3, r0, #0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
    dd40:	d105      	bne.n	dd4e <etharp_update_arp_entry+0x3e>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    dd42:	68bb      	ldr	r3, [r7, #8]
    dd44:	681b      	ldr	r3, [r3, #0]
    dd46:	22f0      	movs	r2, #240	; 0xf0
    dd48:	4013      	ands	r3, r2
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
    dd4a:	2be0      	cmp	r3, #224	; 0xe0
    dd4c:	d102      	bne.n	dd54 <etharp_update_arp_entry+0x44>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
    dd4e:	230e      	movs	r3, #14
    dd50:	425b      	negs	r3, r3
    dd52:	e07c      	b.n	de4e <etharp_update_arp_entry+0x13e>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
    dd54:	2317      	movs	r3, #23
    dd56:	18fc      	adds	r4, r7, r3
    dd58:	1cfb      	adds	r3, r7, #3
    dd5a:	781a      	ldrb	r2, [r3, #0]
    dd5c:	68bb      	ldr	r3, [r7, #8]
    dd5e:	0011      	movs	r1, r2
    dd60:	0018      	movs	r0, r3
    dd62:	4b3e      	ldr	r3, [pc, #248]	; (de5c <etharp_update_arp_entry+0x14c>)
    dd64:	4798      	blx	r3
    dd66:	0003      	movs	r3, r0
    dd68:	7023      	strb	r3, [r4, #0]
  /* bail out if no entry could be found */
  if (i < 0) {
    dd6a:	2317      	movs	r3, #23
    dd6c:	18fb      	adds	r3, r7, r3
    dd6e:	781b      	ldrb	r3, [r3, #0]
    dd70:	2b7f      	cmp	r3, #127	; 0x7f
    dd72:	d904      	bls.n	dd7e <etharp_update_arp_entry+0x6e>
    return (err_t)i;
    dd74:	2317      	movs	r3, #23
    dd76:	18fb      	adds	r3, r7, r3
    dd78:	781b      	ldrb	r3, [r3, #0]
    dd7a:	b25b      	sxtb	r3, r3
    dd7c:	e067      	b.n	de4e <etharp_update_arp_entry+0x13e>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
    dd7e:	2317      	movs	r3, #23
    dd80:	18fb      	adds	r3, r7, r3
    dd82:	2200      	movs	r2, #0
    dd84:	569a      	ldrsb	r2, [r3, r2]
    dd86:	4936      	ldr	r1, [pc, #216]	; (de60 <etharp_update_arp_entry+0x150>)
    dd88:	0013      	movs	r3, r2
    dd8a:	009b      	lsls	r3, r3, #2
    dd8c:	189b      	adds	r3, r3, r2
    dd8e:	009b      	lsls	r3, r3, #2
    dd90:	18cb      	adds	r3, r1, r3
    dd92:	3312      	adds	r3, #18
    dd94:	2202      	movs	r2, #2
    dd96:	701a      	strb	r2, [r3, #0]
  }

  /* record network interface */
  arp_table[i].netif = netif;
    dd98:	2317      	movs	r3, #23
    dd9a:	18fb      	adds	r3, r7, r3
    dd9c:	2200      	movs	r2, #0
    dd9e:	569a      	ldrsb	r2, [r3, r2]
    dda0:	492f      	ldr	r1, [pc, #188]	; (de60 <etharp_update_arp_entry+0x150>)
    dda2:	0013      	movs	r3, r2
    dda4:	009b      	lsls	r3, r3, #2
    dda6:	189b      	adds	r3, r3, r2
    dda8:	009b      	lsls	r3, r3, #2
    ddaa:	18cb      	adds	r3, r1, r3
    ddac:	3308      	adds	r3, #8
    ddae:	68fa      	ldr	r2, [r7, #12]
    ddb0:	601a      	str	r2, [r3, #0]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
    ddb2:	2317      	movs	r3, #23
    ddb4:	18fb      	adds	r3, r7, r3
    ddb6:	2200      	movs	r2, #0
    ddb8:	569a      	ldrsb	r2, [r3, r2]
    ddba:	0013      	movs	r3, r2
    ddbc:	009b      	lsls	r3, r3, #2
    ddbe:	189b      	adds	r3, r3, r2
    ddc0:	009b      	lsls	r3, r3, #2
    ddc2:	3308      	adds	r3, #8
    ddc4:	001a      	movs	r2, r3
    ddc6:	4b26      	ldr	r3, [pc, #152]	; (de60 <etharp_update_arp_entry+0x150>)
    ddc8:	18d3      	adds	r3, r2, r3
    ddca:	3304      	adds	r3, #4
    ddcc:	6879      	ldr	r1, [r7, #4]
    ddce:	2206      	movs	r2, #6
    ddd0:	0018      	movs	r0, r3
    ddd2:	4b24      	ldr	r3, [pc, #144]	; (de64 <etharp_update_arp_entry+0x154>)
    ddd4:	4798      	blx	r3
  /* reset time stamp */
  arp_table[i].ctime = 0;
    ddd6:	2317      	movs	r3, #23
    ddd8:	18fb      	adds	r3, r7, r3
    ddda:	2200      	movs	r2, #0
    dddc:	569a      	ldrsb	r2, [r3, r2]
    ddde:	4920      	ldr	r1, [pc, #128]	; (de60 <etharp_update_arp_entry+0x150>)
    dde0:	0013      	movs	r3, r2
    dde2:	009b      	lsls	r3, r3, #2
    dde4:	189b      	adds	r3, r3, r2
    dde6:	009b      	lsls	r3, r3, #2
    dde8:	18cb      	adds	r3, r1, r3
    ddea:	3313      	adds	r3, #19
    ddec:	2200      	movs	r2, #0
    ddee:	701a      	strb	r2, [r3, #0]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
#else /* ARP_QUEUEING */
  if (arp_table[i].q != NULL) {
    ddf0:	2317      	movs	r3, #23
    ddf2:	18fb      	adds	r3, r7, r3
    ddf4:	2200      	movs	r2, #0
    ddf6:	569a      	ldrsb	r2, [r3, r2]
    ddf8:	4919      	ldr	r1, [pc, #100]	; (de60 <etharp_update_arp_entry+0x150>)
    ddfa:	0013      	movs	r3, r2
    ddfc:	009b      	lsls	r3, r3, #2
    ddfe:	189b      	adds	r3, r3, r2
    de00:	009b      	lsls	r3, r3, #2
    de02:	585b      	ldr	r3, [r3, r1]
    de04:	2b00      	cmp	r3, #0
    de06:	d021      	beq.n	de4c <etharp_update_arp_entry+0x13c>
    struct pbuf *p = arp_table[i].q;
    de08:	2317      	movs	r3, #23
    de0a:	18fb      	adds	r3, r7, r3
    de0c:	2200      	movs	r2, #0
    de0e:	569a      	ldrsb	r2, [r3, r2]
    de10:	4913      	ldr	r1, [pc, #76]	; (de60 <etharp_update_arp_entry+0x150>)
    de12:	0013      	movs	r3, r2
    de14:	009b      	lsls	r3, r3, #2
    de16:	189b      	adds	r3, r3, r2
    de18:	009b      	lsls	r3, r3, #2
    de1a:	585b      	ldr	r3, [r3, r1]
    de1c:	613b      	str	r3, [r7, #16]
    arp_table[i].q = NULL;
    de1e:	2317      	movs	r3, #23
    de20:	18fb      	adds	r3, r7, r3
    de22:	2200      	movs	r2, #0
    de24:	569a      	ldrsb	r2, [r3, r2]
    de26:	490e      	ldr	r1, [pc, #56]	; (de60 <etharp_update_arp_entry+0x150>)
    de28:	0013      	movs	r3, r2
    de2a:	009b      	lsls	r3, r3, #2
    de2c:	189b      	adds	r3, r3, r2
    de2e:	009b      	lsls	r3, r3, #2
    de30:	2200      	movs	r2, #0
    de32:	505a      	str	r2, [r3, r1]
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    de34:	68fb      	ldr	r3, [r7, #12]
    de36:	3327      	adds	r3, #39	; 0x27
    de38:	001a      	movs	r2, r3
    de3a:	687b      	ldr	r3, [r7, #4]
    de3c:	6939      	ldr	r1, [r7, #16]
    de3e:	68f8      	ldr	r0, [r7, #12]
    de40:	4c09      	ldr	r4, [pc, #36]	; (de68 <etharp_update_arp_entry+0x158>)
    de42:	47a0      	blx	r4
    /* free the queued IP packet */
    pbuf_free(p);
    de44:	693b      	ldr	r3, [r7, #16]
    de46:	0018      	movs	r0, r3
    de48:	4b08      	ldr	r3, [pc, #32]	; (de6c <etharp_update_arp_entry+0x15c>)
    de4a:	4798      	blx	r3
  }
  return ERR_OK;
    de4c:	2300      	movs	r3, #0
}
    de4e:	0018      	movs	r0, r3
    de50:	46bd      	mov	sp, r7
    de52:	b007      	add	sp, #28
    de54:	bd90      	pop	{r4, r7, pc}
    de56:	46c0      	nop			; (mov r8, r8)
    de58:	0000626d 	.word	0x0000626d
    de5c:	0000d9cd 	.word	0x0000d9cd
    de60:	20002c9c 	.word	0x20002c9c
    de64:	0000fc43 	.word	0x0000fc43
    de68:	0000dcb1 	.word	0x0000dcb1
    de6c:	00008349 	.word	0x00008349

0000de70 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
    de70:	b590      	push	{r4, r7, lr}
    de72:	b08b      	sub	sp, #44	; 0x2c
    de74:	af00      	add	r7, sp, #0
    de76:	60f8      	str	r0, [r7, #12]
    de78:	60b9      	str	r1, [r7, #8]
    de7a:	607a      	str	r2, [r7, #4]
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    de7c:	68fb      	ldr	r3, [r7, #12]
    de7e:	2b00      	cmp	r3, #0
    de80:	d100      	bne.n	de84 <etharp_arp_input+0x14>
    de82:	e0d0      	b.n	e026 <etharp_arp_input+0x1b6>

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
    de84:	687b      	ldr	r3, [r7, #4]
    de86:	895b      	ldrh	r3, [r3, #10]
    de88:	2b29      	cmp	r3, #41	; 0x29
    de8a:	d804      	bhi.n	de96 <etharp_arp_input+0x26>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    de8c:	687b      	ldr	r3, [r7, #4]
    de8e:	0018      	movs	r0, r3
    de90:	4b67      	ldr	r3, [pc, #412]	; (e030 <etharp_arp_input+0x1c0>)
    de92:	4798      	blx	r3
    return;
    de94:	e0c8      	b.n	e028 <etharp_arp_input+0x1b8>
  }

  ethhdr = (struct eth_hdr *)p->payload;
    de96:	687b      	ldr	r3, [r7, #4]
    de98:	685b      	ldr	r3, [r3, #4]
    de9a:	623b      	str	r3, [r7, #32]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
    de9c:	6a3b      	ldr	r3, [r7, #32]
    de9e:	330e      	adds	r3, #14
    dea0:	61fb      	str	r3, [r7, #28]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
    dea2:	69fb      	ldr	r3, [r7, #28]
    dea4:	781a      	ldrb	r2, [r3, #0]
    dea6:	785b      	ldrb	r3, [r3, #1]
    dea8:	021b      	lsls	r3, r3, #8
    deaa:	4313      	orrs	r3, r2
    deac:	b29a      	uxth	r2, r3
    deae:	2380      	movs	r3, #128	; 0x80
    deb0:	005b      	lsls	r3, r3, #1
    deb2:	429a      	cmp	r2, r3
    deb4:	d10f      	bne.n	ded6 <etharp_arp_input+0x66>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
    deb6:	69fb      	ldr	r3, [r7, #28]
    deb8:	791b      	ldrb	r3, [r3, #4]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
    deba:	2b06      	cmp	r3, #6
    debc:	d10b      	bne.n	ded6 <etharp_arp_input+0x66>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
    debe:	69fb      	ldr	r3, [r7, #28]
    dec0:	795b      	ldrb	r3, [r3, #5]
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
    dec2:	2b04      	cmp	r3, #4
    dec4:	d107      	bne.n	ded6 <etharp_arp_input+0x66>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    dec6:	69fb      	ldr	r3, [r7, #28]
    dec8:	789a      	ldrb	r2, [r3, #2]
    deca:	78db      	ldrb	r3, [r3, #3]
    decc:	021b      	lsls	r3, r3, #8
    dece:	4313      	orrs	r3, r2
    ded0:	b29b      	uxth	r3, r3
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
    ded2:	2b08      	cmp	r3, #8
    ded4:	d004      	beq.n	dee0 <etharp_arp_input+0x70>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    ded6:	687b      	ldr	r3, [r7, #4]
    ded8:	0018      	movs	r0, r3
    deda:	4b55      	ldr	r3, [pc, #340]	; (e030 <etharp_arp_input+0x1c0>)
    dedc:	4798      	blx	r3
    return;
    dede:	e0a3      	b.n	e028 <etharp_arp_input+0x1b8>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
    dee0:	69fb      	ldr	r3, [r7, #28]
    dee2:	330e      	adds	r3, #14
    dee4:	0019      	movs	r1, r3
    dee6:	2318      	movs	r3, #24
    dee8:	18fb      	adds	r3, r7, r3
    deea:	2204      	movs	r2, #4
    deec:	0018      	movs	r0, r3
    deee:	4b51      	ldr	r3, [pc, #324]	; (e034 <etharp_arp_input+0x1c4>)
    def0:	4798      	blx	r3
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
    def2:	69fb      	ldr	r3, [r7, #28]
    def4:	3318      	adds	r3, #24
    def6:	0019      	movs	r1, r3
    def8:	2314      	movs	r3, #20
    defa:	18fb      	adds	r3, r7, r3
    defc:	2204      	movs	r2, #4
    defe:	0018      	movs	r0, r3
    df00:	4b4c      	ldr	r3, [pc, #304]	; (e034 <etharp_arp_input+0x1c4>)
    df02:	4798      	blx	r3

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
    df04:	68fb      	ldr	r3, [r7, #12]
    df06:	3304      	adds	r3, #4
    df08:	2b00      	cmp	r3, #0
    df0a:	d003      	beq.n	df14 <etharp_arp_input+0xa4>
    df0c:	68fb      	ldr	r3, [r7, #12]
    df0e:	685b      	ldr	r3, [r3, #4]
    df10:	2b00      	cmp	r3, #0
    df12:	d104      	bne.n	df1e <etharp_arp_input+0xae>
    for_us = 0;
    df14:	2327      	movs	r3, #39	; 0x27
    df16:	18fb      	adds	r3, r7, r3
    df18:	2200      	movs	r2, #0
    df1a:	701a      	strb	r2, [r3, #0]
    df1c:	e009      	b.n	df32 <etharp_arp_input+0xc2>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
    df1e:	697a      	ldr	r2, [r7, #20]
    df20:	68fb      	ldr	r3, [r7, #12]
    df22:	685b      	ldr	r3, [r3, #4]
    df24:	1ad3      	subs	r3, r2, r3
    df26:	425a      	negs	r2, r3
    df28:	4153      	adcs	r3, r2
    df2a:	b2da      	uxtb	r2, r3
    df2c:	2327      	movs	r3, #39	; 0x27
    df2e:	18fb      	adds	r3, r7, r3
    df30:	701a      	strb	r2, [r3, #0]
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
    df32:	69fb      	ldr	r3, [r7, #28]
    df34:	3308      	adds	r3, #8
    df36:	001a      	movs	r2, r3
    df38:	2327      	movs	r3, #39	; 0x27
    df3a:	18fb      	adds	r3, r7, r3
    df3c:	781b      	ldrb	r3, [r3, #0]
    df3e:	2b00      	cmp	r3, #0
    df40:	d001      	beq.n	df46 <etharp_arp_input+0xd6>
    df42:	2301      	movs	r3, #1
    df44:	e000      	b.n	df48 <etharp_arp_input+0xd8>
    df46:	2302      	movs	r3, #2
    df48:	2118      	movs	r1, #24
    df4a:	1879      	adds	r1, r7, r1
    df4c:	68f8      	ldr	r0, [r7, #12]
    df4e:	4c3a      	ldr	r4, [pc, #232]	; (e038 <etharp_arp_input+0x1c8>)
    df50:	47a0      	blx	r4
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
    df52:	69fb      	ldr	r3, [r7, #28]
    df54:	799a      	ldrb	r2, [r3, #6]
    df56:	79db      	ldrb	r3, [r3, #7]
    df58:	021b      	lsls	r3, r3, #8
    df5a:	4313      	orrs	r3, r2
    df5c:	b29b      	uxth	r3, r3
    df5e:	2280      	movs	r2, #128	; 0x80
    df60:	0052      	lsls	r2, r2, #1
    df62:	4293      	cmp	r3, r2
    df64:	d004      	beq.n	df70 <etharp_arp_input+0x100>
    df66:	2280      	movs	r2, #128	; 0x80
    df68:	0092      	lsls	r2, r2, #2
    df6a:	4293      	cmp	r3, r2
    df6c:	d055      	beq.n	e01a <etharp_arp_input+0x1aa>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
    df6e:	e055      	b.n	e01c <etharp_arp_input+0x1ac>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
    df70:	2327      	movs	r3, #39	; 0x27
    df72:	18fb      	adds	r3, r7, r3
    df74:	781b      	ldrb	r3, [r3, #0]
    df76:	2b00      	cmp	r3, #0
    df78:	d050      	beq.n	e01c <etharp_arp_input+0x1ac>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
    df7a:	2002      	movs	r0, #2
    df7c:	4b2f      	ldr	r3, [pc, #188]	; (e03c <etharp_arp_input+0x1cc>)
    df7e:	4798      	blx	r3
    df80:	0003      	movs	r3, r0
    df82:	001a      	movs	r2, r3
    df84:	69fb      	ldr	r3, [r7, #28]
    df86:	21ff      	movs	r1, #255	; 0xff
    df88:	4011      	ands	r1, r2
    df8a:	000c      	movs	r4, r1
    df8c:	7999      	ldrb	r1, [r3, #6]
    df8e:	2000      	movs	r0, #0
    df90:	4001      	ands	r1, r0
    df92:	1c08      	adds	r0, r1, #0
    df94:	1c21      	adds	r1, r4, #0
    df96:	4301      	orrs	r1, r0
    df98:	7199      	strb	r1, [r3, #6]
    df9a:	0a12      	lsrs	r2, r2, #8
    df9c:	b290      	uxth	r0, r2
    df9e:	79da      	ldrb	r2, [r3, #7]
    dfa0:	2100      	movs	r1, #0
    dfa2:	400a      	ands	r2, r1
    dfa4:	1c11      	adds	r1, r2, #0
    dfa6:	1c02      	adds	r2, r0, #0
    dfa8:	430a      	orrs	r2, r1
    dfaa:	71da      	strb	r2, [r3, #7]

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
    dfac:	69fb      	ldr	r3, [r7, #28]
    dfae:	3318      	adds	r3, #24
    dfb0:	0018      	movs	r0, r3
    dfb2:	69fb      	ldr	r3, [r7, #28]
    dfb4:	330e      	adds	r3, #14
    dfb6:	2204      	movs	r2, #4
    dfb8:	0019      	movs	r1, r3
    dfba:	4b1e      	ldr	r3, [pc, #120]	; (e034 <etharp_arp_input+0x1c4>)
    dfbc:	4798      	blx	r3
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
    dfbe:	69fb      	ldr	r3, [r7, #28]
    dfc0:	330e      	adds	r3, #14
    dfc2:	0018      	movs	r0, r3
    dfc4:	68fb      	ldr	r3, [r7, #12]
    dfc6:	3304      	adds	r3, #4
    dfc8:	2204      	movs	r2, #4
    dfca:	0019      	movs	r1, r3
    dfcc:	4b19      	ldr	r3, [pc, #100]	; (e034 <etharp_arp_input+0x1c4>)
    dfce:	4798      	blx	r3
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
    dfd0:	69fb      	ldr	r3, [r7, #28]
    dfd2:	3312      	adds	r3, #18
    dfd4:	0018      	movs	r0, r3
    dfd6:	69fb      	ldr	r3, [r7, #28]
    dfd8:	3308      	adds	r3, #8
    dfda:	2206      	movs	r2, #6
    dfdc:	0019      	movs	r1, r3
    dfde:	4b15      	ldr	r3, [pc, #84]	; (e034 <etharp_arp_input+0x1c4>)
    dfe0:	4798      	blx	r3
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
    dfe2:	6a38      	ldr	r0, [r7, #32]
    dfe4:	69fb      	ldr	r3, [r7, #28]
    dfe6:	3308      	adds	r3, #8
    dfe8:	2206      	movs	r2, #6
    dfea:	0019      	movs	r1, r3
    dfec:	4b11      	ldr	r3, [pc, #68]	; (e034 <etharp_arp_input+0x1c4>)
    dfee:	4798      	blx	r3
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
    dff0:	69fb      	ldr	r3, [r7, #28]
    dff2:	3308      	adds	r3, #8
    dff4:	68b9      	ldr	r1, [r7, #8]
    dff6:	2206      	movs	r2, #6
    dff8:	0018      	movs	r0, r3
    dffa:	4b0e      	ldr	r3, [pc, #56]	; (e034 <etharp_arp_input+0x1c4>)
    dffc:	4798      	blx	r3
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
    dffe:	6a3b      	ldr	r3, [r7, #32]
    e000:	3306      	adds	r3, #6
    e002:	68b9      	ldr	r1, [r7, #8]
    e004:	2206      	movs	r2, #6
    e006:	0018      	movs	r0, r3
    e008:	4b0a      	ldr	r3, [pc, #40]	; (e034 <etharp_arp_input+0x1c4>)
    e00a:	4798      	blx	r3

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
    e00c:	68fb      	ldr	r3, [r7, #12]
    e00e:	699b      	ldr	r3, [r3, #24]
    e010:	6879      	ldr	r1, [r7, #4]
    e012:	68fa      	ldr	r2, [r7, #12]
    e014:	0010      	movs	r0, r2
    e016:	4798      	blx	r3
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
    e018:	e000      	b.n	e01c <etharp_arp_input+0x1ac>
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
    e01a:	46c0      	nop			; (mov r8, r8)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
    e01c:	687b      	ldr	r3, [r7, #4]
    e01e:	0018      	movs	r0, r3
    e020:	4b03      	ldr	r3, [pc, #12]	; (e030 <etharp_arp_input+0x1c0>)
    e022:	4798      	blx	r3
    e024:	e000      	b.n	e028 <etharp_arp_input+0x1b8>
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
    e026:	46c0      	nop			; (mov r8, r8)
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
    e028:	46bd      	mov	sp, r7
    e02a:	b00b      	add	sp, #44	; 0x2c
    e02c:	bd90      	pop	{r4, r7, pc}
    e02e:	46c0      	nop			; (mov r8, r8)
    e030:	00008349 	.word	0x00008349
    e034:	0000fc43 	.word	0x0000fc43
    e038:	0000dd11 	.word	0x0000dd11
    e03c:	000055f1 	.word	0x000055f1

0000e040 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
    e040:	b590      	push	{r4, r7, lr}
    e042:	b085      	sub	sp, #20
    e044:	af00      	add	r7, sp, #0
    e046:	60f8      	str	r0, [r7, #12]
    e048:	60b9      	str	r1, [r7, #8]
    e04a:	1dfb      	adds	r3, r7, #7
    e04c:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
    e04e:	1dfb      	adds	r3, r7, #7
    e050:	781a      	ldrb	r2, [r3, #0]
    e052:	4924      	ldr	r1, [pc, #144]	; (e0e4 <etharp_output_to_arp_index+0xa4>)
    e054:	0013      	movs	r3, r2
    e056:	009b      	lsls	r3, r3, #2
    e058:	189b      	adds	r3, r3, r2
    e05a:	009b      	lsls	r3, r3, #2
    e05c:	18cb      	adds	r3, r1, r3
    e05e:	3312      	adds	r3, #18
    e060:	781b      	ldrb	r3, [r3, #0]
    e062:	2b02      	cmp	r3, #2
    e064:	d126      	bne.n	e0b4 <etharp_output_to_arp_index+0x74>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    e066:	1dfb      	adds	r3, r7, #7
    e068:	781a      	ldrb	r2, [r3, #0]
    e06a:	491e      	ldr	r1, [pc, #120]	; (e0e4 <etharp_output_to_arp_index+0xa4>)
    e06c:	0013      	movs	r3, r2
    e06e:	009b      	lsls	r3, r3, #2
    e070:	189b      	adds	r3, r3, r2
    e072:	009b      	lsls	r3, r3, #2
    e074:	18cb      	adds	r3, r1, r3
    e076:	3313      	adds	r3, #19
    e078:	781b      	ldrb	r3, [r3, #0]
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
    e07a:	2be3      	cmp	r3, #227	; 0xe3
    e07c:	d91a      	bls.n	e0b4 <etharp_output_to_arp_index+0x74>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
    e07e:	1dfb      	adds	r3, r7, #7
    e080:	781a      	ldrb	r2, [r3, #0]
    e082:	0013      	movs	r3, r2
    e084:	009b      	lsls	r3, r3, #2
    e086:	189b      	adds	r3, r3, r2
    e088:	009b      	lsls	r3, r3, #2
    e08a:	4a16      	ldr	r2, [pc, #88]	; (e0e4 <etharp_output_to_arp_index+0xa4>)
    e08c:	189b      	adds	r3, r3, r2
    e08e:	1d1a      	adds	r2, r3, #4
    e090:	68fb      	ldr	r3, [r7, #12]
    e092:	0011      	movs	r1, r2
    e094:	0018      	movs	r0, r3
    e096:	4b14      	ldr	r3, [pc, #80]	; (e0e8 <etharp_output_to_arp_index+0xa8>)
    e098:	4798      	blx	r3
    e09a:	1e03      	subs	r3, r0, #0
    e09c:	d10a      	bne.n	e0b4 <etharp_output_to_arp_index+0x74>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    e09e:	1dfb      	adds	r3, r7, #7
    e0a0:	781a      	ldrb	r2, [r3, #0]
    e0a2:	4910      	ldr	r1, [pc, #64]	; (e0e4 <etharp_output_to_arp_index+0xa4>)
    e0a4:	0013      	movs	r3, r2
    e0a6:	009b      	lsls	r3, r3, #2
    e0a8:	189b      	adds	r3, r3, r2
    e0aa:	009b      	lsls	r3, r3, #2
    e0ac:	18cb      	adds	r3, r1, r3
    e0ae:	3312      	adds	r3, #18
    e0b0:	2203      	movs	r2, #3
    e0b2:	701a      	strb	r2, [r3, #0]
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
    e0b4:	68fb      	ldr	r3, [r7, #12]
    e0b6:	3327      	adds	r3, #39	; 0x27
    e0b8:	001c      	movs	r4, r3
    &arp_table[arp_idx].ethaddr);
    e0ba:	1dfb      	adds	r3, r7, #7
    e0bc:	781a      	ldrb	r2, [r3, #0]
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
    e0be:	0013      	movs	r3, r2
    e0c0:	009b      	lsls	r3, r3, #2
    e0c2:	189b      	adds	r3, r3, r2
    e0c4:	009b      	lsls	r3, r3, #2
    e0c6:	3308      	adds	r3, #8
    e0c8:	001a      	movs	r2, r3
    e0ca:	4b06      	ldr	r3, [pc, #24]	; (e0e4 <etharp_output_to_arp_index+0xa4>)
    e0cc:	18d3      	adds	r3, r2, r3
    e0ce:	3304      	adds	r3, #4
    e0d0:	68b9      	ldr	r1, [r7, #8]
    e0d2:	68f8      	ldr	r0, [r7, #12]
    e0d4:	0022      	movs	r2, r4
    e0d6:	4c05      	ldr	r4, [pc, #20]	; (e0ec <etharp_output_to_arp_index+0xac>)
    e0d8:	47a0      	blx	r4
    e0da:	0003      	movs	r3, r0
    &arp_table[arp_idx].ethaddr);
}
    e0dc:	0018      	movs	r0, r3
    e0de:	46bd      	mov	sp, r7
    e0e0:	b005      	add	sp, #20
    e0e2:	bd90      	pop	{r4, r7, pc}
    e0e4:	20002c9c 	.word	0x20002c9c
    e0e8:	0000e69d 	.word	0x0000e69d
    e0ec:	0000dcb1 	.word	0x0000dcb1

0000e0f0 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
    e0f0:	b590      	push	{r4, r7, lr}
    e0f2:	b089      	sub	sp, #36	; 0x24
    e0f4:	af00      	add	r7, sp, #0
    e0f6:	60f8      	str	r0, [r7, #12]
    e0f8:	60b9      	str	r1, [r7, #8]
    e0fa:	607a      	str	r2, [r7, #4]
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;
    e0fc:	687b      	ldr	r3, [r7, #4]
    e0fe:	61bb      	str	r3, [r7, #24]
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    e100:	68bb      	ldr	r3, [r7, #8]
    e102:	210e      	movs	r1, #14
    e104:	0018      	movs	r0, r3
    e106:	4b6b      	ldr	r3, [pc, #428]	; (e2b4 <etharp_output+0x1c4>)
    e108:	4798      	blx	r3
    e10a:	1e03      	subs	r3, r0, #0
    e10c:	d002      	beq.n	e114 <etharp_output+0x24>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
    e10e:	2302      	movs	r3, #2
    e110:	425b      	negs	r3, r3
    e112:	e0cb      	b.n	e2ac <etharp_output+0x1bc>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    e114:	687b      	ldr	r3, [r7, #4]
    e116:	681b      	ldr	r3, [r3, #0]
    e118:	68fa      	ldr	r2, [r7, #12]
    e11a:	0011      	movs	r1, r2
    e11c:	0018      	movs	r0, r3
    e11e:	4b66      	ldr	r3, [pc, #408]	; (e2b8 <etharp_output+0x1c8>)
    e120:	4798      	blx	r3
    e122:	1e03      	subs	r3, r0, #0
    e124:	d002      	beq.n	e12c <etharp_output+0x3c>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
    e126:	4b65      	ldr	r3, [pc, #404]	; (e2bc <etharp_output+0x1cc>)
    e128:	61fb      	str	r3, [r7, #28]
    e12a:	e0b6      	b.n	e29a <etharp_output+0x1aa>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    e12c:	687b      	ldr	r3, [r7, #4]
    e12e:	681b      	ldr	r3, [r3, #0]
    e130:	22f0      	movs	r2, #240	; 0xf0
    e132:	4013      	ands	r3, r2
    e134:	2be0      	cmp	r3, #224	; 0xe0
    e136:	d122      	bne.n	e17e <etharp_output+0x8e>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    e138:	2310      	movs	r3, #16
    e13a:	18fb      	adds	r3, r7, r3
    e13c:	2201      	movs	r2, #1
    e13e:	701a      	strb	r2, [r3, #0]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    e140:	2310      	movs	r3, #16
    e142:	18fb      	adds	r3, r7, r3
    e144:	2200      	movs	r2, #0
    e146:	705a      	strb	r2, [r3, #1]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    e148:	2310      	movs	r3, #16
    e14a:	18fb      	adds	r3, r7, r3
    e14c:	225e      	movs	r2, #94	; 0x5e
    e14e:	709a      	strb	r2, [r3, #2]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    e150:	687b      	ldr	r3, [r7, #4]
    e152:	3301      	adds	r3, #1
    e154:	781b      	ldrb	r3, [r3, #0]
    e156:	227f      	movs	r2, #127	; 0x7f
    e158:	4013      	ands	r3, r2
    e15a:	b2da      	uxtb	r2, r3
    e15c:	2310      	movs	r3, #16
    e15e:	18fb      	adds	r3, r7, r3
    e160:	70da      	strb	r2, [r3, #3]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
    e162:	687b      	ldr	r3, [r7, #4]
    e164:	789a      	ldrb	r2, [r3, #2]
    e166:	2310      	movs	r3, #16
    e168:	18fb      	adds	r3, r7, r3
    e16a:	711a      	strb	r2, [r3, #4]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
    e16c:	687b      	ldr	r3, [r7, #4]
    e16e:	78da      	ldrb	r2, [r3, #3]
    e170:	2310      	movs	r3, #16
    e172:	18fb      	adds	r3, r7, r3
    e174:	715a      	strb	r2, [r3, #5]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
    e176:	2310      	movs	r3, #16
    e178:	18fb      	adds	r3, r7, r3
    e17a:	61fb      	str	r3, [r7, #28]
    e17c:	e08d      	b.n	e29a <etharp_output+0x1aa>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    e17e:	687b      	ldr	r3, [r7, #4]
    e180:	681a      	ldr	r2, [r3, #0]
    e182:	68fb      	ldr	r3, [r7, #12]
    e184:	685b      	ldr	r3, [r3, #4]
    e186:	405a      	eors	r2, r3
    e188:	68fb      	ldr	r3, [r7, #12]
    e18a:	689b      	ldr	r3, [r3, #8]
    e18c:	4013      	ands	r3, r2
    e18e:	d015      	beq.n	e1bc <etharp_output+0xcc>
        !ip_addr_islinklocal(ipaddr)) {
    e190:	687b      	ldr	r3, [r7, #4]
    e192:	681b      	ldr	r3, [r3, #0]
    e194:	041b      	lsls	r3, r3, #16
    e196:	0c1b      	lsrs	r3, r3, #16
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
    e198:	4a49      	ldr	r2, [pc, #292]	; (e2c0 <etharp_output+0x1d0>)
    e19a:	4293      	cmp	r3, r2
    e19c:	d00e      	beq.n	e1bc <etharp_output+0xcc>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
    e19e:	68fb      	ldr	r3, [r7, #12]
    e1a0:	330c      	adds	r3, #12
    e1a2:	2b00      	cmp	r3, #0
    e1a4:	d007      	beq.n	e1b6 <etharp_output+0xc6>
    e1a6:	68fb      	ldr	r3, [r7, #12]
    e1a8:	68db      	ldr	r3, [r3, #12]
    e1aa:	2b00      	cmp	r3, #0
    e1ac:	d003      	beq.n	e1b6 <etharp_output+0xc6>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
    e1ae:	68fb      	ldr	r3, [r7, #12]
    e1b0:	330c      	adds	r3, #12
    e1b2:	61bb      	str	r3, [r7, #24]
    e1b4:	e002      	b.n	e1bc <etharp_output+0xcc>
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
    e1b6:	2304      	movs	r3, #4
    e1b8:	425b      	negs	r3, r3
    e1ba:	e077      	b.n	e2ac <etharp_output+0x1bc>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
    e1bc:	4b41      	ldr	r3, [pc, #260]	; (e2c4 <etharp_output+0x1d4>)
    e1be:	781b      	ldrb	r3, [r3, #0]
    e1c0:	0019      	movs	r1, r3
    e1c2:	4a41      	ldr	r2, [pc, #260]	; (e2c8 <etharp_output+0x1d8>)
    e1c4:	000b      	movs	r3, r1
    e1c6:	009b      	lsls	r3, r3, #2
    e1c8:	185b      	adds	r3, r3, r1
    e1ca:	009b      	lsls	r3, r3, #2
    e1cc:	18d3      	adds	r3, r2, r3
    e1ce:	3312      	adds	r3, #18
    e1d0:	781b      	ldrb	r3, [r3, #0]
    e1d2:	2b01      	cmp	r3, #1
    e1d4:	d917      	bls.n	e206 <etharp_output+0x116>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
    e1d6:	69bb      	ldr	r3, [r7, #24]
    e1d8:	681a      	ldr	r2, [r3, #0]
    e1da:	4b3a      	ldr	r3, [pc, #232]	; (e2c4 <etharp_output+0x1d4>)
    e1dc:	781b      	ldrb	r3, [r3, #0]
    e1de:	0018      	movs	r0, r3
    e1e0:	4939      	ldr	r1, [pc, #228]	; (e2c8 <etharp_output+0x1d8>)
    e1e2:	0003      	movs	r3, r0
    e1e4:	009b      	lsls	r3, r3, #2
    e1e6:	181b      	adds	r3, r3, r0
    e1e8:	009b      	lsls	r3, r3, #2
    e1ea:	18cb      	adds	r3, r1, r3
    e1ec:	3304      	adds	r3, #4
    e1ee:	681b      	ldr	r3, [r3, #0]
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
    e1f0:	429a      	cmp	r2, r3
    e1f2:	d108      	bne.n	e206 <etharp_output+0x116>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
    e1f4:	4b33      	ldr	r3, [pc, #204]	; (e2c4 <etharp_output+0x1d4>)
    e1f6:	781a      	ldrb	r2, [r3, #0]
    e1f8:	68b9      	ldr	r1, [r7, #8]
    e1fa:	68fb      	ldr	r3, [r7, #12]
    e1fc:	0018      	movs	r0, r3
    e1fe:	4b33      	ldr	r3, [pc, #204]	; (e2cc <etharp_output+0x1dc>)
    e200:	4798      	blx	r3
    e202:	0003      	movs	r3, r0
    e204:	e052      	b.n	e2ac <etharp_output+0x1bc>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
    e206:	2317      	movs	r3, #23
    e208:	18fb      	adds	r3, r7, r3
    e20a:	2200      	movs	r2, #0
    e20c:	701a      	strb	r2, [r3, #0]
    e20e:	e036      	b.n	e27e <etharp_output+0x18e>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
    e210:	2317      	movs	r3, #23
    e212:	18fb      	adds	r3, r7, r3
    e214:	2200      	movs	r2, #0
    e216:	569a      	ldrsb	r2, [r3, r2]
    e218:	492b      	ldr	r1, [pc, #172]	; (e2c8 <etharp_output+0x1d8>)
    e21a:	0013      	movs	r3, r2
    e21c:	009b      	lsls	r3, r3, #2
    e21e:	189b      	adds	r3, r3, r2
    e220:	009b      	lsls	r3, r3, #2
    e222:	18cb      	adds	r3, r1, r3
    e224:	3312      	adds	r3, #18
    e226:	781b      	ldrb	r3, [r3, #0]
    e228:	2b01      	cmp	r3, #1
    e22a:	d91e      	bls.n	e26a <etharp_output+0x17a>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
    e22c:	69bb      	ldr	r3, [r7, #24]
    e22e:	6819      	ldr	r1, [r3, #0]
    e230:	2317      	movs	r3, #23
    e232:	18fb      	adds	r3, r7, r3
    e234:	2200      	movs	r2, #0
    e236:	569a      	ldrsb	r2, [r3, r2]
    e238:	4823      	ldr	r0, [pc, #140]	; (e2c8 <etharp_output+0x1d8>)
    e23a:	0013      	movs	r3, r2
    e23c:	009b      	lsls	r3, r3, #2
    e23e:	189b      	adds	r3, r3, r2
    e240:	009b      	lsls	r3, r3, #2
    e242:	18c3      	adds	r3, r0, r3
    e244:	3304      	adds	r3, #4
    e246:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
    e248:	4299      	cmp	r1, r3
    e24a:	d10e      	bne.n	e26a <etharp_output+0x17a>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
    e24c:	2317      	movs	r3, #23
    e24e:	18fb      	adds	r3, r7, r3
    e250:	781a      	ldrb	r2, [r3, #0]
    e252:	4b1c      	ldr	r3, [pc, #112]	; (e2c4 <etharp_output+0x1d4>)
    e254:	701a      	strb	r2, [r3, #0]
        return etharp_output_to_arp_index(netif, q, i);
    e256:	2317      	movs	r3, #23
    e258:	18fb      	adds	r3, r7, r3
    e25a:	781a      	ldrb	r2, [r3, #0]
    e25c:	68b9      	ldr	r1, [r7, #8]
    e25e:	68fb      	ldr	r3, [r7, #12]
    e260:	0018      	movs	r0, r3
    e262:	4b1a      	ldr	r3, [pc, #104]	; (e2cc <etharp_output+0x1dc>)
    e264:	4798      	blx	r3
    e266:	0003      	movs	r3, r0
    e268:	e020      	b.n	e2ac <etharp_output+0x1bc>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
    e26a:	2317      	movs	r3, #23
    e26c:	18fb      	adds	r3, r7, r3
    e26e:	781b      	ldrb	r3, [r3, #0]
    e270:	b25b      	sxtb	r3, r3
    e272:	b2db      	uxtb	r3, r3
    e274:	3301      	adds	r3, #1
    e276:	b2da      	uxtb	r2, r3
    e278:	2317      	movs	r3, #23
    e27a:	18fb      	adds	r3, r7, r3
    e27c:	701a      	strb	r2, [r3, #0]
    e27e:	2317      	movs	r3, #23
    e280:	18fb      	adds	r3, r7, r3
    e282:	781b      	ldrb	r3, [r3, #0]
    e284:	b25b      	sxtb	r3, r3
    e286:	2b09      	cmp	r3, #9
    e288:	ddc2      	ble.n	e210 <etharp_output+0x120>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
    e28a:	68ba      	ldr	r2, [r7, #8]
    e28c:	69b9      	ldr	r1, [r7, #24]
    e28e:	68fb      	ldr	r3, [r7, #12]
    e290:	0018      	movs	r0, r3
    e292:	4b0f      	ldr	r3, [pc, #60]	; (e2d0 <etharp_output+0x1e0>)
    e294:	4798      	blx	r3
    e296:	0003      	movs	r3, r0
    e298:	e008      	b.n	e2ac <etharp_output+0x1bc>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
    e29a:	68fb      	ldr	r3, [r7, #12]
    e29c:	3327      	adds	r3, #39	; 0x27
    e29e:	001a      	movs	r2, r3
    e2a0:	69fb      	ldr	r3, [r7, #28]
    e2a2:	68b9      	ldr	r1, [r7, #8]
    e2a4:	68f8      	ldr	r0, [r7, #12]
    e2a6:	4c0b      	ldr	r4, [pc, #44]	; (e2d4 <etharp_output+0x1e4>)
    e2a8:	47a0      	blx	r4
    e2aa:	0003      	movs	r3, r0
}
    e2ac:	0018      	movs	r0, r3
    e2ae:	46bd      	mov	sp, r7
    e2b0:	b009      	add	sp, #36	; 0x24
    e2b2:	bd90      	pop	{r4, r7, pc}
    e2b4:	00008235 	.word	0x00008235
    e2b8:	0000626d 	.word	0x0000626d
    e2bc:	0000fde8 	.word	0x0000fde8
    e2c0:	0000fea9 	.word	0x0000fea9
    e2c4:	20002d64 	.word	0x20002d64
    e2c8:	20002c9c 	.word	0x20002c9c
    e2cc:	0000e041 	.word	0x0000e041
    e2d0:	0000e2d9 	.word	0x0000e2d9
    e2d4:	0000dcb1 	.word	0x0000dcb1

0000e2d8 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
    e2d8:	b5b0      	push	{r4, r5, r7, lr}
    e2da:	b08a      	sub	sp, #40	; 0x28
    e2dc:	af00      	add	r7, sp, #0
    e2de:	60f8      	str	r0, [r7, #12]
    e2e0:	60b9      	str	r1, [r7, #8]
    e2e2:	607a      	str	r2, [r7, #4]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
    e2e4:	68fb      	ldr	r3, [r7, #12]
    e2e6:	3327      	adds	r3, #39	; 0x27
    e2e8:	61bb      	str	r3, [r7, #24]
  err_t result = ERR_MEM;
    e2ea:	2327      	movs	r3, #39	; 0x27
    e2ec:	18fb      	adds	r3, r7, r3
    e2ee:	22ff      	movs	r2, #255	; 0xff
    e2f0:	701a      	strb	r2, [r3, #0]
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    e2f2:	68bb      	ldr	r3, [r7, #8]
    e2f4:	681b      	ldr	r3, [r3, #0]
    e2f6:	68fa      	ldr	r2, [r7, #12]
    e2f8:	0011      	movs	r1, r2
    e2fa:	0018      	movs	r0, r3
    e2fc:	4b85      	ldr	r3, [pc, #532]	; (e514 <etharp_query+0x23c>)
    e2fe:	4798      	blx	r3
    e300:	1e03      	subs	r3, r0, #0
    e302:	d10c      	bne.n	e31e <etharp_query+0x46>
      ip_addr_ismulticast(ipaddr) ||
    e304:	68bb      	ldr	r3, [r7, #8]
    e306:	681b      	ldr	r3, [r3, #0]
    e308:	22f0      	movs	r2, #240	; 0xf0
    e30a:	4013      	ands	r3, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
    e30c:	2be0      	cmp	r3, #224	; 0xe0
    e30e:	d006      	beq.n	e31e <etharp_query+0x46>
      ip_addr_ismulticast(ipaddr) ||
    e310:	68bb      	ldr	r3, [r7, #8]
    e312:	2b00      	cmp	r3, #0
    e314:	d003      	beq.n	e31e <etharp_query+0x46>
      ip_addr_isany(ipaddr)) {
    e316:	68bb      	ldr	r3, [r7, #8]
    e318:	681b      	ldr	r3, [r3, #0]
    e31a:	2b00      	cmp	r3, #0
    e31c:	d102      	bne.n	e324 <etharp_query+0x4c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
    e31e:	230e      	movs	r3, #14
    e320:	425b      	negs	r3, r3
    e322:	e0f2      	b.n	e50a <etharp_query+0x232>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
    e324:	2317      	movs	r3, #23
    e326:	18fc      	adds	r4, r7, r3
    e328:	68bb      	ldr	r3, [r7, #8]
    e32a:	2101      	movs	r1, #1
    e32c:	0018      	movs	r0, r3
    e32e:	4b7a      	ldr	r3, [pc, #488]	; (e518 <etharp_query+0x240>)
    e330:	4798      	blx	r3
    e332:	0003      	movs	r3, r0
    e334:	7023      	strb	r3, [r4, #0]

  /* could not find or create entry? */
  if (i < 0) {
    e336:	2317      	movs	r3, #23
    e338:	18fb      	adds	r3, r7, r3
    e33a:	781b      	ldrb	r3, [r3, #0]
    e33c:	2b7f      	cmp	r3, #127	; 0x7f
    e33e:	d904      	bls.n	e34a <etharp_query+0x72>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
    e340:	2317      	movs	r3, #23
    e342:	18fb      	adds	r3, r7, r3
    e344:	781b      	ldrb	r3, [r3, #0]
    e346:	b25b      	sxtb	r3, r3
    e348:	e0df      	b.n	e50a <etharp_query+0x232>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    e34a:	2317      	movs	r3, #23
    e34c:	18fb      	adds	r3, r7, r3
    e34e:	2200      	movs	r2, #0
    e350:	569a      	ldrsb	r2, [r3, r2]
    e352:	4972      	ldr	r1, [pc, #456]	; (e51c <etharp_query+0x244>)
    e354:	0013      	movs	r3, r2
    e356:	009b      	lsls	r3, r3, #2
    e358:	189b      	adds	r3, r3, r2
    e35a:	009b      	lsls	r3, r3, #2
    e35c:	18cb      	adds	r3, r1, r3
    e35e:	3312      	adds	r3, #18
    e360:	781b      	ldrb	r3, [r3, #0]
    e362:	2b00      	cmp	r3, #0
    e364:	d10c      	bne.n	e380 <etharp_query+0xa8>
    arp_table[i].state = ETHARP_STATE_PENDING;
    e366:	2317      	movs	r3, #23
    e368:	18fb      	adds	r3, r7, r3
    e36a:	2200      	movs	r2, #0
    e36c:	569a      	ldrsb	r2, [r3, r2]
    e36e:	496b      	ldr	r1, [pc, #428]	; (e51c <etharp_query+0x244>)
    e370:	0013      	movs	r3, r2
    e372:	009b      	lsls	r3, r3, #2
    e374:	189b      	adds	r3, r3, r2
    e376:	009b      	lsls	r3, r3, #2
    e378:	18cb      	adds	r3, r1, r3
    e37a:	3312      	adds	r3, #18
    e37c:	2201      	movs	r2, #1
    e37e:	701a      	strb	r2, [r3, #0]
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    e380:	2317      	movs	r3, #23
    e382:	18fb      	adds	r3, r7, r3
    e384:	2200      	movs	r2, #0
    e386:	569a      	ldrsb	r2, [r3, r2]
    e388:	4964      	ldr	r1, [pc, #400]	; (e51c <etharp_query+0x244>)
    e38a:	0013      	movs	r3, r2
    e38c:	009b      	lsls	r3, r3, #2
    e38e:	189b      	adds	r3, r3, r2
    e390:	009b      	lsls	r3, r3, #2
    e392:	18cb      	adds	r3, r1, r3
    e394:	3312      	adds	r3, #18
    e396:	781b      	ldrb	r3, [r3, #0]
    e398:	2b01      	cmp	r3, #1
    e39a:	d002      	beq.n	e3a2 <etharp_query+0xca>
    e39c:	687b      	ldr	r3, [r7, #4]
    e39e:	2b00      	cmp	r3, #0
    e3a0:	d111      	bne.n	e3c6 <etharp_query+0xee>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
    e3a2:	2327      	movs	r3, #39	; 0x27
    e3a4:	18fc      	adds	r4, r7, r3
    e3a6:	68ba      	ldr	r2, [r7, #8]
    e3a8:	68fb      	ldr	r3, [r7, #12]
    e3aa:	0011      	movs	r1, r2
    e3ac:	0018      	movs	r0, r3
    e3ae:	4b5c      	ldr	r3, [pc, #368]	; (e520 <etharp_query+0x248>)
    e3b0:	4798      	blx	r3
    e3b2:	0003      	movs	r3, r0
    e3b4:	7023      	strb	r3, [r4, #0]
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
    e3b6:	687b      	ldr	r3, [r7, #4]
    e3b8:	2b00      	cmp	r3, #0
    e3ba:	d104      	bne.n	e3c6 <etharp_query+0xee>
      return result;
    e3bc:	2327      	movs	r3, #39	; 0x27
    e3be:	18fb      	adds	r3, r7, r3
    e3c0:	781b      	ldrb	r3, [r3, #0]
    e3c2:	b25b      	sxtb	r3, r3
    e3c4:	e0a1      	b.n	e50a <etharp_query+0x232>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    e3c6:	2317      	movs	r3, #23
    e3c8:	18fb      	adds	r3, r7, r3
    e3ca:	2200      	movs	r2, #0
    e3cc:	569a      	ldrsb	r2, [r3, r2]
    e3ce:	4953      	ldr	r1, [pc, #332]	; (e51c <etharp_query+0x244>)
    e3d0:	0013      	movs	r3, r2
    e3d2:	009b      	lsls	r3, r3, #2
    e3d4:	189b      	adds	r3, r3, r2
    e3d6:	009b      	lsls	r3, r3, #2
    e3d8:	18cb      	adds	r3, r1, r3
    e3da:	3312      	adds	r3, #18
    e3dc:	781b      	ldrb	r3, [r3, #0]
    e3de:	2b01      	cmp	r3, #1
    e3e0:	d91b      	bls.n	e41a <etharp_query+0x142>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    e3e2:	2317      	movs	r3, #23
    e3e4:	18fb      	adds	r3, r7, r3
    e3e6:	781a      	ldrb	r2, [r3, #0]
    e3e8:	4b4e      	ldr	r3, [pc, #312]	; (e524 <etharp_query+0x24c>)
    e3ea:	701a      	strb	r2, [r3, #0]
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    e3ec:	2317      	movs	r3, #23
    e3ee:	18fb      	adds	r3, r7, r3
    e3f0:	2200      	movs	r2, #0
    e3f2:	569a      	ldrsb	r2, [r3, r2]
    e3f4:	0013      	movs	r3, r2
    e3f6:	009b      	lsls	r3, r3, #2
    e3f8:	189b      	adds	r3, r3, r2
    e3fa:	009b      	lsls	r3, r3, #2
    e3fc:	3308      	adds	r3, #8
    e3fe:	001a      	movs	r2, r3
    e400:	4b46      	ldr	r3, [pc, #280]	; (e51c <etharp_query+0x244>)
    e402:	18d3      	adds	r3, r2, r3
    e404:	3304      	adds	r3, #4
    e406:	2227      	movs	r2, #39	; 0x27
    e408:	18bc      	adds	r4, r7, r2
    e40a:	69ba      	ldr	r2, [r7, #24]
    e40c:	6879      	ldr	r1, [r7, #4]
    e40e:	68f8      	ldr	r0, [r7, #12]
    e410:	4d45      	ldr	r5, [pc, #276]	; (e528 <etharp_query+0x250>)
    e412:	47a8      	blx	r5
    e414:	0003      	movs	r3, r0
    e416:	7023      	strb	r3, [r4, #0]
    e418:	e073      	b.n	e502 <etharp_query+0x22a>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
    e41a:	2317      	movs	r3, #23
    e41c:	18fb      	adds	r3, r7, r3
    e41e:	2200      	movs	r2, #0
    e420:	569a      	ldrsb	r2, [r3, r2]
    e422:	493e      	ldr	r1, [pc, #248]	; (e51c <etharp_query+0x244>)
    e424:	0013      	movs	r3, r2
    e426:	009b      	lsls	r3, r3, #2
    e428:	189b      	adds	r3, r3, r2
    e42a:	009b      	lsls	r3, r3, #2
    e42c:	18cb      	adds	r3, r1, r3
    e42e:	3312      	adds	r3, #18
    e430:	781b      	ldrb	r3, [r3, #0]
    e432:	2b01      	cmp	r3, #1
    e434:	d165      	bne.n	e502 <etharp_query+0x22a>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
    e436:	2300      	movs	r3, #0
    e438:	61fb      	str	r3, [r7, #28]
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    e43a:	687b      	ldr	r3, [r7, #4]
    e43c:	623b      	str	r3, [r7, #32]
    while (p) {
    e43e:	e009      	b.n	e454 <etharp_query+0x17c>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
    e440:	6a3b      	ldr	r3, [r7, #32]
    e442:	7b1b      	ldrb	r3, [r3, #12]
    e444:	2b01      	cmp	r3, #1
    e446:	d002      	beq.n	e44e <etharp_query+0x176>
        copy_needed = 1;
    e448:	2301      	movs	r3, #1
    e44a:	61fb      	str	r3, [r7, #28]
        break;
    e44c:	e005      	b.n	e45a <etharp_query+0x182>
      }
      p = p->next;
    e44e:	6a3b      	ldr	r3, [r7, #32]
    e450:	681b      	ldr	r3, [r3, #0]
    e452:	623b      	str	r3, [r7, #32]
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
    e454:	6a3b      	ldr	r3, [r7, #32]
    e456:	2b00      	cmp	r3, #0
    e458:	d1f2      	bne.n	e440 <etharp_query+0x168>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if(copy_needed) {
    e45a:	69fb      	ldr	r3, [r7, #28]
    e45c:	2b00      	cmp	r3, #0
    e45e:	d01a      	beq.n	e496 <etharp_query+0x1be>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
    e460:	6a3b      	ldr	r3, [r7, #32]
    e462:	891b      	ldrh	r3, [r3, #8]
    e464:	2200      	movs	r2, #0
    e466:	0019      	movs	r1, r3
    e468:	2003      	movs	r0, #3
    e46a:	4b30      	ldr	r3, [pc, #192]	; (e52c <etharp_query+0x254>)
    e46c:	4798      	blx	r3
    e46e:	0003      	movs	r3, r0
    e470:	623b      	str	r3, [r7, #32]
      if(p != NULL) {
    e472:	6a3b      	ldr	r3, [r7, #32]
    e474:	2b00      	cmp	r3, #0
    e476:	d014      	beq.n	e4a2 <etharp_query+0x1ca>
        if (pbuf_copy(p, q) != ERR_OK) {
    e478:	687a      	ldr	r2, [r7, #4]
    e47a:	6a3b      	ldr	r3, [r7, #32]
    e47c:	0011      	movs	r1, r2
    e47e:	0018      	movs	r0, r3
    e480:	4b2b      	ldr	r3, [pc, #172]	; (e530 <etharp_query+0x258>)
    e482:	4798      	blx	r3
    e484:	1e03      	subs	r3, r0, #0
    e486:	d00c      	beq.n	e4a2 <etharp_query+0x1ca>
          pbuf_free(p);
    e488:	6a3b      	ldr	r3, [r7, #32]
    e48a:	0018      	movs	r0, r3
    e48c:	4b29      	ldr	r3, [pc, #164]	; (e534 <etharp_query+0x25c>)
    e48e:	4798      	blx	r3
          p = NULL;
    e490:	2300      	movs	r3, #0
    e492:	623b      	str	r3, [r7, #32]
    e494:	e005      	b.n	e4a2 <etharp_query+0x1ca>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
    e496:	687b      	ldr	r3, [r7, #4]
    e498:	623b      	str	r3, [r7, #32]
      pbuf_ref(p);
    e49a:	6a3b      	ldr	r3, [r7, #32]
    e49c:	0018      	movs	r0, r3
    e49e:	4b26      	ldr	r3, [pc, #152]	; (e538 <etharp_query+0x260>)
    e4a0:	4798      	blx	r3
    }
    /* packet could be taken over? */
    if (p != NULL) {
    e4a2:	6a3b      	ldr	r3, [r7, #32]
    e4a4:	2b00      	cmp	r3, #0
    e4a6:	d028      	beq.n	e4fa <etharp_query+0x222>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
      }
#else /* ARP_QUEUEING */
      /* always queue one packet per ARP request only, freeing a previously queued packet */
      if (arp_table[i].q != NULL) {
    e4a8:	2317      	movs	r3, #23
    e4aa:	18fb      	adds	r3, r7, r3
    e4ac:	2200      	movs	r2, #0
    e4ae:	569a      	ldrsb	r2, [r3, r2]
    e4b0:	491a      	ldr	r1, [pc, #104]	; (e51c <etharp_query+0x244>)
    e4b2:	0013      	movs	r3, r2
    e4b4:	009b      	lsls	r3, r3, #2
    e4b6:	189b      	adds	r3, r3, r2
    e4b8:	009b      	lsls	r3, r3, #2
    e4ba:	585b      	ldr	r3, [r3, r1]
    e4bc:	2b00      	cmp	r3, #0
    e4be:	d00c      	beq.n	e4da <etharp_query+0x202>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: dropped previously queued packet %p for ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        pbuf_free(arp_table[i].q);
    e4c0:	2317      	movs	r3, #23
    e4c2:	18fb      	adds	r3, r7, r3
    e4c4:	2200      	movs	r2, #0
    e4c6:	569a      	ldrsb	r2, [r3, r2]
    e4c8:	4914      	ldr	r1, [pc, #80]	; (e51c <etharp_query+0x244>)
    e4ca:	0013      	movs	r3, r2
    e4cc:	009b      	lsls	r3, r3, #2
    e4ce:	189b      	adds	r3, r3, r2
    e4d0:	009b      	lsls	r3, r3, #2
    e4d2:	585b      	ldr	r3, [r3, r1]
    e4d4:	0018      	movs	r0, r3
    e4d6:	4b17      	ldr	r3, [pc, #92]	; (e534 <etharp_query+0x25c>)
    e4d8:	4798      	blx	r3
      }
      arp_table[i].q = p;
    e4da:	2317      	movs	r3, #23
    e4dc:	18fb      	adds	r3, r7, r3
    e4de:	2200      	movs	r2, #0
    e4e0:	569a      	ldrsb	r2, [r3, r2]
    e4e2:	490e      	ldr	r1, [pc, #56]	; (e51c <etharp_query+0x244>)
    e4e4:	0013      	movs	r3, r2
    e4e6:	009b      	lsls	r3, r3, #2
    e4e8:	189b      	adds	r3, r3, r2
    e4ea:	009b      	lsls	r3, r3, #2
    e4ec:	6a3a      	ldr	r2, [r7, #32]
    e4ee:	505a      	str	r2, [r3, r1]
      result = ERR_OK;
    e4f0:	2327      	movs	r3, #39	; 0x27
    e4f2:	18fb      	adds	r3, r7, r3
    e4f4:	2200      	movs	r2, #0
    e4f6:	701a      	strb	r2, [r3, #0]
    e4f8:	e003      	b.n	e502 <etharp_query+0x22a>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    e4fa:	2327      	movs	r3, #39	; 0x27
    e4fc:	18fb      	adds	r3, r7, r3
    e4fe:	22ff      	movs	r2, #255	; 0xff
    e500:	701a      	strb	r2, [r3, #0]
    }
  }
  return result;
    e502:	2327      	movs	r3, #39	; 0x27
    e504:	18fb      	adds	r3, r7, r3
    e506:	781b      	ldrb	r3, [r3, #0]
    e508:	b25b      	sxtb	r3, r3
}
    e50a:	0018      	movs	r0, r3
    e50c:	46bd      	mov	sp, r7
    e50e:	b00a      	add	sp, #40	; 0x28
    e510:	bdb0      	pop	{r4, r5, r7, pc}
    e512:	46c0      	nop			; (mov r8, r8)
    e514:	0000626d 	.word	0x0000626d
    e518:	0000d9cd 	.word	0x0000d9cd
    e51c:	20002c9c 	.word	0x20002c9c
    e520:	0000e69d 	.word	0x0000e69d
    e524:	20002d64 	.word	0x20002d64
    e528:	0000dcb1 	.word	0x0000dcb1
    e52c:	00007e19 	.word	0x00007e19
    e530:	0000851d 	.word	0x0000851d
    e534:	00008349 	.word	0x00008349
    e538:	0000846d 	.word	0x0000846d

0000e53c <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
           const u16_t opcode)
{
    e53c:	b590      	push	{r4, r7, lr}
    e53e:	b089      	sub	sp, #36	; 0x24
    e540:	af00      	add	r7, sp, #0
    e542:	60f8      	str	r0, [r7, #12]
    e544:	60b9      	str	r1, [r7, #8]
    e546:	607a      	str	r2, [r7, #4]
    e548:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  err_t result = ERR_OK;
    e54a:	231f      	movs	r3, #31
    e54c:	18fb      	adds	r3, r7, r3
    e54e:	2200      	movs	r2, #0
    e550:	701a      	strb	r2, [r3, #0]
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
    e552:	2200      	movs	r2, #0
    e554:	212a      	movs	r1, #42	; 0x2a
    e556:	2003      	movs	r0, #3
    e558:	4b4c      	ldr	r3, [pc, #304]	; (e68c <etharp_raw+0x150>)
    e55a:	4798      	blx	r3
    e55c:	0003      	movs	r3, r0
    e55e:	61bb      	str	r3, [r7, #24]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    e560:	69bb      	ldr	r3, [r7, #24]
    e562:	2b00      	cmp	r3, #0
    e564:	d102      	bne.n	e56c <etharp_raw+0x30>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
    e566:	2301      	movs	r3, #1
    e568:	425b      	negs	r3, r3
    e56a:	e08b      	b.n	e684 <etharp_raw+0x148>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
    e56c:	69bb      	ldr	r3, [r7, #24]
    e56e:	685b      	ldr	r3, [r3, #4]
    e570:	617b      	str	r3, [r7, #20]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
    e572:	697b      	ldr	r3, [r7, #20]
    e574:	330e      	adds	r3, #14
    e576:	613b      	str	r3, [r7, #16]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
    e578:	233c      	movs	r3, #60	; 0x3c
    e57a:	18fb      	adds	r3, r7, r3
    e57c:	881b      	ldrh	r3, [r3, #0]
    e57e:	0018      	movs	r0, r3
    e580:	4b43      	ldr	r3, [pc, #268]	; (e690 <etharp_raw+0x154>)
    e582:	4798      	blx	r3
    e584:	0003      	movs	r3, r0
    e586:	001a      	movs	r2, r3
    e588:	693b      	ldr	r3, [r7, #16]
    e58a:	21ff      	movs	r1, #255	; 0xff
    e58c:	4011      	ands	r1, r2
    e58e:	000c      	movs	r4, r1
    e590:	7999      	ldrb	r1, [r3, #6]
    e592:	2000      	movs	r0, #0
    e594:	4001      	ands	r1, r0
    e596:	1c08      	adds	r0, r1, #0
    e598:	1c21      	adds	r1, r4, #0
    e59a:	4301      	orrs	r1, r0
    e59c:	7199      	strb	r1, [r3, #6]
    e59e:	0a12      	lsrs	r2, r2, #8
    e5a0:	b290      	uxth	r0, r2
    e5a2:	79da      	ldrb	r2, [r3, #7]
    e5a4:	2100      	movs	r1, #0
    e5a6:	400a      	ands	r2, r1
    e5a8:	1c11      	adds	r1, r2, #0
    e5aa:	1c02      	adds	r2, r0, #0
    e5ac:	430a      	orrs	r2, r1
    e5ae:	71da      	strb	r2, [r3, #7]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
    e5b0:	693b      	ldr	r3, [r7, #16]
    e5b2:	3308      	adds	r3, #8
    e5b4:	6839      	ldr	r1, [r7, #0]
    e5b6:	2206      	movs	r2, #6
    e5b8:	0018      	movs	r0, r3
    e5ba:	4b36      	ldr	r3, [pc, #216]	; (e694 <etharp_raw+0x158>)
    e5bc:	4798      	blx	r3
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
    e5be:	693b      	ldr	r3, [r7, #16]
    e5c0:	3312      	adds	r3, #18
    e5c2:	6b79      	ldr	r1, [r7, #52]	; 0x34
    e5c4:	2206      	movs	r2, #6
    e5c6:	0018      	movs	r0, r3
    e5c8:	4b32      	ldr	r3, [pc, #200]	; (e694 <etharp_raw+0x158>)
    e5ca:	4798      	blx	r3
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
    e5cc:	697b      	ldr	r3, [r7, #20]
    e5ce:	6879      	ldr	r1, [r7, #4]
    e5d0:	2206      	movs	r2, #6
    e5d2:	0018      	movs	r0, r3
    e5d4:	4b2f      	ldr	r3, [pc, #188]	; (e694 <etharp_raw+0x158>)
    e5d6:	4798      	blx	r3
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
    e5d8:	697b      	ldr	r3, [r7, #20]
    e5da:	3306      	adds	r3, #6
    e5dc:	68b9      	ldr	r1, [r7, #8]
    e5de:	2206      	movs	r2, #6
    e5e0:	0018      	movs	r0, r3
    e5e2:	4b2c      	ldr	r3, [pc, #176]	; (e694 <etharp_raw+0x158>)
    e5e4:	4798      	blx	r3
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
    e5e6:	693b      	ldr	r3, [r7, #16]
    e5e8:	330e      	adds	r3, #14
    e5ea:	6b39      	ldr	r1, [r7, #48]	; 0x30
    e5ec:	2204      	movs	r2, #4
    e5ee:	0018      	movs	r0, r3
    e5f0:	4b28      	ldr	r3, [pc, #160]	; (e694 <etharp_raw+0x158>)
    e5f2:	4798      	blx	r3
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
    e5f4:	693b      	ldr	r3, [r7, #16]
    e5f6:	3318      	adds	r3, #24
    e5f8:	6bb9      	ldr	r1, [r7, #56]	; 0x38
    e5fa:	2204      	movs	r2, #4
    e5fc:	0018      	movs	r0, r3
    e5fe:	4b25      	ldr	r3, [pc, #148]	; (e694 <etharp_raw+0x158>)
    e600:	4798      	blx	r3

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
    e602:	693b      	ldr	r3, [r7, #16]
    e604:	781a      	ldrb	r2, [r3, #0]
    e606:	2100      	movs	r1, #0
    e608:	400a      	ands	r2, r1
    e60a:	701a      	strb	r2, [r3, #0]
    e60c:	785a      	ldrb	r2, [r3, #1]
    e60e:	2100      	movs	r1, #0
    e610:	400a      	ands	r2, r1
    e612:	1c11      	adds	r1, r2, #0
    e614:	2201      	movs	r2, #1
    e616:	430a      	orrs	r2, r1
    e618:	705a      	strb	r2, [r3, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
    e61a:	693b      	ldr	r3, [r7, #16]
    e61c:	789a      	ldrb	r2, [r3, #2]
    e61e:	2100      	movs	r1, #0
    e620:	400a      	ands	r2, r1
    e622:	1c11      	adds	r1, r2, #0
    e624:	2208      	movs	r2, #8
    e626:	430a      	orrs	r2, r1
    e628:	709a      	strb	r2, [r3, #2]
    e62a:	78da      	ldrb	r2, [r3, #3]
    e62c:	2100      	movs	r1, #0
    e62e:	400a      	ands	r2, r1
    e630:	70da      	strb	r2, [r3, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
    e632:	693b      	ldr	r3, [r7, #16]
    e634:	2206      	movs	r2, #6
    e636:	711a      	strb	r2, [r3, #4]
  hdr->protolen = sizeof(ip_addr_t);
    e638:	693b      	ldr	r3, [r7, #16]
    e63a:	2204      	movs	r2, #4
    e63c:	715a      	strb	r2, [r3, #5]

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
    e63e:	697b      	ldr	r3, [r7, #20]
    e640:	7b1a      	ldrb	r2, [r3, #12]
    e642:	2100      	movs	r1, #0
    e644:	400a      	ands	r2, r1
    e646:	1c11      	adds	r1, r2, #0
    e648:	2208      	movs	r2, #8
    e64a:	430a      	orrs	r2, r1
    e64c:	731a      	strb	r2, [r3, #12]
    e64e:	7b5a      	ldrb	r2, [r3, #13]
    e650:	2100      	movs	r1, #0
    e652:	400a      	ands	r2, r1
    e654:	1c11      	adds	r1, r2, #0
    e656:	2206      	movs	r2, #6
    e658:	430a      	orrs	r2, r1
    e65a:	735a      	strb	r2, [r3, #13]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
    e65c:	68fb      	ldr	r3, [r7, #12]
    e65e:	699b      	ldr	r3, [r3, #24]
    e660:	221f      	movs	r2, #31
    e662:	18bc      	adds	r4, r7, r2
    e664:	69b9      	ldr	r1, [r7, #24]
    e666:	68fa      	ldr	r2, [r7, #12]
    e668:	0010      	movs	r0, r2
    e66a:	4798      	blx	r3
    e66c:	0003      	movs	r3, r0
    e66e:	7023      	strb	r3, [r4, #0]
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
    e670:	69bb      	ldr	r3, [r7, #24]
    e672:	0018      	movs	r0, r3
    e674:	4b08      	ldr	r3, [pc, #32]	; (e698 <etharp_raw+0x15c>)
    e676:	4798      	blx	r3
  p = NULL;
    e678:	2300      	movs	r3, #0
    e67a:	61bb      	str	r3, [r7, #24]
  /* could not allocate pbuf for ARP request */

  return result;
    e67c:	231f      	movs	r3, #31
    e67e:	18fb      	adds	r3, r7, r3
    e680:	781b      	ldrb	r3, [r3, #0]
    e682:	b25b      	sxtb	r3, r3
}
    e684:	0018      	movs	r0, r3
    e686:	46bd      	mov	sp, r7
    e688:	b009      	add	sp, #36	; 0x24
    e68a:	bd90      	pop	{r4, r7, pc}
    e68c:	00007e19 	.word	0x00007e19
    e690:	000055f1 	.word	0x000055f1
    e694:	0000fc43 	.word	0x0000fc43
    e698:	00008349 	.word	0x00008349

0000e69c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
    e69c:	b5b0      	push	{r4, r5, r7, lr}
    e69e:	b086      	sub	sp, #24
    e6a0:	af04      	add	r7, sp, #16
    e6a2:	6078      	str	r0, [r7, #4]
    e6a4:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
    e6a6:	687b      	ldr	r3, [r7, #4]
    e6a8:	3327      	adds	r3, #39	; 0x27
    e6aa:	0019      	movs	r1, r3
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
    e6ac:	687b      	ldr	r3, [r7, #4]
    e6ae:	3327      	adds	r3, #39	; 0x27
    e6b0:	001d      	movs	r5, r3
    e6b2:	687b      	ldr	r3, [r7, #4]
    e6b4:	3304      	adds	r3, #4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
    e6b6:	4c09      	ldr	r4, [pc, #36]	; (e6dc <etharp_request+0x40>)
    e6b8:	6878      	ldr	r0, [r7, #4]
    e6ba:	2201      	movs	r2, #1
    e6bc:	9203      	str	r2, [sp, #12]
    e6be:	683a      	ldr	r2, [r7, #0]
    e6c0:	9202      	str	r2, [sp, #8]
    e6c2:	4a07      	ldr	r2, [pc, #28]	; (e6e0 <etharp_request+0x44>)
    e6c4:	9201      	str	r2, [sp, #4]
    e6c6:	9300      	str	r3, [sp, #0]
    e6c8:	002b      	movs	r3, r5
    e6ca:	0022      	movs	r2, r4
    e6cc:	4c05      	ldr	r4, [pc, #20]	; (e6e4 <etharp_request+0x48>)
    e6ce:	47a0      	blx	r4
    e6d0:	0003      	movs	r3, r0
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
    e6d2:	0018      	movs	r0, r3
    e6d4:	46bd      	mov	sp, r7
    e6d6:	b002      	add	sp, #8
    e6d8:	bdb0      	pop	{r4, r5, r7, pc}
    e6da:	46c0      	nop			; (mov r8, r8)
    e6dc:	0000fde8 	.word	0x0000fde8
    e6e0:	0000fdf0 	.word	0x0000fdf0
    e6e4:	0000e53d 	.word	0x0000e53d

0000e6e8 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
    e6e8:	b580      	push	{r7, lr}
    e6ea:	b086      	sub	sp, #24
    e6ec:	af00      	add	r7, sp, #0
    e6ee:	6078      	str	r0, [r7, #4]
    e6f0:	6039      	str	r1, [r7, #0]
  struct eth_hdr* ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
    e6f2:	2316      	movs	r3, #22
    e6f4:	18fb      	adds	r3, r7, r3
    e6f6:	220e      	movs	r2, #14
    e6f8:	801a      	strh	r2, [r3, #0]
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
    e6fa:	687b      	ldr	r3, [r7, #4]
    e6fc:	895b      	ldrh	r3, [r3, #10]
    e6fe:	2b0e      	cmp	r3, #14
    e700:	d800      	bhi.n	e704 <ethernet_input+0x1c>
    e702:	e06a      	b.n	e7da <ethernet_input+0xf2>
	
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
    e704:	687b      	ldr	r3, [r7, #4]
    e706:	685b      	ldr	r3, [r3, #4]
    e708:	613b      	str	r3, [r7, #16]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
    e70a:	230e      	movs	r3, #14
    e70c:	18fa      	adds	r2, r7, r3
    e70e:	693b      	ldr	r3, [r7, #16]
    e710:	7b19      	ldrb	r1, [r3, #12]
    e712:	7b5b      	ldrb	r3, [r3, #13]
    e714:	021b      	lsls	r3, r3, #8
    e716:	430b      	orrs	r3, r1
    e718:	8013      	strh	r3, [r2, #0]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    e71a:	693b      	ldr	r3, [r7, #16]
    e71c:	781b      	ldrb	r3, [r3, #0]
    e71e:	001a      	movs	r2, r3
    e720:	2301      	movs	r3, #1
    e722:	4013      	ands	r3, r2
    e724:	d022      	beq.n	e76c <ethernet_input+0x84>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    e726:	693b      	ldr	r3, [r7, #16]
    e728:	781b      	ldrb	r3, [r3, #0]
    e72a:	2b01      	cmp	r3, #1
    e72c:	d10f      	bne.n	e74e <ethernet_input+0x66>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
    e72e:	693b      	ldr	r3, [r7, #16]
    e730:	785b      	ldrb	r3, [r3, #1]
    e732:	2b00      	cmp	r3, #0
    e734:	d11a      	bne.n	e76c <ethernet_input+0x84>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    e736:	693b      	ldr	r3, [r7, #16]
    e738:	789b      	ldrb	r3, [r3, #2]
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
    e73a:	2b5e      	cmp	r3, #94	; 0x5e
    e73c:	d116      	bne.n	e76c <ethernet_input+0x84>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
    e73e:	687b      	ldr	r3, [r7, #4]
    e740:	7b5b      	ldrb	r3, [r3, #13]
    e742:	2210      	movs	r2, #16
    e744:	4313      	orrs	r3, r2
    e746:	b2da      	uxtb	r2, r3
    e748:	687b      	ldr	r3, [r7, #4]
    e74a:	735a      	strb	r2, [r3, #13]
    e74c:	e00e      	b.n	e76c <ethernet_input+0x84>
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    e74e:	693b      	ldr	r3, [r7, #16]
    e750:	492a      	ldr	r1, [pc, #168]	; (e7fc <ethernet_input+0x114>)
    e752:	2206      	movs	r2, #6
    e754:	0018      	movs	r0, r3
    e756:	4b2a      	ldr	r3, [pc, #168]	; (e800 <ethernet_input+0x118>)
    e758:	4798      	blx	r3
    e75a:	1e03      	subs	r3, r0, #0
    e75c:	d106      	bne.n	e76c <ethernet_input+0x84>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
    e75e:	687b      	ldr	r3, [r7, #4]
    e760:	7b5b      	ldrb	r3, [r3, #13]
    e762:	2208      	movs	r2, #8
    e764:	4313      	orrs	r3, r2
    e766:	b2da      	uxtb	r2, r3
    e768:	687b      	ldr	r3, [r7, #4]
    e76a:	735a      	strb	r2, [r3, #13]
    }
  }

  switch (type) {
    e76c:	230e      	movs	r3, #14
    e76e:	18fb      	adds	r3, r7, r3
    e770:	881b      	ldrh	r3, [r3, #0]
    e772:	2b08      	cmp	r3, #8
    e774:	d004      	beq.n	e780 <ethernet_input+0x98>
    e776:	22c1      	movs	r2, #193	; 0xc1
    e778:	00d2      	lsls	r2, r2, #3
    e77a:	4293      	cmp	r3, r2
    e77c:	d01b      	beq.n	e7b6 <ethernet_input+0xce>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      goto free_and_return;
    e77e:	e033      	b.n	e7e8 <ethernet_input+0x100>

  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    e780:	683b      	ldr	r3, [r7, #0]
    e782:	222d      	movs	r2, #45	; 0x2d
    e784:	5c9b      	ldrb	r3, [r3, r2]
    e786:	001a      	movs	r2, r3
    e788:	2320      	movs	r3, #32
    e78a:	4013      	ands	r3, r2
    e78c:	d027      	beq.n	e7de <ethernet_input+0xf6>
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
    e78e:	2316      	movs	r3, #22
    e790:	18fb      	adds	r3, r7, r3
    e792:	881b      	ldrh	r3, [r3, #0]
    e794:	425b      	negs	r3, r3
    e796:	b29b      	uxth	r3, r3
    e798:	b21a      	sxth	r2, r3
    e79a:	687b      	ldr	r3, [r7, #4]
    e79c:	0011      	movs	r1, r2
    e79e:	0018      	movs	r0, r3
    e7a0:	4b18      	ldr	r3, [pc, #96]	; (e804 <ethernet_input+0x11c>)
    e7a2:	4798      	blx	r3
    e7a4:	1e03      	subs	r3, r0, #0
    e7a6:	d11c      	bne.n	e7e2 <ethernet_input+0xfa>
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
    e7a8:	683a      	ldr	r2, [r7, #0]
    e7aa:	687b      	ldr	r3, [r7, #4]
    e7ac:	0011      	movs	r1, r2
    e7ae:	0018      	movs	r0, r3
    e7b0:	4b15      	ldr	r3, [pc, #84]	; (e808 <ethernet_input+0x120>)
    e7b2:	4798      	blx	r3
      }
      break;
    e7b4:	e00f      	b.n	e7d6 <ethernet_input+0xee>
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    e7b6:	683b      	ldr	r3, [r7, #0]
    e7b8:	222d      	movs	r2, #45	; 0x2d
    e7ba:	5c9b      	ldrb	r3, [r3, r2]
    e7bc:	001a      	movs	r2, r3
    e7be:	2320      	movs	r3, #32
    e7c0:	4013      	ands	r3, r2
    e7c2:	d010      	beq.n	e7e6 <ethernet_input+0xfe>
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
    e7c4:	683b      	ldr	r3, [r7, #0]
    e7c6:	3327      	adds	r3, #39	; 0x27
    e7c8:	0019      	movs	r1, r3
    e7ca:	687a      	ldr	r2, [r7, #4]
    e7cc:	683b      	ldr	r3, [r7, #0]
    e7ce:	0018      	movs	r0, r3
    e7d0:	4b0e      	ldr	r3, [pc, #56]	; (e80c <ethernet_input+0x124>)
    e7d2:	4798      	blx	r3
      break;
    e7d4:	46c0      	nop			; (mov r8, r8)
      goto free_and_return;
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
    e7d6:	2300      	movs	r3, #0
    e7d8:	e00b      	b.n	e7f2 <ethernet_input+0x10a>
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
	
	
	
    goto free_and_return;
    e7da:	46c0      	nop			; (mov r8, r8)
    e7dc:	e004      	b.n	e7e8 <ethernet_input+0x100>
  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
    e7de:	46c0      	nop			; (mov r8, r8)
    e7e0:	e002      	b.n	e7e8 <ethernet_input+0x100>
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
    e7e2:	46c0      	nop			; (mov r8, r8)
    e7e4:	e000      	b.n	e7e8 <ethernet_input+0x100>
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
    e7e6:	46c0      	nop			; (mov r8, r8)
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
    e7e8:	687b      	ldr	r3, [r7, #4]
    e7ea:	0018      	movs	r0, r3
    e7ec:	4b08      	ldr	r3, [pc, #32]	; (e810 <ethernet_input+0x128>)
    e7ee:	4798      	blx	r3
  return ERR_OK;
    e7f0:	2300      	movs	r3, #0
}
    e7f2:	0018      	movs	r0, r3
    e7f4:	46bd      	mov	sp, r7
    e7f6:	b006      	add	sp, #24
    e7f8:	bd80      	pop	{r7, pc}
    e7fa:	46c0      	nop			; (mov r8, r8)
    e7fc:	0000fde8 	.word	0x0000fde8
    e800:	0000fc25 	.word	0x0000fc25
    e804:	00008235 	.word	0x00008235
    e808:	00005cf9 	.word	0x00005cf9
    e80c:	0000de71 	.word	0x0000de71
    e810:	00008349 	.word	0x00008349

0000e814 <NVIC_EnableIRQ>:
    The function enables a device-specific interrupt in the NVIC interrupt controller.

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
    e814:	b580      	push	{r7, lr}
    e816:	b082      	sub	sp, #8
    e818:	af00      	add	r7, sp, #0
    e81a:	0002      	movs	r2, r0
    e81c:	1dfb      	adds	r3, r7, #7
    e81e:	701a      	strb	r2, [r3, #0]
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
    e820:	4b06      	ldr	r3, [pc, #24]	; (e83c <NVIC_EnableIRQ+0x28>)
    e822:	1dfa      	adds	r2, r7, #7
    e824:	7812      	ldrb	r2, [r2, #0]
    e826:	0011      	movs	r1, r2
    e828:	221f      	movs	r2, #31
    e82a:	400a      	ands	r2, r1
    e82c:	2101      	movs	r1, #1
    e82e:	4091      	lsls	r1, r2
    e830:	000a      	movs	r2, r1
    e832:	601a      	str	r2, [r3, #0]
}
    e834:	46c0      	nop			; (mov r8, r8)
    e836:	46bd      	mov	sp, r7
    e838:	b002      	add	sp, #8
    e83a:	bd80      	pop	{r7, pc}
    e83c:	e000e100 	.word	0xe000e100

0000e840 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
    e840:	b5b0      	push	{r4, r5, r7, lr}
    e842:	b082      	sub	sp, #8
    e844:	af00      	add	r7, sp, #0
    e846:	0002      	movs	r2, r0
    e848:	6039      	str	r1, [r7, #0]
    e84a:	1dfb      	adds	r3, r7, #7
    e84c:	701a      	strb	r2, [r3, #0]
  if(IRQn < 0) {
    e84e:	1dfb      	adds	r3, r7, #7
    e850:	781b      	ldrb	r3, [r3, #0]
    e852:	2b7f      	cmp	r3, #127	; 0x7f
    e854:	d932      	bls.n	e8bc <NVIC_SetPriority+0x7c>
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
    e856:	4c2f      	ldr	r4, [pc, #188]	; (e914 <NVIC_SetPriority+0xd4>)
    e858:	1dfb      	adds	r3, r7, #7
    e85a:	781b      	ldrb	r3, [r3, #0]
    e85c:	001a      	movs	r2, r3
    e85e:	230f      	movs	r3, #15
    e860:	4013      	ands	r3, r2
    e862:	3b08      	subs	r3, #8
    e864:	0899      	lsrs	r1, r3, #2
    e866:	4a2b      	ldr	r2, [pc, #172]	; (e914 <NVIC_SetPriority+0xd4>)
    e868:	1dfb      	adds	r3, r7, #7
    e86a:	781b      	ldrb	r3, [r3, #0]
    e86c:	0018      	movs	r0, r3
    e86e:	230f      	movs	r3, #15
    e870:	4003      	ands	r3, r0
    e872:	3b08      	subs	r3, #8
    e874:	089b      	lsrs	r3, r3, #2
    e876:	3306      	adds	r3, #6
    e878:	009b      	lsls	r3, r3, #2
    e87a:	18d3      	adds	r3, r2, r3
    e87c:	3304      	adds	r3, #4
    e87e:	681b      	ldr	r3, [r3, #0]
    e880:	1dfa      	adds	r2, r7, #7
    e882:	7812      	ldrb	r2, [r2, #0]
    e884:	0010      	movs	r0, r2
    e886:	2203      	movs	r2, #3
    e888:	4002      	ands	r2, r0
    e88a:	00d2      	lsls	r2, r2, #3
    e88c:	20ff      	movs	r0, #255	; 0xff
    e88e:	4090      	lsls	r0, r2
    e890:	0002      	movs	r2, r0
    e892:	43d2      	mvns	r2, r2
    e894:	401a      	ands	r2, r3
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
    e896:	683b      	ldr	r3, [r7, #0]
    e898:	019b      	lsls	r3, r3, #6
    e89a:	20ff      	movs	r0, #255	; 0xff
    e89c:	4018      	ands	r0, r3
    e89e:	1dfb      	adds	r3, r7, #7
    e8a0:	781b      	ldrb	r3, [r3, #0]
    e8a2:	001d      	movs	r5, r3
    e8a4:	2303      	movs	r3, #3
    e8a6:	402b      	ands	r3, r5
    e8a8:	00db      	lsls	r3, r3, #3
    e8aa:	4098      	lsls	r0, r3
    e8ac:	0003      	movs	r3, r0
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
    e8ae:	431a      	orrs	r2, r3
    e8b0:	1d8b      	adds	r3, r1, #6
    e8b2:	009b      	lsls	r3, r3, #2
    e8b4:	18e3      	adds	r3, r4, r3
    e8b6:	3304      	adds	r3, #4
    e8b8:	601a      	str	r2, [r3, #0]
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
}
    e8ba:	e027      	b.n	e90c <NVIC_SetPriority+0xcc>
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
    e8bc:	4c16      	ldr	r4, [pc, #88]	; (e918 <NVIC_SetPriority+0xd8>)
    e8be:	1dfb      	adds	r3, r7, #7
    e8c0:	781b      	ldrb	r3, [r3, #0]
    e8c2:	b25b      	sxtb	r3, r3
    e8c4:	089b      	lsrs	r3, r3, #2
    e8c6:	4914      	ldr	r1, [pc, #80]	; (e918 <NVIC_SetPriority+0xd8>)
    e8c8:	1dfa      	adds	r2, r7, #7
    e8ca:	7812      	ldrb	r2, [r2, #0]
    e8cc:	b252      	sxtb	r2, r2
    e8ce:	0892      	lsrs	r2, r2, #2
    e8d0:	32c0      	adds	r2, #192	; 0xc0
    e8d2:	0092      	lsls	r2, r2, #2
    e8d4:	5852      	ldr	r2, [r2, r1]
    e8d6:	1df9      	adds	r1, r7, #7
    e8d8:	7809      	ldrb	r1, [r1, #0]
    e8da:	0008      	movs	r0, r1
    e8dc:	2103      	movs	r1, #3
    e8de:	4001      	ands	r1, r0
    e8e0:	00c9      	lsls	r1, r1, #3
    e8e2:	20ff      	movs	r0, #255	; 0xff
    e8e4:	4088      	lsls	r0, r1
    e8e6:	0001      	movs	r1, r0
    e8e8:	43c9      	mvns	r1, r1
    e8ea:	4011      	ands	r1, r2
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
    e8ec:	683a      	ldr	r2, [r7, #0]
    e8ee:	0192      	lsls	r2, r2, #6
    e8f0:	20ff      	movs	r0, #255	; 0xff
    e8f2:	4010      	ands	r0, r2
    e8f4:	1dfa      	adds	r2, r7, #7
    e8f6:	7812      	ldrb	r2, [r2, #0]
    e8f8:	0015      	movs	r5, r2
    e8fa:	2203      	movs	r2, #3
    e8fc:	402a      	ands	r2, r5
    e8fe:	00d2      	lsls	r2, r2, #3
    e900:	4090      	lsls	r0, r2
    e902:	0002      	movs	r2, r0
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
  else {
    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
    e904:	430a      	orrs	r2, r1
    e906:	33c0      	adds	r3, #192	; 0xc0
    e908:	009b      	lsls	r3, r3, #2
    e90a:	511a      	str	r2, [r3, r4]
        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
}
    e90c:	46c0      	nop			; (mov r8, r8)
    e90e:	46bd      	mov	sp, r7
    e910:	b002      	add	sp, #8
    e912:	bdb0      	pop	{r4, r5, r7, pc}
    e914:	e000ed00 	.word	0xe000ed00
    e918:	e000e100 	.word	0xe000e100

0000e91c <INTN_Handler>:

/**
 * \brief Handler for INTN falling edge interrupt.
 */
static void INTN_Handler()
{
    e91c:	b580      	push	{r7, lr}
    e91e:	af00      	add	r7, sp, #0
#if NO_SYS == 0
	portBASE_TYPE xKSZTaskWoken = pdFALSE;
#endif

	/* Enable INTN flag. */
	g_intn_flag = 1;
    e920:	4b02      	ldr	r3, [pc, #8]	; (e92c <INTN_Handler+0x10>)
    e922:	2201      	movs	r2, #1
    e924:	601a      	str	r2, [r3, #0]

#if NO_SYS == 0
	xSemaphoreGiveFromISR(gs_ksz8851snl_dev.sync_sem, &xKSZTaskWoken);
	portEND_SWITCHING_ISR(xKSZTaskWoken);
#endif
}
    e926:	46c0      	nop			; (mov r8, r8)
    e928:	46bd      	mov	sp, r7
    e92a:	bd80      	pop	{r7, pc}
    e92c:	20002da0 	.word	0x20002da0

0000e930 <ksz8851snl_rx_populate_queue>:
 * \brief Populate the RX descriptor ring buffers with pbufs.
 *
 * \param p_ksz8851snl_dev Pointer to driver data structure.
 */
static void ksz8851snl_rx_populate_queue(struct ksz8851snl_device *p_ksz8851snl_dev)
{
    e930:	b580      	push	{r7, lr}
    e932:	b084      	sub	sp, #16
    e934:	af00      	add	r7, sp, #0
    e936:	6078      	str	r0, [r7, #4]
	uint32_t ul_index = 0;
    e938:	2300      	movs	r3, #0
    e93a:	60fb      	str	r3, [r7, #12]
	struct pbuf *p = 0;
    e93c:	2300      	movs	r3, #0
    e93e:	60bb      	str	r3, [r7, #8]

	/* Set up the RX descriptors */
	for (ul_index = 0; ul_index < NETIF_RX_BUFFERS; ul_index++) {
    e940:	2300      	movs	r3, #0
    e942:	60fb      	str	r3, [r7, #12]
    e944:	e01d      	b.n	e982 <ksz8851snl_rx_populate_queue+0x52>
		if (p_ksz8851snl_dev->rx_pbuf[ul_index] == 0) {
    e946:	687b      	ldr	r3, [r7, #4]
    e948:	68fa      	ldr	r2, [r7, #12]
    e94a:	3204      	adds	r2, #4
    e94c:	0092      	lsls	r2, r2, #2
    e94e:	58d3      	ldr	r3, [r2, r3]
    e950:	2b00      	cmp	r3, #0
    e952:	d113      	bne.n	e97c <ksz8851snl_rx_populate_queue+0x4c>

			/* Allocate a new pbuf with the maximum size. */
			p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
    e954:	23be      	movs	r3, #190	; 0xbe
    e956:	00db      	lsls	r3, r3, #3
    e958:	2203      	movs	r2, #3
    e95a:	0019      	movs	r1, r3
    e95c:	2003      	movs	r0, #3
    e95e:	4b0c      	ldr	r3, [pc, #48]	; (e990 <ksz8851snl_rx_populate_queue+0x60>)
    e960:	4798      	blx	r3
    e962:	0003      	movs	r3, r0
    e964:	60bb      	str	r3, [r7, #8]

			/* Make sure lwIP is well configured so one pbuf can contain the maximum packet size. */
			LWIP_ASSERT("ksz8851snl_rx_populate_queue: pbuf size too small!", pbuf_clen(p) <= 1);

			/* Set owner as Micrel. */
			p_ksz8851snl_dev->rx_desc[ul_index] = 0;
    e966:	687b      	ldr	r3, [r7, #4]
    e968:	68fa      	ldr	r2, [r7, #12]
    e96a:	0092      	lsls	r2, r2, #2
    e96c:	2100      	movs	r1, #0
    e96e:	50d1      	str	r1, [r2, r3]

			/* Save pbuf pointer to be sent to lwIP upper layer. */
			p_ksz8851snl_dev->rx_pbuf[ul_index] = p;
    e970:	687b      	ldr	r3, [r7, #4]
    e972:	68fa      	ldr	r2, [r7, #12]
    e974:	3204      	adds	r2, #4
    e976:	0092      	lsls	r2, r2, #2
    e978:	68b9      	ldr	r1, [r7, #8]
    e97a:	50d1      	str	r1, [r2, r3]
{
	uint32_t ul_index = 0;
	struct pbuf *p = 0;

	/* Set up the RX descriptors */
	for (ul_index = 0; ul_index < NETIF_RX_BUFFERS; ul_index++) {
    e97c:	68fb      	ldr	r3, [r7, #12]
    e97e:	3301      	adds	r3, #1
    e980:	60fb      	str	r3, [r7, #12]
    e982:	68fb      	ldr	r3, [r7, #12]
    e984:	2b01      	cmp	r3, #1
    e986:	d9de      	bls.n	e946 <ksz8851snl_rx_populate_queue+0x16>
			LWIP_DEBUGF(NETIF_DEBUG,
					("ksz8851snl_rx_populate_queue: new pbuf allocated with size %d: 0x%p [pos=%u]\n",
					PBUF_POOL_BUFSIZE, p, ul_index));
		}
	}
}
    e988:	46c0      	nop			; (mov r8, r8)
    e98a:	46bd      	mov	sp, r7
    e98c:	b004      	add	sp, #16
    e98e:	bd80      	pop	{r7, pc}
    e990:	00007e19 	.word	0x00007e19

0000e994 <ksz8851snl_update>:
 * \brief Update Micrel state machine and perform required actions.
 *
 * \param netif the lwIP network interface structure for this ethernetif.
 */
static void ksz8851snl_update(struct netif *netif)
{
    e994:	b590      	push	{r4, r7, lr}
    e996:	b087      	sub	sp, #28
    e998:	af00      	add	r7, sp, #0
    e99a:	6078      	str	r0, [r7, #4]
	struct ksz8851snl_device *ps_ksz8851snl_dev = netif->state;
    e99c:	687b      	ldr	r3, [r7, #4]
    e99e:	6a1b      	ldr	r3, [r3, #32]
    e9a0:	613b      	str	r3, [r7, #16]
	struct pbuf *q = NULL;
    e9a2:	2300      	movs	r3, #0
    e9a4:	617b      	str	r3, [r7, #20]
	uint16_t status = 0;
    e9a6:	230e      	movs	r3, #14
    e9a8:	18fb      	adds	r3, r7, r3
    e9aa:	2200      	movs	r2, #0
    e9ac:	801a      	strh	r2, [r3, #0]
	uint16_t len = 0;
    e9ae:	230c      	movs	r3, #12
    e9b0:	18fb      	adds	r3, r7, r3
    e9b2:	2200      	movs	r2, #0
    e9b4:	801a      	strh	r2, [r3, #0]
	uint16_t txmir = 0;
    e9b6:	230a      	movs	r3, #10
    e9b8:	18fb      	adds	r3, r7, r3
    e9ba:	2200      	movs	r2, #0
    e9bc:	801a      	strh	r2, [r3, #0]

	/* Handle TX. */
	/* Fetch next packet marked as owned by Micrel. */
	if (ps_ksz8851snl_dev->tx_desc[ps_ksz8851snl_dev->us_tx_tail]
    e9be:	693b      	ldr	r3, [r7, #16]
    e9c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e9c2:	693b      	ldr	r3, [r7, #16]
    e9c4:	3202      	adds	r2, #2
    e9c6:	0092      	lsls	r2, r2, #2
    e9c8:	58d3      	ldr	r3, [r2, r3]
    e9ca:	2b00      	cmp	r3, #0
    e9cc:	d100      	bne.n	e9d0 <ksz8851snl_update+0x3c>
    e9ce:	e07b      	b.n	eac8 <ksz8851snl_update+0x134>
			&& (pending_frame == 0)) {
    e9d0:	4bb0      	ldr	r3, [pc, #704]	; (ec94 <ksz8851snl_update+0x300>)
    e9d2:	881b      	ldrh	r3, [r3, #0]
    e9d4:	2b00      	cmp	r3, #0
    e9d6:	d000      	beq.n	e9da <ksz8851snl_update+0x46>
    e9d8:	e076      	b.n	eac8 <ksz8851snl_update+0x134>
#if ETH_PAD_SIZE
		/* Drop the padding word */
		pbuf_header(ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail],
				-ETH_PAD_SIZE);
#endif
		len = ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail]->tot_len;
    e9da:	693b      	ldr	r3, [r7, #16]
    e9dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e9de:	693b      	ldr	r3, [r7, #16]
    e9e0:	3206      	adds	r2, #6
    e9e2:	0092      	lsls	r2, r2, #2
    e9e4:	58d2      	ldr	r2, [r2, r3]
    e9e6:	230c      	movs	r3, #12
    e9e8:	18fb      	adds	r3, r7, r3
    e9ea:	8912      	ldrh	r2, [r2, #8]
    e9ec:	801a      	strh	r2, [r3, #0]

		/* TX step1: check if TXQ memory size is available for transmit. */
		txmir = ksz8851_reg_read(REG_TX_MEM_INFO) & TX_MEM_AVAILABLE_MASK;
    e9ee:	2078      	movs	r0, #120	; 0x78
    e9f0:	4ba9      	ldr	r3, [pc, #676]	; (ec98 <ksz8851snl_update+0x304>)
    e9f2:	4798      	blx	r3
    e9f4:	0003      	movs	r3, r0
    e9f6:	001a      	movs	r2, r3
    e9f8:	230a      	movs	r3, #10
    e9fa:	18fb      	adds	r3, r7, r3
    e9fc:	04d2      	lsls	r2, r2, #19
    e9fe:	0cd2      	lsrs	r2, r2, #19
    ea00:	801a      	strh	r2, [r3, #0]
		if (txmir < len + 8) {
    ea02:	230a      	movs	r3, #10
    ea04:	18fb      	adds	r3, r7, r3
    ea06:	881a      	ldrh	r2, [r3, #0]
    ea08:	230c      	movs	r3, #12
    ea0a:	18fb      	adds	r3, r7, r3
    ea0c:	881b      	ldrh	r3, [r3, #0]
    ea0e:	3308      	adds	r3, #8
    ea10:	429a      	cmp	r2, r3
    ea12:	da00      	bge.n	ea16 <ksz8851snl_update+0x82>
    ea14:	e135      	b.n	ec82 <ksz8851snl_update+0x2ee>
#endif
			return;
		}

		/* TX step2: disable all interrupts. */
		ksz8851_reg_write(REG_INT_MASK, 0);
    ea16:	2100      	movs	r1, #0
    ea18:	2090      	movs	r0, #144	; 0x90
    ea1a:	4ba0      	ldr	r3, [pc, #640]	; (ec9c <ksz8851snl_update+0x308>)
    ea1c:	4798      	blx	r3
				("ksz8851snl_update: TX start packet transmit len=%d [tail=%u head=%u]\n",
				len,
				ps_ksz8851snl_dev->us_tx_tail, ps_ksz8851snl_dev->us_tx_head));

		/* TX step3: enable TXQ write access. */
		ksz8851_reg_setbits(REG_RXQ_CMD, RXQ_START);
    ea1e:	2108      	movs	r1, #8
    ea20:	2082      	movs	r0, #130	; 0x82
    ea22:	4b9f      	ldr	r3, [pc, #636]	; (eca0 <ksz8851snl_update+0x30c>)
    ea24:	4798      	blx	r3

		/* TX step4-8: perform FIFO write operation. */
		ksz8851_fifo_write_begin(len);
    ea26:	230c      	movs	r3, #12
    ea28:	18fb      	adds	r3, r7, r3
    ea2a:	881b      	ldrh	r3, [r3, #0]
    ea2c:	0018      	movs	r0, r3
    ea2e:	4b9d      	ldr	r3, [pc, #628]	; (eca4 <ksz8851snl_update+0x310>)
    ea30:	4798      	blx	r3
		for (q = ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail]; q != NULL; q = q->next) {
    ea32:	693b      	ldr	r3, [r7, #16]
    ea34:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    ea36:	693b      	ldr	r3, [r7, #16]
    ea38:	3206      	adds	r2, #6
    ea3a:	0092      	lsls	r2, r2, #2
    ea3c:	58d3      	ldr	r3, [r2, r3]
    ea3e:	617b      	str	r3, [r7, #20]
    ea40:	e00a      	b.n	ea58 <ksz8851snl_update+0xc4>
			ksz8851_fifo_write(q->payload, q->len);
    ea42:	697b      	ldr	r3, [r7, #20]
    ea44:	685a      	ldr	r2, [r3, #4]
    ea46:	697b      	ldr	r3, [r7, #20]
    ea48:	895b      	ldrh	r3, [r3, #10]
    ea4a:	0019      	movs	r1, r3
    ea4c:	0010      	movs	r0, r2
    ea4e:	4b96      	ldr	r3, [pc, #600]	; (eca8 <ksz8851snl_update+0x314>)
    ea50:	4798      	blx	r3
		/* TX step3: enable TXQ write access. */
		ksz8851_reg_setbits(REG_RXQ_CMD, RXQ_START);

		/* TX step4-8: perform FIFO write operation. */
		ksz8851_fifo_write_begin(len);
		for (q = ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail]; q != NULL; q = q->next) {
    ea52:	697b      	ldr	r3, [r7, #20]
    ea54:	681b      	ldr	r3, [r3, #0]
    ea56:	617b      	str	r3, [r7, #20]
    ea58:	697b      	ldr	r3, [r7, #20]
    ea5a:	2b00      	cmp	r3, #0
    ea5c:	d1f1      	bne.n	ea42 <ksz8851snl_update+0xae>
			ksz8851_fifo_write(q->payload, q->len);
		}
		/* TX step9-10: pad with dummy data to keep dword alignment. */
		ksz8851_fifo_write_end(len & 3);
    ea5e:	230c      	movs	r3, #12
    ea60:	18fb      	adds	r3, r7, r3
    ea62:	881b      	ldrh	r3, [r3, #0]
    ea64:	2203      	movs	r2, #3
    ea66:	4013      	ands	r3, r2
    ea68:	0018      	movs	r0, r3
    ea6a:	4b90      	ldr	r3, [pc, #576]	; (ecac <ksz8851snl_update+0x318>)
    ea6c:	4798      	blx	r3

		/* TX step12: disable TXQ write access. */
		ksz8851_reg_clrbits(REG_RXQ_CMD, RXQ_START);
    ea6e:	2108      	movs	r1, #8
    ea70:	2082      	movs	r0, #130	; 0x82
    ea72:	4b8f      	ldr	r3, [pc, #572]	; (ecb0 <ksz8851snl_update+0x31c>)
    ea74:	4798      	blx	r3

		/* TX step12.1: enqueue frame in TXQ. */
		ksz8851_reg_setbits(REG_TXQ_CMD, TXQ_ENQUEUE);
    ea76:	2101      	movs	r1, #1
    ea78:	2080      	movs	r0, #128	; 0x80
    ea7a:	4b89      	ldr	r3, [pc, #548]	; (eca0 <ksz8851snl_update+0x30c>)
    ea7c:	4798      	blx	r3

		/* RX step13: enable INT_RX flag. */
		ksz8851_reg_write(REG_INT_MASK, INT_RX);
    ea7e:	2380      	movs	r3, #128	; 0x80
    ea80:	019b      	lsls	r3, r3, #6
    ea82:	0019      	movs	r1, r3
    ea84:	2090      	movs	r0, #144	; 0x90
    ea86:	4b85      	ldr	r3, [pc, #532]	; (ec9c <ksz8851snl_update+0x308>)
    ea88:	4798      	blx	r3
			/* Reclaim the padding word */
			pbuf_header(ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail], ETH_PAD_SIZE);
#endif

		/* Buffer sent, free the corresponding buffer and mark descriptor as owned by software. */
		pbuf_free(ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail]);
    ea8a:	693b      	ldr	r3, [r7, #16]
    ea8c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    ea8e:	693b      	ldr	r3, [r7, #16]
    ea90:	3206      	adds	r2, #6
    ea92:	0092      	lsls	r2, r2, #2
    ea94:	58d3      	ldr	r3, [r2, r3]
    ea96:	0018      	movs	r0, r3
    ea98:	4b86      	ldr	r3, [pc, #536]	; (ecb4 <ksz8851snl_update+0x320>)
    ea9a:	4798      	blx	r3
		ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail] = NULL;
    ea9c:	693b      	ldr	r3, [r7, #16]
    ea9e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    eaa0:	693b      	ldr	r3, [r7, #16]
    eaa2:	3206      	adds	r2, #6
    eaa4:	0092      	lsls	r2, r2, #2
    eaa6:	2100      	movs	r1, #0
    eaa8:	50d1      	str	r1, [r2, r3]
		ps_ksz8851snl_dev->tx_desc[ps_ksz8851snl_dev->us_tx_tail] = 0;
    eaaa:	693b      	ldr	r3, [r7, #16]
    eaac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    eaae:	693b      	ldr	r3, [r7, #16]
    eab0:	3202      	adds	r2, #2
    eab2:	0092      	lsls	r2, r2, #2
    eab4:	2100      	movs	r1, #0
    eab6:	50d1      	str	r1, [r2, r3]
		ps_ksz8851snl_dev->us_tx_tail = (ps_ksz8851snl_dev->us_tx_tail + 1) % NETIF_TX_BUFFERS;
    eab8:	693b      	ldr	r3, [r7, #16]
    eaba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    eabc:	3301      	adds	r3, #1
    eabe:	2201      	movs	r2, #1
    eac0:	401a      	ands	r2, r3
    eac2:	693b      	ldr	r3, [r7, #16]
    eac4:	62da      	str	r2, [r3, #44]	; 0x2c
    eac6:	e0e1      	b.n	ec8c <ksz8851snl_update+0x2f8>
	}

	/* Handle RX. */
	else if (g_intn_flag || pending_frame > 0) {
    eac8:	4b7b      	ldr	r3, [pc, #492]	; (ecb8 <ksz8851snl_update+0x324>)
    eaca:	681b      	ldr	r3, [r3, #0]
    eacc:	2b00      	cmp	r3, #0
    eace:	d104      	bne.n	eada <ksz8851snl_update+0x146>
    ead0:	4b70      	ldr	r3, [pc, #448]	; (ec94 <ksz8851snl_update+0x300>)
    ead2:	881b      	ldrh	r3, [r3, #0]
    ead4:	2b00      	cmp	r3, #0
    ead6:	d100      	bne.n	eada <ksz8851snl_update+0x146>
    ead8:	e0d8      	b.n	ec8c <ksz8851snl_update+0x2f8>
		g_intn_flag = 0;
    eada:	4b77      	ldr	r3, [pc, #476]	; (ecb8 <ksz8851snl_update+0x324>)
    eadc:	2200      	movs	r2, #0
    eade:	601a      	str	r2, [r3, #0]


		if (0 == pending_frame) {
    eae0:	4b6c      	ldr	r3, [pc, #432]	; (ec94 <ksz8851snl_update+0x300>)
    eae2:	881b      	ldrh	r3, [r3, #0]
    eae4:	2b00      	cmp	r3, #0
    eae6:	d12b      	bne.n	eb40 <ksz8851snl_update+0x1ac>
			/* RX step1: read interrupt status for INT_RX flag. */
			status = ksz8851_reg_read(REG_INT_STATUS);
    eae8:	230e      	movs	r3, #14
    eaea:	18fc      	adds	r4, r7, r3
    eaec:	2092      	movs	r0, #146	; 0x92
    eaee:	4b6a      	ldr	r3, [pc, #424]	; (ec98 <ksz8851snl_update+0x304>)
    eaf0:	4798      	blx	r3
    eaf2:	0003      	movs	r3, r0
    eaf4:	8023      	strh	r3, [r4, #0]
			if (!(status & INT_RX)) {
    eaf6:	230e      	movs	r3, #14
    eaf8:	18fb      	adds	r3, r7, r3
    eafa:	881a      	ldrh	r2, [r3, #0]
    eafc:	2380      	movs	r3, #128	; 0x80
    eafe:	019b      	lsls	r3, r3, #6
    eb00:	4013      	ands	r3, r2
    eb02:	d100      	bne.n	eb06 <ksz8851snl_update+0x172>
    eb04:	e0bf      	b.n	ec86 <ksz8851snl_update+0x2f2>
				return;
			}

			/* RX step2: disable all interrupts. */
			ksz8851_reg_write(REG_INT_MASK, 0);
    eb06:	2100      	movs	r1, #0
    eb08:	2090      	movs	r0, #144	; 0x90
    eb0a:	4b64      	ldr	r3, [pc, #400]	; (ec9c <ksz8851snl_update+0x308>)
    eb0c:	4798      	blx	r3

			/* RX step3: clear INT_RX flag. */
			ksz8851_reg_setbits(REG_INT_STATUS, INT_RX);
    eb0e:	2380      	movs	r3, #128	; 0x80
    eb10:	019b      	lsls	r3, r3, #6
    eb12:	0019      	movs	r1, r3
    eb14:	2092      	movs	r0, #146	; 0x92
    eb16:	4b62      	ldr	r3, [pc, #392]	; (eca0 <ksz8851snl_update+0x30c>)
    eb18:	4798      	blx	r3

			/* RX step4-5: check for received frames. */
			pending_frame = ksz8851_reg_read(REG_RX_FRAME_CNT_THRES) >> 8;
    eb1a:	209c      	movs	r0, #156	; 0x9c
    eb1c:	4b5e      	ldr	r3, [pc, #376]	; (ec98 <ksz8851snl_update+0x304>)
    eb1e:	4798      	blx	r3
    eb20:	0003      	movs	r3, r0
    eb22:	0a1b      	lsrs	r3, r3, #8
    eb24:	b29a      	uxth	r2, r3
    eb26:	4b5b      	ldr	r3, [pc, #364]	; (ec94 <ksz8851snl_update+0x300>)
    eb28:	801a      	strh	r2, [r3, #0]
			if (0 == pending_frame) {
    eb2a:	4b5a      	ldr	r3, [pc, #360]	; (ec94 <ksz8851snl_update+0x300>)
    eb2c:	881b      	ldrh	r3, [r3, #0]
    eb2e:	2b00      	cmp	r3, #0
    eb30:	d106      	bne.n	eb40 <ksz8851snl_update+0x1ac>
				/* RX step24: enable INT_RX flag. */
				ksz8851_reg_write(REG_INT_MASK, INT_RX);
    eb32:	2380      	movs	r3, #128	; 0x80
    eb34:	019b      	lsls	r3, r3, #6
    eb36:	0019      	movs	r1, r3
    eb38:	2090      	movs	r0, #144	; 0x90
    eb3a:	4b58      	ldr	r3, [pc, #352]	; (ec9c <ksz8851snl_update+0x308>)
    eb3c:	4798      	blx	r3
				return;
    eb3e:	e0a5      	b.n	ec8c <ksz8851snl_update+0x2f8>
			}
		}

		/* Don't break Micrel state machine, wait for a free descriptor first! */
		if (ps_ksz8851snl_dev->rx_desc[ps_ksz8851snl_dev->us_rx_head]) {
    eb40:	693b      	ldr	r3, [r7, #16]
    eb42:	6a1a      	ldr	r2, [r3, #32]
    eb44:	693b      	ldr	r3, [r7, #16]
    eb46:	0092      	lsls	r2, r2, #2
    eb48:	58d3      	ldr	r3, [r2, r3]
    eb4a:	2b00      	cmp	r3, #0
    eb4c:	d000      	beq.n	eb50 <ksz8851snl_update+0x1bc>
    eb4e:	e09c      	b.n	ec8a <ksz8851snl_update+0x2f6>
			LWIP_DEBUGF(NETIF_DEBUG,
					("ksz8851snl_update: out of free descriptor! [tail=%u head=%u]\n",
					ps_ksz8851snl_dev->us_rx_tail, ps_ksz8851snl_dev->us_rx_head));
			return;
		}
		if (0 == ps_ksz8851snl_dev->rx_pbuf[ps_ksz8851snl_dev->us_rx_head]) {
    eb50:	693b      	ldr	r3, [r7, #16]
    eb52:	6a1a      	ldr	r2, [r3, #32]
    eb54:	693b      	ldr	r3, [r7, #16]
    eb56:	3204      	adds	r2, #4
    eb58:	0092      	lsls	r2, r2, #2
    eb5a:	58d3      	ldr	r3, [r2, r3]
    eb5c:	2b00      	cmp	r3, #0
    eb5e:	d104      	bne.n	eb6a <ksz8851snl_update+0x1d6>
			ksz8851snl_rx_populate_queue(ps_ksz8851snl_dev);
    eb60:	693b      	ldr	r3, [r7, #16]
    eb62:	0018      	movs	r0, r3
    eb64:	4b55      	ldr	r3, [pc, #340]	; (ecbc <ksz8851snl_update+0x328>)
    eb66:	4798      	blx	r3
			LWIP_DEBUGF(NETIF_DEBUG,
					("ksz8851snl_update: descriptor with NULL pbuf! [head=%u]\n",
					ps_ksz8851snl_dev->us_rx_head));
			return;
    eb68:	e090      	b.n	ec8c <ksz8851snl_update+0x2f8>
		}

		/* RX step6: get RX packet status. */
		status = ksz8851_reg_read(REG_RX_FHR_STATUS);
    eb6a:	230e      	movs	r3, #14
    eb6c:	18fc      	adds	r4, r7, r3
    eb6e:	207c      	movs	r0, #124	; 0x7c
    eb70:	4b49      	ldr	r3, [pc, #292]	; (ec98 <ksz8851snl_update+0x304>)
    eb72:	4798      	blx	r3
    eb74:	0003      	movs	r3, r0
    eb76:	8023      	strh	r3, [r4, #0]
		if (((status & RX_VALID) == 0) || (status & RX_ERRORS)) {
    eb78:	230e      	movs	r3, #14
    eb7a:	18fb      	adds	r3, r7, r3
    eb7c:	2200      	movs	r2, #0
    eb7e:	5e9b      	ldrsh	r3, [r3, r2]
    eb80:	2b00      	cmp	r3, #0
    eb82:	da05      	bge.n	eb90 <ksz8851snl_update+0x1fc>
    eb84:	230e      	movs	r3, #14
    eb86:	18fb      	adds	r3, r7, r3
    eb88:	881b      	ldrh	r3, [r3, #0]
    eb8a:	4a4d      	ldr	r2, [pc, #308]	; (ecc0 <ksz8851snl_update+0x32c>)
    eb8c:	4013      	ands	r3, r2
    eb8e:	d00a      	beq.n	eba6 <ksz8851snl_update+0x212>
			ksz8851_reg_setbits(REG_RXQ_CMD, RXQ_CMD_FREE_PACKET);
    eb90:	2101      	movs	r1, #1
    eb92:	2082      	movs	r0, #130	; 0x82
    eb94:	4b42      	ldr	r3, [pc, #264]	; (eca0 <ksz8851snl_update+0x30c>)
    eb96:	4798      	blx	r3
			pending_frame -= 1;
    eb98:	4b3e      	ldr	r3, [pc, #248]	; (ec94 <ksz8851snl_update+0x300>)
    eb9a:	881b      	ldrh	r3, [r3, #0]
    eb9c:	3b01      	subs	r3, #1
    eb9e:	b29a      	uxth	r2, r3
    eba0:	4b3c      	ldr	r3, [pc, #240]	; (ec94 <ksz8851snl_update+0x300>)
    eba2:	801a      	strh	r2, [r3, #0]
    eba4:	e072      	b.n	ec8c <ksz8851snl_update+0x2f8>
			LWIP_DEBUGF(NETIF_DEBUG, ("ksz8851snl_update: RX packet error!\n"));
		}
		else {
			/* RX step7: read frame length. */
			len = ksz8851_reg_read(REG_RX_FHR_BYTE_CNT) & RX_BYTE_CNT_MASK;
    eba6:	207e      	movs	r0, #126	; 0x7e
    eba8:	4b3b      	ldr	r3, [pc, #236]	; (ec98 <ksz8851snl_update+0x304>)
    ebaa:	4798      	blx	r3
    ebac:	0003      	movs	r3, r0
    ebae:	001a      	movs	r2, r3
    ebb0:	230c      	movs	r3, #12
    ebb2:	18fb      	adds	r3, r7, r3
    ebb4:	0512      	lsls	r2, r2, #20
    ebb6:	0d12      	lsrs	r2, r2, #20
    ebb8:	801a      	strh	r2, [r3, #0]

			/* RX step8: Drop packet if len is invalid or no descriptor available. */
			if (0 == len) {
    ebba:	230c      	movs	r3, #12
    ebbc:	18fb      	adds	r3, r7, r3
    ebbe:	881b      	ldrh	r3, [r3, #0]
    ebc0:	2b00      	cmp	r3, #0
    ebc2:	d10a      	bne.n	ebda <ksz8851snl_update+0x246>
				ksz8851_reg_setbits(REG_RXQ_CMD, RXQ_CMD_FREE_PACKET);
    ebc4:	2101      	movs	r1, #1
    ebc6:	2082      	movs	r0, #130	; 0x82
    ebc8:	4b35      	ldr	r3, [pc, #212]	; (eca0 <ksz8851snl_update+0x30c>)
    ebca:	4798      	blx	r3
				pending_frame -= 1;
    ebcc:	4b31      	ldr	r3, [pc, #196]	; (ec94 <ksz8851snl_update+0x300>)
    ebce:	881b      	ldrh	r3, [r3, #0]
    ebd0:	3b01      	subs	r3, #1
    ebd2:	b29a      	uxth	r2, r3
    ebd4:	4b2f      	ldr	r3, [pc, #188]	; (ec94 <ksz8851snl_update+0x300>)
    ebd6:	801a      	strh	r2, [r3, #0]
    ebd8:	e058      	b.n	ec8c <ksz8851snl_update+0x2f8>
						("ksz8851snl_update: RX start packet receive len=%d [tail=%u head=%u]\n",
						len,
						ps_ksz8851snl_dev->us_rx_tail, ps_ksz8851snl_dev->us_rx_head));

				/* RX step9: reset RX frame pointer. */
				ksz8851_reg_clrbits(REG_RX_ADDR_PTR, ADDR_PTR_MASK);
    ebda:	4b3a      	ldr	r3, [pc, #232]	; (ecc4 <ksz8851snl_update+0x330>)
    ebdc:	0019      	movs	r1, r3
    ebde:	2086      	movs	r0, #134	; 0x86
    ebe0:	4b33      	ldr	r3, [pc, #204]	; (ecb0 <ksz8851snl_update+0x31c>)
    ebe2:	4798      	blx	r3

				/* RX step10: start RXQ read access. */
				ksz8851_reg_setbits(REG_RXQ_CMD, RXQ_START);
    ebe4:	2108      	movs	r1, #8
    ebe6:	2082      	movs	r0, #130	; 0x82
    ebe8:	4b2d      	ldr	r3, [pc, #180]	; (eca0 <ksz8851snl_update+0x30c>)
    ebea:	4798      	blx	r3

				/* Remove CRC and update pbuf length. */
				len -= 4;
    ebec:	230c      	movs	r3, #12
    ebee:	18fb      	adds	r3, r7, r3
    ebf0:	220c      	movs	r2, #12
    ebf2:	18ba      	adds	r2, r7, r2
    ebf4:	8812      	ldrh	r2, [r2, #0]
    ebf6:	3a04      	subs	r2, #4
    ebf8:	801a      	strh	r2, [r3, #0]
				ps_ksz8851snl_dev->rx_pbuf[ps_ksz8851snl_dev->us_rx_head]->len = len;
    ebfa:	693b      	ldr	r3, [r7, #16]
    ebfc:	6a1a      	ldr	r2, [r3, #32]
    ebfe:	693b      	ldr	r3, [r7, #16]
    ec00:	3204      	adds	r2, #4
    ec02:	0092      	lsls	r2, r2, #2
    ec04:	58d3      	ldr	r3, [r2, r3]
    ec06:	220c      	movs	r2, #12
    ec08:	18ba      	adds	r2, r7, r2
    ec0a:	8812      	ldrh	r2, [r2, #0]
    ec0c:	815a      	strh	r2, [r3, #10]
				ps_ksz8851snl_dev->rx_pbuf[ps_ksz8851snl_dev->us_rx_head]->tot_len = len;
    ec0e:	693b      	ldr	r3, [r7, #16]
    ec10:	6a1a      	ldr	r2, [r3, #32]
    ec12:	693b      	ldr	r3, [r7, #16]
    ec14:	3204      	adds	r2, #4
    ec16:	0092      	lsls	r2, r2, #2
    ec18:	58d3      	ldr	r3, [r2, r3]
    ec1a:	220c      	movs	r2, #12
    ec1c:	18ba      	adds	r2, r7, r2
    ec1e:	8812      	ldrh	r2, [r2, #0]
    ec20:	811a      	strh	r2, [r3, #8]

				/* RX step11-17: start FIFO read operation. */
				ksz8851_fifo_read(ps_ksz8851snl_dev->rx_pbuf[ps_ksz8851snl_dev->us_rx_head]->payload, len);
    ec22:	693b      	ldr	r3, [r7, #16]
    ec24:	6a1a      	ldr	r2, [r3, #32]
    ec26:	693b      	ldr	r3, [r7, #16]
    ec28:	3204      	adds	r2, #4
    ec2a:	0092      	lsls	r2, r2, #2
    ec2c:	58d3      	ldr	r3, [r2, r3]
    ec2e:	685a      	ldr	r2, [r3, #4]
    ec30:	230c      	movs	r3, #12
    ec32:	18fb      	adds	r3, r7, r3
    ec34:	881b      	ldrh	r3, [r3, #0]
    ec36:	0019      	movs	r1, r3
    ec38:	0010      	movs	r0, r2
    ec3a:	4b23      	ldr	r3, [pc, #140]	; (ecc8 <ksz8851snl_update+0x334>)
    ec3c:	4798      	blx	r3

				/* RX step21: end RXQ read access. */
				ksz8851_reg_clrbits(REG_RXQ_CMD, RXQ_START);
    ec3e:	2108      	movs	r1, #8
    ec40:	2082      	movs	r0, #130	; 0x82
    ec42:	4b1b      	ldr	r3, [pc, #108]	; (ecb0 <ksz8851snl_update+0x31c>)
    ec44:	4798      	blx	r3

				/* RX step22-23: update frame count to be read. */
				pending_frame -= 1;
    ec46:	4b13      	ldr	r3, [pc, #76]	; (ec94 <ksz8851snl_update+0x300>)
    ec48:	881b      	ldrh	r3, [r3, #0]
    ec4a:	3b01      	subs	r3, #1
    ec4c:	b29a      	uxth	r2, r3
    ec4e:	4b11      	ldr	r3, [pc, #68]	; (ec94 <ksz8851snl_update+0x300>)
    ec50:	801a      	strh	r2, [r3, #0]

				/* RX step24: enable INT_RX flag if transfer complete. */
				if (0 == pending_frame) {
    ec52:	4b10      	ldr	r3, [pc, #64]	; (ec94 <ksz8851snl_update+0x300>)
    ec54:	881b      	ldrh	r3, [r3, #0]
    ec56:	2b00      	cmp	r3, #0
    ec58:	d105      	bne.n	ec66 <ksz8851snl_update+0x2d2>
					ksz8851_reg_write(REG_INT_MASK, INT_RX);
    ec5a:	2380      	movs	r3, #128	; 0x80
    ec5c:	019b      	lsls	r3, r3, #6
    ec5e:	0019      	movs	r1, r3
    ec60:	2090      	movs	r0, #144	; 0x90
    ec62:	4b0e      	ldr	r3, [pc, #56]	; (ec9c <ksz8851snl_update+0x308>)
    ec64:	4798      	blx	r3
				}

				/* Mark descriptor ready to be read. */
				ps_ksz8851snl_dev->rx_desc[ps_ksz8851snl_dev->us_rx_head] = 1;
    ec66:	693b      	ldr	r3, [r7, #16]
    ec68:	6a1a      	ldr	r2, [r3, #32]
    ec6a:	693b      	ldr	r3, [r7, #16]
    ec6c:	0092      	lsls	r2, r2, #2
    ec6e:	2101      	movs	r1, #1
    ec70:	50d1      	str	r1, [r2, r3]
				ps_ksz8851snl_dev->us_rx_head = (ps_ksz8851snl_dev->us_rx_head + 1) % NETIF_RX_BUFFERS;
    ec72:	693b      	ldr	r3, [r7, #16]
    ec74:	6a1b      	ldr	r3, [r3, #32]
    ec76:	3301      	adds	r3, #1
    ec78:	2201      	movs	r2, #1
    ec7a:	401a      	ands	r2, r3
    ec7c:	693b      	ldr	r3, [r7, #16]
    ec7e:	621a      	str	r2, [r3, #32]
    ec80:	e004      	b.n	ec8c <ksz8851snl_update+0x2f8>
					txmir, len + 8));
#if ETH_PAD_SIZE
			/* Reclaim the padding word */
			pbuf_header(ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_tail], ETH_PAD_SIZE);
#endif
			return;
    ec82:	46c0      	nop			; (mov r8, r8)
    ec84:	e002      	b.n	ec8c <ksz8851snl_update+0x2f8>

		if (0 == pending_frame) {
			/* RX step1: read interrupt status for INT_RX flag. */
			status = ksz8851_reg_read(REG_INT_STATUS);
			if (!(status & INT_RX)) {
				return;
    ec86:	46c0      	nop			; (mov r8, r8)
    ec88:	e000      	b.n	ec8c <ksz8851snl_update+0x2f8>
		/* Don't break Micrel state machine, wait for a free descriptor first! */
		if (ps_ksz8851snl_dev->rx_desc[ps_ksz8851snl_dev->us_rx_head]) {
			LWIP_DEBUGF(NETIF_DEBUG,
					("ksz8851snl_update: out of free descriptor! [tail=%u head=%u]\n",
					ps_ksz8851snl_dev->us_rx_tail, ps_ksz8851snl_dev->us_rx_head));
			return;
    ec8a:	46c0      	nop			; (mov r8, r8)
				ps_ksz8851snl_dev->rx_desc[ps_ksz8851snl_dev->us_rx_head] = 1;
				ps_ksz8851snl_dev->us_rx_head = (ps_ksz8851snl_dev->us_rx_head + 1) % NETIF_RX_BUFFERS;
			}
		}
	}
}
    ec8c:	46bd      	mov	sp, r7
    ec8e:	b007      	add	sp, #28
    ec90:	bd90      	pop	{r4, r7, pc}
    ec92:	46c0      	nop			; (mov r8, r8)
    ec94:	20002d9c 	.word	0x20002d9c
    ec98:	000020d1 	.word	0x000020d1
    ec9c:	000021d1 	.word	0x000021d1
    eca0:	000022bd 	.word	0x000022bd
    eca4:	00001fe5 	.word	0x00001fe5
    eca8:	00002061 	.word	0x00002061
    ecac:	00002089 	.word	0x00002089
    ecb0:	00002315 	.word	0x00002315
    ecb4:	00008349 	.word	0x00008349
    ecb8:	20002da0 	.word	0x20002da0
    ecbc:	0000e931 	.word	0x0000e931
    ecc0:	00003c17 	.word	0x00003c17
    ecc4:	000003ff 	.word	0x000003ff
    ecc8:	00001f4d 	.word	0x00001f4d

0000eccc <ksz8851snl_rx_init>:
 * This function sets up the descriptor list used for RX packets.
 *
 * \param ps_ksz8851snl_dev Pointer to driver data structure.
 */
static void ksz8851snl_rx_init(struct ksz8851snl_device *ps_ksz8851snl_dev)
{
    eccc:	b580      	push	{r7, lr}
    ecce:	b084      	sub	sp, #16
    ecd0:	af00      	add	r7, sp, #0
    ecd2:	6078      	str	r0, [r7, #4]
	uint32_t ul_index = 0;
    ecd4:	2300      	movs	r3, #0
    ecd6:	60fb      	str	r3, [r7, #12]

	/* Init pointer index. */
	ps_ksz8851snl_dev->us_rx_head = 0;
    ecd8:	687b      	ldr	r3, [r7, #4]
    ecda:	2200      	movs	r2, #0
    ecdc:	621a      	str	r2, [r3, #32]
	ps_ksz8851snl_dev->us_rx_tail = 0;
    ecde:	687b      	ldr	r3, [r7, #4]
    ece0:	2200      	movs	r2, #0
    ece2:	625a      	str	r2, [r3, #36]	; 0x24

	/* Set up the RX descriptors. */
	for (ul_index = 0; ul_index < NETIF_RX_BUFFERS; ul_index++) {
    ece4:	2300      	movs	r3, #0
    ece6:	60fb      	str	r3, [r7, #12]
    ece8:	e00d      	b.n	ed06 <ksz8851snl_rx_init+0x3a>
		ps_ksz8851snl_dev->rx_pbuf[ul_index] = 0;
    ecea:	687b      	ldr	r3, [r7, #4]
    ecec:	68fa      	ldr	r2, [r7, #12]
    ecee:	3204      	adds	r2, #4
    ecf0:	0092      	lsls	r2, r2, #2
    ecf2:	2100      	movs	r1, #0
    ecf4:	50d1      	str	r1, [r2, r3]
		ps_ksz8851snl_dev->rx_desc[ul_index] = 0;
    ecf6:	687b      	ldr	r3, [r7, #4]
    ecf8:	68fa      	ldr	r2, [r7, #12]
    ecfa:	0092      	lsls	r2, r2, #2
    ecfc:	2100      	movs	r1, #0
    ecfe:	50d1      	str	r1, [r2, r3]
	/* Init pointer index. */
	ps_ksz8851snl_dev->us_rx_head = 0;
	ps_ksz8851snl_dev->us_rx_tail = 0;

	/* Set up the RX descriptors. */
	for (ul_index = 0; ul_index < NETIF_RX_BUFFERS; ul_index++) {
    ed00:	68fb      	ldr	r3, [r7, #12]
    ed02:	3301      	adds	r3, #1
    ed04:	60fb      	str	r3, [r7, #12]
    ed06:	68fb      	ldr	r3, [r7, #12]
    ed08:	2b01      	cmp	r3, #1
    ed0a:	d9ee      	bls.n	ecea <ksz8851snl_rx_init+0x1e>
		ps_ksz8851snl_dev->rx_pbuf[ul_index] = 0;
		ps_ksz8851snl_dev->rx_desc[ul_index] = 0;
	}

	/* Build RX buffer and descriptors. */
	ksz8851snl_rx_populate_queue(ps_ksz8851snl_dev);
    ed0c:	687b      	ldr	r3, [r7, #4]
    ed0e:	0018      	movs	r0, r3
    ed10:	4b02      	ldr	r3, [pc, #8]	; (ed1c <ksz8851snl_rx_init+0x50>)
    ed12:	4798      	blx	r3
}
    ed14:	46c0      	nop			; (mov r8, r8)
    ed16:	46bd      	mov	sp, r7
    ed18:	b004      	add	sp, #16
    ed1a:	bd80      	pop	{r7, pc}
    ed1c:	0000e931 	.word	0x0000e931

0000ed20 <ksz8851snl_tx_init>:
 * This function sets up the descriptor list used for TX packets.
 *
 * \param ps_ksz8851snl_dev Pointer to driver data structure.
 */
static void ksz8851snl_tx_init(struct ksz8851snl_device *ps_ksz8851snl_dev)
{
    ed20:	b580      	push	{r7, lr}
    ed22:	b084      	sub	sp, #16
    ed24:	af00      	add	r7, sp, #0
    ed26:	6078      	str	r0, [r7, #4]
	uint32_t ul_index = 0;
    ed28:	2300      	movs	r3, #0
    ed2a:	60fb      	str	r3, [r7, #12]

	/* Init TX index pointer. */
	ps_ksz8851snl_dev->us_tx_head = 0;
    ed2c:	687b      	ldr	r3, [r7, #4]
    ed2e:	2200      	movs	r2, #0
    ed30:	629a      	str	r2, [r3, #40]	; 0x28
	ps_ksz8851snl_dev->us_tx_tail = 0;
    ed32:	687b      	ldr	r3, [r7, #4]
    ed34:	2200      	movs	r2, #0
    ed36:	62da      	str	r2, [r3, #44]	; 0x2c

	/* Set up the TX descriptors */
	for (ul_index = 0; ul_index < NETIF_TX_BUFFERS; ul_index++) {
    ed38:	2300      	movs	r3, #0
    ed3a:	60fb      	str	r3, [r7, #12]
    ed3c:	e008      	b.n	ed50 <ksz8851snl_tx_init+0x30>
		ps_ksz8851snl_dev->tx_desc[ul_index] = 0;
    ed3e:	687b      	ldr	r3, [r7, #4]
    ed40:	68fa      	ldr	r2, [r7, #12]
    ed42:	3202      	adds	r2, #2
    ed44:	0092      	lsls	r2, r2, #2
    ed46:	2100      	movs	r1, #0
    ed48:	50d1      	str	r1, [r2, r3]
	/* Init TX index pointer. */
	ps_ksz8851snl_dev->us_tx_head = 0;
	ps_ksz8851snl_dev->us_tx_tail = 0;

	/* Set up the TX descriptors */
	for (ul_index = 0; ul_index < NETIF_TX_BUFFERS; ul_index++) {
    ed4a:	68fb      	ldr	r3, [r7, #12]
    ed4c:	3301      	adds	r3, #1
    ed4e:	60fb      	str	r3, [r7, #12]
    ed50:	68fb      	ldr	r3, [r7, #12]
    ed52:	2b01      	cmp	r3, #1
    ed54:	d9f3      	bls.n	ed3e <ksz8851snl_tx_init+0x1e>
		ps_ksz8851snl_dev->tx_desc[ul_index] = 0;
	}
}
    ed56:	46c0      	nop			; (mov r8, r8)
    ed58:	46bd      	mov	sp, r7
    ed5a:	b004      	add	sp, #16
    ed5c:	bd80      	pop	{r7, pc}
    ed5e:	46c0      	nop			; (mov r8, r8)

0000ed60 <ksz8851snl_low_level_init>:
 * \note Called from ethernetif_init().
 *
 * \param netif the lwIP network interface structure for this ethernetif.
 */
static void ksz8851snl_low_level_init(struct netif *netif)
{
    ed60:	b580      	push	{r7, lr}
    ed62:	b082      	sub	sp, #8
    ed64:	af00      	add	r7, sp, #0
    ed66:	6078      	str	r0, [r7, #4]
	/* Set MAC hardware address length. */
	netif->hwaddr_len = sizeof(gs_uc_mac_address);
    ed68:	687b      	ldr	r3, [r7, #4]
    ed6a:	2226      	movs	r2, #38	; 0x26
    ed6c:	2106      	movs	r1, #6
    ed6e:	5499      	strb	r1, [r3, r2]
	/* Set MAC hardware address. */
	netif->hwaddr[0] = gs_uc_mac_address[0];
    ed70:	4b21      	ldr	r3, [pc, #132]	; (edf8 <ksz8851snl_low_level_init+0x98>)
    ed72:	7819      	ldrb	r1, [r3, #0]
    ed74:	687b      	ldr	r3, [r7, #4]
    ed76:	2227      	movs	r2, #39	; 0x27
    ed78:	5499      	strb	r1, [r3, r2]
	netif->hwaddr[1] = gs_uc_mac_address[1];
    ed7a:	4b1f      	ldr	r3, [pc, #124]	; (edf8 <ksz8851snl_low_level_init+0x98>)
    ed7c:	7859      	ldrb	r1, [r3, #1]
    ed7e:	687b      	ldr	r3, [r7, #4]
    ed80:	2228      	movs	r2, #40	; 0x28
    ed82:	5499      	strb	r1, [r3, r2]
	netif->hwaddr[2] = gs_uc_mac_address[2];
    ed84:	4b1c      	ldr	r3, [pc, #112]	; (edf8 <ksz8851snl_low_level_init+0x98>)
    ed86:	7899      	ldrb	r1, [r3, #2]
    ed88:	687b      	ldr	r3, [r7, #4]
    ed8a:	2229      	movs	r2, #41	; 0x29
    ed8c:	5499      	strb	r1, [r3, r2]
	netif->hwaddr[3] = gs_uc_mac_address[3];
    ed8e:	4b1a      	ldr	r3, [pc, #104]	; (edf8 <ksz8851snl_low_level_init+0x98>)
    ed90:	78d9      	ldrb	r1, [r3, #3]
    ed92:	687b      	ldr	r3, [r7, #4]
    ed94:	222a      	movs	r2, #42	; 0x2a
    ed96:	5499      	strb	r1, [r3, r2]
	netif->hwaddr[4] = gs_uc_mac_address[4];
    ed98:	4b17      	ldr	r3, [pc, #92]	; (edf8 <ksz8851snl_low_level_init+0x98>)
    ed9a:	7919      	ldrb	r1, [r3, #4]
    ed9c:	687b      	ldr	r3, [r7, #4]
    ed9e:	222b      	movs	r2, #43	; 0x2b
    eda0:	5499      	strb	r1, [r3, r2]
	netif->hwaddr[5] = gs_uc_mac_address[5];
    eda2:	4b15      	ldr	r3, [pc, #84]	; (edf8 <ksz8851snl_low_level_init+0x98>)
    eda4:	7959      	ldrb	r1, [r3, #5]
    eda6:	687b      	ldr	r3, [r7, #4]
    eda8:	222c      	movs	r2, #44	; 0x2c
    edaa:	5499      	strb	r1, [r3, r2]

	/* Set maximum transfer unit. */
	netif->mtu = NET_MTU;
    edac:	687b      	ldr	r3, [r7, #4]
    edae:	4a13      	ldr	r2, [pc, #76]	; (edfc <ksz8851snl_low_level_init+0x9c>)
    edb0:	849a      	strh	r2, [r3, #36]	; 0x24

	/* Device capabilities. */
	netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP
    edb2:	687b      	ldr	r3, [r7, #4]
    edb4:	222d      	movs	r2, #45	; 0x2d
    edb6:	5c9b      	ldrb	r3, [r3, r2]
    edb8:	2222      	movs	r2, #34	; 0x22
    edba:	4313      	orrs	r3, r2
    edbc:	b2d9      	uxtb	r1, r3
    edbe:	687b      	ldr	r3, [r7, #4]
    edc0:	222d      	movs	r2, #45	; 0x2d
    edc2:	5499      	strb	r1, [r3, r2]
#if defined(DHCP_USED)
			| NETIF_FLAG_DHCP
#endif
	;

	ksz8851snl_rx_init(&gs_ksz8851snl_dev);
    edc4:	4b0e      	ldr	r3, [pc, #56]	; (ee00 <ksz8851snl_low_level_init+0xa0>)
    edc6:	0018      	movs	r0, r3
    edc8:	4b0e      	ldr	r3, [pc, #56]	; (ee04 <ksz8851snl_low_level_init+0xa4>)
    edca:	4798      	blx	r3
	ksz8851snl_tx_init(&gs_ksz8851snl_dev);
    edcc:	4b0c      	ldr	r3, [pc, #48]	; (ee00 <ksz8851snl_low_level_init+0xa0>)
    edce:	0018      	movs	r0, r3
    edd0:	4b0d      	ldr	r3, [pc, #52]	; (ee08 <ksz8851snl_low_level_init+0xa8>)
    edd2:	4798      	blx	r3

	/* Enable NVIC interrupts. */
	NVIC_SetPriority(KSZ8851SNL_SPI_IRQn, INT_PRIORITY_SPI);
    edd4:	210c      	movs	r1, #12
    edd6:	2007      	movs	r0, #7
    edd8:	4b0c      	ldr	r3, [pc, #48]	; (ee0c <ksz8851snl_low_level_init+0xac>)
    edda:	4798      	blx	r3
	NVIC_EnableIRQ(KSZ8851SNL_SPI_IRQn);
    eddc:	2007      	movs	r0, #7
    edde:	4b0c      	ldr	r3, [pc, #48]	; (ee10 <ksz8851snl_low_level_init+0xb0>)
    ede0:	4798      	blx	r3

	/* Initialize SPI link. */
	if (0 != ksz8851snl_init()) {
    ede2:	4b0c      	ldr	r3, [pc, #48]	; (ee14 <ksz8851snl_low_level_init+0xb4>)
    ede4:	4798      	blx	r3
				("ksz8851snl_low_level_init: failed to initialize the Micrel driver!\n"));
		LWIP_ASSERT("SPI communication issue", 1);
	}

	/* Initialize interrupt line INTN. */
	configure_intn(INTN_Handler);
    ede6:	4b0c      	ldr	r3, [pc, #48]	; (ee18 <ksz8851snl_low_level_init+0xb8>)
    ede8:	0018      	movs	r0, r3
    edea:	4b0c      	ldr	r3, [pc, #48]	; (ee1c <ksz8851snl_low_level_init+0xbc>)
    edec:	4798      	blx	r3
}
    edee:	46c0      	nop			; (mov r8, r8)
    edf0:	46bd      	mov	sp, r7
    edf2:	b002      	add	sp, #8
    edf4:	bd80      	pop	{r7, pc}
    edf6:	46c0      	nop			; (mov r8, r8)
    edf8:	20000014 	.word	0x20000014
    edfc:	000005dc 	.word	0x000005dc
    ee00:	20002d68 	.word	0x20002d68
    ee04:	0000eccd 	.word	0x0000eccd
    ee08:	0000ed21 	.word	0x0000ed21
    ee0c:	0000e841 	.word	0x0000e841
    ee10:	0000e815 	.word	0x0000e815
    ee14:	00002371 	.word	0x00002371
    ee18:	0000e91d 	.word	0x0000e91d
    ee1c:	00001ed9 	.word	0x00001ed9

0000ee20 <ksz8851snl_low_level_output>:
 *
 * \return ERR_OK if the packet could be sent.
 * an err_t value if the packet couldn't be sent.
 */
static err_t ksz8851snl_low_level_output(struct netif *netif, struct pbuf *p)
{
    ee20:	b580      	push	{r7, lr}
    ee22:	b084      	sub	sp, #16
    ee24:	af00      	add	r7, sp, #0
    ee26:	6078      	str	r0, [r7, #4]
    ee28:	6039      	str	r1, [r7, #0]
	struct ksz8851snl_device *ps_ksz8851snl_dev = netif->state;
    ee2a:	687b      	ldr	r3, [r7, #4]
    ee2c:	6a1b      	ldr	r3, [r3, #32]
    ee2e:	60fb      	str	r3, [r7, #12]

	/* Make sure the next descriptor is free. */
	if (ps_ksz8851snl_dev->tx_desc[ps_ksz8851snl_dev->us_tx_head]) {
    ee30:	68fb      	ldr	r3, [r7, #12]
    ee32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    ee34:	68fb      	ldr	r3, [r7, #12]
    ee36:	3202      	adds	r2, #2
    ee38:	0092      	lsls	r2, r2, #2
    ee3a:	58d3      	ldr	r3, [r2, r3]
    ee3c:	2b00      	cmp	r3, #0
    ee3e:	d002      	beq.n	ee46 <ksz8851snl_low_level_output+0x26>
#if NO_SYS
		LWIP_DEBUGF(NETIF_DEBUG,
				("ksz8851snl_low_level_output: out of free descriptor! [tail=%u head=%u]\n",
				ps_ksz8851snl_dev->us_tx_tail, ps_ksz8851snl_dev->us_tx_head));
#endif
		return ERR_IF;
    ee40:	230f      	movs	r3, #15
    ee42:	425b      	negs	r3, r3
    ee44:	e019      	b.n	ee7a <ksz8851snl_low_level_output+0x5a>
	}

	/* Ensure lwIP won't free this pbuf before the Micrel actually sends it. */
	pbuf_ref(p);
    ee46:	683b      	ldr	r3, [r7, #0]
    ee48:	0018      	movs	r0, r3
    ee4a:	4b0e      	ldr	r3, [pc, #56]	; (ee84 <ksz8851snl_low_level_output+0x64>)
    ee4c:	4798      	blx	r3

	/* Mark descriptor has owned by Micrel. Enqueue pbuf packet. */
	ps_ksz8851snl_dev->tx_desc[ps_ksz8851snl_dev->us_tx_head] = 1;
    ee4e:	68fb      	ldr	r3, [r7, #12]
    ee50:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    ee52:	68fb      	ldr	r3, [r7, #12]
    ee54:	3202      	adds	r2, #2
    ee56:	0092      	lsls	r2, r2, #2
    ee58:	2101      	movs	r1, #1
    ee5a:	50d1      	str	r1, [r2, r3]
	ps_ksz8851snl_dev->tx_pbuf[ps_ksz8851snl_dev->us_tx_head] = p;
    ee5c:	68fb      	ldr	r3, [r7, #12]
    ee5e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    ee60:	68fb      	ldr	r3, [r7, #12]
    ee62:	3206      	adds	r2, #6
    ee64:	0092      	lsls	r2, r2, #2
    ee66:	6839      	ldr	r1, [r7, #0]
    ee68:	50d1      	str	r1, [r2, r3]
	LWIP_DEBUGF(NETIF_DEBUG,
			("ksz8851snl_low_level_output: DMA buffer 0x%p sent, size=%u [tail=%u head=%u]\n",
			p->payload, p->tot_len, ps_ksz8851snl_dev->us_tx_tail, ps_ksz8851snl_dev->us_tx_head));
#endif

	ps_ksz8851snl_dev->us_tx_head = (ps_ksz8851snl_dev->us_tx_head + 1) % NETIF_TX_BUFFERS;
    ee6a:	68fb      	ldr	r3, [r7, #12]
    ee6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    ee6e:	3301      	adds	r3, #1
    ee70:	2201      	movs	r2, #1
    ee72:	401a      	ands	r2, r3
    ee74:	68fb      	ldr	r3, [r7, #12]
    ee76:	629a      	str	r2, [r3, #40]	; 0x28
#if NO_SYS == 0
	/* Release KSZ task to perform packet transfer. */
	xSemaphoreGive(ps_ksz8851snl_dev->sync_sem);
#endif

	return ERR_OK;
    ee78:	2300      	movs	r3, #0
}
    ee7a:	0018      	movs	r0, r3
    ee7c:	46bd      	mov	sp, r7
    ee7e:	b004      	add	sp, #16
    ee80:	bd80      	pop	{r7, pc}
    ee82:	46c0      	nop			; (mov r8, r8)
    ee84:	0000846d 	.word	0x0000846d

0000ee88 <ksz8851snl_low_level_input>:
 *
 * \return a pbuf filled with the received packet (including MAC header).
 * 0 on memory error.
 */
static struct pbuf *ksz8851snl_low_level_input(struct netif *netif)
{
    ee88:	b580      	push	{r7, lr}
    ee8a:	b084      	sub	sp, #16
    ee8c:	af00      	add	r7, sp, #0
    ee8e:	6078      	str	r0, [r7, #4]
	struct ksz8851snl_device *ps_ksz8851snl_dev = netif->state;
    ee90:	687b      	ldr	r3, [r7, #4]
    ee92:	6a1b      	ldr	r3, [r3, #32]
    ee94:	60bb      	str	r3, [r7, #8]
	struct pbuf *p = 0;
    ee96:	2300      	movs	r3, #0
    ee98:	60fb      	str	r3, [r7, #12]

	/* Check that descriptor is owned by software (ie packet received). */
	if (ps_ksz8851snl_dev->rx_desc[ps_ksz8851snl_dev->us_rx_tail]) {
    ee9a:	68bb      	ldr	r3, [r7, #8]
    ee9c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    ee9e:	68bb      	ldr	r3, [r7, #8]
    eea0:	0092      	lsls	r2, r2, #2
    eea2:	58d3      	ldr	r3, [r2, r3]
    eea4:	2b00      	cmp	r3, #0
    eea6:	d018      	beq.n	eeda <ksz8851snl_low_level_input+0x52>

		/* Fetch pre-allocated pbuf. */
		p = ps_ksz8851snl_dev->rx_pbuf[ps_ksz8851snl_dev->us_rx_tail];
    eea8:	68bb      	ldr	r3, [r7, #8]
    eeaa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    eeac:	68bb      	ldr	r3, [r7, #8]
    eeae:	3204      	adds	r2, #4
    eeb0:	0092      	lsls	r2, r2, #2
    eeb2:	58d3      	ldr	r3, [r2, r3]
    eeb4:	60fb      	str	r3, [r7, #12]

		/* Remove this pbuf from its descriptor. */
		ps_ksz8851snl_dev->rx_pbuf[ps_ksz8851snl_dev->us_rx_tail] = 0;
    eeb6:	68bb      	ldr	r3, [r7, #8]
    eeb8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    eeba:	68bb      	ldr	r3, [r7, #8]
    eebc:	3204      	adds	r2, #4
    eebe:	0092      	lsls	r2, r2, #2
    eec0:	2100      	movs	r1, #0
    eec2:	50d1      	str	r1, [r2, r3]

		/* Set pbuf total packet size. */
		LINK_STATS_INC(link.recv);

		/* Fill empty descriptors with new pbufs. */
		ksz8851snl_rx_populate_queue(ps_ksz8851snl_dev);
    eec4:	68bb      	ldr	r3, [r7, #8]
    eec6:	0018      	movs	r0, r3
    eec8:	4b06      	ldr	r3, [pc, #24]	; (eee4 <ksz8851snl_low_level_input+0x5c>)
    eeca:	4798      	blx	r3

		ps_ksz8851snl_dev->us_rx_tail = (ps_ksz8851snl_dev->us_rx_tail + 1) % NETIF_RX_BUFFERS;
    eecc:	68bb      	ldr	r3, [r7, #8]
    eece:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    eed0:	3301      	adds	r3, #1
    eed2:	2201      	movs	r2, #1
    eed4:	401a      	ands	r2, r3
    eed6:	68bb      	ldr	r3, [r7, #8]
    eed8:	625a      	str	r2, [r3, #36]	; 0x24
#if LWIP_STATS
		lwip_rx_count += p->tot_len;
#endif
	}

	return p;
    eeda:	68fb      	ldr	r3, [r7, #12]
}
    eedc:	0018      	movs	r0, r3
    eede:	46bd      	mov	sp, r7
    eee0:	b004      	add	sp, #16
    eee2:	bd80      	pop	{r7, pc}
    eee4:	0000e931 	.word	0x0000e931

0000eee8 <ethernetif_input>:
 * input function is called.
 *
 * \param netif the lwIP network interface structure for this ethernetif.
 */
void ethernetif_input(struct netif *netif)
{
    eee8:	b580      	push	{r7, lr}
    eeea:	b084      	sub	sp, #16
    eeec:	af00      	add	r7, sp, #0
    eeee:	6078      	str	r0, [r7, #4]
	struct eth_hdr *ethhdr;
	struct pbuf *p;

	/* Update driver state machine. */
	ksz8851snl_update(netif);
    eef0:	687b      	ldr	r3, [r7, #4]
    eef2:	0018      	movs	r0, r3
    eef4:	4b1b      	ldr	r3, [pc, #108]	; (ef64 <ethernetif_input+0x7c>)
    eef6:	4798      	blx	r3

	/* Move received packet into a new pbuf. */
	p = ksz8851snl_low_level_input(netif);
    eef8:	687b      	ldr	r3, [r7, #4]
    eefa:	0018      	movs	r0, r3
    eefc:	4b1a      	ldr	r3, [pc, #104]	; (ef68 <ethernetif_input+0x80>)
    eefe:	4798      	blx	r3
    ef00:	0003      	movs	r3, r0
    ef02:	60fb      	str	r3, [r7, #12]
	if (p == NULL)
    ef04:	68fb      	ldr	r3, [r7, #12]
    ef06:	2b00      	cmp	r3, #0
    ef08:	d026      	beq.n	ef58 <ethernetif_input+0x70>
		return;

	/* Points to packet payload, which starts with an Ethernet header. */
	ethhdr = p->payload;
    ef0a:	68fb      	ldr	r3, [r7, #12]
    ef0c:	685b      	ldr	r3, [r3, #4]
    ef0e:	60bb      	str	r3, [r7, #8]

	switch (htons(ethhdr->type)) {
    ef10:	68bb      	ldr	r3, [r7, #8]
    ef12:	7b1a      	ldrb	r2, [r3, #12]
    ef14:	7b5b      	ldrb	r3, [r3, #13]
    ef16:	021b      	lsls	r3, r3, #8
    ef18:	4313      	orrs	r3, r2
    ef1a:	b29b      	uxth	r3, r3
    ef1c:	0018      	movs	r0, r3
    ef1e:	4b13      	ldr	r3, [pc, #76]	; (ef6c <ethernetif_input+0x84>)
    ef20:	4798      	blx	r3
    ef22:	0003      	movs	r3, r0
    ef24:	2280      	movs	r2, #128	; 0x80
    ef26:	0112      	lsls	r2, r2, #4
    ef28:	4293      	cmp	r3, r2
    ef2a:	d002      	beq.n	ef32 <ethernetif_input+0x4a>
    ef2c:	4a10      	ldr	r2, [pc, #64]	; (ef70 <ethernetif_input+0x88>)
    ef2e:	4293      	cmp	r3, r2
    ef30:	d10c      	bne.n	ef4c <ethernetif_input+0x64>
#if PPPOE_SUPPORT
		case ETHTYPE_PPPOEDISC:
		case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
			/* Send packet to lwIP for processing. */
			if (netif->input(p, netif) != ERR_OK) {
    ef32:	687b      	ldr	r3, [r7, #4]
    ef34:	691b      	ldr	r3, [r3, #16]
    ef36:	6879      	ldr	r1, [r7, #4]
    ef38:	68fa      	ldr	r2, [r7, #12]
    ef3a:	0010      	movs	r0, r2
    ef3c:	4798      	blx	r3
    ef3e:	1e03      	subs	r3, r0, #0
    ef40:	d00c      	beq.n	ef5c <ethernetif_input+0x74>
				LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
				/* Free buffer. */
				pbuf_free(p);
    ef42:	68fb      	ldr	r3, [r7, #12]
    ef44:	0018      	movs	r0, r3
    ef46:	4b0b      	ldr	r3, [pc, #44]	; (ef74 <ethernetif_input+0x8c>)
    ef48:	4798      	blx	r3
			}
			break;
    ef4a:	e007      	b.n	ef5c <ethernetif_input+0x74>

		default:
			/* Free buffer. */
			pbuf_free(p);
    ef4c:	68fb      	ldr	r3, [r7, #12]
    ef4e:	0018      	movs	r0, r3
    ef50:	4b08      	ldr	r3, [pc, #32]	; (ef74 <ethernetif_input+0x8c>)
    ef52:	4798      	blx	r3
			break;
    ef54:	46c0      	nop			; (mov r8, r8)
    ef56:	e002      	b.n	ef5e <ethernetif_input+0x76>
	ksz8851snl_update(netif);

	/* Move received packet into a new pbuf. */
	p = ksz8851snl_low_level_input(netif);
	if (p == NULL)
		return;
    ef58:	46c0      	nop			; (mov r8, r8)
    ef5a:	e000      	b.n	ef5e <ethernetif_input+0x76>
			if (netif->input(p, netif) != ERR_OK) {
				LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
				/* Free buffer. */
				pbuf_free(p);
			}
			break;
    ef5c:	46c0      	nop			; (mov r8, r8)
		default:
			/* Free buffer. */
			pbuf_free(p);
			break;
	}
}
    ef5e:	46bd      	mov	sp, r7
    ef60:	b004      	add	sp, #16
    ef62:	bd80      	pop	{r7, pc}
    ef64:	0000e995 	.word	0x0000e995
    ef68:	0000ee89 	.word	0x0000ee89
    ef6c:	000055f1 	.word	0x000055f1
    ef70:	00000806 	.word	0x00000806
    ef74:	00008349 	.word	0x00008349

0000ef78 <ethernetif_init>:
 * \return ERR_OK if the loopif is initialized.
 * ERR_MEM if private data couldn't be allocated.
 * any other err_t on error.
 */
err_t ethernetif_init(struct netif *netif)
{
    ef78:	b580      	push	{r7, lr}
    ef7a:	b082      	sub	sp, #8
    ef7c:	af00      	add	r7, sp, #0
    ef7e:	6078      	str	r0, [r7, #4]
	LWIP_ASSERT("netif != NULL", (netif != NULL));

	gs_ksz8851snl_dev.netif = netif;
    ef80:	4b0e      	ldr	r3, [pc, #56]	; (efbc <ethernetif_init+0x44>)
    ef82:	687a      	ldr	r2, [r7, #4]
    ef84:	631a      	str	r2, [r3, #48]	; 0x30
	 */
#if LWIP_SNMP
	NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, NET_LINK_SPEED);
#endif /* LWIP_SNMP */

	netif->state = &gs_ksz8851snl_dev;
    ef86:	687b      	ldr	r3, [r7, #4]
    ef88:	4a0c      	ldr	r2, [pc, #48]	; (efbc <ethernetif_init+0x44>)
    ef8a:	621a      	str	r2, [r3, #32]
	netif->name[0] = IFNAME0;
    ef8c:	687b      	ldr	r3, [r7, #4]
    ef8e:	222e      	movs	r2, #46	; 0x2e
    ef90:	2165      	movs	r1, #101	; 0x65
    ef92:	5499      	strb	r1, [r3, r2]
	netif->name[1] = IFNAME1;
    ef94:	687b      	ldr	r3, [r7, #4]
    ef96:	222f      	movs	r2, #47	; 0x2f
    ef98:	216e      	movs	r1, #110	; 0x6e
    ef9a:	5499      	strb	r1, [r3, r2]

	/* We directly use etharp_output() here to save a function call.
	 * You can instead declare your own function an call etharp_output()
	 * from it if you have to do some checks before sending (e.g. if link
	 * is available...) */
	netif->output = etharp_output;
    ef9c:	687b      	ldr	r3, [r7, #4]
    ef9e:	4a08      	ldr	r2, [pc, #32]	; (efc0 <ethernetif_init+0x48>)
    efa0:	615a      	str	r2, [r3, #20]
	netif->linkoutput = ksz8851snl_low_level_output;
    efa2:	687b      	ldr	r3, [r7, #4]
    efa4:	4a07      	ldr	r2, [pc, #28]	; (efc4 <ethernetif_init+0x4c>)
    efa6:	619a      	str	r2, [r3, #24]
	/* Initialize the hardware. */
	ksz8851snl_low_level_init(netif);
    efa8:	687b      	ldr	r3, [r7, #4]
    efaa:	0018      	movs	r0, r3
    efac:	4b06      	ldr	r3, [pc, #24]	; (efc8 <ethernetif_init+0x50>)
    efae:	4798      	blx	r3
			(id != 0));
	if (id == 0)
		return ERR_MEM;
#endif

	return ERR_OK;
    efb0:	2300      	movs	r3, #0
}
    efb2:	0018      	movs	r0, r3
    efb4:	46bd      	mov	sp, r7
    efb6:	b002      	add	sp, #8
    efb8:	bd80      	pop	{r7, pc}
    efba:	46c0      	nop			; (mov r8, r8)
    efbc:	20002d68 	.word	0x20002d68
    efc0:	0000e0f1 	.word	0x0000e0f1
    efc4:	0000ee21 	.word	0x0000ee21
    efc8:	0000ed61 	.word	0x0000ed61

0000efcc <timers_update>:

/**
 * \brief Timer management function.
 */
static void timers_update(void)
{
    efcc:	b580      	push	{r7, lr}
    efce:	b084      	sub	sp, #16
    efd0:	af00      	add	r7, sp, #0
	static uint32_t ul_last_time;
	uint32_t ul_cur_time, ul_time_diff, ul_idx_timer;
	timers_info_t *p_tmr_inf;

	ul_cur_time = sys_get_ms();
    efd2:	4b25      	ldr	r3, [pc, #148]	; (f068 <timers_update+0x9c>)
    efd4:	4798      	blx	r3
    efd6:	0003      	movs	r3, r0
    efd8:	607b      	str	r3, [r7, #4]
	if (ul_cur_time >= ul_last_time) {
    efda:	4b24      	ldr	r3, [pc, #144]	; (f06c <timers_update+0xa0>)
    efdc:	681b      	ldr	r3, [r3, #0]
    efde:	687a      	ldr	r2, [r7, #4]
    efe0:	429a      	cmp	r2, r3
    efe2:	d305      	bcc.n	eff0 <timers_update+0x24>
		ul_time_diff = ul_cur_time - ul_last_time;
    efe4:	4b21      	ldr	r3, [pc, #132]	; (f06c <timers_update+0xa0>)
    efe6:	681b      	ldr	r3, [r3, #0]
    efe8:	687a      	ldr	r2, [r7, #4]
    efea:	1ad3      	subs	r3, r2, r3
    efec:	60fb      	str	r3, [r7, #12]
    efee:	e005      	b.n	effc <timers_update+0x30>
	} else {
		ul_time_diff = 0xFFFFFFFF - ul_last_time + ul_cur_time;
    eff0:	4b1e      	ldr	r3, [pc, #120]	; (f06c <timers_update+0xa0>)
    eff2:	681b      	ldr	r3, [r3, #0]
    eff4:	687a      	ldr	r2, [r7, #4]
    eff6:	1ad3      	subs	r3, r2, r3
    eff8:	3b01      	subs	r3, #1
    effa:	60fb      	str	r3, [r7, #12]
	}

	if (ul_time_diff) {
    effc:	68fb      	ldr	r3, [r7, #12]
    effe:	2b00      	cmp	r3, #0
    f000:	d02d      	beq.n	f05e <timers_update+0x92>
		ul_last_time = ul_cur_time;
    f002:	4b1a      	ldr	r3, [pc, #104]	; (f06c <timers_update+0xa0>)
    f004:	687a      	ldr	r2, [r7, #4]
    f006:	601a      	str	r2, [r3, #0]
		for (ul_idx_timer = 0;
    f008:	2300      	movs	r3, #0
    f00a:	60bb      	str	r3, [r7, #8]
    f00c:	e024      	b.n	f058 <timers_update+0x8c>
			 ul_idx_timer < (sizeof(gs_timers_table) / sizeof(timers_info_t));
			 ul_idx_timer++) {
			p_tmr_inf = &gs_timers_table[ul_idx_timer];
    f00e:	68ba      	ldr	r2, [r7, #8]
    f010:	0013      	movs	r3, r2
    f012:	005b      	lsls	r3, r3, #1
    f014:	189b      	adds	r3, r3, r2
    f016:	009b      	lsls	r3, r3, #2
    f018:	4a15      	ldr	r2, [pc, #84]	; (f070 <timers_update+0xa4>)
    f01a:	189b      	adds	r3, r3, r2
    f01c:	603b      	str	r3, [r7, #0]
			p_tmr_inf->timer += ul_time_diff;
    f01e:	683b      	ldr	r3, [r7, #0]
    f020:	681a      	ldr	r2, [r3, #0]
    f022:	68fb      	ldr	r3, [r7, #12]
    f024:	18d2      	adds	r2, r2, r3
    f026:	683b      	ldr	r3, [r7, #0]
    f028:	601a      	str	r2, [r3, #0]
			if (p_tmr_inf->timer > p_tmr_inf->timer_interval) {
    f02a:	683b      	ldr	r3, [r7, #0]
    f02c:	681a      	ldr	r2, [r3, #0]
    f02e:	683b      	ldr	r3, [r7, #0]
    f030:	685b      	ldr	r3, [r3, #4]
    f032:	429a      	cmp	r2, r3
    f034:	d90d      	bls.n	f052 <timers_update+0x86>
				if (p_tmr_inf->timer_func) {
    f036:	683b      	ldr	r3, [r7, #0]
    f038:	689b      	ldr	r3, [r3, #8]
    f03a:	2b00      	cmp	r3, #0
    f03c:	d002      	beq.n	f044 <timers_update+0x78>
					p_tmr_inf->timer_func();
    f03e:	683b      	ldr	r3, [r7, #0]
    f040:	689b      	ldr	r3, [r3, #8]
    f042:	4798      	blx	r3
				}

				p_tmr_inf->timer -= p_tmr_inf->timer_interval;
    f044:	683b      	ldr	r3, [r7, #0]
    f046:	681a      	ldr	r2, [r3, #0]
    f048:	683b      	ldr	r3, [r7, #0]
    f04a:	685b      	ldr	r3, [r3, #4]
    f04c:	1ad2      	subs	r2, r2, r3
    f04e:	683b      	ldr	r3, [r7, #0]
    f050:	601a      	str	r2, [r3, #0]

	if (ul_time_diff) {
		ul_last_time = ul_cur_time;
		for (ul_idx_timer = 0;
			 ul_idx_timer < (sizeof(gs_timers_table) / sizeof(timers_info_t));
			 ul_idx_timer++) {
    f052:	68bb      	ldr	r3, [r7, #8]
    f054:	3301      	adds	r3, #1
    f056:	60bb      	str	r3, [r7, #8]
		ul_time_diff = 0xFFFFFFFF - ul_last_time + ul_cur_time;
	}

	if (ul_time_diff) {
		ul_last_time = ul_cur_time;
		for (ul_idx_timer = 0;
    f058:	68bb      	ldr	r3, [r7, #8]
    f05a:	2b02      	cmp	r3, #2
    f05c:	d9d7      	bls.n	f00e <timers_update+0x42>

				p_tmr_inf->timer -= p_tmr_inf->timer_interval;
			}
		}
	}
}
    f05e:	46c0      	nop			; (mov r8, r8)
    f060:	46bd      	mov	sp, r7
    f062:	b004      	add	sp, #16
    f064:	bd80      	pop	{r7, pc}
    f066:	46c0      	nop			; (mov r8, r8)
    f068:	0000f7f5 	.word	0x0000f7f5
    f06c:	20002da4 	.word	0x20002da4
    f070:	2000001c 	.word	0x2000001c

0000f074 <ethernet_configure_interface>:

/**
 * \brief Configure network interface driver.
 */
static void ethernet_configure_interface(void)
{
    f074:	b590      	push	{r4, r7, lr}
    f076:	b089      	sub	sp, #36	; 0x24
    f078:	af04      	add	r7, sp, #16
	//x_ip_addr.addr = 0;
	//x_net_mask.addr = 0;
//#else
	/* Fixed IP mode. */
	/* Default ip addr */
	IP4_ADDR(&x_ip_addr, ETHERNET_CONF_IPADDR0, ETHERNET_CONF_IPADDR1,
    f07a:	4b13      	ldr	r3, [pc, #76]	; (f0c8 <ethernet_configure_interface+0x54>)
    f07c:	60fb      	str	r3, [r7, #12]
			ETHERNET_CONF_IPADDR2, ETHERNET_CONF_IPADDR3);

	/* Default subnet mask */
	IP4_ADDR(&x_net_mask, ETHERNET_CONF_NET_MASK0, ETHERNET_CONF_NET_MASK1,
    f07e:	4b13      	ldr	r3, [pc, #76]	; (f0cc <ethernet_configure_interface+0x58>)
    f080:	60bb      	str	r3, [r7, #8]
			ETHERNET_CONF_NET_MASK2, ETHERNET_CONF_NET_MASK3);

	/* Default gateway addr */
	IP4_ADDR(&x_gateway, ETHERNET_CONF_GATEWAY_ADDR0,
    f082:	4b13      	ldr	r3, [pc, #76]	; (f0d0 <ethernet_configure_interface+0x5c>)
    f084:	607b      	str	r3, [r7, #4]
			ETHERNET_CONF_GATEWAY_ADDR2,
			ETHERNET_CONF_GATEWAY_ADDR3);
//#endif

	/* Add data to netif */
	if (NULL == netif_add(&gs_net_if, &x_ip_addr, &x_net_mask, &x_gateway, NULL,
    f086:	1d3c      	adds	r4, r7, #4
    f088:	2308      	movs	r3, #8
    f08a:	18fa      	adds	r2, r7, r3
    f08c:	230c      	movs	r3, #12
    f08e:	18f9      	adds	r1, r7, r3
    f090:	4810      	ldr	r0, [pc, #64]	; (f0d4 <ethernet_configure_interface+0x60>)
    f092:	4b11      	ldr	r3, [pc, #68]	; (f0d8 <ethernet_configure_interface+0x64>)
    f094:	9302      	str	r3, [sp, #8]
    f096:	4b11      	ldr	r3, [pc, #68]	; (f0dc <ethernet_configure_interface+0x68>)
    f098:	9301      	str	r3, [sp, #4]
    f09a:	2300      	movs	r3, #0
    f09c:	9300      	str	r3, [sp, #0]
    f09e:	0023      	movs	r3, r4
    f0a0:	4c0f      	ldr	r4, [pc, #60]	; (f0e0 <ethernet_configure_interface+0x6c>)
    f0a2:	47a0      	blx	r4
	ethernetif_init, ethernet_input)) {
		LWIP_ASSERT("NULL == netif_add", 0);
	}

	/* Make it the default interface */
	netif_set_default(&gs_net_if);
    f0a4:	4b0b      	ldr	r3, [pc, #44]	; (f0d4 <ethernet_configure_interface+0x60>)
    f0a6:	0018      	movs	r0, r3
    f0a8:	4b0e      	ldr	r3, [pc, #56]	; (f0e4 <ethernet_configure_interface+0x70>)
    f0aa:	4798      	blx	r3

	/* Setup callback function for netif status change */
	netif_set_status_callback(&gs_net_if, status_callback);
    f0ac:	4a0e      	ldr	r2, [pc, #56]	; (f0e8 <ethernet_configure_interface+0x74>)
    f0ae:	4b09      	ldr	r3, [pc, #36]	; (f0d4 <ethernet_configure_interface+0x60>)
    f0b0:	0011      	movs	r1, r2
    f0b2:	0018      	movs	r0, r3
    f0b4:	4b0d      	ldr	r3, [pc, #52]	; (f0ec <ethernet_configure_interface+0x78>)
    f0b6:	4798      	blx	r3
		//LWIP_ASSERT("ERR_OK != dhcp_start", 0);
	//}
	////printf("DHCP Started\r\n");
//#else
	/* Static mode. */
	netif_set_up(&gs_net_if);
    f0b8:	4b06      	ldr	r3, [pc, #24]	; (f0d4 <ethernet_configure_interface+0x60>)
    f0ba:	0018      	movs	r0, r3
    f0bc:	4b0c      	ldr	r3, [pc, #48]	; (f0f0 <ethernet_configure_interface+0x7c>)
    f0be:	4798      	blx	r3
	//printf("Static IP Address Assigned\r\n");
//#endif
}
    f0c0:	46c0      	nop			; (mov r8, r8)
    f0c2:	46bd      	mov	sp, r7
    f0c4:	b005      	add	sp, #20
    f0c6:	bd90      	pop	{r4, r7, pc}
    f0c8:	6400a8c0 	.word	0x6400a8c0
    f0cc:	00ffffff 	.word	0x00ffffff
    f0d0:	fa00a8c0 	.word	0xfa00a8c0
    f0d4:	20003ee4 	.word	0x20003ee4
    f0d8:	0000e6e9 	.word	0x0000e6e9
    f0dc:	0000ef79 	.word	0x0000ef79
    f0e0:	00007b85 	.word	0x00007b85
    f0e4:	00007d59 	.word	0x00007d59
    f0e8:	0000f119 	.word	0x0000f119
    f0ec:	00007de5 	.word	0x00007de5
    f0f0:	00007d75 	.word	0x00007d75

0000f0f4 <init_ethernet>:

/**
 * \brief Initialize the lwIP TCP/IP stack with the network interface driver.
 */
void init_ethernet(void)
{
    f0f4:	b580      	push	{r7, lr}
    f0f6:	af00      	add	r7, sp, #0
	/* Initialize lwIP. */
	lwip_init();
    f0f8:	4b04      	ldr	r3, [pc, #16]	; (f10c <init_ethernet+0x18>)
    f0fa:	4798      	blx	r3

	/* Set hw and IP parameters, initialize MAC too. */
	ethernet_configure_interface();
    f0fc:	4b04      	ldr	r3, [pc, #16]	; (f110 <init_ethernet+0x1c>)
    f0fe:	4798      	blx	r3

	/* Initialize timer. */
	sys_init_timing();
    f100:	4b04      	ldr	r3, [pc, #16]	; (f114 <init_ethernet+0x20>)
    f102:	4798      	blx	r3
}
    f104:	46c0      	nop			; (mov r8, r8)
    f106:	46bd      	mov	sp, r7
    f108:	bd80      	pop	{r7, pc}
    f10a:	46c0      	nop			; (mov r8, r8)
    f10c:	000072c9 	.word	0x000072c9
    f110:	0000f075 	.word	0x0000f075
    f114:	0000f761 	.word	0x0000f761

0000f118 <status_callback>:
 * is up.
 *
 * \param netif The network interface instance.
 */
void status_callback(struct netif *netif)
{
    f118:	b580      	push	{r7, lr}
    f11a:	b088      	sub	sp, #32
    f11c:	af00      	add	r7, sp, #0
    f11e:	6078      	str	r0, [r7, #4]
	int8_t c_mess[20];
	if (netif_is_up(netif)) {
    f120:	687b      	ldr	r3, [r7, #4]
    f122:	222d      	movs	r2, #45	; 0x2d
    f124:	5c9b      	ldrb	r3, [r3, r2]
    f126:	001a      	movs	r2, r3
    f128:	2301      	movs	r3, #1
    f12a:	4013      	ands	r3, r2
    f12c:	d00f      	beq.n	f14e <status_callback+0x36>
		strcpy((char*)c_mess, "IP=");
    f12e:	230c      	movs	r3, #12
    f130:	18fb      	adds	r3, r7, r3
    f132:	4a09      	ldr	r2, [pc, #36]	; (f158 <status_callback+0x40>)
    f134:	601a      	str	r2, [r3, #0]
		strcat((char*)c_mess, inet_ntoa(*(struct in_addr *)&(netif->ip_addr)));
    f136:	687b      	ldr	r3, [r7, #4]
    f138:	3304      	adds	r3, #4
    f13a:	0018      	movs	r0, r3
    f13c:	4b07      	ldr	r3, [pc, #28]	; (f15c <status_callback+0x44>)
    f13e:	4798      	blx	r3
    f140:	0002      	movs	r2, r0
    f142:	230c      	movs	r3, #12
    f144:	18fb      	adds	r3, r7, r3
    f146:	0011      	movs	r1, r2
    f148:	0018      	movs	r0, r3
    f14a:	4b05      	ldr	r3, [pc, #20]	; (f160 <status_callback+0x48>)
    f14c:	4798      	blx	r3
		//printf("Network up %s\r\n", (char const*)c_mess);
	} else {
		//printf("Network down\r\n");
	}
}
    f14e:	46c0      	nop			; (mov r8, r8)
    f150:	46bd      	mov	sp, r7
    f152:	b008      	add	sp, #32
    f154:	bd80      	pop	{r7, pc}
    f156:	46c0      	nop			; (mov r8, r8)
    f158:	003d5049 	.word	0x003d5049
    f15c:	000062dd 	.word	0x000062dd
    f160:	0000fc65 	.word	0x0000fc65

0000f164 <ethernet_task>:

/**
 * \brief Process incoming ethernet frames, then update timers.
 */
void ethernet_task(void)
{
    f164:	b580      	push	{r7, lr}
    f166:	af00      	add	r7, sp, #0
	/* Poll the network interface driver for incoming ethernet frames. */
	ethernetif_input(&gs_net_if);
    f168:	4b04      	ldr	r3, [pc, #16]	; (f17c <ethernet_task+0x18>)
    f16a:	0018      	movs	r0, r3
    f16c:	4b04      	ldr	r3, [pc, #16]	; (f180 <ethernet_task+0x1c>)
    f16e:	4798      	blx	r3

	/* Update the periodic timer. */
	timers_update();
    f170:	4b04      	ldr	r3, [pc, #16]	; (f184 <ethernet_task+0x20>)
    f172:	4798      	blx	r3
}
    f174:	46c0      	nop			; (mov r8, r8)
    f176:	46bd      	mov	sp, r7
    f178:	bd80      	pop	{r7, pc}
    f17a:	46c0      	nop			; (mov r8, r8)
    f17c:	20003ee4 	.word	0x20003ee4
    f180:	0000eee9 	.word	0x0000eee9
    f184:	0000efcd 	.word	0x0000efcd

0000f188 <udp_echo_recv>:

	return ERR_OK;
}

static void udp_echo_recv(void *arg,struct udp_pcb *pcb, struct pbuf *p,struct ip_addr *addr, uint16_t port)
{
    f188:	b590      	push	{r4, r7, lr}
    f18a:	b089      	sub	sp, #36	; 0x24
    f18c:	af00      	add	r7, sp, #0
    f18e:	60f8      	str	r0, [r7, #12]
    f190:	60b9      	str	r1, [r7, #8]
    f192:	607a      	str	r2, [r7, #4]
    f194:	603b      	str	r3, [r7, #0]
	struct pbuf *p_smbus;
	//struct pbuf pbuf_smbus;
	uint8_t *p_payload = (uint8_t *)(p->payload);
    f196:	687b      	ldr	r3, [r7, #4]
    f198:	685b      	ldr	r3, [r3, #4]
    f19a:	61bb      	str	r3, [r7, #24]
	uint8_t ssd_port_index = 0;
    f19c:	2317      	movs	r3, #23
    f19e:	18fb      	adds	r3, r7, r3
    f1a0:	2200      	movs	r2, #0
    f1a2:	701a      	strb	r2, [r3, #0]

	if(p != NULL)
    f1a4:	687b      	ldr	r3, [r7, #4]
    f1a6:	2b00      	cmp	r3, #0
    f1a8:	d100      	bne.n	f1ac <udp_echo_recv+0x24>
    f1aa:	e07f      	b.n	f2ac <udp_echo_recv+0x124>
	{
		/* get info */
		if(*p_payload == 0)
    f1ac:	69bb      	ldr	r3, [r7, #24]
    f1ae:	781b      	ldrb	r3, [r3, #0]
    f1b0:	2b00      	cmp	r3, #0
    f1b2:	d16b      	bne.n	f28c <udp_echo_recv+0x104>
		{
			if(*(p_payload+1) < 8)
    f1b4:	69bb      	ldr	r3, [r7, #24]
    f1b6:	3301      	adds	r3, #1
    f1b8:	781b      	ldrb	r3, [r3, #0]
    f1ba:	2b07      	cmp	r3, #7
    f1bc:	d834      	bhi.n	f228 <udp_echo_recv+0xa0>
			{		
				pbuf_smbus.len = ETH_SSD_LOG_LENGTH;
    f1be:	4b3d      	ldr	r3, [pc, #244]	; (f2b4 <udp_echo_recv+0x12c>)
    f1c0:	2296      	movs	r2, #150	; 0x96
    f1c2:	815a      	strh	r2, [r3, #10]
				pbuf_smbus.tot_len = ETH_SSD_LOG_LENGTH;
    f1c4:	4b3b      	ldr	r3, [pc, #236]	; (f2b4 <udp_echo_recv+0x12c>)
    f1c6:	2296      	movs	r2, #150	; 0x96
    f1c8:	811a      	strh	r2, [r3, #8]
				pbuf_smbus.flags = 0;
    f1ca:	4b3a      	ldr	r3, [pc, #232]	; (f2b4 <udp_echo_recv+0x12c>)
    f1cc:	2200      	movs	r2, #0
    f1ce:	735a      	strb	r2, [r3, #13]
				pbuf_smbus.next = 0;
    f1d0:	4b38      	ldr	r3, [pc, #224]	; (f2b4 <udp_echo_recv+0x12c>)
    f1d2:	2200      	movs	r2, #0
    f1d4:	601a      	str	r2, [r3, #0]
				pbuf_smbus.ref = 1;
    f1d6:	4b37      	ldr	r3, [pc, #220]	; (f2b4 <udp_echo_recv+0x12c>)
    f1d8:	2201      	movs	r2, #1
    f1da:	81da      	strh	r2, [r3, #14]
				pbuf_smbus.type = 2;
    f1dc:	4b35      	ldr	r3, [pc, #212]	; (f2b4 <udp_echo_recv+0x12c>)
    f1de:	2202      	movs	r2, #2
    f1e0:	731a      	strb	r2, [r3, #12]
				ssd_port_index = *(p_payload+1);
    f1e2:	2317      	movs	r3, #23
    f1e4:	18fb      	adds	r3, r7, r3
    f1e6:	69ba      	ldr	r2, [r7, #24]
    f1e8:	7852      	ldrb	r2, [r2, #1]
    f1ea:	701a      	strb	r2, [r3, #0]
				if(smbus_log_pingpang == 0 || smbus_log_pingpang == 1)
    f1ec:	4b32      	ldr	r3, [pc, #200]	; (f2b8 <udp_echo_recv+0x130>)
    f1ee:	781b      	ldrb	r3, [r3, #0]
    f1f0:	2b00      	cmp	r3, #0
    f1f2:	d003      	beq.n	f1fc <udp_echo_recv+0x74>
    f1f4:	4b30      	ldr	r3, [pc, #192]	; (f2b8 <udp_echo_recv+0x130>)
    f1f6:	781b      	ldrb	r3, [r3, #0]
    f1f8:	2b01      	cmp	r3, #1
    f1fa:	d10a      	bne.n	f212 <udp_echo_recv+0x8a>
				{
					pbuf_smbus.payload = (uint8_t *)(ssd_port_log_pingpang0+ssd_port_index*ETH_SSD_LOG_LENGTH);
    f1fc:	2317      	movs	r3, #23
    f1fe:	18fb      	adds	r3, r7, r3
    f200:	781b      	ldrb	r3, [r3, #0]
    f202:	2296      	movs	r2, #150	; 0x96
    f204:	4353      	muls	r3, r2
    f206:	001a      	movs	r2, r3
    f208:	4b2c      	ldr	r3, [pc, #176]	; (f2bc <udp_echo_recv+0x134>)
    f20a:	18d2      	adds	r2, r2, r3
    f20c:	4b29      	ldr	r3, [pc, #164]	; (f2b4 <udp_echo_recv+0x12c>)
    f20e:	605a      	str	r2, [r3, #4]
    f210:	e03a      	b.n	f288 <udp_echo_recv+0x100>
				}
				else
				{
					pbuf_smbus.payload = (uint8_t *)(ssd_port_log_pingpang1+ssd_port_index*ETH_SSD_LOG_LENGTH);
    f212:	2317      	movs	r3, #23
    f214:	18fb      	adds	r3, r7, r3
    f216:	781b      	ldrb	r3, [r3, #0]
    f218:	2296      	movs	r2, #150	; 0x96
    f21a:	4353      	muls	r3, r2
    f21c:	001a      	movs	r2, r3
    f21e:	4b28      	ldr	r3, [pc, #160]	; (f2c0 <udp_echo_recv+0x138>)
    f220:	18d2      	adds	r2, r2, r3
    f222:	4b24      	ldr	r3, [pc, #144]	; (f2b4 <udp_echo_recv+0x12c>)
    f224:	605a      	str	r2, [r3, #4]
    f226:	e02f      	b.n	f288 <udp_echo_recv+0x100>
				}
			}
			else if(*(p_payload+1) == 9)
    f228:	69bb      	ldr	r3, [r7, #24]
    f22a:	3301      	adds	r3, #1
    f22c:	781b      	ldrb	r3, [r3, #0]
    f22e:	2b09      	cmp	r3, #9
    f230:	d121      	bne.n	f276 <udp_echo_recv+0xee>
			{
				pbuf_smbus.len = ETH_AGING_BOX_INFO_LENGTH;
    f232:	4b20      	ldr	r3, [pc, #128]	; (f2b4 <udp_echo_recv+0x12c>)
    f234:	221e      	movs	r2, #30
    f236:	815a      	strh	r2, [r3, #10]
				pbuf_smbus.tot_len = ETH_AGING_BOX_INFO_LENGTH;
    f238:	4b1e      	ldr	r3, [pc, #120]	; (f2b4 <udp_echo_recv+0x12c>)
    f23a:	221e      	movs	r2, #30
    f23c:	811a      	strh	r2, [r3, #8]
				pbuf_smbus.flags = 0;
    f23e:	4b1d      	ldr	r3, [pc, #116]	; (f2b4 <udp_echo_recv+0x12c>)
    f240:	2200      	movs	r2, #0
    f242:	735a      	strb	r2, [r3, #13]
				pbuf_smbus.next = 0;
    f244:	4b1b      	ldr	r3, [pc, #108]	; (f2b4 <udp_echo_recv+0x12c>)
    f246:	2200      	movs	r2, #0
    f248:	601a      	str	r2, [r3, #0]
				pbuf_smbus.ref = 1;
    f24a:	4b1a      	ldr	r3, [pc, #104]	; (f2b4 <udp_echo_recv+0x12c>)
    f24c:	2201      	movs	r2, #1
    f24e:	81da      	strh	r2, [r3, #14]
				pbuf_smbus.type = 2;
    f250:	4b18      	ldr	r3, [pc, #96]	; (f2b4 <udp_echo_recv+0x12c>)
    f252:	2202      	movs	r2, #2
    f254:	731a      	strb	r2, [r3, #12]
				if(smbus_log_pingpang == 0 || smbus_log_pingpang == 1)
    f256:	4b18      	ldr	r3, [pc, #96]	; (f2b8 <udp_echo_recv+0x130>)
    f258:	781b      	ldrb	r3, [r3, #0]
    f25a:	2b00      	cmp	r3, #0
    f25c:	d003      	beq.n	f266 <udp_echo_recv+0xde>
    f25e:	4b16      	ldr	r3, [pc, #88]	; (f2b8 <udp_echo_recv+0x130>)
    f260:	781b      	ldrb	r3, [r3, #0]
    f262:	2b01      	cmp	r3, #1
    f264:	d103      	bne.n	f26e <udp_echo_recv+0xe6>
				{
					pbuf_smbus.payload = (uint8_t *)aging_box_log_pingpang0;
    f266:	4b13      	ldr	r3, [pc, #76]	; (f2b4 <udp_echo_recv+0x12c>)
    f268:	4a16      	ldr	r2, [pc, #88]	; (f2c4 <udp_echo_recv+0x13c>)
    f26a:	605a      	str	r2, [r3, #4]
    f26c:	e00c      	b.n	f288 <udp_echo_recv+0x100>
				}
				else
				{
					pbuf_smbus.payload = (uint8_t *)aging_box_log_pingpang1;
    f26e:	4b11      	ldr	r3, [pc, #68]	; (f2b4 <udp_echo_recv+0x12c>)
    f270:	4a15      	ldr	r2, [pc, #84]	; (f2c8 <udp_echo_recv+0x140>)
    f272:	605a      	str	r2, [r3, #4]
    f274:	e008      	b.n	f288 <udp_echo_recv+0x100>
				}
			}		
			else
			{
				pbuf_free(p);
    f276:	687b      	ldr	r3, [r7, #4]
    f278:	0018      	movs	r0, r3
    f27a:	4b14      	ldr	r3, [pc, #80]	; (f2cc <udp_echo_recv+0x144>)
    f27c:	4798      	blx	r3
				pbuf_free(p_smbus);
    f27e:	69fb      	ldr	r3, [r7, #28]
    f280:	0018      	movs	r0, r3
    f282:	4b12      	ldr	r3, [pc, #72]	; (f2cc <udp_echo_recv+0x144>)
    f284:	4798      	blx	r3
				return;
    f286:	e011      	b.n	f2ac <udp_echo_recv+0x124>
			}	
			p_smbus = &pbuf_smbus;
    f288:	4b0a      	ldr	r3, [pc, #40]	; (f2b4 <udp_echo_recv+0x12c>)
    f28a:	61fb      	str	r3, [r7, #28]
		}
		udp_sendto(pcb,p_smbus,addr,port);
    f28c:	2330      	movs	r3, #48	; 0x30
    f28e:	18fb      	adds	r3, r7, r3
    f290:	881b      	ldrh	r3, [r3, #0]
    f292:	683a      	ldr	r2, [r7, #0]
    f294:	69f9      	ldr	r1, [r7, #28]
    f296:	68b8      	ldr	r0, [r7, #8]
    f298:	4c0d      	ldr	r4, [pc, #52]	; (f2d0 <udp_echo_recv+0x148>)
    f29a:	47a0      	blx	r4
		//udp_sendto(pcb,p,addr,port);
		pbuf_free(p);
    f29c:	687b      	ldr	r3, [r7, #4]
    f29e:	0018      	movs	r0, r3
    f2a0:	4b0a      	ldr	r3, [pc, #40]	; (f2cc <udp_echo_recv+0x144>)
    f2a2:	4798      	blx	r3
		pbuf_free(p_smbus);
    f2a4:	69fb      	ldr	r3, [r7, #28]
    f2a6:	0018      	movs	r0, r3
    f2a8:	4b08      	ldr	r3, [pc, #32]	; (f2cc <udp_echo_recv+0x144>)
    f2aa:	4798      	blx	r3
	}
}
    f2ac:	46bd      	mov	sp, r7
    f2ae:	b009      	add	sp, #36	; 0x24
    f2b0:	bd90      	pop	{r4, r7, pc}
    f2b2:	46c0      	nop			; (mov r8, r8)
    f2b4:	20003f18 	.word	0x20003f18
    f2b8:	20000066 	.word	0x20000066
    f2bc:	20000068 	.word	0x20000068
    f2c0:	20000518 	.word	0x20000518
    f2c4:	200009c8 	.word	0x200009c8
    f2c8:	200009e8 	.word	0x200009e8
    f2cc:	00008349 	.word	0x00008349
    f2d0:	0000d4f9 	.word	0x0000d4f9

0000f2d4 <httpd_init>:

/**
 * \brief HTTP server init.
 */
void httpd_init(void)
{
    f2d4:	b580      	push	{r7, lr}
    f2d6:	b082      	sub	sp, #8
    f2d8:	af00      	add	r7, sp, #0
	//tcp_bind(pcb, IP_ADDR_ANY, 80);
	//pcb = tcp_listen(pcb);
	//tcp_accept(pcb, http_accept);
	struct udp_pcb *pcb;
	
	pcb = udp_new();
    f2da:	4b0e      	ldr	r3, [pc, #56]	; (f314 <httpd_init+0x40>)
    f2dc:	4798      	blx	r3
    f2de:	0003      	movs	r3, r0
    f2e0:	607b      	str	r3, [r7, #4]
	if(pcb == NULL)
    f2e2:	687b      	ldr	r3, [r7, #4]
    f2e4:	2b00      	cmp	r3, #0
    f2e6:	d00f      	beq.n	f308 <httpd_init+0x34>
	{
		return;
	}
	if(udp_bind(pcb,IP_ADDR_ANY,600) != ERR_OK)
    f2e8:	2396      	movs	r3, #150	; 0x96
    f2ea:	009a      	lsls	r2, r3, #2
    f2ec:	490a      	ldr	r1, [pc, #40]	; (f318 <httpd_init+0x44>)
    f2ee:	687b      	ldr	r3, [r7, #4]
    f2f0:	0018      	movs	r0, r3
    f2f2:	4b0a      	ldr	r3, [pc, #40]	; (f31c <httpd_init+0x48>)
    f2f4:	4798      	blx	r3
    f2f6:	1e03      	subs	r3, r0, #0
    f2f8:	d108      	bne.n	f30c <httpd_init+0x38>
	}
	//if(udp_connect(pcb,IP_ADDR_ANY,500) != ERR_OK)
	//{
		//return;
	//}
	udp_recv(pcb,udp_echo_recv,NULL);
    f2fa:	4909      	ldr	r1, [pc, #36]	; (f320 <httpd_init+0x4c>)
    f2fc:	687b      	ldr	r3, [r7, #4]
    f2fe:	2200      	movs	r2, #0
    f300:	0018      	movs	r0, r3
    f302:	4b08      	ldr	r3, [pc, #32]	; (f324 <httpd_init+0x50>)
    f304:	4798      	blx	r3
    f306:	e002      	b.n	f30e <httpd_init+0x3a>
	struct udp_pcb *pcb;
	
	pcb = udp_new();
	if(pcb == NULL)
	{
		return;
    f308:	46c0      	nop			; (mov r8, r8)
    f30a:	e000      	b.n	f30e <httpd_init+0x3a>
	}
	if(udp_bind(pcb,IP_ADDR_ANY,600) != ERR_OK)
	{
		return;
    f30c:	46c0      	nop			; (mov r8, r8)
	//if(udp_connect(pcb,IP_ADDR_ANY,500) != ERR_OK)
	//{
		//return;
	//}
	udp_recv(pcb,udp_echo_recv,NULL);
}
    f30e:	46bd      	mov	sp, r7
    f310:	b002      	add	sp, #8
    f312:	bd80      	pop	{r7, pc}
    f314:	0000d831 	.word	0x0000d831
    f318:	0000fd5c 	.word	0x0000fd5c
    f31c:	0000d735 	.word	0x0000d735
    f320:	0000f189 	.word	0x0000f189
    f324:	0000d811 	.word	0x0000d811

0000f328 <system_pinmux_get_group_from_gpio_pin>:
 *
 * \return Base address of the associated PORT module.
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    f328:	b580      	push	{r7, lr}
    f32a:	b084      	sub	sp, #16
    f32c:	af00      	add	r7, sp, #0
    f32e:	0002      	movs	r2, r0
    f330:	1dfb      	adds	r3, r7, #7
    f332:	701a      	strb	r2, [r3, #0]
	uint8_t port_index  = (gpio_pin / 128);
    f334:	230f      	movs	r3, #15
    f336:	18fb      	adds	r3, r7, r3
    f338:	1dfa      	adds	r2, r7, #7
    f33a:	7812      	ldrb	r2, [r2, #0]
    f33c:	09d2      	lsrs	r2, r2, #7
    f33e:	701a      	strb	r2, [r3, #0]
	uint8_t group_index = (gpio_pin / 32);
    f340:	230e      	movs	r3, #14
    f342:	18fb      	adds	r3, r7, r3
    f344:	1dfa      	adds	r2, r7, #7
    f346:	7812      	ldrb	r2, [r2, #0]
    f348:	0952      	lsrs	r2, r2, #5
    f34a:	701a      	strb	r2, [r3, #0]

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;
    f34c:	4b0d      	ldr	r3, [pc, #52]	; (f384 <system_pinmux_get_group_from_gpio_pin+0x5c>)
    f34e:	60bb      	str	r3, [r7, #8]

	if (port_index < PORT_INST_NUM) {
    f350:	230f      	movs	r3, #15
    f352:	18fb      	adds	r3, r7, r3
    f354:	781b      	ldrb	r3, [r3, #0]
    f356:	2b00      	cmp	r3, #0
    f358:	d10f      	bne.n	f37a <system_pinmux_get_group_from_gpio_pin+0x52>
		return &(ports[port_index]->Group[group_index]);
    f35a:	230f      	movs	r3, #15
    f35c:	18fb      	adds	r3, r7, r3
    f35e:	781b      	ldrb	r3, [r3, #0]
    f360:	009b      	lsls	r3, r3, #2
    f362:	2210      	movs	r2, #16
    f364:	4694      	mov	ip, r2
    f366:	44bc      	add	ip, r7
    f368:	4463      	add	r3, ip
    f36a:	3b08      	subs	r3, #8
    f36c:	681a      	ldr	r2, [r3, #0]
    f36e:	230e      	movs	r3, #14
    f370:	18fb      	adds	r3, r7, r3
    f372:	781b      	ldrb	r3, [r3, #0]
    f374:	01db      	lsls	r3, r3, #7
    f376:	18d3      	adds	r3, r2, r3
    f378:	e000      	b.n	f37c <system_pinmux_get_group_from_gpio_pin+0x54>
	} else {
		Assert(false);
		return NULL;
    f37a:	2300      	movs	r3, #0
	}
}
    f37c:	0018      	movs	r0, r3
    f37e:	46bd      	mov	sp, r7
    f380:	b004      	add	sp, #16
    f382:	bd80      	pop	{r7, pc}
    f384:	41004400 	.word	0x41004400

0000f388 <port_get_group_from_gpio_pin>:
 *
 *  \return Base address of the associated PORT module.
 */
static inline PortGroup* port_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
    f388:	b580      	push	{r7, lr}
    f38a:	b082      	sub	sp, #8
    f38c:	af00      	add	r7, sp, #0
    f38e:	0002      	movs	r2, r0
    f390:	1dfb      	adds	r3, r7, #7
    f392:	701a      	strb	r2, [r3, #0]
	return system_pinmux_get_group_from_gpio_pin(gpio_pin);
    f394:	1dfb      	adds	r3, r7, #7
    f396:	781b      	ldrb	r3, [r3, #0]
    f398:	0018      	movs	r0, r3
    f39a:	4b03      	ldr	r3, [pc, #12]	; (f3a8 <port_get_group_from_gpio_pin+0x20>)
    f39c:	4798      	blx	r3
    f39e:	0003      	movs	r3, r0
}
    f3a0:	0018      	movs	r0, r3
    f3a2:	46bd      	mov	sp, r7
    f3a4:	b002      	add	sp, #8
    f3a6:	bd80      	pop	{r7, pc}
    f3a8:	0000f329 	.word	0x0000f329

0000f3ac <port_get_config_defaults>:
 *
 *  \param[out] config  Configuration structure to initialize to default values
 */
static inline void port_get_config_defaults(
		struct port_config *const config)
{
    f3ac:	b580      	push	{r7, lr}
    f3ae:	b082      	sub	sp, #8
    f3b0:	af00      	add	r7, sp, #0
    f3b2:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->direction  = PORT_PIN_DIR_INPUT;
    f3b4:	687b      	ldr	r3, [r7, #4]
    f3b6:	2200      	movs	r2, #0
    f3b8:	701a      	strb	r2, [r3, #0]
	config->input_pull = PORT_PIN_PULL_UP;
    f3ba:	687b      	ldr	r3, [r7, #4]
    f3bc:	2201      	movs	r2, #1
    f3be:	705a      	strb	r2, [r3, #1]
	config->powersave  = false;
    f3c0:	687b      	ldr	r3, [r7, #4]
    f3c2:	2200      	movs	r2, #0
    f3c4:	709a      	strb	r2, [r3, #2]
}
    f3c6:	46c0      	nop			; (mov r8, r8)
    f3c8:	46bd      	mov	sp, r7
    f3ca:	b002      	add	sp, #8
    f3cc:	bd80      	pop	{r7, pc}
    f3ce:	46c0      	nop			; (mov r8, r8)

0000f3d0 <port_pin_set_output_level>:
 *  \param[in] level     Logical level to set the given pin to
 */
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
    f3d0:	b580      	push	{r7, lr}
    f3d2:	b084      	sub	sp, #16
    f3d4:	af00      	add	r7, sp, #0
    f3d6:	0002      	movs	r2, r0
    f3d8:	1dfb      	adds	r3, r7, #7
    f3da:	701a      	strb	r2, [r3, #0]
    f3dc:	1dbb      	adds	r3, r7, #6
    f3de:	1c0a      	adds	r2, r1, #0
    f3e0:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    f3e2:	1dfb      	adds	r3, r7, #7
    f3e4:	781b      	ldrb	r3, [r3, #0]
    f3e6:	0018      	movs	r0, r3
    f3e8:	4b0d      	ldr	r3, [pc, #52]	; (f420 <port_pin_set_output_level+0x50>)
    f3ea:	4798      	blx	r3
    f3ec:	0003      	movs	r3, r0
    f3ee:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    f3f0:	1dfb      	adds	r3, r7, #7
    f3f2:	781b      	ldrb	r3, [r3, #0]
    f3f4:	221f      	movs	r2, #31
    f3f6:	4013      	ands	r3, r2
    f3f8:	2201      	movs	r2, #1
    f3fa:	409a      	lsls	r2, r3
    f3fc:	0013      	movs	r3, r2
    f3fe:	60bb      	str	r3, [r7, #8]

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
    f400:	1dbb      	adds	r3, r7, #6
    f402:	781b      	ldrb	r3, [r3, #0]
    f404:	2b00      	cmp	r3, #0
    f406:	d003      	beq.n	f410 <port_pin_set_output_level+0x40>
		port_base->OUTSET.reg = pin_mask;
    f408:	68fb      	ldr	r3, [r7, #12]
    f40a:	68ba      	ldr	r2, [r7, #8]
    f40c:	619a      	str	r2, [r3, #24]
	} else {
		port_base->OUTCLR.reg = pin_mask;
	}
}
    f40e:	e002      	b.n	f416 <port_pin_set_output_level+0x46>

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
	} else {
		port_base->OUTCLR.reg = pin_mask;
    f410:	68fb      	ldr	r3, [r7, #12]
    f412:	68ba      	ldr	r2, [r7, #8]
    f414:	615a      	str	r2, [r3, #20]
	}
}
    f416:	46c0      	nop			; (mov r8, r8)
    f418:	46bd      	mov	sp, r7
    f41a:	b004      	add	sp, #16
    f41c:	bd80      	pop	{r7, pc}
    f41e:	46c0      	nop			; (mov r8, r8)
    f420:	0000f389 	.word	0x0000f389

0000f424 <port_pin_toggle_output_level>:
 *
 *  \param[in] gpio_pin  Index of the GPIO pin to toggle
 */
static inline void port_pin_toggle_output_level(
		const uint8_t gpio_pin)
{
    f424:	b580      	push	{r7, lr}
    f426:	b084      	sub	sp, #16
    f428:	af00      	add	r7, sp, #0
    f42a:	0002      	movs	r2, r0
    f42c:	1dfb      	adds	r3, r7, #7
    f42e:	701a      	strb	r2, [r3, #0]
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
    f430:	1dfb      	adds	r3, r7, #7
    f432:	781b      	ldrb	r3, [r3, #0]
    f434:	0018      	movs	r0, r3
    f436:	4b09      	ldr	r3, [pc, #36]	; (f45c <port_pin_toggle_output_level+0x38>)
    f438:	4798      	blx	r3
    f43a:	0003      	movs	r3, r0
    f43c:	60fb      	str	r3, [r7, #12]
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    f43e:	1dfb      	adds	r3, r7, #7
    f440:	781b      	ldrb	r3, [r3, #0]
    f442:	221f      	movs	r2, #31
    f444:	4013      	ands	r3, r2
    f446:	2201      	movs	r2, #1
    f448:	409a      	lsls	r2, r3
    f44a:	0013      	movs	r3, r2
    f44c:	60bb      	str	r3, [r7, #8]

	/* Toggle pin output level */
	port_base->OUTTGL.reg = pin_mask;
    f44e:	68fb      	ldr	r3, [r7, #12]
    f450:	68ba      	ldr	r2, [r7, #8]
    f452:	61da      	str	r2, [r3, #28]
}
    f454:	46c0      	nop			; (mov r8, r8)
    f456:	46bd      	mov	sp, r7
    f458:	b004      	add	sp, #16
    f45a:	bd80      	pop	{r7, pc}
    f45c:	0000f389 	.word	0x0000f389

0000f460 <system_interrupt_enable_global>:
 * \brief Enables global interrupts.
 *
 * Enables global interrupts in the device to fire any enabled interrupt handlers.
 */
static inline void system_interrupt_enable_global(void)
{
    f460:	b580      	push	{r7, lr}
    f462:	af00      	add	r7, sp, #0
	cpu_irq_enable();
    f464:	4b04      	ldr	r3, [pc, #16]	; (f478 <system_interrupt_enable_global+0x18>)
    f466:	2201      	movs	r2, #1
    f468:	701a      	strb	r2, [r3, #0]
    f46a:	f3bf 8f5f 	dmb	sy
    f46e:	b662      	cpsie	i
}
    f470:	46c0      	nop			; (mov r8, r8)
    f472:	46bd      	mov	sp, r7
    f474:	bd80      	pop	{r7, pc}
    f476:	46c0      	nop			; (mov r8, r8)
    f478:	20000008 	.word	0x20000008

0000f47c <system_interrupt_enable>:
 *
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
    f47c:	b580      	push	{r7, lr}
    f47e:	b082      	sub	sp, #8
    f480:	af00      	add	r7, sp, #0
    f482:	0002      	movs	r2, r0
    f484:	1dfb      	adds	r3, r7, #7
    f486:	701a      	strb	r2, [r3, #0]
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    f488:	4b06      	ldr	r3, [pc, #24]	; (f4a4 <system_interrupt_enable+0x28>)
    f48a:	1dfa      	adds	r2, r7, #7
    f48c:	7812      	ldrb	r2, [r2, #0]
    f48e:	0011      	movs	r1, r2
    f490:	221f      	movs	r2, #31
    f492:	400a      	ands	r2, r1
    f494:	2101      	movs	r1, #1
    f496:	4091      	lsls	r1, r2
    f498:	000a      	movs	r2, r1
    f49a:	601a      	str	r2, [r3, #0]
}
    f49c:	46c0      	nop			; (mov r8, r8)
    f49e:	46bd      	mov	sp, r7
    f4a0:	b002      	add	sp, #8
    f4a2:	bd80      	pop	{r7, pc}
    f4a4:	e000e100 	.word	0xe000e100

0000f4a8 <tc_is_syncing>:
 * \retval false If the module has completed synchronization
 * \retval true  If the module synchronization is ongoing
 */
static inline bool tc_is_syncing(
		const struct tc_module *const module_inst)
{
    f4a8:	b580      	push	{r7, lr}
    f4aa:	b084      	sub	sp, #16
    f4ac:	af00      	add	r7, sp, #0
    f4ae:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    f4b0:	687b      	ldr	r3, [r7, #4]
    f4b2:	681b      	ldr	r3, [r3, #0]
    f4b4:	60fb      	str	r3, [r7, #12]

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    f4b6:	68fb      	ldr	r3, [r7, #12]
    f4b8:	7bdb      	ldrb	r3, [r3, #15]
    f4ba:	b2db      	uxtb	r3, r3
    f4bc:	001a      	movs	r2, r3
    f4be:	2380      	movs	r3, #128	; 0x80
    f4c0:	4013      	ands	r3, r2
    f4c2:	1e5a      	subs	r2, r3, #1
    f4c4:	4193      	sbcs	r3, r2
    f4c6:	b2db      	uxtb	r3, r3
#endif
}
    f4c8:	0018      	movs	r0, r3
    f4ca:	46bd      	mov	sp, r7
    f4cc:	b004      	add	sp, #16
    f4ce:	bd80      	pop	{r7, pc}

0000f4d0 <tc_get_config_defaults>:
 *
 * \param[out]  config  Pointer to a TC module configuration structure to set
 */
static inline void tc_get_config_defaults(
		struct tc_config *const config)
{
    f4d0:	b580      	push	{r7, lr}
    f4d2:	b082      	sub	sp, #8
    f4d4:	af00      	add	r7, sp, #0
    f4d6:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Write default config to config struct */
	config->clock_source               = GCLK_GENERATOR_0;
    f4d8:	687b      	ldr	r3, [r7, #4]
    f4da:	2200      	movs	r2, #0
    f4dc:	701a      	strb	r2, [r3, #0]
	config->counter_size               = TC_COUNTER_SIZE_16BIT;
    f4de:	687b      	ldr	r3, [r7, #4]
    f4e0:	2200      	movs	r2, #0
    f4e2:	709a      	strb	r2, [r3, #2]
	config->clock_prescaler            = TC_CLOCK_PRESCALER_DIV1;
    f4e4:	687b      	ldr	r3, [r7, #4]
    f4e6:	2200      	movs	r2, #0
    f4e8:	809a      	strh	r2, [r3, #4]
	config->wave_generation            = TC_WAVE_GENERATION_NORMAL_FREQ;
    f4ea:	687b      	ldr	r3, [r7, #4]
    f4ec:	2200      	movs	r2, #0
    f4ee:	719a      	strb	r2, [r3, #6]
	config->reload_action              = TC_RELOAD_ACTION_GCLK;
    f4f0:	687b      	ldr	r3, [r7, #4]
    f4f2:	2200      	movs	r2, #0
    f4f4:	811a      	strh	r2, [r3, #8]
	config->run_in_standby             = false;
    f4f6:	687b      	ldr	r3, [r7, #4]
    f4f8:	2200      	movs	r2, #0
    f4fa:	705a      	strb	r2, [r3, #1]
#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	config->on_demand                  = false;
#endif
	config->waveform_invert_output     = TC_WAVEFORM_INVERT_OUTPUT_NONE;
    f4fc:	687b      	ldr	r3, [r7, #4]
    f4fe:	2200      	movs	r2, #0
    f500:	729a      	strb	r2, [r3, #10]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    f502:	687b      	ldr	r3, [r7, #4]
    f504:	2200      	movs	r2, #0
    f506:	72da      	strb	r2, [r3, #11]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    f508:	687b      	ldr	r3, [r7, #4]
    f50a:	2200      	movs	r2, #0
    f50c:	731a      	strb	r2, [r3, #12]
#ifdef 	FEATURE_TC_IO_CAPTURE
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
	config->enable_capture_on_IO[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
#endif

	config->count_direction            = TC_COUNT_DIRECTION_UP;
    f50e:	687b      	ldr	r3, [r7, #4]
    f510:	2200      	movs	r2, #0
    f512:	739a      	strb	r2, [r3, #14]
	config->oneshot                    = false;
    f514:	687b      	ldr	r3, [r7, #4]
    f516:	2200      	movs	r2, #0
    f518:	735a      	strb	r2, [r3, #13]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].enabled = false;
    f51a:	687b      	ldr	r3, [r7, #4]
    f51c:	2200      	movs	r2, #0
    f51e:	741a      	strb	r2, [r3, #16]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_out = 0;
    f520:	687b      	ldr	r3, [r7, #4]
    f522:	2200      	movs	r2, #0
    f524:	615a      	str	r2, [r3, #20]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_mux = 0;
    f526:	687b      	ldr	r3, [r7, #4]
    f528:	2200      	movs	r2, #0
    f52a:	619a      	str	r2, [r3, #24]

	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].enabled = false;
    f52c:	687b      	ldr	r3, [r7, #4]
    f52e:	2200      	movs	r2, #0
    f530:	771a      	strb	r2, [r3, #28]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_out = 0;
    f532:	687b      	ldr	r3, [r7, #4]
    f534:	2200      	movs	r2, #0
    f536:	621a      	str	r2, [r3, #32]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_mux = 0;
    f538:	687b      	ldr	r3, [r7, #4]
    f53a:	2200      	movs	r2, #0
    f53c:	625a      	str	r2, [r3, #36]	; 0x24

	config->counter_16_bit.value                   = 0x0000;
    f53e:	687b      	ldr	r3, [r7, #4]
    f540:	2200      	movs	r2, #0
    f542:	851a      	strh	r2, [r3, #40]	; 0x28
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_0]                        = 0x0000;
    f544:	687b      	ldr	r3, [r7, #4]
    f546:	2200      	movs	r2, #0
    f548:	855a      	strh	r2, [r3, #42]	; 0x2a
	config->counter_16_bit.compare_capture_channel\
		[TC_COMPARE_CAPTURE_CHANNEL_1]                        = 0x0000;
    f54a:	687b      	ldr	r3, [r7, #4]
    f54c:	2200      	movs	r2, #0
    f54e:	859a      	strh	r2, [r3, #44]	; 0x2c
#ifdef FEATURE_TC_DOUBLE_BUFFERED
	config->double_buffering_enabled = false;
#endif

}
    f550:	46c0      	nop			; (mov r8, r8)
    f552:	46bd      	mov	sp, r7
    f554:	b002      	add	sp, #8
    f556:	bd80      	pop	{r7, pc}

0000f558 <tc_enable>:
 *
 * \param[in]  module_inst   Pointer to the software module instance struct
 */
static inline void tc_enable(
		const struct tc_module *const module_inst)
{
    f558:	b580      	push	{r7, lr}
    f55a:	b084      	sub	sp, #16
    f55c:	af00      	add	r7, sp, #0
    f55e:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);
    f560:	687b      	ldr	r3, [r7, #4]
    f562:	681b      	ldr	r3, [r3, #0]
    f564:	60fb      	str	r3, [r7, #12]

	while (tc_is_syncing(module_inst)) {
    f566:	46c0      	nop			; (mov r8, r8)
    f568:	687b      	ldr	r3, [r7, #4]
    f56a:	0018      	movs	r0, r3
    f56c:	4b07      	ldr	r3, [pc, #28]	; (f58c <tc_enable+0x34>)
    f56e:	4798      	blx	r3
    f570:	1e03      	subs	r3, r0, #0
    f572:	d1f9      	bne.n	f568 <tc_enable+0x10>
		/* Wait for sync */
	}

	/* Enable TC module */
	tc_module->CTRLA.reg |= TC_CTRLA_ENABLE;
    f574:	68fb      	ldr	r3, [r7, #12]
    f576:	881b      	ldrh	r3, [r3, #0]
    f578:	b29b      	uxth	r3, r3
    f57a:	2202      	movs	r2, #2
    f57c:	4313      	orrs	r3, r2
    f57e:	b29a      	uxth	r2, r3
    f580:	68fb      	ldr	r3, [r7, #12]
    f582:	801a      	strh	r2, [r3, #0]
}
    f584:	46c0      	nop			; (mov r8, r8)
    f586:	46bd      	mov	sp, r7
    f588:	b004      	add	sp, #16
    f58a:	bd80      	pop	{r7, pc}
    f58c:	0000f4a9 	.word	0x0000f4a9

0000f590 <_tc_interrupt_get_interrupt_vector>:
 *
 * \return Interrupt vector for of the given TC module instance.
 */
static enum system_interrupt_vector _tc_interrupt_get_interrupt_vector(
		uint32_t inst_num)
{
    f590:	b580      	push	{r7, lr}
    f592:	b082      	sub	sp, #8
    f594:	af00      	add	r7, sp, #0
    f596:	6078      	str	r0, [r7, #4]
#else
			MRECURSION(TC_INST_NUM, _TC_INTERRUPT_VECT_NUM, TC_INST_MAX_ID)
#endif
		};

	return (enum system_interrupt_vector)tc_interrupt_vectors[inst_num];
    f598:	4a04      	ldr	r2, [pc, #16]	; (f5ac <_tc_interrupt_get_interrupt_vector+0x1c>)
    f59a:	687b      	ldr	r3, [r7, #4]
    f59c:	18d3      	adds	r3, r2, r3
    f59e:	781b      	ldrb	r3, [r3, #0]
    f5a0:	b25b      	sxtb	r3, r3
}
    f5a2:	0018      	movs	r0, r3
    f5a4:	46bd      	mov	sp, r7
    f5a6:	b002      	add	sp, #8
    f5a8:	bd80      	pop	{r7, pc}
    f5aa:	46c0      	nop			; (mov r8, r8)
    f5ac:	20000040 	.word	0x20000040

0000f5b0 <tc_enable_callback>:
 * \param[in]     callback_type Callback type given by an enum
 */
static inline void tc_enable_callback(
		struct tc_module *const module,
		const enum tc_callback callback_type)
{
    f5b0:	b580      	push	{r7, lr}
    f5b2:	b082      	sub	sp, #8
    f5b4:	af00      	add	r7, sp, #0
    f5b6:	6078      	str	r0, [r7, #4]
    f5b8:	000a      	movs	r2, r1
    f5ba:	1cfb      	adds	r3, r7, #3
    f5bc:	701a      	strb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);


	/* Enable interrupts for this TC module */
	system_interrupt_enable(_tc_interrupt_get_interrupt_vector(_tc_get_inst_index(module->hw)));
    f5be:	687b      	ldr	r3, [r7, #4]
    f5c0:	681b      	ldr	r3, [r3, #0]
    f5c2:	0018      	movs	r0, r3
    f5c4:	4b22      	ldr	r3, [pc, #136]	; (f650 <tc_enable_callback+0xa0>)
    f5c6:	4798      	blx	r3
    f5c8:	0003      	movs	r3, r0
    f5ca:	0018      	movs	r0, r3
    f5cc:	4b21      	ldr	r3, [pc, #132]	; (f654 <tc_enable_callback+0xa4>)
    f5ce:	4798      	blx	r3
    f5d0:	0003      	movs	r3, r0
    f5d2:	0018      	movs	r0, r3
    f5d4:	4b20      	ldr	r3, [pc, #128]	; (f658 <tc_enable_callback+0xa8>)
    f5d6:	4798      	blx	r3

	/* Enable callback */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
    f5d8:	1cfb      	adds	r3, r7, #3
    f5da:	781b      	ldrb	r3, [r3, #0]
    f5dc:	2b02      	cmp	r3, #2
    f5de:	d10b      	bne.n	f5f8 <tc_enable_callback+0x48>
		module->enable_callback_mask |= TC_INTFLAG_MC(1);
    f5e0:	687b      	ldr	r3, [r7, #4]
    f5e2:	7e5b      	ldrb	r3, [r3, #25]
    f5e4:	2210      	movs	r2, #16
    f5e6:	4313      	orrs	r3, r2
    f5e8:	b2da      	uxtb	r2, r3
    f5ea:	687b      	ldr	r3, [r7, #4]
    f5ec:	765a      	strb	r2, [r3, #25]
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(1);
    f5ee:	687b      	ldr	r3, [r7, #4]
    f5f0:	681b      	ldr	r3, [r3, #0]
    f5f2:	2210      	movs	r2, #16
    f5f4:	735a      	strb	r2, [r3, #13]
	}
	else {
		module->enable_callback_mask |= (1 << callback_type);
		module->hw->COUNT8.INTENSET.reg = (1 << callback_type);
	}
}
    f5f6:	e026      	b.n	f646 <tc_enable_callback+0x96>
	/* Enable callback */
	if (callback_type == TC_CALLBACK_CC_CHANNEL0) {
		module->enable_callback_mask |= TC_INTFLAG_MC(1);
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(1);
	}
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
    f5f8:	1cfb      	adds	r3, r7, #3
    f5fa:	781b      	ldrb	r3, [r3, #0]
    f5fc:	2b03      	cmp	r3, #3
    f5fe:	d10b      	bne.n	f618 <tc_enable_callback+0x68>
		module->enable_callback_mask |= TC_INTFLAG_MC(2);
    f600:	687b      	ldr	r3, [r7, #4]
    f602:	7e5b      	ldrb	r3, [r3, #25]
    f604:	2220      	movs	r2, #32
    f606:	4313      	orrs	r3, r2
    f608:	b2da      	uxtb	r2, r3
    f60a:	687b      	ldr	r3, [r7, #4]
    f60c:	765a      	strb	r2, [r3, #25]
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(2);
    f60e:	687b      	ldr	r3, [r7, #4]
    f610:	681b      	ldr	r3, [r3, #0]
    f612:	2220      	movs	r2, #32
    f614:	735a      	strb	r2, [r3, #13]
	}
	else {
		module->enable_callback_mask |= (1 << callback_type);
		module->hw->COUNT8.INTENSET.reg = (1 << callback_type);
	}
}
    f616:	e016      	b.n	f646 <tc_enable_callback+0x96>
	else if (callback_type == TC_CALLBACK_CC_CHANNEL1) {
		module->enable_callback_mask |= TC_INTFLAG_MC(2);
		module->hw->COUNT8.INTENSET.reg = TC_INTFLAG_MC(2);
	}
	else {
		module->enable_callback_mask |= (1 << callback_type);
    f618:	687b      	ldr	r3, [r7, #4]
    f61a:	7e5b      	ldrb	r3, [r3, #25]
    f61c:	b25a      	sxtb	r2, r3
    f61e:	1cfb      	adds	r3, r7, #3
    f620:	781b      	ldrb	r3, [r3, #0]
    f622:	2101      	movs	r1, #1
    f624:	4099      	lsls	r1, r3
    f626:	000b      	movs	r3, r1
    f628:	b25b      	sxtb	r3, r3
    f62a:	4313      	orrs	r3, r2
    f62c:	b25b      	sxtb	r3, r3
    f62e:	b2da      	uxtb	r2, r3
    f630:	687b      	ldr	r3, [r7, #4]
    f632:	765a      	strb	r2, [r3, #25]
		module->hw->COUNT8.INTENSET.reg = (1 << callback_type);
    f634:	687b      	ldr	r3, [r7, #4]
    f636:	681b      	ldr	r3, [r3, #0]
    f638:	1cfa      	adds	r2, r7, #3
    f63a:	7812      	ldrb	r2, [r2, #0]
    f63c:	2101      	movs	r1, #1
    f63e:	4091      	lsls	r1, r2
    f640:	000a      	movs	r2, r1
    f642:	b2d2      	uxtb	r2, r2
    f644:	735a      	strb	r2, [r3, #13]
	}
}
    f646:	46c0      	nop			; (mov r8, r8)
    f648:	46bd      	mov	sp, r7
    f64a:	b002      	add	sp, #8
    f64c:	bd80      	pop	{r7, pc}
    f64e:	46c0      	nop			; (mov r8, r8)
    f650:	000050ad 	.word	0x000050ad
    f654:	0000f591 	.word	0x0000f591
    f658:	0000f47d 	.word	0x0000f47d

0000f65c <tc_callback>:
 * 1. led blinks every 1 second
 * 2. 30s timer tick
 * 3. implement ms delay
 */
static void tc_callback(struct tc_module *const module_inst)
{
    f65c:	b580      	push	{r7, lr}
    f65e:	b082      	sub	sp, #8
    f660:	af00      	add	r7, sp, #0
    f662:	6078      	str	r0, [r7, #4]
	static uint16_t counter = 0;
	static uint16_t counter_led = 0;
	/* Increase tick. */
	gs_ul_clk_tick++;
    f664:	4b1c      	ldr	r3, [pc, #112]	; (f6d8 <tc_callback+0x7c>)
    f666:	681b      	ldr	r3, [r3, #0]
    f668:	1c5a      	adds	r2, r3, #1
    f66a:	4b1b      	ldr	r3, [pc, #108]	; (f6d8 <tc_callback+0x7c>)
    f66c:	601a      	str	r2, [r3, #0]

	if(sys_delay_ms_counter)
    f66e:	4b1b      	ldr	r3, [pc, #108]	; (f6dc <tc_callback+0x80>)
    f670:	881b      	ldrh	r3, [r3, #0]
    f672:	b29b      	uxth	r3, r3
    f674:	2b00      	cmp	r3, #0
    f676:	d006      	beq.n	f686 <tc_callback+0x2a>
	{
		sys_delay_ms_counter--;
    f678:	4b18      	ldr	r3, [pc, #96]	; (f6dc <tc_callback+0x80>)
    f67a:	881b      	ldrh	r3, [r3, #0]
    f67c:	b29b      	uxth	r3, r3
    f67e:	3b01      	subs	r3, #1
    f680:	b29a      	uxth	r2, r3
    f682:	4b16      	ldr	r3, [pc, #88]	; (f6dc <tc_callback+0x80>)
    f684:	801a      	strh	r2, [r3, #0]
	}

	if(counter == 9999)
    f686:	4b16      	ldr	r3, [pc, #88]	; (f6e0 <tc_callback+0x84>)
    f688:	881b      	ldrh	r3, [r3, #0]
    f68a:	4a16      	ldr	r2, [pc, #88]	; (f6e4 <tc_callback+0x88>)
    f68c:	4293      	cmp	r3, r2
    f68e:	d106      	bne.n	f69e <tc_callback+0x42>
	{
		counter = 0;
    f690:	4b13      	ldr	r3, [pc, #76]	; (f6e0 <tc_callback+0x84>)
    f692:	2200      	movs	r2, #0
    f694:	801a      	strh	r2, [r3, #0]
		sys_timer_30s_tick = 1;
    f696:	4b14      	ldr	r3, [pc, #80]	; (f6e8 <tc_callback+0x8c>)
    f698:	2201      	movs	r2, #1
    f69a:	701a      	strb	r2, [r3, #0]
    f69c:	e005      	b.n	f6aa <tc_callback+0x4e>
	}
	else
	{
		counter++;
    f69e:	4b10      	ldr	r3, [pc, #64]	; (f6e0 <tc_callback+0x84>)
    f6a0:	881b      	ldrh	r3, [r3, #0]
    f6a2:	3301      	adds	r3, #1
    f6a4:	b29a      	uxth	r2, r3
    f6a6:	4b0e      	ldr	r3, [pc, #56]	; (f6e0 <tc_callback+0x84>)
    f6a8:	801a      	strh	r2, [r3, #0]
	}

	if(counter_led == 499)
    f6aa:	4b10      	ldr	r3, [pc, #64]	; (f6ec <tc_callback+0x90>)
    f6ac:	881a      	ldrh	r2, [r3, #0]
    f6ae:	23f4      	movs	r3, #244	; 0xf4
    f6b0:	33ff      	adds	r3, #255	; 0xff
    f6b2:	429a      	cmp	r2, r3
    f6b4:	d106      	bne.n	f6c4 <tc_callback+0x68>
	{
		counter_led = 0;
    f6b6:	4b0d      	ldr	r3, [pc, #52]	; (f6ec <tc_callback+0x90>)
    f6b8:	2200      	movs	r2, #0
    f6ba:	801a      	strh	r2, [r3, #0]
		port_pin_toggle_output_level(MCU_LED1);
    f6bc:	2002      	movs	r0, #2
    f6be:	4b0c      	ldr	r3, [pc, #48]	; (f6f0 <tc_callback+0x94>)
    f6c0:	4798      	blx	r3
	}
	else
	{
		counter_led++;
	}
}
    f6c2:	e005      	b.n	f6d0 <tc_callback+0x74>
		counter_led = 0;
		port_pin_toggle_output_level(MCU_LED1);
	}
	else
	{
		counter_led++;
    f6c4:	4b09      	ldr	r3, [pc, #36]	; (f6ec <tc_callback+0x90>)
    f6c6:	881b      	ldrh	r3, [r3, #0]
    f6c8:	3301      	adds	r3, #1
    f6ca:	b29a      	uxth	r2, r3
    f6cc:	4b07      	ldr	r3, [pc, #28]	; (f6ec <tc_callback+0x90>)
    f6ce:	801a      	strh	r2, [r3, #0]
	}
}
    f6d0:	46c0      	nop			; (mov r8, r8)
    f6d2:	46bd      	mov	sp, r7
    f6d4:	b002      	add	sp, #8
    f6d6:	bd80      	pop	{r7, pc}
    f6d8:	20002da8 	.word	0x20002da8
    f6dc:	20002dae 	.word	0x20002dae
    f6e0:	20002db0 	.word	0x20002db0
    f6e4:	0000270f 	.word	0x0000270f
    f6e8:	20002dac 	.word	0x20002dac
    f6ec:	20002db2 	.word	0x20002db2
    f6f0:	0000f425 	.word	0x0000f425

0000f6f4 <configure_led>:
/* led pin configure function */
static void configure_led(void)
{
    f6f4:	b580      	push	{r7, lr}
    f6f6:	b082      	sub	sp, #8
    f6f8:	af00      	add	r7, sp, #0
	struct port_config config_led;
	port_get_config_defaults(&config_led);
    f6fa:	1d3b      	adds	r3, r7, #4
    f6fc:	0018      	movs	r0, r3
    f6fe:	4b09      	ldr	r3, [pc, #36]	; (f724 <configure_led+0x30>)
    f700:	4798      	blx	r3

	config_led.direction = PORT_PIN_DIR_OUTPUT;
    f702:	1d3b      	adds	r3, r7, #4
    f704:	2201      	movs	r2, #1
    f706:	701a      	strb	r2, [r3, #0]

	port_pin_set_config(MCU_LED1,&config_led);
    f708:	1d3b      	adds	r3, r7, #4
    f70a:	0019      	movs	r1, r3
    f70c:	2002      	movs	r0, #2
    f70e:	4b06      	ldr	r3, [pc, #24]	; (f728 <configure_led+0x34>)
    f710:	4798      	blx	r3
	port_pin_set_output_level(MCU_LED1,true);
    f712:	2101      	movs	r1, #1
    f714:	2002      	movs	r0, #2
    f716:	4b05      	ldr	r3, [pc, #20]	; (f72c <configure_led+0x38>)
    f718:	4798      	blx	r3
}
    f71a:	46c0      	nop			; (mov r8, r8)
    f71c:	46bd      	mov	sp, r7
    f71e:	b002      	add	sp, #8
    f720:	bd80      	pop	{r7, pc}
    f722:	46c0      	nop			; (mov r8, r8)
    f724:	0000f3ad 	.word	0x0000f3ad
    f728:	00002a8d 	.word	0x00002a8d
    f72c:	0000f3d1 	.word	0x0000f3d1

0000f730 <sys_delay_ms>:

/* 
 * ms delay function
 */
uint16_t sys_delay_ms(uint16_t ms)
{
    f730:	b580      	push	{r7, lr}
    f732:	b082      	sub	sp, #8
    f734:	af00      	add	r7, sp, #0
    f736:	0002      	movs	r2, r0
    f738:	1dbb      	adds	r3, r7, #6
    f73a:	801a      	strh	r2, [r3, #0]
	if(ms)
    f73c:	1dbb      	adds	r3, r7, #6
    f73e:	881b      	ldrh	r3, [r3, #0]
    f740:	2b00      	cmp	r3, #0
    f742:	d003      	beq.n	f74c <sys_delay_ms+0x1c>
	{
		sys_delay_ms_counter = ms;
    f744:	4b05      	ldr	r3, [pc, #20]	; (f75c <sys_delay_ms+0x2c>)
    f746:	1dba      	adds	r2, r7, #6
    f748:	8812      	ldrh	r2, [r2, #0]
    f74a:	801a      	strh	r2, [r3, #0]
	}
	return sys_delay_ms_counter;
    f74c:	4b03      	ldr	r3, [pc, #12]	; (f75c <sys_delay_ms+0x2c>)
    f74e:	881b      	ldrh	r3, [r3, #0]
    f750:	b29b      	uxth	r3, r3
}
    f752:	0018      	movs	r0, r3
    f754:	46bd      	mov	sp, r7
    f756:	b002      	add	sp, #8
    f758:	bd80      	pop	{r7, pc}
    f75a:	46c0      	nop			; (mov r8, r8)
    f75c:	20002dae 	.word	0x20002dae

0000f760 <sys_init_timing>:


void sys_init_timing(void)
{
    f760:	b580      	push	{r7, lr}
    f762:	b08e      	sub	sp, #56	; 0x38
    f764:	af00      	add	r7, sp, #0
	struct tc_config config_tc;
	tc_get_config_defaults(&config_tc);
    f766:	1d3b      	adds	r3, r7, #4
    f768:	0018      	movs	r0, r3
    f76a:	4b17      	ldr	r3, [pc, #92]	; (f7c8 <sys_init_timing+0x68>)
    f76c:	4798      	blx	r3
	configure_led();
    f76e:	4b17      	ldr	r3, [pc, #92]	; (f7cc <sys_init_timing+0x6c>)
    f770:	4798      	blx	r3

	config_tc.counter_size    = TC_COUNTER_SIZE_16BIT;
    f772:	1d3b      	adds	r3, r7, #4
    f774:	2200      	movs	r2, #0
    f776:	709a      	strb	r2, [r3, #2]
	config_tc.wave_generation = TC_WAVE_GENERATION_MATCH_FREQ;
    f778:	1d3b      	adds	r3, r7, #4
    f77a:	2220      	movs	r2, #32
    f77c:	719a      	strb	r2, [r3, #6]
	config_tc.counter_16_bit.compare_capture_channel[0] = 0x5DC0;
    f77e:	1d3b      	adds	r3, r7, #4
    f780:	4a13      	ldr	r2, [pc, #76]	; (f7d0 <sys_init_timing+0x70>)
    f782:	855a      	strh	r2, [r3, #42]	; 0x2a
	config_tc.clock_source = GCLK_GENERATOR_0;
    f784:	1d3b      	adds	r3, r7, #4
    f786:	2200      	movs	r2, #0
    f788:	701a      	strb	r2, [r3, #0]
	config_tc.clock_prescaler = TC_CLOCK_PRESCALER_DIV2;
    f78a:	1d3b      	adds	r3, r7, #4
    f78c:	2280      	movs	r2, #128	; 0x80
    f78e:	0052      	lsls	r2, r2, #1
    f790:	809a      	strh	r2, [r3, #4]

	tc_init(&tc_instance, TC0, &config_tc);
    f792:	1d3a      	adds	r2, r7, #4
    f794:	490f      	ldr	r1, [pc, #60]	; (f7d4 <sys_init_timing+0x74>)
    f796:	4b10      	ldr	r3, [pc, #64]	; (f7d8 <sys_init_timing+0x78>)
    f798:	0018      	movs	r0, r3
    f79a:	4b10      	ldr	r3, [pc, #64]	; (f7dc <sys_init_timing+0x7c>)
    f79c:	4798      	blx	r3
	tc_enable(&tc_instance);
    f79e:	4b0e      	ldr	r3, [pc, #56]	; (f7d8 <sys_init_timing+0x78>)
    f7a0:	0018      	movs	r0, r3
    f7a2:	4b0f      	ldr	r3, [pc, #60]	; (f7e0 <sys_init_timing+0x80>)
    f7a4:	4798      	blx	r3
	tc_register_callback(&tc_instance, tc_callback, TC_CALLBACK_CC_CHANNEL0);
    f7a6:	490f      	ldr	r1, [pc, #60]	; (f7e4 <sys_init_timing+0x84>)
    f7a8:	4b0b      	ldr	r3, [pc, #44]	; (f7d8 <sys_init_timing+0x78>)
    f7aa:	2202      	movs	r2, #2
    f7ac:	0018      	movs	r0, r3
    f7ae:	4b0e      	ldr	r3, [pc, #56]	; (f7e8 <sys_init_timing+0x88>)
    f7b0:	4798      	blx	r3
	tc_enable_callback(&tc_instance, TC_CALLBACK_CC_CHANNEL0);
    f7b2:	4b09      	ldr	r3, [pc, #36]	; (f7d8 <sys_init_timing+0x78>)
    f7b4:	2102      	movs	r1, #2
    f7b6:	0018      	movs	r0, r3
    f7b8:	4b0c      	ldr	r3, [pc, #48]	; (f7ec <sys_init_timing+0x8c>)
    f7ba:	4798      	blx	r3

	/* Enable system interrupts. */
	system_interrupt_enable_global();
    f7bc:	4b0c      	ldr	r3, [pc, #48]	; (f7f0 <sys_init_timing+0x90>)
    f7be:	4798      	blx	r3
}
    f7c0:	46c0      	nop			; (mov r8, r8)
    f7c2:	46bd      	mov	sp, r7
    f7c4:	b00e      	add	sp, #56	; 0x38
    f7c6:	bd80      	pop	{r7, pc}
    f7c8:	0000f4d1 	.word	0x0000f4d1
    f7cc:	0000f6f5 	.word	0x0000f6f5
    f7d0:	00005dc0 	.word	0x00005dc0
    f7d4:	42002000 	.word	0x42002000
    f7d8:	20003f28 	.word	0x20003f28
    f7dc:	000050fd 	.word	0x000050fd
    f7e0:	0000f559 	.word	0x0000f559
    f7e4:	0000f65d 	.word	0x0000f65d
    f7e8:	00004e1d 	.word	0x00004e1d
    f7ec:	0000f5b1 	.word	0x0000f5b1
    f7f0:	0000f461 	.word	0x0000f461

0000f7f4 <sys_get_ms>:

/**
 * \brief Return the number of timer ticks (ms).
 */
uint32_t sys_get_ms(void)
{
    f7f4:	b580      	push	{r7, lr}
    f7f6:	af00      	add	r7, sp, #0
	return gs_ul_clk_tick;
    f7f8:	4b02      	ldr	r3, [pc, #8]	; (f804 <sys_get_ms+0x10>)
    f7fa:	681b      	ldr	r3, [r3, #0]
}
    f7fc:	0018      	movs	r0, r3
    f7fe:	46bd      	mov	sp, r7
    f800:	bd80      	pop	{r7, pc}
    f802:	46c0      	nop			; (mov r8, r8)
    f804:	20002da8 	.word	0x20002da8

0000f808 <sys_now>:

#if ((LWIP_VERSION) != ((1U << 24) | (3U << 16) | (2U << 8) | (LWIP_VERSION_RC)))
u32_t sys_now(void)
{
    f808:	b580      	push	{r7, lr}
    f80a:	af00      	add	r7, sp, #0
	return (sys_get_ms());
    f80c:	4b02      	ldr	r3, [pc, #8]	; (f818 <sys_now+0x10>)
    f80e:	4798      	blx	r3
    f810:	0003      	movs	r3, r0
}
    f812:	0018      	movs	r0, r3
    f814:	46bd      	mov	sp, r7
    f816:	bd80      	pop	{r7, pc}
    f818:	0000f7f5 	.word	0x0000f7f5

0000f81c <system_pinmux_get_config_defaults>:
 *
 * \param[out] config  Configuration structure to initialize to default values
 */
static inline void system_pinmux_get_config_defaults(
		struct system_pinmux_config *const config)
{
    f81c:	b580      	push	{r7, lr}
    f81e:	b082      	sub	sp, #8
    f820:	af00      	add	r7, sp, #0
    f822:	6078      	str	r0, [r7, #4]
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->mux_position = SYSTEM_PINMUX_GPIO;
    f824:	687b      	ldr	r3, [r7, #4]
    f826:	2280      	movs	r2, #128	; 0x80
    f828:	701a      	strb	r2, [r3, #0]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    f82a:	687b      	ldr	r3, [r7, #4]
    f82c:	2200      	movs	r2, #0
    f82e:	705a      	strb	r2, [r3, #1]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    f830:	687b      	ldr	r3, [r7, #4]
    f832:	2201      	movs	r2, #1
    f834:	709a      	strb	r2, [r3, #2]
	config->powersave    = false;
    f836:	687b      	ldr	r3, [r7, #4]
    f838:	2200      	movs	r2, #0
    f83a:	70da      	strb	r2, [r3, #3]
}
    f83c:	46c0      	nop			; (mov r8, r8)
    f83e:	46bd      	mov	sp, r7
    f840:	b002      	add	sp, #8
    f842:	bd80      	pop	{r7, pc}

0000f844 <main>:
/**
 * \brief Main program function. Configure the hardware, initialize lwIP
 * TCP/IP stack, and start HTTP service.
 */
int main(void)
{
    f844:	b580      	push	{r7, lr}
    f846:	b082      	sub	sp, #8
    f848:	af00      	add	r7, sp, #0
	uint16_t timer_count = 0;
    f84a:	1dbb      	adds	r3, r7, #6
    f84c:	2200      	movs	r2, #0
    f84e:	801a      	strh	r2, [r3, #0]
	/* Initialize the SAM system. */
	system_init();
    f850:	4b0c      	ldr	r3, [pc, #48]	; (f884 <main+0x40>)
    f852:	4798      	blx	r3
	delay_init();
    f854:	4b0c      	ldr	r3, [pc, #48]	; (f888 <main+0x44>)
    f856:	4798      	blx	r3
	configure_pinmux();
    f858:	4b0c      	ldr	r3, [pc, #48]	; (f88c <main+0x48>)
    f85a:	4798      	blx	r3

	///* Print example information. */
	////puts(STRING_HEADER);
//
	///* Bring up the ethernet interface & initialize timer0, channel0. */
	init_ethernet();
    f85c:	4b0c      	ldr	r3, [pc, #48]	; (f890 <main+0x4c>)
    f85e:	4798      	blx	r3
	
	smbus_init();
    f860:	4b0c      	ldr	r3, [pc, #48]	; (f894 <main+0x50>)
    f862:	4798      	blx	r3

	/* Bring up the web server. */
	httpd_init();
    f864:	4b0c      	ldr	r3, [pc, #48]	; (f898 <main+0x54>)
    f866:	4798      	blx	r3

	/* Program main loop. */
	while (1) 
	{
		/* Check for input packet and process it. */
		ethernet_task();
    f868:	4b0c      	ldr	r3, [pc, #48]	; (f89c <main+0x58>)
    f86a:	4798      	blx	r3
		if(sys_timer_30s_tick)
    f86c:	4b0c      	ldr	r3, [pc, #48]	; (f8a0 <main+0x5c>)
    f86e:	781b      	ldrb	r3, [r3, #0]
    f870:	b2db      	uxtb	r3, r3
    f872:	2b00      	cmp	r3, #0
    f874:	d0f8      	beq.n	f868 <main+0x24>
		{
			sys_timer_30s_tick = 0;
    f876:	4b0a      	ldr	r3, [pc, #40]	; (f8a0 <main+0x5c>)
    f878:	2200      	movs	r2, #0
    f87a:	701a      	strb	r2, [r3, #0]
			smbus_read_all_info();
    f87c:	4b09      	ldr	r3, [pc, #36]	; (f8a4 <main+0x60>)
    f87e:	4798      	blx	r3
		}
	}
    f880:	e7f2      	b.n	f868 <main+0x24>
    f882:	46c0      	nop			; (mov r8, r8)
    f884:	00004de9 	.word	0x00004de9
    f888:	000018d5 	.word	0x000018d5
    f88c:	0000f8a9 	.word	0x0000f8a9
    f890:	0000f0f5 	.word	0x0000f0f5
    f894:	00000fe1 	.word	0x00000fe1
    f898:	0000f2d5 	.word	0x0000f2d5
    f89c:	0000f165 	.word	0x0000f165
    f8a0:	20002dac 	.word	0x20002dac
    f8a4:	00001811 	.word	0x00001811

0000f8a8 <configure_pinmux>:
}


void configure_pinmux(void)
{
    f8a8:	b580      	push	{r7, lr}
    f8aa:	b082      	sub	sp, #8
    f8ac:	af00      	add	r7, sp, #0
	struct system_pinmux_config config_pinmux;
	system_pinmux_get_config_defaults(&config_pinmux);
    f8ae:	1d3b      	adds	r3, r7, #4
    f8b0:	0018      	movs	r0, r3
    f8b2:	4b0c      	ldr	r3, [pc, #48]	; (f8e4 <configure_pinmux+0x3c>)
    f8b4:	4798      	blx	r3
	
	config_pinmux.mux_position = 3;
    f8b6:	1d3b      	adds	r3, r7, #4
    f8b8:	2203      	movs	r2, #3
    f8ba:	701a      	strb	r2, [r3, #0]
	
	system_pinmux_pin_set_config(ETHERNET_SPI_MOSI,&config_pinmux);
    f8bc:	1d3b      	adds	r3, r7, #4
    f8be:	0019      	movs	r1, r3
    f8c0:	203e      	movs	r0, #62	; 0x3e
    f8c2:	4b09      	ldr	r3, [pc, #36]	; (f8e8 <configure_pinmux+0x40>)
    f8c4:	4798      	blx	r3
	system_pinmux_pin_set_config(ETHERNET_SPI_SCK,&config_pinmux);
    f8c6:	1d3b      	adds	r3, r7, #4
    f8c8:	0019      	movs	r1, r3
    f8ca:	203f      	movs	r0, #63	; 0x3f
    f8cc:	4b06      	ldr	r3, [pc, #24]	; (f8e8 <configure_pinmux+0x40>)
    f8ce:	4798      	blx	r3
	system_pinmux_pin_set_config(ETHERNET_SPI_MISO,&config_pinmux);
    f8d0:	1d3b      	adds	r3, r7, #4
    f8d2:	0019      	movs	r1, r3
    f8d4:	2020      	movs	r0, #32
    f8d6:	4b04      	ldr	r3, [pc, #16]	; (f8e8 <configure_pinmux+0x40>)
    f8d8:	4798      	blx	r3
    f8da:	46c0      	nop			; (mov r8, r8)
    f8dc:	46bd      	mov	sp, r7
    f8de:	b002      	add	sp, #8
    f8e0:	bd80      	pop	{r7, pc}
    f8e2:	46c0      	nop			; (mov r8, r8)
    f8e4:	0000f81d 	.word	0x0000f81d
    f8e8:	00004d95 	.word	0x00004d95

0000f8ec <__aeabi_uidiv>:
    f8ec:	2200      	movs	r2, #0
    f8ee:	0843      	lsrs	r3, r0, #1
    f8f0:	428b      	cmp	r3, r1
    f8f2:	d374      	bcc.n	f9de <__aeabi_uidiv+0xf2>
    f8f4:	0903      	lsrs	r3, r0, #4
    f8f6:	428b      	cmp	r3, r1
    f8f8:	d35f      	bcc.n	f9ba <__aeabi_uidiv+0xce>
    f8fa:	0a03      	lsrs	r3, r0, #8
    f8fc:	428b      	cmp	r3, r1
    f8fe:	d344      	bcc.n	f98a <__aeabi_uidiv+0x9e>
    f900:	0b03      	lsrs	r3, r0, #12
    f902:	428b      	cmp	r3, r1
    f904:	d328      	bcc.n	f958 <__aeabi_uidiv+0x6c>
    f906:	0c03      	lsrs	r3, r0, #16
    f908:	428b      	cmp	r3, r1
    f90a:	d30d      	bcc.n	f928 <__aeabi_uidiv+0x3c>
    f90c:	22ff      	movs	r2, #255	; 0xff
    f90e:	0209      	lsls	r1, r1, #8
    f910:	ba12      	rev	r2, r2
    f912:	0c03      	lsrs	r3, r0, #16
    f914:	428b      	cmp	r3, r1
    f916:	d302      	bcc.n	f91e <__aeabi_uidiv+0x32>
    f918:	1212      	asrs	r2, r2, #8
    f91a:	0209      	lsls	r1, r1, #8
    f91c:	d065      	beq.n	f9ea <__aeabi_uidiv+0xfe>
    f91e:	0b03      	lsrs	r3, r0, #12
    f920:	428b      	cmp	r3, r1
    f922:	d319      	bcc.n	f958 <__aeabi_uidiv+0x6c>
    f924:	e000      	b.n	f928 <__aeabi_uidiv+0x3c>
    f926:	0a09      	lsrs	r1, r1, #8
    f928:	0bc3      	lsrs	r3, r0, #15
    f92a:	428b      	cmp	r3, r1
    f92c:	d301      	bcc.n	f932 <__aeabi_uidiv+0x46>
    f92e:	03cb      	lsls	r3, r1, #15
    f930:	1ac0      	subs	r0, r0, r3
    f932:	4152      	adcs	r2, r2
    f934:	0b83      	lsrs	r3, r0, #14
    f936:	428b      	cmp	r3, r1
    f938:	d301      	bcc.n	f93e <__aeabi_uidiv+0x52>
    f93a:	038b      	lsls	r3, r1, #14
    f93c:	1ac0      	subs	r0, r0, r3
    f93e:	4152      	adcs	r2, r2
    f940:	0b43      	lsrs	r3, r0, #13
    f942:	428b      	cmp	r3, r1
    f944:	d301      	bcc.n	f94a <__aeabi_uidiv+0x5e>
    f946:	034b      	lsls	r3, r1, #13
    f948:	1ac0      	subs	r0, r0, r3
    f94a:	4152      	adcs	r2, r2
    f94c:	0b03      	lsrs	r3, r0, #12
    f94e:	428b      	cmp	r3, r1
    f950:	d301      	bcc.n	f956 <__aeabi_uidiv+0x6a>
    f952:	030b      	lsls	r3, r1, #12
    f954:	1ac0      	subs	r0, r0, r3
    f956:	4152      	adcs	r2, r2
    f958:	0ac3      	lsrs	r3, r0, #11
    f95a:	428b      	cmp	r3, r1
    f95c:	d301      	bcc.n	f962 <__aeabi_uidiv+0x76>
    f95e:	02cb      	lsls	r3, r1, #11
    f960:	1ac0      	subs	r0, r0, r3
    f962:	4152      	adcs	r2, r2
    f964:	0a83      	lsrs	r3, r0, #10
    f966:	428b      	cmp	r3, r1
    f968:	d301      	bcc.n	f96e <__aeabi_uidiv+0x82>
    f96a:	028b      	lsls	r3, r1, #10
    f96c:	1ac0      	subs	r0, r0, r3
    f96e:	4152      	adcs	r2, r2
    f970:	0a43      	lsrs	r3, r0, #9
    f972:	428b      	cmp	r3, r1
    f974:	d301      	bcc.n	f97a <__aeabi_uidiv+0x8e>
    f976:	024b      	lsls	r3, r1, #9
    f978:	1ac0      	subs	r0, r0, r3
    f97a:	4152      	adcs	r2, r2
    f97c:	0a03      	lsrs	r3, r0, #8
    f97e:	428b      	cmp	r3, r1
    f980:	d301      	bcc.n	f986 <__aeabi_uidiv+0x9a>
    f982:	020b      	lsls	r3, r1, #8
    f984:	1ac0      	subs	r0, r0, r3
    f986:	4152      	adcs	r2, r2
    f988:	d2cd      	bcs.n	f926 <__aeabi_uidiv+0x3a>
    f98a:	09c3      	lsrs	r3, r0, #7
    f98c:	428b      	cmp	r3, r1
    f98e:	d301      	bcc.n	f994 <__aeabi_uidiv+0xa8>
    f990:	01cb      	lsls	r3, r1, #7
    f992:	1ac0      	subs	r0, r0, r3
    f994:	4152      	adcs	r2, r2
    f996:	0983      	lsrs	r3, r0, #6
    f998:	428b      	cmp	r3, r1
    f99a:	d301      	bcc.n	f9a0 <__aeabi_uidiv+0xb4>
    f99c:	018b      	lsls	r3, r1, #6
    f99e:	1ac0      	subs	r0, r0, r3
    f9a0:	4152      	adcs	r2, r2
    f9a2:	0943      	lsrs	r3, r0, #5
    f9a4:	428b      	cmp	r3, r1
    f9a6:	d301      	bcc.n	f9ac <__aeabi_uidiv+0xc0>
    f9a8:	014b      	lsls	r3, r1, #5
    f9aa:	1ac0      	subs	r0, r0, r3
    f9ac:	4152      	adcs	r2, r2
    f9ae:	0903      	lsrs	r3, r0, #4
    f9b0:	428b      	cmp	r3, r1
    f9b2:	d301      	bcc.n	f9b8 <__aeabi_uidiv+0xcc>
    f9b4:	010b      	lsls	r3, r1, #4
    f9b6:	1ac0      	subs	r0, r0, r3
    f9b8:	4152      	adcs	r2, r2
    f9ba:	08c3      	lsrs	r3, r0, #3
    f9bc:	428b      	cmp	r3, r1
    f9be:	d301      	bcc.n	f9c4 <__aeabi_uidiv+0xd8>
    f9c0:	00cb      	lsls	r3, r1, #3
    f9c2:	1ac0      	subs	r0, r0, r3
    f9c4:	4152      	adcs	r2, r2
    f9c6:	0883      	lsrs	r3, r0, #2
    f9c8:	428b      	cmp	r3, r1
    f9ca:	d301      	bcc.n	f9d0 <__aeabi_uidiv+0xe4>
    f9cc:	008b      	lsls	r3, r1, #2
    f9ce:	1ac0      	subs	r0, r0, r3
    f9d0:	4152      	adcs	r2, r2
    f9d2:	0843      	lsrs	r3, r0, #1
    f9d4:	428b      	cmp	r3, r1
    f9d6:	d301      	bcc.n	f9dc <__aeabi_uidiv+0xf0>
    f9d8:	004b      	lsls	r3, r1, #1
    f9da:	1ac0      	subs	r0, r0, r3
    f9dc:	4152      	adcs	r2, r2
    f9de:	1a41      	subs	r1, r0, r1
    f9e0:	d200      	bcs.n	f9e4 <__aeabi_uidiv+0xf8>
    f9e2:	4601      	mov	r1, r0
    f9e4:	4152      	adcs	r2, r2
    f9e6:	4610      	mov	r0, r2
    f9e8:	4770      	bx	lr
    f9ea:	e7ff      	b.n	f9ec <__aeabi_uidiv+0x100>
    f9ec:	b501      	push	{r0, lr}
    f9ee:	2000      	movs	r0, #0
    f9f0:	f000 f8f0 	bl	fbd4 <__aeabi_idiv0>
    f9f4:	bd02      	pop	{r1, pc}
    f9f6:	46c0      	nop			; (mov r8, r8)

0000f9f8 <__aeabi_uidivmod>:
    f9f8:	2900      	cmp	r1, #0
    f9fa:	d0f7      	beq.n	f9ec <__aeabi_uidiv+0x100>
    f9fc:	e776      	b.n	f8ec <__aeabi_uidiv>
    f9fe:	4770      	bx	lr

0000fa00 <__aeabi_idiv>:
    fa00:	4603      	mov	r3, r0
    fa02:	430b      	orrs	r3, r1
    fa04:	d47f      	bmi.n	fb06 <__aeabi_idiv+0x106>
    fa06:	2200      	movs	r2, #0
    fa08:	0843      	lsrs	r3, r0, #1
    fa0a:	428b      	cmp	r3, r1
    fa0c:	d374      	bcc.n	faf8 <__aeabi_idiv+0xf8>
    fa0e:	0903      	lsrs	r3, r0, #4
    fa10:	428b      	cmp	r3, r1
    fa12:	d35f      	bcc.n	fad4 <__aeabi_idiv+0xd4>
    fa14:	0a03      	lsrs	r3, r0, #8
    fa16:	428b      	cmp	r3, r1
    fa18:	d344      	bcc.n	faa4 <__aeabi_idiv+0xa4>
    fa1a:	0b03      	lsrs	r3, r0, #12
    fa1c:	428b      	cmp	r3, r1
    fa1e:	d328      	bcc.n	fa72 <__aeabi_idiv+0x72>
    fa20:	0c03      	lsrs	r3, r0, #16
    fa22:	428b      	cmp	r3, r1
    fa24:	d30d      	bcc.n	fa42 <__aeabi_idiv+0x42>
    fa26:	22ff      	movs	r2, #255	; 0xff
    fa28:	0209      	lsls	r1, r1, #8
    fa2a:	ba12      	rev	r2, r2
    fa2c:	0c03      	lsrs	r3, r0, #16
    fa2e:	428b      	cmp	r3, r1
    fa30:	d302      	bcc.n	fa38 <__aeabi_idiv+0x38>
    fa32:	1212      	asrs	r2, r2, #8
    fa34:	0209      	lsls	r1, r1, #8
    fa36:	d065      	beq.n	fb04 <__aeabi_idiv+0x104>
    fa38:	0b03      	lsrs	r3, r0, #12
    fa3a:	428b      	cmp	r3, r1
    fa3c:	d319      	bcc.n	fa72 <__aeabi_idiv+0x72>
    fa3e:	e000      	b.n	fa42 <__aeabi_idiv+0x42>
    fa40:	0a09      	lsrs	r1, r1, #8
    fa42:	0bc3      	lsrs	r3, r0, #15
    fa44:	428b      	cmp	r3, r1
    fa46:	d301      	bcc.n	fa4c <__aeabi_idiv+0x4c>
    fa48:	03cb      	lsls	r3, r1, #15
    fa4a:	1ac0      	subs	r0, r0, r3
    fa4c:	4152      	adcs	r2, r2
    fa4e:	0b83      	lsrs	r3, r0, #14
    fa50:	428b      	cmp	r3, r1
    fa52:	d301      	bcc.n	fa58 <__aeabi_idiv+0x58>
    fa54:	038b      	lsls	r3, r1, #14
    fa56:	1ac0      	subs	r0, r0, r3
    fa58:	4152      	adcs	r2, r2
    fa5a:	0b43      	lsrs	r3, r0, #13
    fa5c:	428b      	cmp	r3, r1
    fa5e:	d301      	bcc.n	fa64 <__aeabi_idiv+0x64>
    fa60:	034b      	lsls	r3, r1, #13
    fa62:	1ac0      	subs	r0, r0, r3
    fa64:	4152      	adcs	r2, r2
    fa66:	0b03      	lsrs	r3, r0, #12
    fa68:	428b      	cmp	r3, r1
    fa6a:	d301      	bcc.n	fa70 <__aeabi_idiv+0x70>
    fa6c:	030b      	lsls	r3, r1, #12
    fa6e:	1ac0      	subs	r0, r0, r3
    fa70:	4152      	adcs	r2, r2
    fa72:	0ac3      	lsrs	r3, r0, #11
    fa74:	428b      	cmp	r3, r1
    fa76:	d301      	bcc.n	fa7c <__aeabi_idiv+0x7c>
    fa78:	02cb      	lsls	r3, r1, #11
    fa7a:	1ac0      	subs	r0, r0, r3
    fa7c:	4152      	adcs	r2, r2
    fa7e:	0a83      	lsrs	r3, r0, #10
    fa80:	428b      	cmp	r3, r1
    fa82:	d301      	bcc.n	fa88 <__aeabi_idiv+0x88>
    fa84:	028b      	lsls	r3, r1, #10
    fa86:	1ac0      	subs	r0, r0, r3
    fa88:	4152      	adcs	r2, r2
    fa8a:	0a43      	lsrs	r3, r0, #9
    fa8c:	428b      	cmp	r3, r1
    fa8e:	d301      	bcc.n	fa94 <__aeabi_idiv+0x94>
    fa90:	024b      	lsls	r3, r1, #9
    fa92:	1ac0      	subs	r0, r0, r3
    fa94:	4152      	adcs	r2, r2
    fa96:	0a03      	lsrs	r3, r0, #8
    fa98:	428b      	cmp	r3, r1
    fa9a:	d301      	bcc.n	faa0 <__aeabi_idiv+0xa0>
    fa9c:	020b      	lsls	r3, r1, #8
    fa9e:	1ac0      	subs	r0, r0, r3
    faa0:	4152      	adcs	r2, r2
    faa2:	d2cd      	bcs.n	fa40 <__aeabi_idiv+0x40>
    faa4:	09c3      	lsrs	r3, r0, #7
    faa6:	428b      	cmp	r3, r1
    faa8:	d301      	bcc.n	faae <__aeabi_idiv+0xae>
    faaa:	01cb      	lsls	r3, r1, #7
    faac:	1ac0      	subs	r0, r0, r3
    faae:	4152      	adcs	r2, r2
    fab0:	0983      	lsrs	r3, r0, #6
    fab2:	428b      	cmp	r3, r1
    fab4:	d301      	bcc.n	faba <__aeabi_idiv+0xba>
    fab6:	018b      	lsls	r3, r1, #6
    fab8:	1ac0      	subs	r0, r0, r3
    faba:	4152      	adcs	r2, r2
    fabc:	0943      	lsrs	r3, r0, #5
    fabe:	428b      	cmp	r3, r1
    fac0:	d301      	bcc.n	fac6 <__aeabi_idiv+0xc6>
    fac2:	014b      	lsls	r3, r1, #5
    fac4:	1ac0      	subs	r0, r0, r3
    fac6:	4152      	adcs	r2, r2
    fac8:	0903      	lsrs	r3, r0, #4
    faca:	428b      	cmp	r3, r1
    facc:	d301      	bcc.n	fad2 <__aeabi_idiv+0xd2>
    face:	010b      	lsls	r3, r1, #4
    fad0:	1ac0      	subs	r0, r0, r3
    fad2:	4152      	adcs	r2, r2
    fad4:	08c3      	lsrs	r3, r0, #3
    fad6:	428b      	cmp	r3, r1
    fad8:	d301      	bcc.n	fade <__aeabi_idiv+0xde>
    fada:	00cb      	lsls	r3, r1, #3
    fadc:	1ac0      	subs	r0, r0, r3
    fade:	4152      	adcs	r2, r2
    fae0:	0883      	lsrs	r3, r0, #2
    fae2:	428b      	cmp	r3, r1
    fae4:	d301      	bcc.n	faea <__aeabi_idiv+0xea>
    fae6:	008b      	lsls	r3, r1, #2
    fae8:	1ac0      	subs	r0, r0, r3
    faea:	4152      	adcs	r2, r2
    faec:	0843      	lsrs	r3, r0, #1
    faee:	428b      	cmp	r3, r1
    faf0:	d301      	bcc.n	faf6 <__aeabi_idiv+0xf6>
    faf2:	004b      	lsls	r3, r1, #1
    faf4:	1ac0      	subs	r0, r0, r3
    faf6:	4152      	adcs	r2, r2
    faf8:	1a41      	subs	r1, r0, r1
    fafa:	d200      	bcs.n	fafe <__aeabi_idiv+0xfe>
    fafc:	4601      	mov	r1, r0
    fafe:	4152      	adcs	r2, r2
    fb00:	4610      	mov	r0, r2
    fb02:	4770      	bx	lr
    fb04:	e05d      	b.n	fbc2 <__aeabi_idiv+0x1c2>
    fb06:	0fca      	lsrs	r2, r1, #31
    fb08:	d000      	beq.n	fb0c <__aeabi_idiv+0x10c>
    fb0a:	4249      	negs	r1, r1
    fb0c:	1003      	asrs	r3, r0, #32
    fb0e:	d300      	bcc.n	fb12 <__aeabi_idiv+0x112>
    fb10:	4240      	negs	r0, r0
    fb12:	4053      	eors	r3, r2
    fb14:	2200      	movs	r2, #0
    fb16:	469c      	mov	ip, r3
    fb18:	0903      	lsrs	r3, r0, #4
    fb1a:	428b      	cmp	r3, r1
    fb1c:	d32d      	bcc.n	fb7a <__aeabi_idiv+0x17a>
    fb1e:	0a03      	lsrs	r3, r0, #8
    fb20:	428b      	cmp	r3, r1
    fb22:	d312      	bcc.n	fb4a <__aeabi_idiv+0x14a>
    fb24:	22fc      	movs	r2, #252	; 0xfc
    fb26:	0189      	lsls	r1, r1, #6
    fb28:	ba12      	rev	r2, r2
    fb2a:	0a03      	lsrs	r3, r0, #8
    fb2c:	428b      	cmp	r3, r1
    fb2e:	d30c      	bcc.n	fb4a <__aeabi_idiv+0x14a>
    fb30:	0189      	lsls	r1, r1, #6
    fb32:	1192      	asrs	r2, r2, #6
    fb34:	428b      	cmp	r3, r1
    fb36:	d308      	bcc.n	fb4a <__aeabi_idiv+0x14a>
    fb38:	0189      	lsls	r1, r1, #6
    fb3a:	1192      	asrs	r2, r2, #6
    fb3c:	428b      	cmp	r3, r1
    fb3e:	d304      	bcc.n	fb4a <__aeabi_idiv+0x14a>
    fb40:	0189      	lsls	r1, r1, #6
    fb42:	d03a      	beq.n	fbba <__aeabi_idiv+0x1ba>
    fb44:	1192      	asrs	r2, r2, #6
    fb46:	e000      	b.n	fb4a <__aeabi_idiv+0x14a>
    fb48:	0989      	lsrs	r1, r1, #6
    fb4a:	09c3      	lsrs	r3, r0, #7
    fb4c:	428b      	cmp	r3, r1
    fb4e:	d301      	bcc.n	fb54 <__aeabi_idiv+0x154>
    fb50:	01cb      	lsls	r3, r1, #7
    fb52:	1ac0      	subs	r0, r0, r3
    fb54:	4152      	adcs	r2, r2
    fb56:	0983      	lsrs	r3, r0, #6
    fb58:	428b      	cmp	r3, r1
    fb5a:	d301      	bcc.n	fb60 <__aeabi_idiv+0x160>
    fb5c:	018b      	lsls	r3, r1, #6
    fb5e:	1ac0      	subs	r0, r0, r3
    fb60:	4152      	adcs	r2, r2
    fb62:	0943      	lsrs	r3, r0, #5
    fb64:	428b      	cmp	r3, r1
    fb66:	d301      	bcc.n	fb6c <__aeabi_idiv+0x16c>
    fb68:	014b      	lsls	r3, r1, #5
    fb6a:	1ac0      	subs	r0, r0, r3
    fb6c:	4152      	adcs	r2, r2
    fb6e:	0903      	lsrs	r3, r0, #4
    fb70:	428b      	cmp	r3, r1
    fb72:	d301      	bcc.n	fb78 <__aeabi_idiv+0x178>
    fb74:	010b      	lsls	r3, r1, #4
    fb76:	1ac0      	subs	r0, r0, r3
    fb78:	4152      	adcs	r2, r2
    fb7a:	08c3      	lsrs	r3, r0, #3
    fb7c:	428b      	cmp	r3, r1
    fb7e:	d301      	bcc.n	fb84 <__aeabi_idiv+0x184>
    fb80:	00cb      	lsls	r3, r1, #3
    fb82:	1ac0      	subs	r0, r0, r3
    fb84:	4152      	adcs	r2, r2
    fb86:	0883      	lsrs	r3, r0, #2
    fb88:	428b      	cmp	r3, r1
    fb8a:	d301      	bcc.n	fb90 <__aeabi_idiv+0x190>
    fb8c:	008b      	lsls	r3, r1, #2
    fb8e:	1ac0      	subs	r0, r0, r3
    fb90:	4152      	adcs	r2, r2
    fb92:	d2d9      	bcs.n	fb48 <__aeabi_idiv+0x148>
    fb94:	0843      	lsrs	r3, r0, #1
    fb96:	428b      	cmp	r3, r1
    fb98:	d301      	bcc.n	fb9e <__aeabi_idiv+0x19e>
    fb9a:	004b      	lsls	r3, r1, #1
    fb9c:	1ac0      	subs	r0, r0, r3
    fb9e:	4152      	adcs	r2, r2
    fba0:	1a41      	subs	r1, r0, r1
    fba2:	d200      	bcs.n	fba6 <__aeabi_idiv+0x1a6>
    fba4:	4601      	mov	r1, r0
    fba6:	4663      	mov	r3, ip
    fba8:	4152      	adcs	r2, r2
    fbaa:	105b      	asrs	r3, r3, #1
    fbac:	4610      	mov	r0, r2
    fbae:	d301      	bcc.n	fbb4 <__aeabi_idiv+0x1b4>
    fbb0:	4240      	negs	r0, r0
    fbb2:	2b00      	cmp	r3, #0
    fbb4:	d500      	bpl.n	fbb8 <__aeabi_idiv+0x1b8>
    fbb6:	4249      	negs	r1, r1
    fbb8:	4770      	bx	lr
    fbba:	4663      	mov	r3, ip
    fbbc:	105b      	asrs	r3, r3, #1
    fbbe:	d300      	bcc.n	fbc2 <__aeabi_idiv+0x1c2>
    fbc0:	4240      	negs	r0, r0
    fbc2:	b501      	push	{r0, lr}
    fbc4:	2000      	movs	r0, #0
    fbc6:	f000 f805 	bl	fbd4 <__aeabi_idiv0>
    fbca:	bd02      	pop	{r1, pc}

0000fbcc <__aeabi_idivmod>:
    fbcc:	2900      	cmp	r1, #0
    fbce:	d0f8      	beq.n	fbc2 <__aeabi_idiv+0x1c2>
    fbd0:	e716      	b.n	fa00 <__aeabi_idiv>
    fbd2:	4770      	bx	lr

0000fbd4 <__aeabi_idiv0>:
    fbd4:	4770      	bx	lr
    fbd6:	46c0      	nop			; (mov r8, r8)

0000fbd8 <__libc_init_array>:
    fbd8:	4b0e      	ldr	r3, [pc, #56]	; (fc14 <__libc_init_array+0x3c>)
    fbda:	b570      	push	{r4, r5, r6, lr}
    fbdc:	2500      	movs	r5, #0
    fbde:	001e      	movs	r6, r3
    fbe0:	4c0d      	ldr	r4, [pc, #52]	; (fc18 <__libc_init_array+0x40>)
    fbe2:	1ae4      	subs	r4, r4, r3
    fbe4:	10a4      	asrs	r4, r4, #2
    fbe6:	42a5      	cmp	r5, r4
    fbe8:	d004      	beq.n	fbf4 <__libc_init_array+0x1c>
    fbea:	00ab      	lsls	r3, r5, #2
    fbec:	58f3      	ldr	r3, [r6, r3]
    fbee:	4798      	blx	r3
    fbf0:	3501      	adds	r5, #1
    fbf2:	e7f8      	b.n	fbe6 <__libc_init_array+0xe>
    fbf4:	f000 f900 	bl	fdf8 <_init>
    fbf8:	4b08      	ldr	r3, [pc, #32]	; (fc1c <__libc_init_array+0x44>)
    fbfa:	2500      	movs	r5, #0
    fbfc:	001e      	movs	r6, r3
    fbfe:	4c08      	ldr	r4, [pc, #32]	; (fc20 <__libc_init_array+0x48>)
    fc00:	1ae4      	subs	r4, r4, r3
    fc02:	10a4      	asrs	r4, r4, #2
    fc04:	42a5      	cmp	r5, r4
    fc06:	d004      	beq.n	fc12 <__libc_init_array+0x3a>
    fc08:	00ab      	lsls	r3, r5, #2
    fc0a:	58f3      	ldr	r3, [r6, r3]
    fc0c:	4798      	blx	r3
    fc0e:	3501      	adds	r5, #1
    fc10:	e7f8      	b.n	fc04 <__libc_init_array+0x2c>
    fc12:	bd70      	pop	{r4, r5, r6, pc}
    fc14:	0000fe04 	.word	0x0000fe04
    fc18:	0000fe04 	.word	0x0000fe04
    fc1c:	0000fe04 	.word	0x0000fe04
    fc20:	0000fe08 	.word	0x0000fe08

0000fc24 <memcmp>:
    fc24:	b530      	push	{r4, r5, lr}
    fc26:	2400      	movs	r4, #0
    fc28:	42a2      	cmp	r2, r4
    fc2a:	d008      	beq.n	fc3e <memcmp+0x1a>
    fc2c:	5d03      	ldrb	r3, [r0, r4]
    fc2e:	1c65      	adds	r5, r4, #1
    fc30:	5d0c      	ldrb	r4, [r1, r4]
    fc32:	42a3      	cmp	r3, r4
    fc34:	d001      	beq.n	fc3a <memcmp+0x16>
    fc36:	1b18      	subs	r0, r3, r4
    fc38:	e002      	b.n	fc40 <memcmp+0x1c>
    fc3a:	002c      	movs	r4, r5
    fc3c:	e7f4      	b.n	fc28 <memcmp+0x4>
    fc3e:	2000      	movs	r0, #0
    fc40:	bd30      	pop	{r4, r5, pc}

0000fc42 <memcpy>:
    fc42:	2300      	movs	r3, #0
    fc44:	b510      	push	{r4, lr}
    fc46:	429a      	cmp	r2, r3
    fc48:	d003      	beq.n	fc52 <memcpy+0x10>
    fc4a:	5ccc      	ldrb	r4, [r1, r3]
    fc4c:	54c4      	strb	r4, [r0, r3]
    fc4e:	3301      	adds	r3, #1
    fc50:	e7f9      	b.n	fc46 <memcpy+0x4>
    fc52:	bd10      	pop	{r4, pc}

0000fc54 <memset>:
    fc54:	0003      	movs	r3, r0
    fc56:	1882      	adds	r2, r0, r2
    fc58:	4293      	cmp	r3, r2
    fc5a:	d002      	beq.n	fc62 <memset+0xe>
    fc5c:	7019      	strb	r1, [r3, #0]
    fc5e:	3301      	adds	r3, #1
    fc60:	e7fa      	b.n	fc58 <memset+0x4>
    fc62:	4770      	bx	lr

0000fc64 <strcat>:
    fc64:	0002      	movs	r2, r0
    fc66:	b510      	push	{r4, lr}
    fc68:	7813      	ldrb	r3, [r2, #0]
    fc6a:	2b00      	cmp	r3, #0
    fc6c:	d001      	beq.n	fc72 <strcat+0xe>
    fc6e:	3201      	adds	r2, #1
    fc70:	e7fa      	b.n	fc68 <strcat+0x4>
    fc72:	5ccc      	ldrb	r4, [r1, r3]
    fc74:	54d4      	strb	r4, [r2, r3]
    fc76:	3301      	adds	r3, #1
    fc78:	2c00      	cmp	r4, #0
    fc7a:	d1fa      	bne.n	fc72 <strcat+0xe>
    fc7c:	bd10      	pop	{r4, pc}
    fc7e:	0000      	movs	r0, r0
    fc80:	ffff000a 	.word	0xffff000a
    fc84:	00010006 	.word	0x00010006
    fc88:	00000000 	.word	0x00000000
    fc8c:	ffff000a 	.word	0xffff000a
    fc90:	00020006 	.word	0x00020006
    fc94:	00000000 	.word	0x00000000
    fc98:	ffff000a 	.word	0xffff000a
    fc9c:	00030006 	.word	0x00030006
    fca0:	00000000 	.word	0x00000000
    fca4:	42000800 	.word	0x42000800
    fca8:	42000c00 	.word	0x42000c00
    fcac:	42001000 	.word	0x42001000
    fcb0:	42001400 	.word	0x42001400
    fcb4:	42001800 	.word	0x42001800
    fcb8:	42001c00 	.word	0x42001c00
    fcbc:	0a090807 	.word	0x0a090807
    fcc0:	00000c0b 	.word	0x00000c0b
    fcc4:	000040d6 	.word	0x000040d6
    fcc8:	00004134 	.word	0x00004134
    fccc:	00004134 	.word	0x00004134
    fcd0:	000040f4 	.word	0x000040f4
    fcd4:	000040ee 	.word	0x000040ee
    fcd8:	000040fa 	.word	0x000040fa
    fcdc:	000040dc 	.word	0x000040dc
    fce0:	00004100 	.word	0x00004100
    fce4:	000043dc 	.word	0x000043dc
    fce8:	00004416 	.word	0x00004416
    fcec:	00004416 	.word	0x00004416
    fcf0:	00004412 	.word	0x00004412
    fcf4:	000043ce 	.word	0x000043ce
    fcf8:	000043ee 	.word	0x000043ee
    fcfc:	000043be 	.word	0x000043be
    fd00:	00004400 	.word	0x00004400
    fd04:	00004462 	.word	0x00004462
    fd08:	00004478 	.word	0x00004478
    fd0c:	00004478 	.word	0x00004478
    fd10:	00004474 	.word	0x00004474
    fd14:	0000445c 	.word	0x0000445c
    fd18:	00004468 	.word	0x00004468
    fd1c:	00004456 	.word	0x00004456
    fd20:	0000446e 	.word	0x0000446e
    fd24:	42002000 	.word	0x42002000
    fd28:	42002400 	.word	0x42002400
    fd2c:	42002800 	.word	0x42002800
    fd30:	42002c00 	.word	0x42002c00
    fd34:	42003000 	.word	0x42003000
    fd38:	42003400 	.word	0x42003400
    fd3c:	42003800 	.word	0x42003800
    fd40:	42003c00 	.word	0x42003c00
    fd44:	14141313 	.word	0x14141313
    fd48:	16161515 	.word	0x16161515
    fd4c:	02000100 	.word	0x02000100
    fd50:	08000400 	.word	0x08000400
    fd54:	20001000 	.word	0x20001000
    fd58:	80004000 	.word	0x80004000

0000fd5c <ip_addr_any>:
    fd5c:	00000000                                ....

0000fd60 <memp_sizes>:
    fd60:	00980020 0010001c 00180020 00100010      ....... .......
    fd70:	00000600                                ....

0000fd74 <memp_num>:
    fd74:	00020001 00080001 00060002 00020003     ................
    fd84:	00000005                                ....

0000fd88 <tcp_backoff>:
    fd88:	04030201 07070605 07070707 00000007     ................

0000fd98 <tcp_persist_backoff>:
    fd98:	180c0603 00786030 000088ea 0000895a     ....0`x.....Z...
    fda8:	0000897e 000089a8 000089cc 00008a14     ~...............
    fdb8:	00008a14 000089f0 0000aa9e 0000aa9e     ................
    fdc8:	0000a4a4 0000a67e 0000a81e 0000a84a     ....~.......J...
    fdd8:	0000a936 0000a81e 0000a9d2 0000aa6e     6...........n...

0000fde8 <ethbroadcast>:
    fde8:	ffffffff 0000ffff                       ........

0000fdf0 <ethzero>:
	...

0000fdf8 <_init>:
    fdf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    fdfa:	46c0      	nop			; (mov r8, r8)
    fdfc:	bcf8      	pop	{r3, r4, r5, r6, r7}
    fdfe:	bc08      	pop	{r3}
    fe00:	469e      	mov	lr, r3
    fe02:	4770      	bx	lr

0000fe04 <__init_array_start>:
    fe04:	000000cd 	.word	0x000000cd

0000fe08 <_fini>:
    fe08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    fe0a:	46c0      	nop			; (mov r8, r8)
    fe0c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    fe0e:	bc08      	pop	{r3}
    fe10:	469e      	mov	lr, r3
    fe12:	4770      	bx	lr

0000fe14 <__fini_array_start>:
    fe14:	000000a5 	.word	0x000000a5
